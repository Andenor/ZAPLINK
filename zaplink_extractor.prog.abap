REPORT  zaplink_extractor MESSAGE-ID zaplink.
TYPE-POOLS:abap,icon,rpyty,rsds,sana,sedi,seex,seoc,seof,seok,seoo,seop,seor,seos,seot,seox,sewor,slis,smodi,ststc,swbm.
TYPES zaplink_subcomponent_level(1) TYPE c .
CLASS zaplink_acid_data DEFINITION DEFERRED.
CLASS zaplink_activate DEFINITION DEFERRED.
CLASS zaplink_avar_data DEFINITION DEFERRED.
CLASS zaplink_badi DEFINITION DEFERRED.
CLASS zaplink_badi_data DEFINITION DEFERRED.
CLASS zaplink_checkpoints DEFINITION DEFERRED.
CLASS zaplink_checkpoints_data DEFINITION DEFERRED.
CLASS zaplink_clas_data DEFINITION DEFERRED.
INTERFACE zaplink_cnx_ext_cleaner DEFERRED.
INTERFACE zaplink_cnx_ext_cleaner_4data DEFERRED.
INTERFACE zaplink_cnx_ext_code_signature DEFERRED.
CLASS zaplink_component DEFINITION DEFERRED.
CLASS zaplink_component_4inst DEFINITION DEFERRED.
INTERFACE zaplink_connector DEFERRED.
CLASS zaplink_connectors DEFINITION DEFERRED.
CLASS zaplink_connectors_4extractor DEFINITION DEFERRED.
CLASS zaplink_connectors_4inst DEFINITION DEFERRED.
CLASS zaplink_connector_ DEFINITION DEFERRED.
CLASS zaplink_container DEFINITION DEFERRED.
CLASS zaplink_container_4inst DEFINITION DEFERRED.
CLASS zaplink_cx DEFINITION DEFERRED.
CLASS zaplink_cx_component DEFINITION DEFERRED.
CLASS zaplink_cx_connector DEFINITION DEFERRED.
CLASS zaplink_cx_container DEFINITION DEFERRED.
CLASS zaplink_cx_file DEFINITION DEFERRED.
CLASS zaplink_cx_gui DEFINITION DEFERRED.
CLASS zaplink_cx_import_not_allowed DEFINITION DEFERRED.
CLASS zaplink_cx_installer_create DEFINITION DEFERRED.
CLASS zaplink_cx_list DEFINITION DEFERRED.
CLASS zaplink_cx_options DEFINITION DEFERRED.
CLASS zaplink_cx_opt_devclass DEFINITION DEFERRED.
CLASS zaplink_cx_opt_transport_req DEFINITION DEFERRED.
CLASS zaplink_cx_release DEFINITION DEFERRED.
INTERFACE zaplink_datatypes DEFERRED.
CLASS zaplink_dependencies_analyser DEFINITION DEFERRED.
CLASS zaplink_devc_data DEFINITION DEFERRED.
CLASS zaplink_devc_raw DEFINITION DEFERRED.
CLASS zaplink_dictionary DEFINITION DEFERRED.
CLASS zaplink_documentation DEFINITION DEFERRED.
CLASS zaplink_docv_data DEFINITION DEFERRED.
CLASS zaplink_doma_data DEFINITION DEFERRED.
CLASS zaplink_dtel_data DEFINITION DEFERRED.
CLASS zaplink_easyxml DEFINITION DEFERRED.
CLASS zaplink_easyxml_4cnx DEFINITION DEFERRED.
CLASS zaplink_enhancement DEFINITION DEFERRED.
CLASS zaplink_enhancement_data DEFINITION DEFERRED.
CLASS zaplink_enhc_data DEFINITION DEFERRED.
CLASS zaplink_enho_data DEFINITION DEFERRED.
CLASS zaplink_enhs_data DEFINITION DEFERRED.
CLASS zaplink_enqu_data DEFINITION DEFERRED.
CLASS zaplink_ensc_data DEFINITION DEFERRED.
CLASS zaplink_excc_data DEFINITION DEFERRED.
CLASS zaplink_extractor DEFINITION DEFERRED.
CLASS zaplink_file DEFINITION DEFERRED.
CLASS zaplink_fugr_data DEFINITION DEFERRED.
CLASS zaplink_function_group DEFINITION DEFERRED.
CLASS zaplink_func_data DEFINITION DEFERRED.
CLASS zaplink_func_raw DEFINITION DEFERRED.
CLASS zaplink_gui DEFINITION DEFERRED.
CLASS zaplink_infos DEFINITION DEFERRED.
CLASS zaplink_intf_data DEFINITION DEFERRED.
INTERFACE zaplink_kernel_types DEFERRED.
CLASS zaplink_list DEFINITION DEFERRED.
CLASS zaplink_list_4extractor DEFINITION DEFERRED.
CLASS zaplink_menupainter_data DEFINITION DEFERRED.
CLASS zaplink_message DEFINITION DEFERRED.
CLASS zaplink_message_collector DEFINITION DEFERRED.
CLASS zaplink_msag_data DEFINITION DEFERRED.
CLASS zaplink_object DEFINITION DEFERRED.
CLASS zaplink_object_data DEFINITION DEFERRED.
CLASS zaplink_options DEFINITION DEFERRED.
CLASS zaplink_opt_base DEFINITION DEFERRED.
CLASS zaplink_opt_devclass DEFINITION DEFERRED.
CLASS zaplink_opt_directory DEFINITION DEFERRED.
CLASS zaplink_opt_transport_request DEFINITION DEFERRED.
CLASS zaplink_os_command DEFINITION DEFERRED.
CLASS zaplink_package DEFINITION DEFERRED.
CLASS zaplink_pinf_data DEFINITION DEFERRED.
CLASS zaplink_pinf_raw DEFINITION DEFERRED.
CLASS zaplink_program DEFINITION DEFERRED.
CLASS zaplink_program_4dep_analyser DEFINITION DEFERRED.
CLASS zaplink_prog_data DEFINITION DEFERRED.
CLASS zaplink_raw DEFINITION DEFERRED.
CLASS zaplink_raw_base DEFINITION DEFERRED.
CLASS zaplink_raw_data DEFINITION DEFERRED.
CLASS zaplink_shlp_data DEFINITION DEFERRED.
CLASS zaplink_standalone_generator DEFINITION DEFERRED.
CLASS zaplink_sxci_data DEFINITION DEFERRED.
CLASS zaplink_sxsd_data DEFINITION DEFERRED.
CLASS zaplink_tabl_data DEFINITION DEFERRED.
CLASS zaplink_tabu_data DEFINITION DEFERRED.
CLASS zaplink_tools DEFINITION DEFERRED.
CLASS zaplink_transaction DEFINITION DEFERRED.
CLASS zaplink_tran_data DEFINITION DEFERRED.
CLASS zaplink_ttyp_data DEFINITION DEFERRED.
INTERFACE zaplink_types DEFERRED.
CLASS zaplink_type_data DEFINITION DEFERRED.
CLASS zaplink_vari_data DEFINITION DEFERRED.
CLASS zaplink_vari_raw DEFINITION DEFERRED.
CLASS zaplink_view_data DEFINITION DEFERRED.
CLASS zaplink_xinx_data DEFINITION DEFERRED.
CLASS zaplink_xinx_raw DEFINITION DEFERRED.
CLASS zlcx_comp_already_exists DEFINITION DEFERRED.
INTERFACE zaplink_datatypes.
  TYPE-POOLS abap .
  TYPES td_checkbox TYPE abap_bool .
  TYPES:
  tt_gensetc TYPE STANDARD TABLE OF gensetc WITH DEFAULT KEY .
  TYPES td_transport_kind TYPE ko100-pgmid .
  TYPES td_compadd_data TYPE string .
  TYPES td_frameworkver TYPE string .
  TYPES td_with_subcomp TYPE zaplink_subcomponent_level .
  TYPES td_typeorder TYPE i .
  TYPES td_orderkind TYPE char1 .
  TYPES td_checksum TYPE md5_fields-hash .
  TYPES td_substitutionkind TYPE char1 .
  TYPES td_devclass TYPE tadir-devclass .
  TYPES td_srcsystem TYPE tadir-srcsystem .
  TYPES:
    BEGIN OF ts_directory,
      korrnum    TYPE tadir-korrnum,
      srcsystem  TYPE td_srcsystem,
      author     TYPE tadir-author,
      srcdep     TYPE tadir-srcdep,
      devclass   TYPE td_devclass,
      genflag    TYPE tadir-genflag,
      edtflag    TYPE tadir-edtflag,
      masterlang TYPE tadir-masterlang,
      paknocheck TYPE tadir-paknocheck,
      objstablty TYPE tadir-objstablty,
      component  TYPE tadir-component,
      crelease   TYPE tadir-crelease,
      translttxt TYPE tadir-translttxt,
      trkorr     TYPE e070-trkorr,
    END OF ts_directory .
  TYPES td_connuuid TYPE guid_16 .
  TYPES td_type_as_text TYPE ko100-text .
  TYPES td_comptext TYPE ko100-text .
  TYPES td_contname TYPE string .
  TYPES td_contver TYPE string .
  TYPES td_filename TYPE string .
  TYPES td_filetype TYPE char1 .
  TYPES td_transport_request TYPE e070-trkorr .
  TYPES td_abapsource TYPE string .
  TYPES:
    BEGIN OF ts_sourceasstruc,
      _ TYPE td_abapsource,
    END OF ts_sourceasstruc .
  TYPES td_progname TYPE programm .
  TYPES tt_abaprawsource TYPE rswsourcet .
  TYPES ts_token TYPE stokes .
  TYPES ts_statment TYPE sstmnt .
  TYPES:
  tt_tokens TYPE STANDARD TABLE OF stokes .
  TYPES:
  tt_statments TYPE STANDARD TABLE OF sstmnt .
  TYPES to_xml TYPE REF TO if_ixml_document .
  TYPES td_light TYPE icon_l4 .
  TYPES td_action TYPE char1 .
  TYPES td_connver TYPE string .
  TYPES td_exists TYPE abap_bool .
  TYPES td_classname TYPE seoclsname .
  TYPES td_compexists TYPE td_exists .
  TYPES td_connclass TYPE td_classname .
  TYPES td_connexists TYPE td_exists .
  TYPES td_obj_type TYPE abap_abstypename .
  TYPES td_compname TYPE string .
  TYPES td_comptype TYPE tadir-object .
  TYPES:
    BEGIN OF ts_compkey,
      type TYPE td_comptype,
      name TYPE td_compname,
    END OF ts_compkey .
  TYPES:
  tt_compkeys TYPE STANDARD TABLE OF ts_compkey WITH DEFAULT KEY .
  TYPES:
  tr_tr TYPE RANGE OF td_transport_request .
  TYPES:
  tr_packages TYPE RANGE OF tadir-devclass .
  TYPES:
  tr_comptype TYPE RANGE OF td_comptype .
  TYPES:
  tr_compname TYPE RANGE OF tadir-obj_name .
  TYPES:
  tr_author TYPE RANGE OF tadir-author .
  TYPES:
  tr_srcsystem TYPE RANGE OF tadir-srcsystem .
  TYPES td_softcomp TYPE tdevc-dlvunit .
  TYPES:
  tr_dlvunit TYPE RANGE OF tdevc-dlvunit .
  TYPES:
    BEGIN OF ts_base_attributs,
      name     TYPE td_compname,
      class    TYPE td_connclass,
      devclass TYPE td_devclass,
      version  TYPE td_connver,
    END OF ts_base_attributs .
  TYPES:
    BEGIN OF ts_conn_class,
      uuid      TYPE td_connuuid,
      classname TYPE td_connclass,
      devclass  TYPE td_devclass,
    END OF ts_conn_class .
  TYPES:
  tt_conn_classes TYPE SORTED TABLE OF ts_conn_class WITH UNIQUE KEY uuid .
  TYPES:
    BEGIN OF ts_conn_def,
      object        TYPE ko100-object,
      text          TYPE ko100-text,
      default_class TYPE td_connclass,
      classes       TYPE tt_conn_classes,
    END OF ts_conn_def .
  TYPES:
  tt_typelist TYPE SORTED TABLE OF ts_conn_def WITH UNIQUE KEY object .
  TYPES:
    BEGIN OF ts_type,
      type TYPE td_comptype,
    END OF ts_type .
  TYPES:
  tt_types TYPE SORTED TABLE OF ts_type WITH UNIQUE KEY type .
  TYPES td_lang TYPE spras .
  TYPES td_txtp_text TYPE textpooltx .
  TYPES td_txtp_len TYPE textpoolln .
  TYPES td_txtp_kind TYPE textpoolid .
  TYPES td_txtp_id TYPE textpoolky .
  TYPES:
    BEGIN OF ts_txtp_text,
      langu  TYPE td_lang,
      entry  TYPE td_txtp_text,
      length TYPE td_txtp_len,
    END OF ts_txtp_text .
  TYPES:
  tt_txtp_texts TYPE SORTED TABLE OF ts_txtp_text WITH UNIQUE KEY langu .
  TYPES:
    BEGIN OF ts_txtp_textpool,
      id    TYPE td_txtp_kind,
      key   TYPE td_txtp_id,
      texts TYPE tt_txtp_texts,
    END OF ts_txtp_textpool .
  TYPES:
  tt_txtp_textpools TYPE SORTED TABLE OF ts_txtp_textpool WITH UNIQUE KEY id key .
  TYPES:
    BEGIN OF ts_conndata,
      zsl_name      TYPE td_compname,
      zsl_connector TYPE td_connclass,
      zsl_version   TYPE td_connver,
    END OF ts_conndata .
  TYPES:
    BEGIN OF ts_contdata,
      name TYPE td_contname,
    END OF ts_contdata .
  TYPES td_doc_id TYPE doku_id .
  TYPES:
  tt_rawtext TYPE STANDARD TABLE OF tline WITH DEFAULT KEY .
  TYPES:
    BEGIN OF ts_head,
      application TYPE tdobject,
      id          TYPE doku_id,
      object      TYPE doku_obj,
      langu       TYPE doku_langu,
      masterlang  TYPE dokil-masterlang,
      typ         TYPE doku_typ,
      dokform     TYPE tdformnew,
      dokstyle    TYPE tdstyle,
      selfdef     TYPE dokil-selfdef,
    END OF ts_head .
  TYPES:
    BEGIN OF ts_lang.
      INCLUDE TYPE thead AS head.
  TYPES:
    state TYPE dokhl-dokstate,
    _     TYPE string,
    END OF ts_lang .
  TYPES:
    BEGIN OF ts_text,
      langu     TYPE spras,
      short_txt TYPE string,
      long_txt  TYPE ts_lang,
    END OF ts_text .
  TYPES:
  tt_texts TYPE SORTED TABLE OF ts_text WITH UNIQUE KEY langu .
  TYPES:
    BEGIN OF ts_ltext,
      lang TYPE spras,
      text TYPE string,
      _    TYPE string,
    END OF ts_ltext .
  TYPES:
  tt_ltexts TYPE SORTED TABLE OF ts_ltext WITH UNIQUE KEY lang .
  TYPES:
    BEGIN OF ts_doc.
      INCLUDE TYPE ts_head AS hdr.
  TYPES:
    texts TYPE SORTED TABLE OF ts_lang WITH UNIQUE KEY tdspras,
    END OF ts_doc .
  TYPES:
  tt_docs TYPE STANDARD TABLE OF ts_doc WITH DEFAULT KEY .
  TYPES:
  tr_docid TYPE RANGE OF td_doc_id .
  TYPES:
    BEGIN OF ts_component,
      type TYPE td_comptype,
      name TYPE td_compname,
    END OF ts_component .
  TYPES:
    BEGIN OF ts_field.
      INCLUDE TYPE rpy_dyfatc AS hdr.
  TYPES:
    texts TYPE tt_texts,
    END OF ts_field .
  TYPES:
  tt_fields TYPE SORTED TABLE OF ts_field WITH NON-UNIQUE KEY name .
  TYPES:
    BEGIN OF ts_dynp_cont.
      INCLUDE TYPE rpy_dycatt AS hdr.
  TYPES:
    fields TYPE tt_fields,
    END OF ts_dynp_cont .
  TYPES:
  tt_dynp_containers TYPE SORTED TABLE OF ts_dynp_cont WITH NON-UNIQUE KEY name .
  TYPES:
  tt_flow_logic TYPE STANDARD TABLE OF rpy_dyflow WITH DEFAULT KEY .
  TYPES:
  tt_matchcodes TYPE STANDARD TABLE OF rpy_dypara WITH DEFAULT KEY .
  TYPES:
  tt_dyntexts TYPE SORTED TABLE OF d020t WITH UNIQUE KEY lang .
  TYPES:
    BEGIN OF ts_dynpro.
      INCLUDE TYPE rpy_dyhead AS hdr.
  TYPES:
    texts      TYPE tt_dyntexts,
    flow_logic TYPE ts_sourceasstruc,
    matchcodes TYPE tt_matchcodes,
    containers TYPE tt_dynp_containers,
    END OF ts_dynpro .
  TYPES:
  tt_dynpros TYPE SORTED TABLE OF ts_dynpro WITH UNIQUE KEY screen .
  TYPES:
    BEGIN OF ts_comptype,
      type TYPE td_comptype,
      kind TYPE td_transport_kind,
    END OF ts_comptype .
  CONSTANTS:
    BEGIN OF sub_component,
      without_any   TYPE td_with_subcomp VALUE '0',         "#EC NOTEXT
      with_mine     TYPE td_with_subcomp VALUE '3',         "#EC NOTEXT
      with_required TYPE td_with_subcomp VALUE '6',         "#EC NOTEXT
      with_all      TYPE td_with_subcomp VALUE '9',         "#EC NOTEXT
    END OF sub_component .
  CONSTANTS:
    BEGIN OF exists,
      exists     TYPE td_exists VALUE abap_true,
      not_exists TYPE td_exists VALUE abap_false,
    END OF exists .
  CONSTANTS:
    BEGIN OF textpool_kinds,
      prog_title  TYPE td_txtp_kind VALUE 'R', "#EC NOTEXT R - Program title
      list_title  TYPE td_txtp_kind VALUE 'T', "#EC NOTEXT T - List Title: Titlebar
      list_header TYPE td_txtp_kind VALUE 'H', "#EC NOTEXT H 001 to 004 List header: Column headings
      text_symbol TYPE td_txtp_kind VALUE 'I', "#EC NOTEXT I Text symbol identifier Text symbol text
      parameters  TYPE td_txtp_kind VALUE 'S', "#EC NOTEXT S Name of a parameter or selection criterion Selection text
    END OF textpool_kinds .
  CONSTANTS:
    BEGIN OF actions,
      delete_file  TYPE td_action VALUE 'D',                "#EC NOTEXT
      export       TYPE td_action VALUE 'E',                "#EC NOTEXT
      import       TYPE td_action VALUE 'I',                "#EC NOTEXT
      uninstall    TYPE td_action VALUE 'U',                "#EC NOTEXT
      unreplicable TYPE td_action VALUE 'K',                "#EC NOTEXT
      none         TYPE td_action VALUE space,
      activated    TYPE td_action VALUE 'A',                "#EC NOTEXT
      not_active   TYPE td_action VALUE 'N',                "#EC NOTEXT
    END OF actions .
  CONSTANTS line_separator TYPE abap_char1 VALUE cl_abap_char_utilities=>newline. "#EC NOTEXT
  CONSTANTS ballog_object TYPE balobj_d VALUE 'ZAPLINK'.    "#EC NOTEXT
  CONSTANTS comp_nodename TYPE string VALUE 'ZL_OBJECT'.    "#EC NOTEXT
  CONSTANTS ext_sep TYPE c VALUE '.'.                       "#EC NOTEXT
  CONSTANTS file_ext TYPE string VALUE 'xml'.               "#EC NOTEXT
  CONSTANTS framework_version TYPE td_frameworkver VALUE '0.0.009a'. "#EC NOTEXT
  CONSTANTS default_sub_component_level TYPE td_with_subcomp VALUE sub_component-with_mine. "#EC NOTEXT
ENDINTERFACE.
CLASS zaplink_raw_data DEFINITION
  ABSTRACT
  CREATE PUBLIC .
  PUBLIC SECTION.
    DATA _dependencies TYPE zaplink_datatypes=>tt_compkeys .
    DATA _code_signature TYPE zaplink_datatypes=>td_checksum .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_RAW_DATA definition
CLASS zaplink_checkpoints_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_checkpoints
                 zaplink_easyxml .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_checkbox
      FOR zaplink_datatypes~td_checkbox .
    ALIASES td_checksum
      FOR zaplink_datatypes~td_checksum .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_dynpros
      FOR zaplink_datatypes~tt_dynpros .
    ALIASES tt_ltexts
      FOR zaplink_datatypes~tt_ltexts .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
  PROTECTED SECTION.
    TYPES td_mode TYPE aab_id_mode .
    TYPES:
      BEGIN OF ts_bp_act,
        inactive TYPE td_checkbox,
        break    TYPE td_checkbox,
      END OF ts_bp_act .
    TYPES:
      BEGIN OF ts_lp_act,
        inactive TYPE td_checkbox,
        log      TYPE td_checkbox,
      END OF ts_lp_act .
    TYPES:
      BEGIN OF ts_a_act,
        inactive TYPE td_checkbox,
        log      TYPE td_checkbox,
        abort    TYPE td_checkbox,
        BEGIN OF break,
          log   TYPE td_checkbox,
          abort TYPE td_checkbox,
        END OF break,
      END OF ts_a_act .
    TYPES:
      BEGIN OF ts_activation,
        breakpoints TYPE ts_bp_act,
        logpoints   TYPE ts_lp_act,
        assertions  TYPE ts_a_act,
      END OF ts_activation .
    CLASS-METHODS conv_mode2activation
      IMPORTING
        !mode         TYPE td_mode
      RETURNING
        VALUE(result) TYPE ts_activation .
    CLASS-METHODS conv_activation2mode
      IMPORTING
        !activation   TYPE ts_activation
      RETURNING
        VALUE(result) TYPE td_mode .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CHECKPOINTS_DATA definition
CLASS zaplink_cx DEFINITION
  INHERITING FROM cx_static_check
  CREATE PUBLIC
  FRIENDS zaplink_cx .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS icon .
    INTERFACES if_t100_message .
    TYPES td_exception TYPE scx_t100key .
    TYPES to_exception TYPE REF TO zaplink_cx .
    TYPES to_root_exception TYPE REF TO cx_root .
    TYPES:
      BEGIN OF ts_cx,
        class TYPE seoclsname,
      END OF ts_cx .
    TYPES:
      tt_cx_list TYPE HASHED TABLE OF ts_cx WITH UNIQUE KEY class .
    TYPES:
      BEGIN OF ts_source_def,
        type_txt TYPE euobjt-singular,
        name     TYPE seu_objkey,
        str      TYPE string,
      END OF ts_source_def .
    TYPES o_msg_coll TYPE REF TO zaplink_message_collector .
    TYPES ts_source_pos TYPE abap_callstack_line .
    CONSTANTS:
      BEGIN OF bal_log,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '103',
        attr1 TYPE scx_attrname VALUE 'OBJECT',
        attr2 TYPE scx_attrname VALUE 'SUBOBJECT',
        attr3 TYPE scx_attrname VALUE 'EXT_ID',
        attr4 TYPE scx_attrname VALUE '',
      END OF bal_log .
    CONSTANTS:
      BEGIN OF zaplink_cx,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '105',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx .
    CONSTANTS:
      BEGIN OF system_error,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '104',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF system_error .
    DATA messages TYPE o_msg_coll .
    DATA object TYPE balobj_d .
    DATA subobject TYPE balsubobj .
    DATA ext_id TYPE balnrext .
    DATA cx_name TYPE string .
    CLASS-DATA _cx_list TYPE tt_cx_list .
    DATA systemstack TYPE abap_callstack READ-ONLY .
    CLASS-METHODS class_constructor .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL .
    METHODS update .
    CLASS-METHODS create_from_application_log
      IMPORTING
        !cx_name           TYPE string OPTIONAL
        !message_collector TYPE o_msg_coll
        !textid            TYPE td_exception DEFAULT bal_log
        !prev_cx           TYPE REF TO zaplink_cx OPTIONAL
      RETURNING
        VALUE(result)      TYPE REF TO zaplink_cx
      RAISING
        zaplink_cx .
    METHODS write .
    METHODS get_source_position_as_string
      RETURNING
        VALUE(str) TYPE string .
    CLASS-METHODS source_position_as_string
      IMPORTING
        !exception TYPE REF TO cx_root
      RETURNING
        VALUE(str) TYPE string .
    CLASS-METHODS create_from_mf_cx
      IMPORTING
        !funcname     TYPE rs38l-name
        VALUE(subrc)  TYPE sy-subrc
        !classname    TYPE string OPTIONAL
        !textid       TYPE td_exception DEFAULT system_error
      RETURNING
        VALUE(result) TYPE REF TO zaplink_cx .
    CLASS-METHODS create_from_symsg
      IMPORTING
        !classname    TYPE string OPTIONAL
        !textid       TYPE td_exception DEFAULT system_error
      RETURNING
        VALUE(result) TYPE REF TO zaplink_cx
      RAISING
        zaplink_cx .
    CLASS-METHODS create_from_method_cx
      IMPORTING
        !class        TYPE REF TO object OPTIONAL
        !class_name   TYPE string OPTIONAL
        VALUE(method) TYPE string
        VALUE(subrc)  TYPE sy-subrc
        !cx_classname TYPE string OPTIONAL
        !textid       TYPE td_exception DEFAULT system_error
      RETURNING
        VALUE(result) TYPE REF TO zaplink_cx .
    METHODS load_systemstack
      IMPORTING
        !force_reload TYPE abap_bool OPTIONAL .
    METHODS systemstack_up
      IMPORTING
        !force_reload TYPE abap_bool OPTIONAL .
    METHODS is_exception_text
      IMPORTING
        !textid       TYPE td_exception
      RETURNING
        VALUE(result) TYPE abap_bool .
  PROTECTED SECTION.
    ALIASES textid_msg
      FOR if_t100_message~t100key .
    CLASS-METHODS conv_progname
      IMPORTING
        !object_name  TYPE seu_objkey
        !context      TYPE seu_objkey OPTIONAL
      RETURNING
        VALUE(source) TYPE ts_source_def .
    CLASS-METHODS stack_position_as_string
      IMPORTING
        !source    TYPE ts_source_pos
      RETURNING
        VALUE(str) TYPE string .
    CLASS-METHODS _create_cx
      IMPORTING
        !cx_name      TYPE string OPTIONAL
        !textid       TYPE td_exception
      RETURNING
        VALUE(result) TYPE REF TO zaplink_cx .
  PRIVATE SECTION.
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_CX definition
CLASS zaplink_devc_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_package .
  PUBLIC SECTION.
    TYPES to_pinf_raw TYPE REF TO zaplink_pinf_raw .
    TYPES:
      tt_acls TYPE STANDARD TABLE OF pkgpermdat WITH NON-UNIQUE DEFAULT KEY .
    TYPES to_devc_raw TYPE REF TO zaplink_devc_raw .
    TYPES:
      BEGIN OF ts_interface,
        zl_object TYPE to_pinf_raw,
      END OF ts_interface .
    TYPES:
      tt_interfaces TYPE STANDARD TABLE OF ts_interface WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      BEGIN OF ts_package,
        zl_object TYPE to_devc_raw,
      END OF ts_package .
    TYPES:
      tt_packages TYPE STANDARD TABLE OF ts_package WITH NON-UNIQUE DEFAULT KEY .
    DATA a0_maindata TYPE scompkdtln .
    DATA interfaces TYPE tt_interfaces .
    DATA packages TYPE tt_packages .
    DATA if TYPE REF TO if_package .
    DATA acls TYPE tt_acls .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
    TYPES to_interface TYPE REF TO zaplink_pinf_data .
  PRIVATE SECTION.
    TYPES to_mykind TYPE REF TO zaplink_devc_data .
ENDCLASS. "ZAPLINK_DEVC_DATA definition
CLASS zaplink_docv_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_documentation .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES ts_head
      FOR zaplink_datatypes~ts_head .
    TYPES:
      tt_text TYPE STANDARD TABLE OF tline WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_text,
        langu TYPE sy-langu,
        _     TYPE string,      " Text
      END OF ts_text .
    TYPES:
      tt_texts TYPE SORTED TABLE OF ts_text WITH UNIQUE KEY langu .
    TYPES:
      tt_rawtext TYPE STANDARD TABLE OF tline WITH DEFAULT KEY .
    DATA a0_maindata TYPE ts_head .
    DATA texts TYPE tt_texts .
  PROTECTED SECTION.
    ALIASES ts_doc
      FOR zaplink_datatypes~ts_doc .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_doc .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_doc .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_DOCV_DATA definition
CLASS zaplink_doma_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_dictionary
                 zaplink_easyxml .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES:
      tt_dd07v TYPE STANDARD TABLE OF dd07v WITH DEFAULT KEY .
    TYPES:
      tt_dd07t TYPE SORTED TABLE OF dd07t WITH UNIQUE KEY valpos ddlanguage .
    TYPES:
      tt_dd01t TYPE SORTED TABLE OF dd01t WITH UNIQUE KEY ddlanguage .
    TYPES:
      BEGIN OF ts_fm_data,
        header       TYPE dd01v,
        texts        TYPE tt_dd01t,
        docs         TYPE tt_docs,
        values       TYPE tt_dd07v,
        values_texts TYPE tt_dd07t,
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE dd01v AS hdr.
    TYPES:
      END OF ts_maindata .
    TYPES:
      BEGIN OF ts_value.
        INCLUDE TYPE dd07v AS main.
    TYPES:
      texts TYPE tt_texts,
      END OF ts_value .
    TYPES:
      tt_values TYPE SORTED TABLE OF ts_value WITH UNIQUE KEY valpos .
    DATA a0_maindata TYPE ts_maindata .
    DATA texts TYPE tt_texts .
    DATA values TYPE tt_values .
    CLASS-METHODS class_constructor .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    CLASS-DATA r_doc_ids TYPE tr_docid .
    CONSTANTS:
      BEGIN OF doc_ids,
        header TYPE td_doc_id VALUE 'DO',
      END OF doc_ids .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_DOMA_DATA definition
CLASS zaplink_dtel_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_dictionary
                 zaplink_easyxml .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES:
      tt_dd04t TYPE SORTED TABLE OF dd04t WITH UNIQUE KEY ddlanguage .
    TYPES:
      BEGIN OF ts_fm_data,
        header TYPE dd04v,
        param  TYPE tpara,
        texts  TYPE tt_dd04t,
        docs   TYPE tt_docs,
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE dd04v AS hdr.
        INCLUDE TYPE tpara AS param.
    TYPES:
      END OF ts_maindata .
    DATA a0_maindata TYPE ts_maindata .
    DATA texts TYPE tt_texts .
    CLASS-METHODS class_constructor .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    CLASS-DATA r_doc_ids TYPE tr_docid .
    CONSTANTS:
      BEGIN OF doc_ids,
        header TYPE td_doc_id VALUE 'DE',
      END OF doc_ids .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_DTEL_DATA definition
CLASS zaplink_enqu_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_dictionary
                 zaplink_easyxml .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES:
      tt_dd26e TYPE STANDARD TABLE OF dd26e WITH DEFAULT KEY .
    TYPES:
      tt_dd27p TYPE STANDARD TABLE OF dd27p WITH DEFAULT KEY .
    TYPES:
      tt_dd25t TYPE SORTED TABLE OF dd25t WITH UNIQUE KEY ddlanguage .
    TYPES:
      BEGIN OF ts_fm_data,
        header TYPE dd25v,
        texts  TYPE tt_dd25t,
        docs   TYPE tt_docs,
        tables TYPE tt_dd26e,
        fields TYPE tt_dd27p,
      END OF ts_fm_data .
    TYPES:
      tt_fields TYPE SORTED TABLE OF dd53d WITH UNIQUE KEY viewfield .
    TYPES:
      tt_tables TYPE SORTED TABLE OF dd26e WITH UNIQUE KEY tabpos .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE dd25v AS hdr.
    TYPES:
      END OF ts_maindata .
    DATA a0_maindata TYPE ts_maindata .
    DATA texts TYPE tt_texts .
    DATA fields TYPE tt_fields .
    DATA tables TYPE tt_tables .
    CLASS-METHODS class_constructor .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    CLASS-DATA r_doc_ids TYPE tr_docid .
    CONSTANTS:
      BEGIN OF doc_ids,
        header TYPE td_doc_id VALUE 'TT',
      END OF doc_ids .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_ENQU_DATA definition
CLASS zaplink_excc_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_os_command .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES ts_lang
      FOR zaplink_datatypes~ts_lang .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE sxpgcolist.
    TYPES:
      END OF ts_maindata .
    DATA a0_maindata TYPE ts_maindata .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_EXCC_DATA definition
CLASS zaplink_func_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_fugr_data
                 zaplink_function_group
                 zaplink_func_raw .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_checksum
      FOR zaplink_datatypes~td_checksum .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_dynpros
      FOR zaplink_datatypes~tt_dynpros .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    CLASS-METHODS class_constructor .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    TYPES:
      BEGIN OF ts_doc_param,
        func  TYPE rs38l_fnam,
        param TYPE rs38l_par_,
      END OF ts_doc_param .
    TYPES t_raw TYPE rswsourcet .
    TYPES to_menupainter TYPE REF TO zaplink_menupainter_data .
    TYPES:
      tt_tlibt TYPE SORTED TABLE OF tlibt WITH UNIQUE KEY spras .
    TYPES:
      tt_tftit TYPE SORTED TABLE OF tftit WITH UNIQUE KEY funcname spras .
    TYPES:
      tt_funct TYPE SORTED TABLE OF funct WITH UNIQUE KEY funcname parameter kind spras .
    TYPES:
      tt_rsimp TYPE STANDARD TABLE OF rsimp WITH DEFAULT KEY .
    TYPES:
      tt_rscha TYPE STANDARD TABLE OF rscha WITH DEFAULT KEY .
    TYPES:
      tt_rsexp TYPE STANDARD TABLE OF rsexp WITH DEFAULT KEY .
    TYPES:
      tt_rstbl TYPE STANDARD TABLE OF rstbl WITH DEFAULT KEY .
    TYPES:
      tt_rsexc TYPE STANDARD TABLE OF rsexc WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_source,
        _ TYPE string,
      END OF ts_source .
    TYPES td_includename TYPE d010inc-include .
    TYPES:
      BEGIN OF ts_include,
        name   TYPE td_includename,
        source TYPE ts_source,
      END OF ts_include .
    TYPES:
      tt_includes TYPE SORTED TABLE OF ts_include WITH UNIQUE KEY name .
    TYPES:
      BEGIN OF ts_rawinclude,
        name   TYPE td_includename,
        source TYPE tt_abaprawsource,
      END OF ts_rawinclude .
    TYPES:
      tt_rawincludes TYPE STANDARD TABLE OF ts_rawinclude WITH NON-UNIQUE KEY name .
    TYPES:
      BEGIN OF ts_fm_data,
        header         TYPE rs38l,
        code_signature TYPE td_checksum,
        docs           TYPE tt_docs,
        import_p       TYPE tt_rsimp,
        changing_p     TYPE tt_rscha,
        export_p       TYPE tt_rsexp,
        tables         TYPE tt_rstbl,
        exceptions     TYPE tt_rsexc,
        source         TYPE tt_abaprawsource,
        texts          TYPE tt_tftit,
        param_texts    TYPE tt_funct,
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_maindata,
        name     TYPE rs38l-name,
        global   TYPE rs38l-global,
        remote   TYPE rs38l-remote,
        utask    TYPE rs38l-utask,
        str_area TYPE rs38l-str_area,
      END OF ts_maindata .
    TYPES:
      BEGIN OF ts_textpool,
        id    TYPE  textpoolid,
        key   TYPE  textpoolky,
        texts TYPE  tt_texts,
      END OF ts_textpool .
    TYPES:
      tt_textpools TYPE SORTED TABLE OF ts_textpool WITH UNIQUE KEY id key .
    TYPES td_paramkind TYPE kind .
    TYPES:
      BEGIN OF ts_param,
        kind TYPE td_paramkind.
        INCLUDE TYPE rsimp AS hdr.
    TYPES:
      texts TYPE tt_texts,
      END OF ts_param .
    TYPES:
      tt_params TYPE SORTED TABLE OF ts_param WITH UNIQUE KEY parameter .
    TYPES:
      BEGIN OF ts_excep.
        INCLUDE TYPE rsexc AS hdr.
    TYPES:
      texts TYPE tt_texts,
      END OF ts_excep .
    TYPES:
      tt_exceptions TYPE SORTED TABLE OF ts_excep WITH UNIQUE KEY exception .
    TYPES:
      BEGIN OF ts_function,
        name       TYPE rs38l-name,
        global     TYPE rs38l-global,
        remote     TYPE rs38l-remote,
        utask      TYPE rs38l-utask,
        texts      TYPE tt_texts,
        parameters TYPE tt_params,
        exceptions TYPE tt_exceptions,
        source     TYPE ts_source,
      END OF ts_function .
    TYPES:
      tt_functions TYPE SORTED TABLE OF ts_function WITH UNIQUE KEY name .
    CONSTANTS:
      BEGIN OF parameter_kinds,
        importing TYPE td_paramkind VALUE 'I',
        changing  TYPE td_paramkind VALUE 'C',
        exporting TYPE td_paramkind VALUE 'E',
        table     TYPE td_paramkind VALUE 'T',
      END OF parameter_kinds .
    DATA a0_maindata TYPE ts_maindata .
    DATA source TYPE ts_source .
    DATA texts TYPE tt_texts .
    DATA parameters TYPE tt_params .
    DATA exceptions TYPE tt_exceptions .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
  PRIVATE SECTION.
    CONSTANTS:
      BEGIN OF markups,
        area TYPE string VALUE '[FUNCTIONGROUP NAME]',
      END OF markups .
    CONSTANTS:
      BEGIN OF suffixes,
        top TYPE rs38l-suffix VALUE 'TOP',
      END OF suffixes .
    CONSTANTS:
      BEGIN OF doc_ids,
        group    TYPE td_doc_id VALUE 'RE',    " Report
        function TYPE td_doc_id VALUE 'FU',
      END OF doc_ids .
    CLASS-DATA:
      BEGIN OF r_doc_ids,
        group    TYPE tr_docid,
        function TYPE tr_docid,
      END OF r_doc_ids .
ENDCLASS. "ZAPLINK_FUNC_DATA definition
INTERFACE zaplink_kernel_types.
  TYPES to_component TYPE REF TO zaplink_component .
  TYPES to_container TYPE REF TO zaplink_container .
  TYPES to_file TYPE REF TO zaplink_file .
  TYPES to_list TYPE REF TO zaplink_list .
  TYPES to_msg_coll TYPE REF TO zaplink_message_collector .
  TYPES to_options TYPE REF TO zaplink_options .
  TYPES to_opt_devclass TYPE REF TO zaplink_opt_devclass .
  TYPES to_opt_directory TYPE REF TO zaplink_opt_directory .
  TYPES to_opt_transport_request TYPE REF TO zaplink_opt_transport_request .
  TYPES to_raw TYPE REF TO zaplink_raw .
  TYPES to_raw_base TYPE REF TO zaplink_raw_base .
  CONSTANTS ballog_object TYPE balobj_d VALUE 'ZAPLINK'.    "#EC NOTEXT
ENDINTERFACE.
CLASS zaplink_menupainter_data DEFINITION
  CREATE PUBLIC
  FRIENDS zaplink_easyxml .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_progname
      FOR zaplink_datatypes~td_progname .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES:
      BEGIN OF ts_mp_text,
        langu TYPE rsmptexts-sprsl,
        text  TYPE rsmptexts-text,
      END OF ts_mp_text .
    TYPES:
      tt_mp_texts TYPE SORTED TABLE OF ts_mp_text WITH UNIQUE KEY langu .
    TYPES:
      BEGIN OF ts_mp_ftext,
        langu TYPE rsmptexts-sprsl,
        text  TYPE rsmptexts-text,
        icon  TYPE rsmptexts-text,
        info  TYPE rsmptexts-text,
      END OF ts_mp_ftext .
    TYPES:
      tt_mp_ftexts TYPE SORTED TABLE OF ts_mp_ftext WITH UNIQUE KEY langu .
    TYPES:
      tt_funcs TYPE SORTED TABLE OF gui_func WITH UNIQUE KEY table_line .
    TYPES:
      BEGIN OF ts_status.
        INCLUDE TYPE rsmpe_sta AS hdr.
    TYPES:
      texts     TYPE tt_mp_texts,
      functions TYPE tt_funcs,
      END OF ts_status .
    TYPES:
      tt_status TYPE SORTED TABLE OF ts_status WITH UNIQUE KEY code .
    TYPES:
      BEGIN OF ts_function.
        INCLUDE TYPE rsmpe_fun AS hdr.
    TYPES:
      texts TYPE tt_mp_ftexts,
      END OF ts_function .
    TYPES:
      tt_functions TYPE SORTED TABLE OF ts_function WITH UNIQUE KEY code textno .
    TYPES:
      tt_menu_details TYPE SORTED TABLE OF rsmpe_men WITH UNIQUE KEY no .
    TYPES:
      BEGIN OF ts_menu.
        INCLUDE TYPE rsmpe_mnl AS hdr.
    TYPES:
      texts       TYPE tt_mp_texts,
      composition TYPE tt_menu_details,
      END OF ts_menu .
    TYPES:
      tt_menus TYPE SORTED TABLE OF ts_menu WITH UNIQUE KEY code .
    TYPES:
      tt_bar_details TYPE SORTED TABLE OF rsmpe_act WITH UNIQUE KEY no .
    TYPES:
      BEGIN OF ts_bar.
        INCLUDE TYPE rsmpe_atr AS hdr.
    TYPES:
      texts       TYPE tt_mp_texts,
      composition TYPE tt_bar_details,
      END OF ts_bar .
    TYPES:
      tt_bars TYPE SORTED TABLE OF ts_bar WITH UNIQUE KEY obj_code .
    TYPES:
      tt_button_details TYPE SORTED TABLE OF rsmpe_but WITH UNIQUE KEY no .
    TYPES:
      BEGIN OF ts_button.
        INCLUDE TYPE rsmpe_atr AS hdr.
    TYPES:
      texts       TYPE tt_mp_texts,
      composition TYPE tt_button_details,
      END OF ts_button .
    TYPES:
      tt_buttons TYPE SORTED TABLE OF ts_button WITH UNIQUE KEY sub_code .
    TYPES:
      tt_keyssettings TYPE SORTED TABLE OF rsmpe_pfk WITH UNIQUE KEY pfno .
    TYPES:
      BEGIN OF ts_keyboard.
        INCLUDE TYPE rsmpe_atr AS hdr.
    TYPES:
      texts       TYPE tt_mp_texts,
      keys        TYPE tt_keyssettings,
      pushbuttons TYPE tt_buttons,
      END OF ts_keyboard .
    TYPES:
      tt_keyboards TYPE SORTED TABLE OF ts_keyboard WITH UNIQUE KEY obj_code .
    TYPES:
      BEGIN OF ts_attribute.
        INCLUDE TYPE rsmpe_atr AS hdr.
    TYPES:
      texts TYPE tt_mp_texts,
      END OF ts_attribute .
    TYPES:
      tt_attributes TYPE SORTED TABLE OF ts_attribute WITH UNIQUE KEY obj_type obj_code sub_code .
    TYPES:
      BEGIN OF ts_title.
        INCLUDE TYPE rsmpe_tit AS hdr.
    TYPES:
      texts TYPE tt_mp_texts,
      END OF ts_title .
    TYPES:
      tt_titles TYPE SORTED TABLE OF ts_title WITH UNIQUE KEY code .
    TYPES:
      tt_ffuncs TYPE SORTED TABLE OF rsmpe_buts WITH UNIQUE KEY obj_code sub_code .
    TYPES:
      tt_stat TYPE STANDARD TABLE OF rsmpe_stat WITH DEFAULT KEY .
    TYPES:
      tt_funt TYPE STANDARD TABLE OF rsmpe_funt WITH DEFAULT KEY .
    TYPES:
      tt_men TYPE STANDARD TABLE OF rsmpe_men WITH DEFAULT KEY .
    TYPES:
      tt_mnlt TYPE STANDARD TABLE OF rsmpe_mnlt WITH DEFAULT KEY .
    TYPES:
      tt_act TYPE STANDARD TABLE OF rsmpe_act WITH DEFAULT KEY .
    TYPES:
      tt_but TYPE STANDARD TABLE OF rsmpe_but WITH DEFAULT KEY .
    TYPES:
      tt_pfk TYPE STANDARD TABLE OF rsmpe_pfk WITH DEFAULT KEY .
    TYPES:
      tt_staf TYPE STANDARD TABLE OF rsmpe_staf WITH DEFAULT KEY .
    TYPES:
      tt_atrt TYPE STANDARD TABLE OF rsmpe_atrt WITH DEFAULT KEY .
    TYPES:
      tt_titt TYPE STANDARD TABLE OF rsmpe_titt WITH DEFAULT KEY .
    TYPES:
      tt_buts TYPE STANDARD TABLE OF rsmpe_buts WITH DEFAULT KEY .
    TYPES:
      tt_stexts TYPE SORTED TABLE OF rsmptexts WITH UNIQUE KEY obj_type obj_code sub_code texttype sprsl .
    TYPES:
      BEGIN OF ts_fm_data,
        header      TYPE rsmpe_adm,
        status      TYPE tt_stat,
        functions   TYPE tt_funt,
        menus_det   TYPE tt_men,
        menus       TYPE tt_mnlt,
        bars_det    TYPE tt_act,
        buttons_det TYPE tt_but,
        keyboards   TYPE tt_pfk,
        stat_funcs  TYPE tt_staf,
        attributes  TYPE tt_atrt,
        titles      TYPE tt_titt,
        ffuncs      TYPE tt_buts,
        texts       TYPE tt_stexts,
      END OF ts_fm_data .
    CLASS-METHODS class_constructor .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      IMPORTING
        !program       TYPE td_progname
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    CLASS-DATA r_doc_ids TYPE tr_docid .
    CONSTANTS:
      BEGIN OF doc_ids,
        header TYPE td_doc_id VALUE 'DO',
      END OF doc_ids .
    CONSTANTS:
      BEGIN OF obj_types,   " FROM Include RSMPECON
        menu      TYPE mp_o_type VALUE 'M',
        function  TYPE mp_o_type VALUE 'F',
        title     TYPE mp_o_type VALUE 'T',
        menu_bar  TYPE mp_o_type VALUE 'A',
        key_set   TYPE mp_o_type VALUE 'P',  " Function Key Setting
        button    TYPE mp_o_type VALUE 'B',  " Pushbutton settings
        status    TYPE mp_o_type VALUE 'C',
        separator TYPE mp_o_type VALUE 'S',
        icon      TYPE mp_o_type VALUE 'I',
        program   TYPE mp_o_type VALUE 'D',
        dynpro    TYPE mp_o_type VALUE 'E',
        text      TYPE mp_o_type VALUE 'Z',
        context   TYPE mp_o_type VALUE 'X',
        symbolbar TYPE mp_o_type VALUE 'Y',
      END OF obj_types .
    CONSTANTS:
      BEGIN OF text_types,
        object     TYPE mp_txttype VALUE 'M',
        icon       TYPE mp_txttype VALUE 'I',
        quick_info TYPE mp_txttype VALUE 'Q',
        tech_info  TYPE mp_txttype VALUE 'T',  " Technical Information
      END OF text_types .
    DATA bar TYPE gui_func .
    DATA menu TYPE gui_func .
    DATA function TYPE gui_func .
    DATA default_bar TYPE gui_func .
    DATA default_function TYPE gui_func .
    DATA master_lang TYPE sprsl .
    DATA status TYPE tt_status .
    DATA menu_list TYPE tt_menus .
    DATA menu_bars TYPE tt_bars .
    DATA key_settings TYPE tt_keyboards .
    DATA functions TYPE tt_functions .
    DATA titles TYPE tt_titles .
  PRIVATE SECTION.
    CLASS-METHODS get_texts
      IMPORTING
        !texts        TYPE tt_stexts
        !obj_type     TYPE rsmptexts-obj_type
        !obj_code     TYPE rsmptexts-obj_code
        !sub_code     TYPE clike
        !texttype     TYPE rsmptexts-texttype
      RETURNING
        VALUE(result) TYPE tt_mp_texts .
    CLASS-METHODS get_func_texts
      IMPORTING
        !texts        TYPE tt_stexts
        !obj_code     TYPE rsmptexts-obj_code
        !sub_code     TYPE clike
      RETURNING
        VALUE(result) TYPE tt_mp_ftexts .
    CLASS-METHODS set_texts
      IMPORTING
        !obj_type    TYPE rsmptexts-obj_type
        !obj_code    TYPE rsmptexts-obj_code
        !sub_code    TYPE clike
        !texttype    TYPE rsmptexts-texttype
        VALUE(texts) TYPE tt_mp_texts
      CHANGING
        !result      TYPE tt_stexts .
    CLASS-METHODS set_func_texts
      IMPORTING
        !obj_code TYPE rsmptexts-obj_code
        !sub_code TYPE clike
        !texts    TYPE tt_mp_ftexts
      CHANGING
        !result   TYPE tt_stexts .
ENDCLASS. "ZAPLINK_MENUPAINTER_DATA definition
CLASS zaplink_msag_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_message .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES ts_lang
      FOR zaplink_datatypes~ts_lang .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE t100a.
    TYPES:
      END OF ts_maindata .
    TYPES:
      BEGIN OF ts_text,
        langu     TYPE spras,
        short_txt TYPE string,
        long_txt  TYPE ts_lang,
      END OF ts_text .
    TYPES:
      tt_texts TYPE SORTED TABLE OF ts_text WITH UNIQUE KEY langu .
    TYPES:
      BEGIN OF ts_msgtext,
        msgnr       TYPE msgnr,
        name        TYPE syuname,
        datum       TYPE sydatum,
        selfdef     TYPE doku_selfd,
        application TYPE tdobject,
        typ         TYPE doku_typ,
        dokform     TYPE tdformnew,
        dokstyle    TYPE tdstyle,
        texts       TYPE tt_texts,
      END OF ts_msgtext .
    TYPES:
      tt_msgtexts TYPE SORTED TABLE OF ts_msgtext WITH UNIQUE KEY msgnr .
    DATA a0_maindata TYPE ts_maindata .
    DATA texts TYPE tt_texts .
    DATA messages TYPE tt_msgtexts .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_MSAG_DATA definition
CLASS zaplink_opt_base DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES ballog_object
      FOR zaplink_datatypes~ballog_object .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_exists
      FOR zaplink_datatypes~td_exists .
    ALIASES td_substitutionkind
      FOR zaplink_datatypes~td_substitutionkind .
    ALIASES td_transport_request
      FOR zaplink_datatypes~td_transport_request .
    ALIASES ts_directory
      FOR zaplink_datatypes~ts_directory .
    TYPES to_component TYPE REF TO zaplink_raw_base .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_OPT_BASE definition
CLASS zaplink_pinf_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_package .
  PUBLIC SECTION.
    TYPES:
      tt_elements TYPE STANDARD TABLE OF scomeldtln WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      tt_acls     TYPE STANDARD TABLE OF scomaclstr WITH NON-UNIQUE DEFAULT KEY .
    DATA a0_maindata TYPE scompidtln .
    DATA acls TYPE tt_acls .
    DATA elements TYPE tt_elements .
    DATA if TYPE REF TO if_package_interface .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_PINF_DATA definition
CLASS zaplink_shlp_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_dictionary
                 zaplink_easyxml .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES to_me TYPE REF TO zaplink_shlp_data .
    TYPES:
      tt_dd30t TYPE SORTED TABLE OF dd30t WITH UNIQUE KEY ddlanguage .
    TYPES:
      tt_dd31v TYPE STANDARD TABLE OF dd31v WITH DEFAULT KEY .
    TYPES:
      tt_dd32p TYPE STANDARD TABLE OF dd32p WITH DEFAULT KEY .
    TYPES:
      tt_dd33v TYPE STANDARD TABLE OF dd33v WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_fm_data,
        header     TYPE dd30v,
        texts      TYPE tt_dd30t,
        docs       TYPE tt_docs,
        fields     TYPE tt_dd32p,
        sub_sh     TYPE tt_dd31v,
        ssh_params TYPE tt_dd33v,
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE dd30v AS hdr.
    TYPES:
      END OF ts_maindata .
    TYPES:
      tt_fields TYPE SORTED TABLE OF dd32p WITH UNIQUE KEY fieldname .
    TYPES:
      tt_params TYPE SORTED TABLE OF dd33v WITH UNIQUE KEY subfield .
    TYPES:
      BEGIN OF ts_sub_sh.
        INCLUDE TYPE dd31v AS hdr.
    TYPES:
      params    TYPE tt_params,
      zl_object TYPE to_me,
      END OF ts_sub_sh .
    TYPES:
      tt_sub_sh TYPE SORTED TABLE OF ts_sub_sh WITH UNIQUE KEY shposition .
    DATA a0_maindata TYPE ts_maindata .
    DATA params TYPE tt_fields .
    DATA sub_search_helps TYPE tt_sub_sh .
    DATA texts TYPE tt_texts .
    METHODS anonymize .
    CLASS-METHODS class_constructor .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS unanonymize .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    CONSTANTS:
      BEGIN OF doc_ids,
        header TYPE td_doc_id VALUE 'TT',
      END OF doc_ids .
    CLASS-DATA r_doc_ids TYPE tr_docid .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_SHLP_DATA definition
CLASS zaplink_ttyp_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_dictionary
                 zaplink_easyxml .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES:
      tt_dd42v TYPE STANDARD TABLE OF dd42v WITH DEFAULT KEY .
    TYPES:
      tt_dd40t TYPE SORTED TABLE OF dd40t WITH UNIQUE KEY ddlanguage .
    TYPES:
      BEGIN OF ts_fm_data,
        header TYPE dd40v,
        texts  TYPE tt_dd40t,
        keys   TYPE tt_dd42v,
        docs   TYPE tt_docs,
      END OF ts_fm_data .
    TYPES:
      tt_keys TYPE SORTED TABLE OF dd42v WITH UNIQUE KEY keyfdpos .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE dd40v AS hdr.
    TYPES:
      END OF ts_maindata .
    DATA a0_maindata TYPE ts_maindata .
    DATA texts TYPE tt_texts .
    DATA keys TYPE tt_keys .
    CLASS-METHODS class_constructor .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    CLASS-DATA r_doc_ids TYPE tr_docid .
    CONSTANTS:
      BEGIN OF doc_ids,
        header TYPE td_doc_id VALUE 'TT',
      END OF doc_ids .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_TTYP_DATA definition
CLASS zaplink_type_data DEFINITION
  INHERITING FROM zaplink_raw_data
  FINAL
  CREATE PUBLIC
  FRIENDS zaplink_dictionary
                 zaplink_easyxml .
  PUBLIC SECTION.
    TYPES:
      BEGIN OF ts_data,
        name     TYPE typegroup,
        lang     TYPE langu,
        text     TYPE ddtext,
        devclass TYPE devclass,
        uccheck  TYPE uccheck,
      END OF ts_data .
    TYPES:
      tt_abapsource TYPE STANDARD TABLE OF abapsource WITH DEFAULT KEY .
    TYPES:
      tt_string TYPE STANDARD TABLE OF abapsource WITH DEFAULT KEY .
    DATA a0_maindata TYPE ts_data .
    DATA source TYPE string READ-ONLY .
    METHODS set_source
      IMPORTING
        !source TYPE STANDARD TABLE .
    METHODS get_source
      RETURNING
        VALUE(source) TYPE tt_abapsource .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_TYPE_DATA definition
CLASS zaplink_vari_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_program
                 zaplink_prog_data
                 zaplink_vari_raw .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    ALIASES ts_sourceasstruc
      FOR zaplink_datatypes~ts_sourceasstruc .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_dynpros
      FOR zaplink_datatypes~tt_dynpros .
    ALIASES tt_ltexts
      FOR zaplink_datatypes~tt_ltexts .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
  PROTECTED SECTION.
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    TYPES:
      tt_varit TYPE SORTED TABLE OF varit WITH UNIQUE KEY langu .
    TYPES:
      tr_string TYPE RANGE OF string .
    TYPES:
      tt_screens TYPE SORTED TABLE OF rsdynnr WITH UNIQUE KEY dynnr .
    TYPES:
      BEGIN OF ts_param_data.
        INCLUDE TYPE vanz AS hdr.
    TYPES:
      value  TYPE string,
      values TYPE tr_string,
      params TYPE tr_string,
      END OF ts_param_data .
    TYPES:
      tt_params TYPE SORTED TABLE OF ts_param_data WITH UNIQUE KEY name .
    TYPES:
      BEGIN OF ts_fm_data,
        header  TYPE varid,
        texts   TYPE tt_varit,
        screens TYPE tt_screens,
        params  TYPE tt_params,
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE varid.
    TYPES:
      END OF ts_maindata .
    TYPES:
      BEGIN OF ts_variant_key,
        program TYPE varid-report,
        variant TYPE varid-variant,
      END OF ts_variant_key .
    CONSTANTS:
      BEGIN OF variant_prefix,
        system   TYPE varid-variant VALUE 'SAP&*',
        customer TYPE varid-variant VALUE 'CUS&*',
      END OF variant_prefix .
    DATA a0_maindata TYPE ts_maindata .
    DATA values TYPE tt_params .
    DATA texts TYPE tt_ltexts .
    DATA screens TYPE tt_screens .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
    CLASS-METHODS name_2_key
      IMPORTING
        !data         TYPE td_compname
      RETURNING
        VALUE(result) TYPE ts_variant_key .
    CLASS-METHODS key_2_name
      IMPORTING
        !data         TYPE ts_variant_key
      RETURNING
        VALUE(result) TYPE td_compname .
  PRIVATE SECTION.
    CONSTANTS:
      BEGIN OF transport,
        no_display TYPE varid-transport VALUE 'N',          "#EC NOTEXT
        hidden     TYPE varid-transport VALUE 'X',          "#EC NOTEXT
        protected  TYPE varid-transport VALUE space,        "#EC NOTEXT
        normal     TYPE varid-transport VALUE 'F',          "#EC NOTEXT
      END OF transport .
ENDCLASS. "ZAPLINK_VARI_DATA definition
CLASS zaplink_view_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_dictionary
                 zaplink_easyxml .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES:
      tt_dd26v TYPE STANDARD TABLE OF dd26v WITH DEFAULT KEY .
    TYPES:
      tt_dd27p TYPE STANDARD TABLE OF dd27p WITH DEFAULT KEY .
    TYPES:
      tt_dd28j TYPE STANDARD TABLE OF dd28j WITH DEFAULT KEY .
    TYPES:
      tt_dd28v TYPE STANDARD TABLE OF dd28v WITH DEFAULT KEY .
    TYPES:
      tt_dd25t TYPE SORTED TABLE OF dd25t WITH UNIQUE KEY ddlanguage .
    TYPES:
      BEGIN OF ts_fm_data,
        header TYPE dd25v,
        tech   TYPE dd09v,
        texts  TYPE tt_dd25t,
        docs   TYPE tt_docs,
        tables TYPE tt_dd26v,
        fields TYPE tt_dd27p,
        joins  TYPE tt_dd28j,
        wheres TYPE tt_dd28v,
      END OF ts_fm_data .
    TYPES:
      tt_tables TYPE SORTED TABLE OF dd26v WITH UNIQUE KEY tabpos .
    TYPES:
      tt_fields TYPE SORTED TABLE OF dd27p WITH UNIQUE KEY objpos .
    TYPES:
      tt_joins TYPE STANDARD TABLE OF dd28j WITH DEFAULT KEY .
    TYPES:
      tt_wheres TYPE SORTED TABLE OF dd28v WITH UNIQUE KEY position .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE dd25v AS hdr.
    TYPES:
      technical_settings TYPE dd09v,
      END OF ts_maindata .
    DATA a0_maindata TYPE ts_maindata .
    DATA texts TYPE tt_texts .
    DATA tables TYPE tt_tables .
    DATA fields TYPE tt_fields .
    DATA inner_join TYPE tt_joins .
    DATA conditions TYPE tt_wheres .
    CLASS-METHODS class_constructor .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    CLASS-DATA r_doc_ids TYPE tr_docid .
    CONSTANTS:
      BEGIN OF doc_ids,
        header TYPE td_doc_id VALUE 'VW',
      END OF doc_ids .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_VIEW_DATA definition
INTERFACE zaplink_cnx_ext_cleaner_4data.
  METHODS anonymize
    RAISING
      zaplink_cx .
  METHODS unanonymize
    RAISING
      zaplink_cx .
ENDINTERFACE.
CLASS zaplink_cx_component DEFINITION
  INHERITING FROM zaplink_cx
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    INTERFACES zaplink_datatypes .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    ALIASES td_obj_type
      FOR zaplink_datatypes~td_obj_type .
    CONSTANTS:
      BEGIN OF invalid_exception,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '068',
        attr1 TYPE scx_attrname VALUE 'OBJTYPE',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_exception .
    CONSTANTS:
      BEGIN OF invalid_msg_coll,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '069',
        attr1 TYPE scx_attrname VALUE 'OBJTYPE',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_msg_coll .
    CONSTANTS:
      BEGIN OF invalid_subcomponents,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '070',
        attr1 TYPE scx_attrname VALUE 'OBJTYPE',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_subcomponents .
    CONSTANTS:
      BEGIN OF invalid_type,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '060',
        attr1 TYPE scx_attrname VALUE 'TYPE',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_type .
    CONSTANTS:
      BEGIN OF zaplink_cx_component,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '106',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_component .
    DATA name TYPE td_compname .
    DATA type TYPE td_comptype .
    DATA connclass TYPE td_connclass .
    DATA objtype TYPE td_obj_type .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL
        !name        TYPE td_compname OPTIONAL
        !type        TYPE td_comptype OPTIONAL
        !connclass   TYPE td_connclass OPTIONAL
        !objtype     TYPE td_obj_type OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_COMPONENT definition
CLASS zaplink_cx_connector DEFINITION
  INHERITING FROM zaplink_cx
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    ALIASES td_connuuid
      FOR zaplink_datatypes~td_connuuid .
    ALIASES td_connver
      FOR zaplink_datatypes~td_connver .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    CONSTANTS:
      BEGIN OF not_authorized,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '056',
        attr1 TYPE scx_attrname VALUE 'NAME',
        attr2 TYPE scx_attrname VALUE 'TYPE',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF not_authorized .
    CONSTANTS:
      BEGIN OF not_found,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '057',
        attr1 TYPE scx_attrname VALUE 'NAME',
        attr2 TYPE scx_attrname VALUE 'TYPE',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF not_found .
    CONSTANTS:
      BEGIN OF object_locked,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '058',
        attr1 TYPE scx_attrname VALUE 'NAME',
        attr2 TYPE scx_attrname VALUE 'TYPE',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF object_locked .
    CONSTANTS:
      BEGIN OF zaplink_cx_connector,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '055',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_connector .
    CONSTANTS:
      BEGIN OF twice_class,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '059',
        attr1 TYPE scx_attrname VALUE 'CONNCLASS',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF twice_class .
    CONSTANTS:
      BEGIN OF invalid_type,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '060',
        attr1 TYPE scx_attrname VALUE 'TYPE',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_type .
    CONSTANTS:
      BEGIN OF invalid_connector,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '061',
        attr1 TYPE scx_attrname VALUE 'CONNCLASS',
        attr2 TYPE scx_attrname VALUE 'TYPE',
        attr3 TYPE scx_attrname VALUE 'CX_NAME',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_connector .
    CONSTANTS:
      BEGIN OF invalid_uuid,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '062',
        attr1 TYPE scx_attrname VALUE 'CONNUUID',
        attr2 TYPE scx_attrname VALUE 'TYPE',
        attr3 TYPE scx_attrname VALUE 'CONNCLASS',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_uuid .
    CONSTANTS:
      BEGIN OF invalid_xml,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '063',
        attr1 TYPE scx_attrname VALUE 'NODE_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_xml .
    CONSTANTS:
      BEGIN OF unsuported_version,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '064',
        attr1 TYPE scx_attrname VALUE 'CONN_VER',
        attr2 TYPE scx_attrname VALUE 'CONNUUID',
        attr3 TYPE scx_attrname VALUE 'CONNCLASS',
        attr4 TYPE scx_attrname VALUE '',
      END OF unsuported_version .
    CONSTANTS:
      BEGIN OF type_not_supported,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '065',
        attr1 TYPE scx_attrname VALUE 'TYPE',
        attr2 TYPE scx_attrname VALUE 'CONNCLASS',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF type_not_supported .
    CONSTANTS:
      BEGIN OF twice_uuid,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '066',
        attr1 TYPE scx_attrname VALUE 'CONNCLASS',
        attr2 TYPE scx_attrname VALUE 'OTHERCLASS',
        attr3 TYPE scx_attrname VALUE 'CONNUUID',
        attr4 TYPE scx_attrname VALUE '',
      END OF twice_uuid .
    CONSTANTS:
      BEGIN OF xml_error,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '067',
        attr1 TYPE scx_attrname VALUE 'TYPE',
        attr2 TYPE scx_attrname VALUE 'NAME',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF xml_error .
    DATA name TYPE td_compname VALUE '[NAME]'.            "#EC NOTEXT .
    DATA type TYPE td_comptype VALUE '[TY]'.              "#EC NOTEXT .
    DATA devclass TYPE td_devclass VALUE '[DEVCLASS]'.    "#EC NOTEXT .
    DATA connclass TYPE td_connclass VALUE '[CONNCLASS]'. "#EC NOTEXT .
    DATA connuuid TYPE td_connuuid VALUE '00000000000000000000000000000000'. "#EC NOTEXT .
    DATA node_name TYPE string VALUE '[NODE_NAME]'.       "#EC NOTEXT .
    DATA conn_ver TYPE td_connver VALUE '[CONN_VER]'.     "#EC NOTEXT .
    DATA otherclass TYPE td_connclass VALUE '[OTHERCLASS]'. "#EC NOTEXT .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL
        !name        TYPE td_compname DEFAULT '[NAME]'
        !type        TYPE td_comptype DEFAULT '[TY]'
        !devclass    TYPE td_devclass DEFAULT '[DEVCLASS]'
        !connclass   TYPE td_connclass DEFAULT '[CONNCLASS]'
        !connuuid    TYPE td_connuuid DEFAULT '00000000000000000000000000000000'
        !node_name   TYPE string DEFAULT '[NODE_NAME]'
        !conn_ver    TYPE td_connver DEFAULT '[CONN_VER]'
        !otherclass  TYPE td_connclass DEFAULT '[OTHERCLASS]' .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_CONNECTOR definition
CLASS zaplink_cx_container DEFINITION
  INHERITING FROM zaplink_cx
  CREATE PUBLIC .
  PUBLIC SECTION.
    CONSTANTS:
      BEGIN OF add_comp_failed,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '150',
        attr1 TYPE scx_attrname VALUE 'TYPE',
        attr2 TYPE scx_attrname VALUE 'NAME',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF add_comp_failed .
    CONSTANTS:
      BEGIN OF add_failed,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '151',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF add_failed .
    CONSTANTS:
      BEGIN OF circular_dependencies,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '152',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF circular_dependencies .
    CONSTANTS:
      BEGIN OF zaplink_cx_container,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '107',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_container .
    DATA name TYPE zaplink_cx_component=>td_compname .
    DATA type TYPE zaplink_cx_component=>td_comptype .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL
        !name        TYPE zaplink_cx_component=>td_compname OPTIONAL
        !type        TYPE zaplink_cx_component=>td_comptype OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_CONTAINER definition
CLASS zaplink_cx_file DEFINITION
  INHERITING FROM zaplink_cx
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPES t_filename TYPE string .
    TYPES t_filetype TYPE char1 .
    CONSTANTS:
      BEGIN OF dialog_canceled,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '209',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF dialog_canceled .
    CONSTANTS:
      BEGIN OF invalid_filekind,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '208',
        attr1 TYPE scx_attrname VALUE 'FILEKIND',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_filekind .
    CONSTANTS:
      BEGIN OF invalid_filename,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '207',
        attr1 TYPE scx_attrname VALUE 'FILENAME',
        attr2 TYPE scx_attrname VALUE 'FILETYPE',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_filename .
    CONSTANTS:
      BEGIN OF invalid_filetype,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '206',
        attr1 TYPE scx_attrname VALUE 'FILETYPE',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_filetype .
    CONSTANTS:
      BEGIN OF load_error,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '205',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE 'FILENAME',
        attr3 TYPE scx_attrname VALUE 'FILETYPE',
        attr4 TYPE scx_attrname VALUE '',
      END OF load_error .
    CONSTANTS:
      BEGIN OF missing_filename,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '204',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF missing_filename .
    CONSTANTS:
      BEGIN OF save_error,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '203',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE 'FILENAME',
        attr3 TYPE scx_attrname VALUE 'FILETYPE',
        attr4 TYPE scx_attrname VALUE '',
      END OF save_error .
    CONSTANTS:
      BEGIN OF search_error,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '202',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE 'FILENAME',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF search_error .
    CONSTANTS:
      BEGIN OF zaplink_cx_file,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '108',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_file .
    CONSTANTS:
      BEGIN OF delete_error,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '210',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE 'FILENAME',
        attr3 TYPE scx_attrname VALUE 'FILETYPE',
        attr4 TYPE scx_attrname VALUE '',
      END OF delete_error .
    DATA filename TYPE t_filename .
    DATA filetype TYPE t_filetype .
    DATA filekind TYPE t_filetype .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL
        !filename    TYPE t_filename OPTIONAL
        !filetype    TYPE t_filetype OPTIONAL
        !filekind    TYPE t_filetype OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_FILE definition
CLASS zaplink_cx_gui DEFINITION
  INHERITING FROM zaplink_cx
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    CONSTANTS:
      BEGIN OF missing_filename,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '204',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF missing_filename .
    CONSTANTS:
      BEGIN OF missing_name,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '250',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF missing_name .
    CONSTANTS:
      BEGIN OF missing_objtype,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '251',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF missing_objtype .
    CONSTANTS:
      BEGIN OF zaplink_cx_gui,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '109',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_gui .
    CONSTANTS:
      BEGIN OF missing_container_name,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '252',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF missing_container_name .
    DATA type TYPE td_comptype .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL
        !type        TYPE td_comptype OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_GUI definition
CLASS zaplink_cx_import_not_allowed DEFINITION
  INHERITING FROM zaplink_cx
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    ALIASES td_connuuid
      FOR zaplink_datatypes~td_connuuid .
    ALIASES td_connver
      FOR zaplink_datatypes~td_connver .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    CONSTANTS:
      BEGIN OF zaplink_cx_import_not_allowed,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '071',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_import_not_allowed .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_IMPORT_NOT_ALLOWED definition
CLASS zaplink_cx_installer_create DEFINITION
  INHERITING FROM zaplink_cx
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    CONSTANTS:
      BEGIN OF zaplink_cx_installer_create,
        msgid TYPE symsgid VALUE 'ZAPLINK_DEVTOOLS',
        msgno TYPE symsgno VALUE '499',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_installer_create .
    CONSTANTS:
      BEGIN OF not_exists,
        msgid TYPE symsgid VALUE 'ZAPLINK_DEVTOOLS',
        msgno TYPE symsgno VALUE '500',
        attr1 TYPE scx_attrname VALUE 'MASTER_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF not_exists .
    CONSTANTS:
      BEGIN OF no_overwrite,
        msgid TYPE symsgid VALUE 'ZAPLINK_DEVTOOLS',
        msgno TYPE symsgno VALUE '501',
        attr1 TYPE scx_attrname VALUE 'INSTALLER_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF no_overwrite .
    CONSTANTS:
      BEGIN OF no_include,
        msgid TYPE symsgid VALUE 'ZAPLINK_DEVTOOLS',
        msgno TYPE symsgno VALUE '502',
        attr1 TYPE scx_attrname VALUE 'INCLUDE_NAME',
        attr2 TYPE scx_attrname VALUE 'MASTER_NAME',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF no_include .
    CONSTANTS:
      BEGIN OF activation_error,
        msgid TYPE symsgid VALUE 'ZAPLINK_DEVTOOLS',
        msgno TYPE symsgno VALUE '503',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF activation_error .
    DATA installer_name TYPE programm READ-ONLY .
    DATA master_name TYPE programm READ-ONLY .
    DATA include_name TYPE programm READ-ONLY .
    METHODS constructor
      IMPORTING
        !textid         LIKE if_t100_message=>t100key OPTIONAL
        !previous       LIKE previous OPTIONAL
        !messages       TYPE o_msg_coll OPTIONAL
        !object         TYPE balobj_d OPTIONAL
        !subobject      TYPE balsubobj OPTIONAL
        !ext_id         TYPE balnrext OPTIONAL
        !cx_name        TYPE string OPTIONAL
        !_cx_list       TYPE tt_cx_list OPTIONAL
        !systemstack    TYPE abap_callstack OPTIONAL
        !installer_name TYPE programm OPTIONAL
        !master_name    TYPE programm OPTIONAL
        !include_name   TYPE programm OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_INSTALLER_CREATE definition
CLASS zaplink_cx_list DEFINITION
  INHERITING FROM zaplink_cx
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_action
      FOR zaplink_datatypes~td_action .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    CONSTANTS:
      BEGIN OF invalid_action,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '301',
        attr1 TYPE scx_attrname VALUE 'SEL_ACTION',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_action .
    CONSTANTS:
      BEGIN OF iterator_not_initialize,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '302',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF iterator_not_initialize .
    CONSTANTS:
      BEGIN OF not_found,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '303',
        attr1 TYPE scx_attrname VALUE 'TYPE',
        attr2 TYPE scx_attrname VALUE 'NAME',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF not_found .
    CONSTANTS:
      BEGIN OF zaplink_cx_list,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '110',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_list .
    DATA name TYPE td_compname .
    DATA type TYPE td_comptype .
    DATA connclass TYPE td_connclass .
    DATA sel_action TYPE td_action .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL
        !name        TYPE td_compname OPTIONAL
        !type        TYPE td_comptype OPTIONAL
        !connclass   TYPE td_connclass OPTIONAL
        !sel_action  TYPE td_action OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_LIST definition
CLASS zaplink_cx_options DEFINITION
  INHERITING FROM zaplink_cx
  CREATE PUBLIC .
  PUBLIC SECTION.
    CONSTANTS:
      BEGIN OF dialog_canceled,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '253',
        attr1 TYPE scx_attrname VALUE '',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF dialog_canceled .
    CONSTANTS:
      BEGIN OF zaplink_cx_options,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '111',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_options .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_OPTIONS definition
CLASS zaplink_cx_opt_devclass DEFINITION
  INHERITING FROM zaplink_cx_options
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_substitutionkind
      FOR zaplink_datatypes~td_substitutionkind .
    CONSTANTS:
      BEGIN OF invalid_substitutionkind,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '254',
        attr1 TYPE scx_attrname VALUE 'SUBSTKIND',
        attr2 TYPE scx_attrname VALUE 'OPT_CAT',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_substitutionkind .
    CONSTANTS:
      BEGIN OF zaplink_cx_opt_devclass,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '111',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_opt_devclass .
    CONSTANTS:
      BEGIN OF missing_devclass,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '255',
        attr1 TYPE scx_attrname VALUE 'SUBSTKIND',
        attr2 TYPE scx_attrname VALUE 'OPT_CAT',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF missing_devclass .
    DATA substkind TYPE td_substitutionkind .
    DATA devclass TYPE td_devclass .
    CLASS-DATA opt_cat TYPE string .
    CLASS-METHODS class_constructor .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL
        !substkind   TYPE td_substitutionkind OPTIONAL
        !devclass    TYPE td_devclass OPTIONAL
        !opt_cat     TYPE string OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_OPT_DEVCLASS definition
CLASS zaplink_cx_opt_transport_req DEFINITION
  INHERITING FROM zaplink_cx_options
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_substitutionkind
      FOR zaplink_datatypes~td_substitutionkind .
    ALIASES td_transport_request
      FOR zaplink_datatypes~td_transport_request .
    CONSTANTS:
      BEGIN OF invalid_substitutionkind,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '254',
        attr1 TYPE scx_attrname VALUE 'SUBSTKIND',
        attr2 TYPE scx_attrname VALUE 'OPT_CAT',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF invalid_substitutionkind .
    CONSTANTS:
      BEGIN OF zaplink_cx_opt_transport_req,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '111',
        attr1 TYPE scx_attrname VALUE 'CX_NAME',
        attr2 TYPE scx_attrname VALUE '',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zaplink_cx_opt_transport_req .
    CONSTANTS:
      BEGIN OF missing_transport_request,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '255',
        attr1 TYPE scx_attrname VALUE 'SUBSTKIND',
        attr2 TYPE scx_attrname VALUE 'OPT_CAT',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF missing_transport_request .
    DATA substkind TYPE td_substitutionkind .
    DATA transport_request TYPE td_transport_request .
    CLASS-DATA opt_cat TYPE string .
    CLASS-METHODS class_constructor .
    METHODS constructor
      IMPORTING
        !textid            LIKE if_t100_message=>t100key OPTIONAL
        !previous          LIKE previous OPTIONAL
        !messages          TYPE o_msg_coll OPTIONAL
        !object            TYPE balobj_d OPTIONAL
        !subobject         TYPE balsubobj OPTIONAL
        !ext_id            TYPE balnrext OPTIONAL
        !cx_name           TYPE string OPTIONAL
        !_cx_list          TYPE tt_cx_list OPTIONAL
        !systemstack       TYPE abap_callstack OPTIONAL
        !substkind         TYPE td_substitutionkind OPTIONAL
        !transport_request TYPE td_transport_request OPTIONAL
        !opt_cat           TYPE string OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_OPT_TRANSPORT_REQ definition
CLASS zaplink_cx_release DEFINITION
  INHERITING FROM zaplink_cx
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_progname
      FOR zaplink_datatypes~td_progname .
    CONSTANTS:
      BEGIN OF generation_failed,
        msgid TYPE symsgid VALUE 'ZAPLINK_DEVTOOLS',
        msgno TYPE symsgno VALUE '017',
        attr1 TYPE scx_attrname VALUE 'TARGET_PROGRAM',
        attr2 TYPE scx_attrname VALUE 'MASTER_PROGRAM',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF generation_failed .
    DATA master_program TYPE td_progname .
    DATA target_program TYPE td_progname .
    METHODS constructor
      IMPORTING
        !textid         LIKE if_t100_message=>t100key OPTIONAL
        !previous       LIKE previous OPTIONAL
        !messages       TYPE o_msg_coll OPTIONAL
        !object         TYPE balobj_d OPTIONAL
        !subobject      TYPE balsubobj OPTIONAL
        !ext_id         TYPE balnrext OPTIONAL
        !cx_name        TYPE string OPTIONAL
        !_cx_list       TYPE tt_cx_list OPTIONAL
        !systemstack    TYPE abap_callstack OPTIONAL
        !master_program TYPE td_progname OPTIONAL
        !target_program TYPE td_progname OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CX_RELEASE definition
CLASS zaplink_file DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPES td_fullname TYPE string .
    TYPES td_directoryname TYPE string .
    TYPES td_filedir_kind TYPE char01 .
    TYPES:
      BEGIN OF ts_file_info,
        name TYPE td_fullname,
        kind TYPE td_filedir_kind,
      END OF ts_file_info .
    TYPES td_filename TYPE zaplink_cx_file=>t_filename .
    TYPES td_filetype TYPE zaplink_cx_file=>t_filetype .
    TYPES:
      tt_file_list TYPE STANDARD TABLE OF ts_file_info WITH DEFAULT KEY .
    CONSTANTS c_ft_local TYPE td_filetype VALUE 'L'.        "#EC NOTEXT
    CONSTANTS c_ft_server TYPE td_filetype VALUE 'S'.       "#EC NOTEXT
    CONSTANTS:
      BEGIN OF filetypes,
        local  TYPE td_filetype VALUE 'L',                  "#EC NOTEXT
        server TYPE td_filetype VALUE 'S',                  "#EC NOTEXT
      END OF filetypes .
    CONSTANTS:
      BEGIN OF filedirkinds,
        unknown   TYPE td_filedir_kind VALUE space,         "#EC NOTEXT
        file      TYPE td_filedir_kind VALUE 'F',           "#EC NOTEXT
        directory TYPE td_filedir_kind VALUE 'D',           "#EC NOTEXT
      END OF filedirkinds .
    CLASS-DATA file_sep TYPE c READ-ONLY .
    CLASS-METHODS class_constructor .
    METHODS get_filename
      RETURNING
        VALUE(result) TYPE td_filename .
    METHODS get_filetype
      RETURNING
        VALUE(result) TYPE td_filetype .
    METHODS set_filename
      IMPORTING
        !data TYPE td_filename
      RAISING
        zaplink_cx_file .
    METHODS set_filetype
      IMPORTING
        !data TYPE td_filetype
      RAISING
        zaplink_cx_file .
    METHODS get_filecontent
      RETURNING
        VALUE(result) TYPE string .
    METHODS set_filecontent
      IMPORTING
        !data TYPE string .
    METHODS save
      RAISING
        zaplink_cx_file .
    METHODS load
      RAISING
        zaplink_cx_file .
    METHODS save_dialog
      IMPORTING
        !filename TYPE td_filename OPTIONAL
      RAISING
        zaplink_cx_file .
    METHODS load_dialog
      IMPORTING
        !filename TYPE td_filename OPTIONAL
      RAISING
        zaplink_cx_file .
    METHODS file_exists
      RETURNING
        VALUE(result) TYPE abap_bool
      RAISING
        zaplink_cx_file .
    METHODS search
      IMPORTING
        !mask         TYPE td_filename
        !root_dir     TYPE td_directoryname
      RETURNING
        VALUE(result) TYPE tt_file_list
      RAISING
        zaplink_cx_file .
    METHODS get_temp_directory
      RETURNING
        VALUE(result) TYPE td_directoryname
      RAISING
        zaplink_cx_file .
    METHODS delete
      RAISING
        zaplink_cx_file .
  PROTECTED SECTION.
    TYPES td_content TYPE string .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    TYPES to_exception TYPE REF TO zaplink_cx_file .
    DATA _filename TYPE td_filename .
    DATA _filetype TYPE td_filetype .
    DATA _content TYPE td_content .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_FILE definition
CLASS zaplink_message_collector DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPES:
      t_msg TYPE STANDARD TABLE OF bal_s_msg WITH NON-UNIQUE DEFAULT KEY .
    DATA object TYPE balobj_d READ-ONLY .
    DATA md_extnumber TYPE balnrext READ-ONLY .
    DATA md_level TYPE ballevel READ-ONLY .
    DATA subobject TYPE balsubobj READ-ONLY .
    DATA ext_id TYPE balnrext READ-ONLY .
    CONSTANTS:
      BEGIN OF actions,
        create  TYPE bu_aktyp VALUE '01',                   "#EC NOTEXT
        change  TYPE bu_aktyp VALUE '02',                   "#EC NOTEXT
        display TYPE bu_aktyp VALUE '03',                   "#EC NOTEXT
      END OF actions .
    DATA msgid TYPE symsgid .
    CONSTANTS:
      BEGIN OF probcl,
        very_imp  TYPE balprobcl VALUE '1',                 "#EC NOTEXT
        important TYPE balprobcl VALUE '2',                 "#EC NOTEXT
        medium    TYPE balprobcl VALUE '3',                 "#EC NOTEXT
        for_info  TYPE balprobcl VALUE '4',                 "#EC NOTEXT
        other     TYPE balprobcl VALUE space,
      END OF probcl .
    DATA md_handle TYPE balloghndl READ-ONLY .
    METHODS add
      IMPORTING
        !is_message       TYPE bal_s_msg OPTIONAL
        !id_msgty         TYPE symsgty OPTIONAL
        !id_msgid         TYPE symsgid OPTIONAL
        !id_msgno         TYPE symsgno OPTIONAL
        !id_msgv1         TYPE clike OPTIONAL
        !id_msgv2         TYPE clike OPTIONAL
        !id_msgv3         TYPE clike OPTIONAL
        !id_msgv4         TYPE clike OPTIONAL
        !id_msgd1         TYPE sydatum OPTIONAL
        !id_msgd2         TYPE sydatum OPTIONAL
        !id_msgd3         TYPE sydatum OPTIONAL
        !id_msgd4         TYPE sydatum OPTIONAL
        !id_detlevel      TYPE ballevel OPTIONAL
        !if_cumulate      TYPE abap_bool OPTIONAL
        !id_probclass     TYPE balprobcl OPTIONAL
        !id_index         TYPE numeric OPTIONAL
        !id_sublog        TYPE balloghndl OPTIONAL
      EXPORTING
        VALUE(es_message) TYPE bal_s_msg .
    METHODS add_abend
      IMPORTING
        !id_msgid     TYPE symsgid OPTIONAL
        !id_msgno     TYPE symsgno
        !id_msgv1     TYPE clike OPTIONAL
        !id_msgv2     TYPE clike OPTIONAL
        !id_msgv3     TYPE clike OPTIONAL
        !id_msgv4     TYPE clike OPTIONAL
        !id_detlevel  TYPE ballevel OPTIONAL
        !id_probclass TYPE balprobcl OPTIONAL .
    METHODS add_error
      IMPORTING
        !id_msgid     TYPE symsgid OPTIONAL
        !id_msgno     TYPE symsgno
        !id_msgv1     TYPE clike OPTIONAL
        !id_msgv2     TYPE clike OPTIONAL
        !id_msgv3     TYPE clike OPTIONAL
        !id_msgv4     TYPE clike OPTIONAL
        !id_detlevel  TYPE ballevel OPTIONAL
        !id_probclass TYPE balprobcl OPTIONAL .
    METHODS add_exception
      IMPORTING
        !exception    TYPE REF TO cx_root
        !id_detlevel  TYPE ballevel OPTIONAL
        !id_probclass TYPE balprobcl OPTIONAL .
    METHODS add_from_bapi
      IMPORTING
        !it_bapiret     TYPE bapirettab OPTIONAL
        !is_bapiret     TYPE bapiret2 OPTIONAL
        !if_cumulate    TYPE abap_bool OPTIONAL
      EXPORTING
        !ef_add_error   TYPE abap_bool
        !ef_add_warning TYPE abap_bool .
    METHODS add_from_instance
      IMPORTING
        !io_msglist        TYPE REF TO zaplink_message_collector
        !if_add_as_subnode TYPE abap_bool DEFAULT abap_false
        !if_cumulate       TYPE abap_bool OPTIONAL .
    METHODS add_info
      IMPORTING
        !id_msgid     TYPE symsgid OPTIONAL
        !id_msgno     TYPE symsgno
        !id_msgv1     TYPE clike OPTIONAL
        !id_msgv2     TYPE clike OPTIONAL
        !id_msgv3     TYPE clike OPTIONAL
        !id_msgv4     TYPE clike OPTIONAL
        !id_detlevel  TYPE ballevel OPTIONAL
        !id_probclass TYPE balprobcl OPTIONAL .
    METHODS add_success
      IMPORTING
        !id_msgid     TYPE symsgid OPTIONAL
        !id_msgno     TYPE symsgno
        !id_msgv1     TYPE clike OPTIONAL
        !id_msgv2     TYPE clike OPTIONAL
        !id_msgv3     TYPE clike OPTIONAL
        !id_msgv4     TYPE clike OPTIONAL
        !id_detlevel  TYPE ballevel OPTIONAL
        !id_probclass TYPE balprobcl OPTIONAL .
    METHODS add_symsg
      IMPORTING
        !id_msgty         TYPE symsgty DEFAULT sy-msgty
        !id_detlevel      TYPE ballevel OPTIONAL
        !if_cumulate      TYPE abap_bool OPTIONAL
        !id_probclass     TYPE balprobcl OPTIONAL
        !id_index         TYPE numeric OPTIONAL
      EXPORTING
        VALUE(es_message) TYPE bal_s_msg .
    METHODS add_warning
      IMPORTING
        !id_msgid     TYPE symsgid OPTIONAL
        !id_msgno     TYPE symsgno
        !id_msgv1     TYPE clike OPTIONAL
        !id_msgv2     TYPE clike OPTIONAL
        !id_msgv3     TYPE clike OPTIONAL
        !id_msgv4     TYPE clike OPTIONAL
        !id_detlevel  TYPE ballevel OPTIONAL
        !id_probclass TYPE balprobcl OPTIONAL .
    CLASS-METHODS as_char
      IMPORTING
        !id_date       TYPE sydatum
      RETURNING
        VALUE(rd_date) TYPE char10 .
    METHODS change_msg_type
      IMPORTING
        !id_msgty_src     TYPE symsgty OPTIONAL
        !id_msgty_trg     TYPE symsgty
      RETURNING
        VALUE(rd_changed) TYPE i .
    METHODS check_custo
      IMPORTING
        !id_object    TYPE balobj_d
        !id_subobject TYPE balsubobj
      EXCEPTIONS
        error .
    METHODS clear .
    CLASS-METHODS convert_date_to_string
      IMPORTING
        !id_date        TYPE sydatum
      EXPORTING
        !ed_date_string TYPE csequence .
    METHODS count
      RETURNING
        VALUE(rd_count) TYPE i .
    METHODS delete_message
      IMPORTING
        !id_msgnumber TYPE balmnr
      EXCEPTIONS
        not_found .
    METHODS free .
    METHODS get_first_message
      IMPORTING
        !id_msgty     TYPE symsgty DEFAULT 'I'
        !if_or_higher TYPE abap_bool DEFAULT abap_true
      EXPORTING
        !es_message   TYPE bal_s_msg
      EXCEPTIONS
        not_found .
    METHODS get_handle
      RETURNING
        VALUE(rd_handle) TYPE balloghndl .
    METHODS get_last_message
      IMPORTING
        !id_msgty     TYPE symsgty DEFAULT 'I'
        !if_or_higher TYPE abap_bool DEFAULT abap_true
      EXPORTING
        !es_message   TYPE bal_s_msg
      EXCEPTIONS
        not_found .
    METHODS get_list
      RETURNING
        VALUE(et_list) TYPE t_msg .
    METHODS get_list_as_bapiret
      RETURNING
        VALUE(et_list) TYPE bapirettab .
    CLASS-METHODS get_ref_type
      IMPORTING
        !typedesc       TYPE REF TO cl_abap_typedescr
      RETURNING
        VALUE(ref_type) TYPE REF TO cl_abap_typedescr .
    METHODS get_statistics
      RETURNING
        VALUE(rs_statistics) TYPE bal_s_scnt .
    METHODS get_statistics_as_text
      IMPORTING
        !if_output_e_messages   TYPE abap_bool DEFAULT abap_true
        !if_output_w_messages   TYPE abap_bool DEFAULT abap_true
        !if_output_i_messages   TYPE abap_bool DEFAULT abap_false
        !if_output_highest_only TYPE abap_bool DEFAULT abap_true
      EXPORTING
        VALUE(ed_text)          TYPE csequence .
    METHODS has_messages_of_msgt
      IMPORTING
        !id_msgty        TYPE symsgty
        !if_or_higher    TYPE abap_bool DEFAULT abap_true
      RETURNING
        VALUE(rf_exists) TYPE abap_bool .
    METHODS init
      IMPORTING
        !id_object      TYPE balobj_d
        !id_subobject   TYPE balsubobj
        !id_extnumber   TYPE balnrext OPTIONAL
        !auto_upd_custo TYPE flag DEFAULT abap_false
        !id_activity    TYPE bu_aktyp DEFAULT actions-create
      EXCEPTIONS
        error .
    METHODS init_by_handle
      IMPORTING
        !id_handle TYPE balloghndl
      EXCEPTIONS
        error .
    METHODS insert
      IMPORTING
        !id_insert_index             TYPE i
        !if_set_following_as_subnode TYPE abap_bool DEFAULT abap_false
        !is_message                  TYPE bal_s_msg OPTIONAL
        !id_msgty                    TYPE symsgty OPTIONAL
        !id_msgid                    TYPE symsgid OPTIONAL
        !id_msgno                    TYPE symsgno OPTIONAL
        !id_msgv1                    TYPE clike OPTIONAL
        !id_msgv2                    TYPE clike OPTIONAL
        !id_msgv3                    TYPE clike OPTIONAL
        !id_msgv4                    TYPE clike OPTIONAL
        !id_msgd1                    TYPE sydatum OPTIONAL
        !id_msgd2                    TYPE sydatum OPTIONAL
        !id_msgd3                    TYPE sydatum OPTIONAL
        !id_msgd4                    TYPE sydatum OPTIONAL
        !id_detlevel                 TYPE ballevel OPTIONAL
        !id_probclass                TYPE balprobcl OPTIONAL
        !id_index                    TYPE numeric OPTIONAL
      EXPORTING
        VALUE(es_message)            TYPE bal_s_msg .
    CLASS-METHODS is_date_initial
      IMPORTING
        !id_date          TYPE sy-datum
      RETURNING
        VALUE(rf_initial) TYPE abap_bool .
    METHODS is_empty
      RETURNING
        VALUE(rf_empty) TYPE abap_bool .
    CLASS-METHODS new
      RETURNING
        VALUE(obj) TYPE REF TO zaplink_message_collector .
    METHODS raise_first_message
      IMPORTING
        !id_msgty     TYPE symsgty DEFAULT 'E'
        !if_or_higher TYPE abap_bool DEFAULT abap_true
      EXCEPTIONS
        first_message .
    METHODS raise_on_error
      RAISING
        zaplink_cx .
    METHODS set_detail_level
      IMPORTING
        !id_absolute TYPE ballevel OPTIONAL
        !id_relative TYPE int4 OPTIONAL .
    METHODS set_extnumber
      IMPORTING
        !id_extnumber TYPE balnrext .
    METHODS store
      IMPORTING
        !if_in_update_task TYPE abap_bool DEFAULT abap_false
      EXCEPTIONS
        error .
    METHODS write
      IMPORTING
        !_offset TYPE string OPTIONAL .
  PROTECTED SECTION.
    TYPES:
      BEGIN OF msg_x .
        INCLUDE TYPE bal_s_msg AS msg.
    TYPES:
      msgnumber TYPE balmnr,
      END OF msg_x .
    TYPES:
      t_msg_x TYPE STANDARD TABLE OF msg_x WITH NON-UNIQUE DEFAULT KEY .
    CONSTANTS mc_min_level TYPE n VALUE '1'.                "#EC NOTEXT
    CONSTANTS mc_max_level TYPE n VALUE '9'.                "#EC NOTEXT
    DATA ms_log TYPE bal_s_log .
    DATA md_sup_count TYPE sytabix .
    DATA mt_sup_msg TYPE t_msg_x .
    DATA mf_log_not_stored TYPE abap_bool VALUE abap_false. "#EC NOTEXT .
    METHODS get_list_x
      IMPORTING
        !id_msgty  TYPE symsgty DEFAULT 'I'
      EXPORTING
        !et_list_x TYPE t_msg_x .
    METHODS get_msg_filter
      IMPORTING
        VALUE(id_msgty)     TYPE symsgty DEFAULT 'I'
        VALUE(if_or_higher) TYPE abap_bool DEFAULT abap_true
      EXPORTING
        !es_msg_filter      TYPE bal_s_mfil .
    METHODS _add_zl_cx
      IMPORTING
        !exception    TYPE REF TO zaplink_cx
        !id_detlevel  TYPE ballevel
        !id_probclass TYPE balprobcl .
    METHODS _add_exception
      IMPORTING
        !exception    TYPE REF TO cx_root
        !id_detlevel  TYPE ballevel
        !id_probclass TYPE balprobcl .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_MESSAGE_COLLECTOR definition
CLASS zaplink_opt_devclass DEFINITION
  INHERITING FROM zaplink_opt_base
  CREATE PUBLIC .
  PUBLIC SECTION.
    CONSTANTS:
      BEGIN OF substitutionkinds,
        use_container TYPE td_substitutionkind VALUE 'C',    " Keep dev class in XML file
        no_overwrite  TYPE td_substitutionkind VALUE 'N',    " No overwrite : Use existing devclass, otherwise use container devclass otherwise use local otherwise let user choose
        keep_existing TYPE td_substitutionkind VALUE 'K',    " Use devclass define in component
        local         TYPE td_substitutionkind VALUE 'L',    " Devclass = $TMP
        fixed         TYPE td_substitutionkind VALUE 'F',    " Assign allways the same specified devclass
      END OF substitutionkinds .
    METHODS constructor .
    METHODS get_substitutionkind
      RETURNING
        VALUE(result) TYPE td_substitutionkind
      RAISING
        zaplink_cx_opt_devclass .
    METHODS set_substitutionkind
      IMPORTING
        !data TYPE td_substitutionkind
      RAISING
        zaplink_cx_opt_devclass .
    METHODS get_devclass
      RETURNING
        VALUE(result) TYPE td_devclass
      RAISING
        zaplink_cx_opt_devclass .
    METHODS set_devclass
      IMPORTING
        !data TYPE td_devclass
      RAISING
        zaplink_cx_opt_devclass .
    METHODS substitute
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(result) TYPE td_devclass
      RAISING
        zaplink_cx_opt_devclass .
  PROTECTED SECTION.
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    TYPES to_exception TYPE REF TO zaplink_cx_opt_devclass .
    DATA _substitution TYPE td_substitutionkind .
    DATA _devclass TYPE td_devclass .
    METHODS get_existing
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(result) TYPE td_devclass
      RAISING
        zaplink_cx_opt_devclass .
    METHODS do_exists
      IMPORTING
        !data         TYPE td_devclass
      RETURNING
        VALUE(result) TYPE td_exists
      RAISING
        zaplink_cx_opt_devclass .
  PRIVATE SECTION.
    CONSTANTS local_devclass TYPE td_devclass VALUE '$TMP'. "#EC NOTEXT
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_OPT_DEVCLASS definition
CLASS zaplink_opt_transport_request DEFINITION
  INHERITING FROM zaplink_opt_base
  CREATE PUBLIC .
  PUBLIC SECTION.
    CONSTANTS:
      BEGIN OF substitutionkinds,
        fixed             TYPE td_substitutionkind VALUE 'F',    " Assign allways the same specified devclass
        same_as_container TYPE td_substitutionkind VALUE 'K',    " Keep the same scheme as in container
        user              TYPE td_substitutionkind VALUE 'U',    " let user select a transport request for all component
        input             TYPE td_substitutionkind VALUE 'I',    " let user select a transport request for each component
        custom            TYPE td_substitutionkind VALUE 'X',    " user define
      END OF substitutionkinds .
    METHODS constructor .
    METHODS get_substitutionkind
      RETURNING
        VALUE(result) TYPE td_substitutionkind
      RAISING
        zaplink_cx_opt_devclass .
    METHODS set_substitutionkind
      IMPORTING
        !data TYPE td_substitutionkind
      RAISING
        zaplink_cx_opt_devclass .
    METHODS get_transport_request
      RETURNING
        VALUE(result) TYPE td_transport_request
      RAISING
        zaplink_cx_opt_devclass .
    METHODS set_transport_request
      IMPORTING
        !data TYPE td_transport_request
      RAISING
        zaplink_cx_opt_devclass .
    METHODS substitute
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(result) TYPE td_transport_request
      RAISING
        zaplink_cx_opt_devclass .
  PROTECTED SECTION.
    DATA _substitution TYPE td_substitutionkind .
    DATA _transport_request TYPE td_transport_request .
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ts_tr_substit,
        xml_tr TYPE td_transport_request,
        sap_tr TYPE td_transport_request,
      END OF ts_tr_substit .
    TYPES:
      tt_tr_substits TYPE SORTED TABLE OF ts_tr_substit WITH UNIQUE KEY xml_tr .
    DATA _tr_mapping TYPE tt_tr_substits .
    DATA _user_input TYPE td_transport_request .
ENDCLASS. "ZAPLINK_OPT_TRANSPORT_REQUEST definition
CLASS zaplink_tools DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS sedi .
    TYPE-POOLS sewor .
    TYPE-POOLS smodi .
    INTERFACES zaplink_datatypes .
    ALIASES comp_nodename
      FOR zaplink_datatypes~comp_nodename .
    ALIASES exists
      FOR zaplink_datatypes~exists .
    ALIASES ext_sep
      FOR zaplink_datatypes~ext_sep .
    ALIASES file_ext
      FOR zaplink_datatypes~file_ext .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES textpool_kinds
      FOR zaplink_datatypes~textpool_kinds .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_action
      FOR zaplink_datatypes~td_action .
    ALIASES td_checksum
      FOR zaplink_datatypes~td_checksum .
    ALIASES td_classname
      FOR zaplink_datatypes~td_classname .
    ALIASES td_compexists
      FOR zaplink_datatypes~td_compexists .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptext
      FOR zaplink_datatypes~td_comptext .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    ALIASES td_connexists
      FOR zaplink_datatypes~td_connexists .
    ALIASES td_connuuid
      FOR zaplink_datatypes~td_connuuid .
    ALIASES td_connver
      FOR zaplink_datatypes~td_connver .
    ALIASES td_contname
      FOR zaplink_datatypes~td_contname .
    ALIASES td_contver
      FOR zaplink_datatypes~td_contver .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES td_exists
      FOR zaplink_datatypes~td_exists .
    ALIASES td_filename
      FOR zaplink_datatypes~td_filename .
    ALIASES td_filetype
      FOR zaplink_datatypes~td_filetype .
    ALIASES td_lang
      FOR zaplink_datatypes~td_lang .
    ALIASES td_light
      FOR zaplink_datatypes~td_light .
    ALIASES td_obj_type
      FOR zaplink_datatypes~td_obj_type .
    ALIASES td_orderkind
      FOR zaplink_datatypes~td_orderkind .
    ALIASES td_progname
      FOR zaplink_datatypes~td_progname .
    ALIASES td_substitutionkind
      FOR zaplink_datatypes~td_substitutionkind .
    ALIASES td_transport_request
      FOR zaplink_datatypes~td_transport_request .
    ALIASES td_txtp_id
      FOR zaplink_datatypes~td_txtp_id .
    ALIASES td_txtp_kind
      FOR zaplink_datatypes~td_txtp_kind .
    ALIASES td_txtp_len
      FOR zaplink_datatypes~td_txtp_len .
    ALIASES td_txtp_text
      FOR zaplink_datatypes~td_txtp_text .
    ALIASES td_typeorder
      FOR zaplink_datatypes~td_typeorder .
    ALIASES td_type_as_text
      FOR zaplink_datatypes~td_type_as_text .
    ALIASES td_with_subcomp
      FOR zaplink_datatypes~td_with_subcomp .
    ALIASES to_xml
      FOR zaplink_datatypes~to_xml .
    ALIASES tr_author
      FOR zaplink_datatypes~tr_author .
    ALIASES tr_compname
      FOR zaplink_datatypes~tr_compname .
    ALIASES tr_comptype
      FOR zaplink_datatypes~tr_comptype .
    ALIASES tr_dlvunit
      FOR zaplink_datatypes~tr_dlvunit .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    ALIASES tr_packages
      FOR zaplink_datatypes~tr_packages .
    ALIASES tr_srcsystem
      FOR zaplink_datatypes~tr_srcsystem .
    ALIASES tr_tr
      FOR zaplink_datatypes~tr_tr .
    ALIASES ts_base_attributs
      FOR zaplink_datatypes~ts_base_attributs .
    ALIASES ts_compkey
      FOR zaplink_datatypes~ts_compkey .
    ALIASES ts_component
      FOR zaplink_datatypes~ts_component .
    ALIASES ts_conndata
      FOR zaplink_datatypes~ts_conndata .
    ALIASES ts_conn_class
      FOR zaplink_datatypes~ts_conn_class .
    ALIASES ts_conn_def
      FOR zaplink_datatypes~ts_conn_def .
    ALIASES ts_contdata
      FOR zaplink_datatypes~ts_contdata .
    ALIASES ts_directory
      FOR zaplink_datatypes~ts_directory .
    ALIASES ts_doc
      FOR zaplink_datatypes~ts_doc .
    ALIASES ts_head
      FOR zaplink_datatypes~ts_head .
    ALIASES ts_lang
      FOR zaplink_datatypes~ts_lang .
    ALIASES ts_statment
      FOR zaplink_datatypes~ts_statment .
    ALIASES ts_txtp_text
      FOR zaplink_datatypes~ts_txtp_text .
    ALIASES ts_txtp_textpool
      FOR zaplink_datatypes~ts_txtp_textpool .
    ALIASES ts_type
      FOR zaplink_datatypes~ts_type .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_compkeys
      FOR zaplink_datatypes~tt_compkeys .
    ALIASES tt_conn_classes
      FOR zaplink_datatypes~tt_conn_classes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_gensetc
      FOR zaplink_datatypes~tt_gensetc .
    ALIASES tt_rawtext
      FOR zaplink_datatypes~tt_rawtext .
    ALIASES tt_tokens
      FOR zaplink_datatypes~tt_tokens .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    ALIASES tt_txtp_texts
      FOR zaplink_datatypes~tt_txtp_texts .
    ALIASES tt_types
      FOR zaplink_datatypes~tt_types .
    CLASS-DATA import_allowed TYPE abap_bool READ-ONLY .
    CLASS-METHODS class_constructor .
    CLASS-METHODS calculate_md5_hash
      IMPORTING
        !string       TYPE string
      RETURNING
        VALUE(result) TYPE td_checksum .
    CLASS-METHODS clean_abap_string
      IMPORTING
        !data         TYPE string
      RETURNING
        VALUE(result) TYPE string .
    CLASS-METHODS add_comp_to_working_area
      IMPORTING
        !name TYPE td_compname
        !type TYPE td_comptype
      RAISING
        zaplink_cx .
    CLASS-METHODS remove_comp_from_working_area
      IMPORTING
        !name TYPE td_compname
        !type TYPE td_comptype .
    CLASS-METHODS is_working_areable
      IMPORTING
        !type         TYPE td_comptype
      RETURNING
        VALUE(result) TYPE abap_bool .
    CLASS-METHODS condense_abap_source
      CHANGING
        !table TYPE STANDARD TABLE .
    CLASS-METHODS conv_abap_line
      IMPORTING
        !source       TYPE string
      RETURNING
        VALUE(target) TYPE string .
    CLASS-METHODS conv_table_2upcase
      CHANGING
        !table TYPE STANDARD TABLE .
    CLASS-METHODS extend_packages
      IMPORTING
        !packages     TYPE tr_packages
      RETURNING
        VALUE(result) TYPE tr_packages .
    CLASS-METHODS get_clas_name
      IMPORTING
        !object       TYPE REF TO object
      RETURNING
        VALUE(result) TYPE td_classname .
    CLASS-METHODS get_keys_from_package
      IMPORTING
        !packages     TYPE tr_packages
        !ext          TYPE abap_bool DEFAULT abap_true
      RETURNING
        VALUE(result) TYPE tt_compkeys .
    CLASS-METHODS get_keys_from_tadir
      IMPORTING
        !srcsystem    TYPE tr_srcsystem OPTIONAL
        !type         TYPE tr_comptype OPTIONAL
        !name         TYPE tr_compname OPTIONAL
        !packages     TYPE tr_packages OPTIONAL
        !ext          TYPE abap_bool DEFAULT abap_true
        !author       TYPE tr_author OPTIONAL
      RETURNING
        VALUE(result) TYPE tt_compkeys .
    CLASS-METHODS get_keys_from_tr
      IMPORTING
        !tr           TYPE tr_tr
      RETURNING
        VALUE(result) TYPE tt_compkeys .
    CLASS-METHODS inverse_table_order
      CHANGING
        !my_table TYPE STANDARD TABLE .
    CLASS-METHODS pretty_printer
      IMPORTING
        !indent TYPE abap_bool OPTIONAL
      CHANGING
        !table  TYPE STANDARD TABLE .
    CLASS-METHODS remove_comment_on_source
      CHANGING
        !table TYPE STANDARD TABLE .
    CLASS-METHODS table_2_string
      IMPORTING
        !source       TYPE STANDARD TABLE
      RETURNING
        VALUE(result) TYPE string .
    CLASS-METHODS unzip_string
      IMPORTING
        !data         TYPE xstring
      RETURNING
        VALUE(result) TYPE string .
    CLASS-METHODS zip_string
      IMPORTING
        !data         TYPE string
      RETURNING
        VALUE(result) TYPE xstring .
    CLASS-METHODS check_valid_proglist
      IMPORTING
        !list         TYPE tt_gensetc
      RETURNING
        VALUE(result) TYPE tt_gensetc .
    CLASS-METHODS conv_compkey_2_proglist
      IMPORTING
        !keys         TYPE tt_compkeys
      RETURNING
        VALUE(result) TYPE tt_gensetc .
    CLASS-METHODS conv_proglist_2_compkey
      IMPORTING
        !list         TYPE tt_gensetc
      RETURNING
        VALUE(result) TYPE tt_compkeys .
    CLASS-METHODS comment_statement
      IMPORTING
        !statement TYPE ts_statment
        !tokens    TYPE tt_tokens
        !comment   TYPE string OPTIONAL
      CHANGING
        !code      TYPE tt_abaprawsource .
  PROTECTED SECTION.
    TYPES:
      tt_e071 TYPE STANDARD TABLE OF e071 WITH DEFAULT KEY .
    TYPES:
      tt_pack TYPE STANDARD TABLE OF tdevc-devclass WITH DEFAULT KEY .
    CONSTANTS:
      gc_gen_types(8) TYPE c VALUE '1CFJKMST'.              "#EC NOTEXT
    CLASS-METHODS conv_limu_2_r3tr
      IMPORTING
        !e071         TYPE tt_e071
      RETURNING
        VALUE(result) TYPE tt_compkeys .
    CLASS-METHODS extend_package
      IMPORTING
        !packages     TYPE tt_pack
      RETURNING
        VALUE(result) TYPE tt_pack .
    CLASS-METHODS get_sub_packages
      IMPORTING
        !packages     TYPE tr_packages
      RETURNING
        VALUE(result) TYPE tr_packages .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_TOOLS definition
CLASS zlcx_comp_already_exists DEFINITION
  INHERITING FROM zaplink_cx_list
  CREATE PUBLIC .
  PUBLIC SECTION.
    CONSTANTS:
      BEGIN OF zlcx_comp_already_exists,
        msgid TYPE symsgid VALUE 'ZAPLINK',
        msgno TYPE symsgno VALUE '300',
        attr1 TYPE scx_attrname VALUE 'TYPE',
        attr2 TYPE scx_attrname VALUE 'NAME',
        attr3 TYPE scx_attrname VALUE '',
        attr4 TYPE scx_attrname VALUE '',
      END OF zlcx_comp_already_exists .
    METHODS constructor
      IMPORTING
        !textid      LIKE if_t100_message=>t100key OPTIONAL
        !previous    LIKE previous OPTIONAL
        !messages    TYPE o_msg_coll OPTIONAL
        !object      TYPE balobj_d OPTIONAL
        !subobject   TYPE balsubobj OPTIONAL
        !ext_id      TYPE balnrext OPTIONAL
        !cx_name     TYPE string OPTIONAL
        !_cx_list    TYPE tt_cx_list OPTIONAL
        !systemstack TYPE abap_callstack OPTIONAL
        !name        TYPE td_compname OPTIONAL
        !type        TYPE td_comptype OPTIONAL
        !connclass   TYPE td_connclass OPTIONAL
        !sel_action  TYPE td_action OPTIONAL .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZLCX_COMP_ALREADY_EXISTS definition
CLASS zaplink_acid_data DEFINITION
  INHERITING FROM zaplink_checkpoints_data
  CREATE PUBLIC
  FRIENDS zaplink_checkpoints
                 zaplink_easyxml .
  PUBLIC SECTION.
  PROTECTED SECTION.
    TYPES:
      BEGIN OF ts_fm_data,
        header       TYPE aab_id_prop,     " aab_id_sfields,
        descriptions TYPE STANDARD TABLE OF aab_id_propt WITH DEFAULT KEY,
        modes        TYPE aab_id_act_tab,
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE aab_id_sfields.
    TYPES:
      END OF ts_maindata .
    TYPES:
      BEGIN OF ts_4user,
        user TYPE aab_id_act-username.
        INCLUDE TYPE ts_activation AS activation.
    TYPES:
      END OF ts_4user .
    TYPES:
      tt_users TYPE SORTED TABLE OF ts_4user WITH UNIQUE KEY user .
    TYPES:
      BEGIN OF ts_4server,
        server TYPE aab_id_act-server.
        INCLUDE TYPE ts_activation AS activation.
    TYPES:
      END OF ts_4server .
    TYPES:
      tt_servers TYPE SORTED TABLE OF ts_4server WITH UNIQUE KEY server .
    DATA a0_maindata TYPE ts_maindata .
    DATA global_settings TYPE ts_activation .
    DATA settings_for_users TYPE tt_users .
    DATA settings_for_servers TYPE tt_servers .
    DATA descriptions TYPE tt_ltexts .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_ACID_DATA definition
CLASS zaplink_activate DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS sewor .
    TYPE-POOLS swbm .
    INTERFACES zaplink_datatypes .
    ALIASES td_checkbox
      FOR zaplink_datatypes~td_checkbox .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES tr_author
      FOR zaplink_datatypes~tr_author .
    ALIASES tr_compname
      FOR zaplink_datatypes~tr_compname .
    ALIASES tr_comptype
      FOR zaplink_datatypes~tr_comptype .
    ALIASES tr_packages
      FOR zaplink_datatypes~tr_packages .
    ALIASES tr_srcsystem
      FOR zaplink_datatypes~tr_srcsystem .
    ALIASES tt_compkeys
      FOR zaplink_datatypes~tt_compkeys .
    TYPES to_list TYPE REF TO zaplink_list .
    TYPES:
      tt_objlist TYPE STANDARD TABLE OF e071 WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      tt_genset  TYPE STANDARD TABLE OF gensetc WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      tt_det_obj TYPE STANDARD TABLE OF dwinactiv WITH NON-UNIQUE DEFAULT KEY .
    DATA activation_requested TYPE td_checkbox READ-ONLY .
    DATA object_count TYPE i READ-ONLY .
    DATA force_activation TYPE td_checkbox READ-ONLY .
    METHODS add_from_tadir
      IMPORTING
        !srcsystem TYPE tr_srcsystem
        !author    TYPE tr_author
        !type      TYPE tr_comptype
        !name      TYPE tr_compname
        !packages  TYPE tr_packages
        !ext       TYPE abap_bool
      RAISING
        zaplink_cx .
    METHODS reset .
    METHODS add_keys
      IMPORTING
        !obj_list TYPE tt_compkeys .
    METHODS add_list
      IMPORTING
        !o_list TYPE to_list .
    METHODS ask_for_activation
      RETURNING
        VALUE(result) TYPE tt_compkeys
      RAISING
        zaplink_cx .
    METHODS activate
      IMPORTING
        !force_activation TYPE td_checkbox OPTIONAL
      RETURNING
        VALUE(result)     TYPE tt_compkeys .
    CLASS-METHODS get_inactive_objects
      IMPORTING
        !obj_list    TYPE tt_objlist
      RETURNING
        VALUE(inact) TYPE tt_det_obj .
    CLASS-METHODS check_inactive_objects
      CHANGING
        !obj_list TYPE tt_objlist .
    METHODS generate
      RETURNING
        VALUE(result) TYPE tt_compkeys .
  PROTECTED SECTION.
    TYPES:
      BEGIN OF t_mainprog,
        master          TYPE d010inc-master,
        include         TYPE d010inc-include,
        object          TYPE e071-object,
        error(1)        TYPE c,
        switch_state(1) TYPE c,
      END OF t_mainprog .
    TYPES:
      tt_mainprogs TYPE STANDARD TABLE OF t_mainprog WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      tt_items TYPE STANDARD TABLE OF sewor_working_area WITH NON-UNIQUE DEFAULT KEY .
    DATA it_items TYPE tt_items .
    DATA it_obj_list TYPE tt_objlist .
    DATA component_list TYPE tt_compkeys .
    CLASS-METHODS split_list
      IMPORTING
        !obj_list  TYPE tt_objlist
      EXPORTING
        !ddic      TYPE tt_objlist
        !prog_list TYPE tt_objlist .
    CLASS-METHODS activate_objects
      IMPORTING
        !programs TYPE tt_mainprogs
        !items    TYPE tt_items .
    CLASS-METHODS activate_ddic_v2
      IMPORTING
        !one_by_one TYPE xflag OPTIONAL
      CHANGING
        !it_list    TYPE tt_objlist .
    CLASS-METHODS activate_nonddic
      IMPORTING
        !one_by_one       TYPE td_checkbox OPTIONAL
        !force_activation TYPE td_checkbox OPTIONAL
      CHANGING
        !it_list          TYPE tt_objlist .
    CLASS-METHODS activate_ddic
      CHANGING
        !it_list TYPE tt_objlist .
    METHODS add_obj_to_wa .
    CLASS-METHODS conv_list
      IMPORTING
        !obj_list        TYPE tt_objlist
      RETURNING
        VALUE(item_list) TYPE tt_items .
    CLASS-METHODS compkeys_2_objlist
      IMPORTING
        !keys         TYPE tt_compkeys
      RETURNING
        VALUE(result) TYPE tt_objlist .
    CLASS-METHODS objlist_2_compkeys
      IMPORTING
        !keys         TYPE tt_objlist
      RETURNING
        VALUE(result) TYPE tt_compkeys .
    CLASS-METHODS compkeys_2_genset
      IMPORTING
        !keys         TYPE tt_compkeys
      RETURNING
        VALUE(result) TYPE tt_genset .
    CLASS-METHODS genset_2_compkeys
      IMPORTING
        !keys         TYPE tt_genset
      RETURNING
        VALUE(result) TYPE tt_compkeys .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_ACTIVATE definition
CLASS zaplink_avar_data DEFINITION
  INHERITING FROM zaplink_checkpoints_data
  CREATE PUBLIC
  FRIENDS zaplink_checkpoints
                 zaplink_easyxml .
  PUBLIC SECTION.
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
  PROTECTED SECTION.
    TYPES:
      BEGIN OF ts_name,
        name TYPE aab_var_name,
        user TYPE aab_var_local,
      END OF ts_name .
    TYPES:
      BEGIN OF ts_fm_data,
        header       TYPE aab_var_prop,     " aab_var_sfields,
        descriptions TYPE STANDARD TABLE OF aab_var_propt WITH DEFAULT KEY,
        modes        TYPE aab_var_obj_act_tab,
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE aab_var_sfields.
    TYPES:
      END OF ts_maindata .
    TYPES:
      BEGIN OF ts_definition,
        type TYPE td_comptype,
        name TYPE td_compname.
        INCLUDE TYPE ts_activation AS activation.
    TYPES:
      END OF ts_definition .
    TYPES:
      tt_definitions TYPE SORTED TABLE OF ts_definition WITH UNIQUE KEY type name .
    DATA a0_maindata TYPE ts_maindata .
    DATA definitions TYPE tt_definitions .
    DATA descriptions TYPE tt_ltexts .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
    CLASS-METHODS name_2_key
      IMPORTING
        !data         TYPE td_compname
      RETURNING
        VALUE(result) TYPE ts_name .
    CLASS-METHODS key_2_name
      IMPORTING
        !data         TYPE ts_name
      RETURNING
        VALUE(result) TYPE td_compname .
  PRIVATE SECTION.
    CONSTANTS separator TYPE char01 VALUE '~'.              "#EC NOTEXT
ENDCLASS. "ZAPLINK_AVAR_DATA definition
INTERFACE zaplink_cnx_ext_cleaner.
  TYPE-POOLS abap .
  TYPES to_raw TYPE REF TO zaplink_raw .
  METHODS anonymize
    IMPORTING
      !object TYPE to_raw
    RAISING
      zaplink_cx .
  METHODS unanonymize
    IMPORTING
      !object TYPE to_raw
    RAISING
      zaplink_cx .
ENDINTERFACE.
INTERFACE zaplink_cnx_ext_code_signature.
  TYPE-POOLS abap .
  INTERFACES zaplink_datatypes .
  ALIASES td_checksum
  FOR zaplink_datatypes~td_checksum .
  TYPES to_component TYPE REF TO zaplink_component .
  METHODS get_signature
    IMPORTING
      !component    TYPE to_component
    RETURNING
      VALUE(result) TYPE td_checksum
    RAISING
      zaplink_cx .
ENDINTERFACE.
CLASS zaplink_component DEFINITION
  CREATE PUBLIC
  FRIENDS zaplink_list .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    INTERFACES zaplink_datatypes .
    ALIASES default_sub_component_level
      FOR zaplink_datatypes~default_sub_component_level .
    ALIASES exists
      FOR zaplink_datatypes~exists .
    ALIASES td_action
      FOR zaplink_datatypes~td_action .
    ALIASES td_checksum
      FOR zaplink_datatypes~td_checksum .
    ALIASES td_compadd_data
      FOR zaplink_datatypes~td_compadd_data .
    ALIASES td_compexists
      FOR zaplink_datatypes~td_compexists .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    ALIASES td_connexists
      FOR zaplink_datatypes~td_connexists .
    ALIASES td_connuuid
      FOR zaplink_datatypes~td_connuuid .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_obj_type
      FOR zaplink_datatypes~td_obj_type .
    ALIASES td_srcsystem
      FOR zaplink_datatypes~td_srcsystem .
    ALIASES td_transport_kind
      FOR zaplink_datatypes~td_transport_kind .
    ALIASES td_with_subcomp
      FOR zaplink_datatypes~td_with_subcomp .
    ALIASES ts_compkey
      FOR zaplink_datatypes~ts_compkey .
    ALIASES ts_component
      FOR zaplink_datatypes~ts_component .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    TYPES to_conn_exception TYPE REF TO zaplink_cx_connector .
    TYPES to_list TYPE REF TO zaplink_list .
    TYPES to_exception TYPE REF TO zaplink_cx_component .
    TYPES to_msg_coll TYPE REF TO zaplink_message_collector .
    TYPES to_connector TYPE REF TO zaplink_connector .
    TYPES to_me TYPE REF TO zaplink_component .
    CONSTANTS:
      BEGIN OF connexists,
        exists     TYPE td_connexists VALUE zaplink_datatypes~exists-exists,
        not_exists TYPE td_connexists VALUE zaplink_datatypes~exists-not_exists,
      END OF connexists .
    METHODS constructor .
    CLASS-METHODS class_constructor .
    METHODS get_type
      RETURNING
        VALUE(result) TYPE td_comptype .
    METHODS set_type
      IMPORTING
        !data TYPE td_comptype
      RAISING
        zaplink_cx .
    METHODS get_with_subcomp
      RETURNING
        VALUE(result) TYPE td_with_subcomp .
    METHODS set_with_subcomp
      IMPORTING
        !data TYPE td_with_subcomp .
    METHODS get_devclass
      RETURNING
        VALUE(result) TYPE td_devclass .
    METHODS set_devclass
      IMPORTING
        !data TYPE td_devclass .
    METHODS get_name
      RETURNING
        VALUE(result) TYPE td_compname .
    METHODS set_name
      IMPORTING
        !data TYPE any
      RAISING
        zaplink_cx .
    METHODS do_exists
      RETURNING
        VALUE(result) TYPE td_compexists .
    METHODS connector_exists
      RETURNING
        VALUE(result) TYPE td_connexists .
    METHODS connector
      RETURNING
        VALUE(result) TYPE to_connector .
    METHODS get_connuuid
      RETURNING
        VALUE(result) TYPE td_connuuid .
    METHODS set_connuuid
      IMPORTING
        !data TYPE td_connuuid
      RAISING
        zaplink_cx .
    METHODS get_key
      RETURNING
        VALUE(result) TYPE ts_component
      RAISING
        zaplink_cx .
    METHODS get_exception
      RETURNING
        VALUE(result) TYPE to_root_exception .
    METHODS set_exception
      IMPORTING
        !data TYPE to_root_exception
      RAISING
        zaplink_cx .
    METHODS get_msg_coll
      RETURNING
        VALUE(result) TYPE to_msg_coll .
    METHODS set_msg_coll
      IMPORTING
        !data TYPE to_msg_coll
      RAISING
        zaplink_cx .
    METHODS get_subcomponents
      RETURNING
        VALUE(result) TYPE to_list .
    METHODS set_subcomponents
      IMPORTING
        !data TYPE to_list
      RAISING
        zaplink_cx .
    METHODS get_checksum
      RETURNING
        VALUE(result) TYPE td_checksum .
    METHODS set_checksum
      IMPORTING
        !data TYPE td_checksum .
    METHODS get_code_signature
      RETURNING
        VALUE(result) TYPE td_checksum .
    METHODS set_code_signature
      IMPORTING
        !data TYPE td_checksum .
    METHODS copy_from
      IMPORTING
        !component TYPE to_me .
    METHODS clone
      RETURNING
        VALUE(result) TYPE to_me .
    METHODS refresh .
    METHODS get_action
      RETURNING
        VALUE(result) TYPE td_action .
    METHODS set_action
      IMPORTING
        !data TYPE td_action .
    METHODS get_add_data
      RETURNING
        VALUE(result) TYPE td_compadd_data .
    METHODS set_add_data
      IMPORTING
        !data TYPE td_compadd_data .
    METHODS get_add_object
      RETURNING
        VALUE(result) TYPE REF TO object .
    METHODS set_add_object
      IMPORTING
        !data TYPE REF TO object .
    METHODS get_src_sys
      RETURNING
        VALUE(result) TYPE td_srcsystem .
    METHODS set_src_sys
      IMPORTING
        !data TYPE td_srcsystem .
    METHODS get_typekind
      RETURNING
        VALUE(result) TYPE td_transport_kind .
  PROTECTED SECTION.
    ALIASES ts_conn_class
      FOR zaplink_datatypes~ts_conn_class .
    ALIASES tt_types
      FOR zaplink_datatypes~tt_types .
    TYPES:
      BEGIN OF ts_conndata,
        uuid   TYPE td_connuuid,
        exists TYPE td_connexists,
        o_conn TYPE to_connector,
      END OF ts_conndata .
    TYPES:
      BEGIN OF ts_class.
        INCLUDE TYPE ts_conn_class.
    TYPES:
      types TYPE tt_types,   " supported_types
      END OF ts_class .
    TYPES:
      tt_classes TYPE SORTED TABLE OF ts_class WITH UNIQUE KEY classname .
    TYPES:
      tt_saptypes TYPE HASHED TABLE OF ko100 WITH UNIQUE KEY object .
    CONSTANTS local_devclass TYPE td_devclass VALUE '$LOCAL$'. "#EC NOTEXT
    CLASS-DATA _classes TYPE tt_classes .
    DATA _devclass TYPE td_devclass .
    DATA _exception TYPE to_conn_exception .
    DATA _exists TYPE td_compexists .
    DATA _kind TYPE td_transport_kind .
    DATA _msg_coll TYPE to_msg_coll .
    DATA _object TYPE REF TO object .
    DATA _srcsystem TYPE td_srcsystem .
    DATA _subcomponents TYPE to_list .
    DATA _data TYPE td_compadd_data .
    DATA _connector TYPE ts_conndata .
    DATA _code_signature TYPE td_checksum .
    DATA _checksum TYPE td_checksum .
    DATA _action TYPE td_action .
    DATA with_subcomp TYPE td_with_subcomp VALUE abap_true. "#EC NOTEXT .
    DATA type TYPE td_comptype .
    DATA name TYPE td_compname .
    METHODS _get_key
      RETURNING
        VALUE(result) TYPE ts_compkey .
    CLASS-METHODS create_new
      IMPORTING
        !key          TYPE ts_compkey
      RETURNING
        VALUE(result) TYPE to_me
      RAISING
        zaplink_cx .
    METHODS _set_key
      IMPORTING
        VALUE(data) TYPE ts_compkey
      RAISING
        zaplink_cx .
  PRIVATE SECTION.
    CLASS-DATA o_cx TYPE to_root_exception .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA my_attribs TYPE abap_attrdescr_tab .
    METHODS on_change_clear .
    METHODS on_change_update
      RAISING
        zaplink_cx .
ENDCLASS. "ZAPLINK_COMPONENT definition
INTERFACE zaplink_connector.
  TYPE-POOLS abap .
  INTERFACES zaplink_datatypes .
  ALIASES ballog_object
  FOR zaplink_datatypes~ballog_object .
  ALIASES comp_nodename
  FOR zaplink_datatypes~comp_nodename .
  ALIASES exists
  FOR zaplink_datatypes~exists .
  ALIASES td_compexists
  FOR zaplink_datatypes~td_compexists .
  ALIASES td_compname
  FOR zaplink_datatypes~td_compname .
  ALIASES td_comptype
  FOR zaplink_datatypes~td_comptype .
  ALIASES td_connclass
  FOR zaplink_datatypes~td_connclass .
  ALIASES td_connexists
  FOR zaplink_datatypes~td_connexists .
  ALIASES td_connuuid
  FOR zaplink_datatypes~td_connuuid .
  ALIASES td_connver
  FOR zaplink_datatypes~td_connver .
  ALIASES to_xml
  FOR zaplink_datatypes~to_xml .
  ALIASES ts_base_attributs
  FOR zaplink_datatypes~ts_base_attributs .
  ALIASES ts_conndata
  FOR zaplink_datatypes~ts_conndata .
  ALIASES tt_types
  FOR zaplink_datatypes~tt_types .
  TYPES ti_cleanning TYPE REF TO zaplink_cnx_ext_cleaner .
  TYPES ti_cleanning_4data TYPE REF TO zaplink_cnx_ext_cleaner_4data .
  TYPES to_ez_xml TYPE REF TO zaplink_easyxml_4cnx .
  TYPES to_options TYPE REF TO zaplink_options .
  TYPES to_raw TYPE REF TO zaplink_raw .
  TYPES to_raw_base TYPE REF TO zaplink_raw_base .
  TYPES to_raw_data TYPE REF TO zaplink_raw_data .
  TYPES to_list TYPE REF TO zaplink_list .
  TYPES to_component TYPE REF TO zaplink_component .
  TYPES to_connector TYPE REF TO zaplink_connector .
  TYPES to_msg_coll TYPE REF TO zaplink_message_collector .
  DATA supported_types TYPE tt_types READ-ONLY .
  DATA application_log TYPE to_msg_coll READ-ONLY .
  DATA version TYPE td_connver READ-ONLY .
  DATA options TYPE to_options .
  DATA uuid TYPE td_connuuid READ-ONLY .
  METHODS do_exists
    IMPORTING
      !component    TYPE to_component
    RETURNING
      VALUE(exists) TYPE td_compexists
    RAISING
      zaplink_cx .
  METHODS get_values
    IMPORTING
      !type TYPE td_comptype
    CHANGING
      !name TYPE td_compname
    RAISING
      zaplink_cx .
  METHODS import_to_sap
    IMPORTING
      !object           TYPE to_xml
    RETURNING
      VALUE(components) TYPE to_list
    RAISING
      zaplink_cx .
  METHODS export_from_sap
    IMPORTING
      !component    TYPE to_component
    RETURNING
      VALUE(object) TYPE to_xml
    RAISING
      zaplink_cx .
  METHODS delete_from_sap
    IMPORTING
      !component    TYPE to_component
    RETURNING
      VALUE(result) TYPE abap_bool
    RAISING
      zaplink_cx .
  METHODS write_to_sap
    IMPORTING
      !object           TYPE to_raw
    RETURNING
      VALUE(components) TYPE to_list
    RAISING
      zaplink_cx .
  METHODS read_from_sap
    IMPORTING
      !component    TYPE to_component
    RETURNING
      VALUE(object) TYPE to_raw
    RAISING
      zaplink_cx .
  METHODS create_new_raw
    IMPORTING
      !type         TYPE td_comptype
    RETURNING
      VALUE(object) TYPE to_raw
    RAISING
      zaplink_cx .
  METHODS is_supported_version
    IMPORTING
      !version      TYPE td_connver
    RETURNING
      VALUE(result) TYPE abap_bool
    RAISING
      zaplink_cx .
ENDINTERFACE.
CLASS zaplink_connectors DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_compexists
      FOR zaplink_datatypes~td_compexists .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptext
      FOR zaplink_datatypes~td_comptext .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    ALIASES td_connexists
      FOR zaplink_datatypes~td_connexists .
    ALIASES td_connuuid
      FOR zaplink_datatypes~td_connuuid .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_filename
      FOR zaplink_datatypes~td_filename .
    ALIASES td_obj_type
      FOR zaplink_datatypes~td_obj_type .
    ALIASES td_transport_kind
      FOR zaplink_datatypes~td_transport_kind .
    ALIASES td_typeorder
      FOR zaplink_datatypes~td_typeorder .
    ALIASES td_type_as_text
      FOR zaplink_datatypes~td_type_as_text .
    ALIASES to_xml
      FOR zaplink_datatypes~to_xml .
    ALIASES tt_types
      FOR zaplink_datatypes~tt_types .
    TYPES to_raw_base TYPE REF TO zaplink_raw_base .
    TYPES to_msg_coll TYPE REF TO zaplink_message_collector .
    TYPES to_connector TYPE REF TO zaplink_connector .
    TYPES:
      BEGIN OF ts_component,
        type TYPE td_comptype,
        name TYPE td_compname,
      END OF ts_component .
    CONSTANTS:
      BEGIN OF exists,
        exists     TYPE td_connexists VALUE zaplink_datatypes~exists-exists,
        not_exists TYPE td_connexists VALUE zaplink_datatypes~exists-not_exists,
      END OF exists .
    CLASS-DATA supported_types TYPE tt_types READ-ONLY .
    CLASS-METHODS class_constructor .
    CLASS-METHODS add_local_connector
      IMPORTING
        !local_class TYPE td_connclass
      RAISING
        zaplink_cx .
    CLASS-METHODS do_exists
      IMPORTING
        !type         TYPE td_comptype
      RETURNING
        VALUE(result) TYPE td_connexists
      RAISING
        zaplink_cx .
    CLASS-METHODS create_connector
      IMPORTING
        !type         TYPE td_comptype OPTIONAL
        !connuuid     TYPE td_connuuid OPTIONAL
      RETURNING
        VALUE(result) TYPE to_connector
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS get_values
      CHANGING
        !type TYPE td_comptype
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS node_2_raw
      IMPORTING
        !node         TYPE REF TO if_ixml_node
      RETURNING
        VALUE(result) TYPE to_raw_base
      RAISING
        zaplink_cx .
    CLASS-METHODS get_typeorder
      IMPORTING
        !data         TYPE td_comptype
      RETURNING
        VALUE(result) TYPE td_typeorder .
    CLASS-METHODS type2text
      IMPORTING
        !data         TYPE td_comptype
      RETURNING
        VALUE(result) TYPE td_type_as_text .
    CLASS-METHODS get_classname
      IMPORTING
        !o_conn       TYPE to_connector
      RETURNING
        VALUE(result) TYPE td_connclass .
    CLASS-METHODS clear_connectors .
    CLASS-METHODS reset_connectors
      RAISING
        zaplink_cx .
    CLASS-METHODS get_typekind
      IMPORTING
        !data         TYPE td_comptype
      RETURNING
        VALUE(result) TYPE td_transport_kind .
    CLASS-METHODS raw_2_string
      IMPORTING
        !data         TYPE to_raw_base
      RETURNING
        VALUE(result) TYPE string
      RAISING
        zaplink_cx .
    CLASS-METHODS xml_2_string
      IMPORTING
        !xml          TYPE to_xml
      RETURNING
        VALUE(result) TYPE string .
    CLASS-METHODS string_2_xml
      IMPORTING
        !data         TYPE string
      RETURNING
        VALUE(result) TYPE to_xml .
    CLASS-METHODS raw_2_xml
      IMPORTING
        !data         TYPE to_raw_base
      RETURNING
        VALUE(result) TYPE to_xml
      RAISING
        zaplink_cx .
  PROTECTED SECTION.
    ALIASES comp_nodename
      FOR zaplink_datatypes~comp_nodename .
    ALIASES ts_comptype
      FOR zaplink_datatypes~ts_comptype .
    ALIASES ts_conn_class
      FOR zaplink_datatypes~ts_conn_class .
    ALIASES ts_conn_def
      FOR zaplink_datatypes~ts_conn_def .
    ALIASES tt_typelist
      FOR zaplink_datatypes~tt_typelist .
    TYPES to_list TYPE REF TO zaplink_list .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    TYPES to_exception TYPE REF TO zaplink_cx_connector .
    TYPES:
      BEGIN OF ts_conndata,
        exists    TYPE td_connexists,
        classname TYPE td_connclass,
        o_conn    TYPE to_connector,
      END OF ts_conndata .
    TYPES:
      BEGIN OF ts_class.
        INCLUDE TYPE ts_conn_class.
    TYPES:
      types TYPE tt_types,   " supported_types
      END OF ts_class .
    TYPES:
      tt_classes TYPE SORTED TABLE OF ts_class WITH UNIQUE KEY uuid .
    TYPES:
      BEGIN OF ts_saptypes.
        INCLUDE TYPE ko100 AS hdr.
    TYPES:
      order TYPE td_typeorder,     " order of prefered load
      END OF ts_saptypes .
    TYPES:
      tt_saptypes TYPE HASHED TABLE OF ts_saptypes WITH UNIQUE KEY object .
    TYPES to_component TYPE REF TO zaplink_component .
    CLASS-DATA type_list TYPE tt_typelist .
    CLASS-DATA saptypes TYPE tt_saptypes .
    CLASS-DATA _classes TYPE tt_classes .
    CONSTANTS local_devclass TYPE td_devclass VALUE '$LOCAL$'. "#EC NOTEXT
    CLASS-METHODS _search_connector
      IMPORTING
        !type         TYPE td_comptype
      RETURNING
        VALUE(result) TYPE ts_conn_def
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS get_connectorlist
      RETURNING
        VALUE(result) TYPE to_list
      RAISING
        zaplink_cx .
    CLASS-METHODS _add_connector
      IMPORTING
        !class    TYPE td_connclass
        !devclass TYPE td_devclass OPTIONAL
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS _update_def_class .
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ts_value,
        object TYPE td_comptype,
        text   TYPE td_comptext,
      END OF ts_value .
    TYPES:
      tt_values TYPE STANDARD TABLE OF ts_value WITH DEFAULT KEY .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA value_table TYPE tt_values .
    CLASS-DATA xmlengine TYPE REF TO if_ixml .
    CONSTANTS max_order TYPE td_typeorder VALUE '999999'.   "#EC NOTEXT
    CLASS-DATA o_cx TYPE to_root_exception .
    CLASS-DATA c_class TYPE ts_comptype .
ENDCLASS. "ZAPLINK_CONNECTORS definition
CLASS zaplink_easyxml DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPES to_log TYPE REF TO zaplink_message_collector .
    DATA application_log TYPE to_log READ-ONLY .
    METHODS add_self
      IMPORTING
        !xml_node TYPE REF TO if_ixml_element
        !name     TYPE string OPTIONAL
        !any      TYPE any .
    METHODS add_any
      IMPORTING
        !xml_node TYPE REF TO if_ixml_element
        !name     TYPE string OPTIONAL
        !any      TYPE any
        !xmldoc   TYPE REF TO if_ixml_document
        !typedesc TYPE REF TO cl_abap_typedescr OPTIONAL .
    METHODS any2xml
      IMPORTING
        !any          TYPE any
        !type         TYPE string
        !attributs    TYPE any OPTIONAL
      RETURNING
        VALUE(xmldoc) TYPE REF TO if_ixml_document
      RAISING
        zaplink_cx .
    CLASS-METHODS class_constructor .
    METHODS constructor .
    METHODS get_attributs
      IMPORTING
        !xmldoc    TYPE REF TO if_ixml_document
      CHANGING
        !attributs TYPE any
      RAISING
        zaplink_cx .
    CLASS-METHODS get_ref_type
      IMPORTING
        !typedesc       TYPE REF TO cl_abap_typedescr
      RETURNING
        VALUE(ref_type) TYPE REF TO cl_abap_typedescr .
    CLASS-METHODS node2string
      IMPORTING
        !xml_node     TYPE REF TO if_ixml_element
      RETURNING
        VALUE(string) TYPE string .
    METHODS reset .
    METHODS xml2any
      IMPORTING
        !xmldoc    TYPE REF TO if_ixml_document
      CHANGING
        !any       TYPE any
        !attributs TYPE any OPTIONAL
      RAISING
        zaplink_cx .
    METHODS _xml2any
      IMPORTING
        !xml TYPE REF TO if_ixml_node
      CHANGING
        !any TYPE any
      RAISING
        zaplink_cx .
    METHODS read_any
      IMPORTING
        !xml_node TYPE REF TO if_ixml_element
        !typedesc TYPE REF TO cl_abap_typedescr OPTIONAL
      CHANGING
        !any      TYPE any
      RAISING
        zaplink_cx .
  PROTECTED SECTION.
    TYPES to_exception TYPE REF TO zaplink_cx .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    DATA ixml TYPE REF TO if_ixml .
    METHODS add_object
      IMPORTING
        !xml_node TYPE REF TO if_ixml_element
        !name     TYPE string OPTIONAL
        !object   TYPE REF TO object
        !xmldoc   TYPE REF TO if_ixml_document
        !typedesc TYPE REF TO cl_abap_typedescr OPTIONAL .
    METHODS add_structure
      IMPORTING
        !xml_node  TYPE REF TO if_ixml_element
        !name      TYPE string OPTIONAL
        !structure TYPE data
        !xmldoc    TYPE REF TO if_ixml_document .
    METHODS add_table
      IMPORTING
        !xml_node TYPE REF TO if_ixml_element
        !name     TYPE string OPTIONAL
        !table    TYPE ANY TABLE
        !xmldoc   TYPE REF TO if_ixml_document .
    METHODS elem_2_string
      IMPORTING
        !any          TYPE any
        !type_desc    TYPE REF TO cl_abap_typedescr OPTIONAL
      RETURNING
        VALUE(string) TYPE string .
    CLASS-METHODS is_simple_type_kind
      IMPORTING
        !type_kind    TYPE abap_typekind
      RETURNING
        VALUE(result) TYPE abap_bool .
    METHODS read_object
      IMPORTING
        !xml_node TYPE REF TO if_ixml_element
        !typedesc TYPE REF TO cl_abap_typedescr OPTIONAL
      CHANGING
        !object   TYPE REF TO object
      RAISING
        zaplink_cx .
    METHODS read_structure
      IMPORTING
        !xml_node  TYPE REF TO if_ixml_element
      CHANGING
        !structure TYPE data
      RAISING
        zaplink_cx .
    METHODS read_table
      IMPORTING
        !xml_node TYPE REF TO if_ixml_element
      CHANGING
        !table    TYPE ANY TABLE
      RAISING
        zaplink_cx .
    METHODS stack
      IMPORTING
        !item TYPE string .
    METHODS stack_descr
      IMPORTING
        !desc TYPE REF TO cl_abap_typedescr .
    METHODS string_2_elem
      IMPORTING
        !type_desc    TYPE REF TO cl_abap_typedescr OPTIONAL
        VALUE(string) TYPE string
      CHANGING
        !any          TYPE any .
    METHODS unstack .
    METHODS get_node_text
      IMPORTING
        !xml_node     TYPE REF TO if_ixml_element
      RETURNING
        VALUE(result) TYPE string .
    CLASS-METHODS node_is_not_type
      IMPORTING
        !node         TYPE REF TO if_ixml_node
        !type         TYPE i
      RETURNING
        VALUE(result) TYPE abap_bool .
    CLASS-METHODS node_is_type
      IMPORTING
        !node         TYPE REF TO if_ixml_node
        !type         TYPE i
      RETURNING
        VALUE(result) TYPE abap_bool .
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ts_ele,
        select    TYPE flag,
        elem_type TYPE trobjtype,
        elem_key  TYPE elemgenkey,
        td_pack   TYPE devclass,
        elem_pack TYPE devclass,
      END OF ts_ele .
    TYPES:
      tt_ele TYPE STANDARD TABLE OF ts_ele WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      BEGIN OF ts_itf_el,
        interface TYPE REF TO if_package_interface,
        elements  TYPE STANDARD TABLE OF scomeldtln WITH NON-UNIQUE DEFAULT KEY, "SCOMELDATA,
        acls      TYPE STANDARD TABLE OF scomaclstr WITH NON-UNIQUE DEFAULT KEY, "SCOMACLTAB,
      END OF ts_itf_el .
    TYPES:
      tt_itf_el TYPE STANDARD TABLE OF ts_itf_el WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      tt_context TYPE STANDARD TABLE OF string WITH DEFAULT KEY .
    CONSTANTS en_line TYPE string VALUE 'ITEM'.             "#EC NOTEXT
    CONSTANTS msgid TYPE symsgid VALUE 'ZAPLINK_EASYXML'.   "#EC NOTEXT
    DATA o_mycx TYPE to_exception .
    DATA bal_level TYPE ballevel .
    DATA rc TYPE i .
    DATA crc TYPE string .
    CONSTANTS self_fieldname TYPE string VALUE '_'.         "#EC NOTEXT
    DATA context TYPE tt_context .
    CONSTANTS issue46_prefix TYPE abap_char1 VALUE '_'.     "#EC NOTEXT
    CLASS-DATA issue46_regex TYPE string .
    CONSTANTS protection_char TYPE abap_char1 VALUE '`'.    "#EC NOTEXT
    CLASS-DATA:
      char_to_protect TYPE RANGE OF abap_char1 .
    CLASS-METHODS protect_string
      IMPORTING
        !string       TYPE string
      RETURNING
        VALUE(result) TYPE string .
    CLASS-METHODS unprotect_string
      IMPORTING
        !string       TYPE string
      RETURNING
        VALUE(result) TYPE string .
ENDCLASS. "ZAPLINK_EASYXML definition
CLASS zaplink_enhancement_data DEFINITION
  INHERITING FROM zaplink_raw_data
  ABSTRACT
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_enhancement .
  PUBLIC SECTION.
    TYPE-POOLS seex .
    INTERFACES zaplink_cnx_ext_cleaner_4data
      ABSTRACT METHODS anonymize
      unanonymize .
    INTERFACES zaplink_datatypes .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_checkbox
      FOR zaplink_datatypes~td_checkbox .
    ALIASES ts_sourceasstruc
      FOR zaplink_datatypes~ts_sourceasstruc .
    ALIASES tt_ltexts
      FOR zaplink_datatypes~tt_ltexts .
    DATA texts_2_del TYPE tt_ltexts READ-ONLY .
  PROTECTED SECTION.
    TYPES to_exception TYPE REF TO zaplink_cx_connector .
    TYPES to_list TYPE REF TO zaplink_list .
    TYPES to_component TYPE REF TO zaplink_component .
    TYPES to_msg_coll TYPE REF TO zaplink_message_collector .
    TYPES to_raw TYPE REF TO zaplink_raw .
    TYPES td_sotr_concept TYPE sotr_text-concept .
    TYPES:
      BEGIN OF ts_sotr,
        short TYPE td_sotr_concept,
        long  TYPE td_sotr_concept,
      END OF ts_sotr .
    CLASS-DATA o_mycx TYPE to_exception .
    METHODS sotr_2_texts
      IMPORTING
        !data          TYPE ts_sotr
      RETURNING
        VALUE(results) TYPE tt_ltexts
      RAISING
        zaplink_cx_connector .
    METHODS texts_2_sotr
      IMPORTING
        !sotr  TYPE ts_sotr
        !texts TYPE tt_ltexts
      RAISING
        zaplink_cx_connector .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_ENHANCEMENT_DATA definition
CLASS zaplink_extractor DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    INTERFACES zaplink_datatypes .
    INTERFACES zaplink_kernel_types .
    ALIASES ballog_object
      FOR zaplink_datatypes~ballog_object .
    ALIASES comp_nodename
      FOR zaplink_datatypes~comp_nodename .
    ALIASES exists
      FOR zaplink_datatypes~exists .
    ALIASES ext_sep
      FOR zaplink_datatypes~ext_sep .
    ALIASES file_ext
      FOR zaplink_datatypes~file_ext .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES textpool_kinds
      FOR zaplink_datatypes~textpool_kinds .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_checksum
      FOR zaplink_datatypes~td_checksum .
    ALIASES td_classname
      FOR zaplink_datatypes~td_classname .
    ALIASES td_compexists
      FOR zaplink_datatypes~td_compexists .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptext
      FOR zaplink_datatypes~td_comptext .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    ALIASES td_connexists
      FOR zaplink_datatypes~td_connexists .
    ALIASES td_connuuid
      FOR zaplink_datatypes~td_connuuid .
    ALIASES td_connver
      FOR zaplink_datatypes~td_connver .
    ALIASES td_contname
      FOR zaplink_datatypes~td_contname .
    ALIASES td_contver
      FOR zaplink_datatypes~td_contver .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES td_exists
      FOR zaplink_datatypes~td_exists .
    ALIASES td_filename
      FOR zaplink_datatypes~td_filename .
    ALIASES td_filetype
      FOR zaplink_datatypes~td_filetype .
    ALIASES td_lang
      FOR zaplink_datatypes~td_lang .
    ALIASES td_light
      FOR zaplink_datatypes~td_light .
    ALIASES td_obj_type
      FOR zaplink_datatypes~td_obj_type .
    ALIASES td_orderkind
      FOR zaplink_datatypes~td_orderkind .
    ALIASES td_progname
      FOR zaplink_datatypes~td_progname .
    ALIASES td_substitutionkind
      FOR zaplink_datatypes~td_substitutionkind .
    ALIASES td_transport_request
      FOR zaplink_datatypes~td_transport_request .
    ALIASES td_txtp_id
      FOR zaplink_datatypes~td_txtp_id .
    ALIASES td_txtp_kind
      FOR zaplink_datatypes~td_txtp_kind .
    ALIASES td_txtp_len
      FOR zaplink_datatypes~td_txtp_len .
    ALIASES td_txtp_text
      FOR zaplink_datatypes~td_txtp_text .
    ALIASES td_typeorder
      FOR zaplink_datatypes~td_typeorder .
    ALIASES td_type_as_text
      FOR zaplink_datatypes~td_type_as_text .
    ALIASES td_with_subcomp
      FOR zaplink_datatypes~td_with_subcomp .
    ALIASES to_msg_coll
      FOR zaplink_kernel_types~to_msg_coll .
    ALIASES to_xml
      FOR zaplink_datatypes~to_xml .
    ALIASES tr_author
      FOR zaplink_datatypes~tr_author .
    ALIASES tr_compname
      FOR zaplink_datatypes~tr_compname .
    ALIASES tr_comptype
      FOR zaplink_datatypes~tr_comptype .
    ALIASES tr_dlvunit
      FOR zaplink_datatypes~tr_dlvunit .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    ALIASES tr_packages
      FOR zaplink_datatypes~tr_packages .
    ALIASES tr_srcsystem
      FOR zaplink_datatypes~tr_srcsystem .
    ALIASES tr_tr
      FOR zaplink_datatypes~tr_tr .
    ALIASES ts_base_attributs
      FOR zaplink_datatypes~ts_base_attributs .
    ALIASES ts_compkey
      FOR zaplink_datatypes~ts_compkey .
    ALIASES ts_component
      FOR zaplink_datatypes~ts_component .
    ALIASES ts_conndata
      FOR zaplink_datatypes~ts_conndata .
    ALIASES ts_conn_class
      FOR zaplink_datatypes~ts_conn_class .
    ALIASES ts_conn_def
      FOR zaplink_datatypes~ts_conn_def .
    ALIASES ts_contdata
      FOR zaplink_datatypes~ts_contdata .
    ALIASES ts_directory
      FOR zaplink_datatypes~ts_directory .
    ALIASES ts_doc
      FOR zaplink_datatypes~ts_doc .
    ALIASES ts_head
      FOR zaplink_datatypes~ts_head .
    ALIASES ts_lang
      FOR zaplink_datatypes~ts_lang .
    ALIASES ts_txtp_text
      FOR zaplink_datatypes~ts_txtp_text .
    ALIASES ts_txtp_textpool
      FOR zaplink_datatypes~ts_txtp_textpool .
    ALIASES ts_type
      FOR zaplink_datatypes~ts_type .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_compkeys
      FOR zaplink_datatypes~tt_compkeys .
    ALIASES tt_conn_classes
      FOR zaplink_datatypes~tt_conn_classes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_rawtext
      FOR zaplink_datatypes~tt_rawtext .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    ALIASES tt_txtp_texts
      FOR zaplink_datatypes~tt_txtp_texts .
    ALIASES tt_types
      FOR zaplink_datatypes~tt_types .
    TYPES td_directoryname TYPE td_filename .
    TYPES td_dirhierarchy TYPE char01 .
    TYPES td_package TYPE devclass .
    TYPES to_ez_xml TYPE REF TO zaplink_easyxml .
    DATA application_log TYPE to_msg_coll .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'EXTRACTOR'. "#EC NOTEXT
    CONSTANTS:
      BEGIN OF dirhierachies,
        type TYPE td_dirhierarchy VALUE 'T',                "#EC NOTEXT
        devc TYPE td_dirhierarchy VALUE 'D',                "#EC NOTEXT
        dcty TYPE td_dirhierarchy VALUE 'x', "#EC NOTEXT  Package + Object Type
      END OF dirhierachies .
    CLASS-DATA file_sep TYPE c READ-ONLY .
    DATA o_cx TYPE REF TO zaplink_cx .
    DATA o_mycx TYPE REF TO zaplink_cx .
    METHODS analyse
      IMPORTING
        !author     TYPE tr_author
        !ext        TYPE abap_bool
        !hierarchy  TYPE td_dirhierarchy
        !name       TYPE tr_compname
        !packages   TYPE tr_packages
        !srcsystem  TYPE tr_srcsystem
        !target_dir TYPE td_directoryname
        !type       TYPE tr_comptype
        !f_sub      TYPE td_with_subcomp OPTIONAL
      RAISING
        zaplink_cx .
    CLASS-METHODS class_constructor .
    METHODS constructor .
    METHODS extract_connectors
      IMPORTING
        !package    TYPE tr_packages
        !target_dir TYPE td_directoryname
      RAISING
        zaplink_cx .
    METHODS extract
      IMPORTING
        !author     TYPE tr_author
        !ext        TYPE abap_bool
        !hierarchy  TYPE td_dirhierarchy
        !name       TYPE tr_compname
        !packages   TYPE tr_packages
        !srcsystem  TYPE tr_srcsystem
        !target_dir TYPE td_directoryname
        !type       TYPE tr_comptype
        !f_sub      TYPE td_with_subcomp DEFAULT zaplink_datatypes=>default_sub_component_level
      RAISING
        zaplink_cx .
  PROTECTED SECTION.
    ALIASES actions
      FOR zaplink_datatypes~actions .
    ALIASES to_component
      FOR zaplink_kernel_types~to_component .
    ALIASES to_container
      FOR zaplink_kernel_types~to_container .
    ALIASES to_file
      FOR zaplink_kernel_types~to_file .
    ALIASES to_list
      FOR zaplink_kernel_types~to_list .
    ALIASES to_options
      FOR zaplink_kernel_types~to_options .
    ALIASES to_opt_devclass
      FOR zaplink_kernel_types~to_opt_devclass .
    ALIASES to_opt_directory
      FOR zaplink_kernel_types~to_opt_directory .
    ALIASES to_opt_transport_request
      FOR zaplink_kernel_types~to_opt_transport_request .
    ALIASES to_raw
      FOR zaplink_kernel_types~to_raw .
    ALIASES to_raw_base
      FOR zaplink_kernel_types~to_raw_base .
    TYPES to_connector TYPE REF TO zaplink_connector .
    TYPES to_connector_cleaner TYPE REF TO zaplink_cnx_ext_cleaner .
    TYPES to_list_e TYPE REF TO zaplink_list_4extractor .
    TYPES:
      BEGIN OF ts_my_file,
        o_file     TYPE to_file,
        o_xml      TYPE to_xml,
        o_raw_base TYPE to_raw_base,
        o_raw      TYPE to_raw,
        filename   TYPE td_filename,
        checksum   TYPE td_checksum,
      END OF ts_my_file .
    DATA working_list TYPE to_list .
    CLASS-DATA xmlengine TYPE REF TO if_ixml .
    CLASS-METHODS create_filename
      IMPORTING
        !name         TYPE td_compname
        !type         TYPE td_comptype
      RETURNING
        VALUE(result) TYPE td_filename .
    CLASS-METHODS concatenate_path
      IMPORTING
        !directory    TYPE td_directoryname
        !filename     TYPE td_filename
      RETURNING
        VALUE(result) TYPE td_filename .
    METHODS save_file
      IMPORTING
        !filename TYPE td_filename
        !o_raw    TYPE to_raw
      RAISING
        zaplink_cx .
    METHODS load_file
      IMPORTING
        !filename     TYPE td_filename
      RETURNING
        VALUE(result) TYPE ts_my_file
      RAISING
        zaplink_cx .
    METHODS create_fullpath_by_type
      IMPORTING
        !comp         TYPE to_component
        !directory    TYPE td_directoryname
      RETURNING
        VALUE(result) TYPE td_filename
      RAISING
        zaplink_cx .
    METHODS create_fullpath_by_devc
      IMPORTING
        !comp         TYPE to_component
        !directory    TYPE td_directoryname
        !with_type    TYPE abap_bool OPTIONAL
      RETURNING
        VALUE(result) TYPE td_filename
      RAISING
        zaplink_cx .
    METHODS create_fullpath
      IMPORTING
        !comp         TYPE to_component
        !directory    TYPE td_directoryname
        !hierarchy    TYPE td_dirhierarchy
      RETURNING
        VALUE(result) TYPE td_filename
      RAISING
        zaplink_cx .
  PRIVATE SECTION.
    CLASS-METHODS get_devc_path
      IMPORTING
        !devclass     TYPE td_devclass
        !directory    TYPE td_directoryname
      RETURNING
        VALUE(result) TYPE td_directoryname .
ENDCLASS. "ZAPLINK_EXTRACTOR definition
CLASS zaplink_fugr_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_function_group .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_dynpros
      FOR zaplink_datatypes~tt_dynpros .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    CLASS-METHODS class_constructor .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    TYPES:
      tt_fm_data TYPE STANDARD TABLE OF zaplink_func_data=>ts_fm_data WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_doc_param,
        func  TYPE rs38l_fnam,
        param TYPE rs38l_par_,
      END OF ts_doc_param .
    TYPES t_raw TYPE rswsourcet .
    TYPES to_menupainter TYPE REF TO zaplink_menupainter_data .
    TYPES:
      tt_tlibt TYPE SORTED TABLE OF tlibt WITH UNIQUE KEY spras .
    TYPES:
      tt_tftit TYPE SORTED TABLE OF tftit WITH UNIQUE KEY funcname spras .
    TYPES:
      tt_funct TYPE SORTED TABLE OF funct WITH UNIQUE KEY funcname parameter kind spras .
    TYPES:
      tt_rsimp TYPE STANDARD TABLE OF rsimp WITH DEFAULT KEY .
    TYPES:
      tt_rscha TYPE STANDARD TABLE OF rscha WITH DEFAULT KEY .
    TYPES:
      tt_rsexp TYPE STANDARD TABLE OF rsexp WITH DEFAULT KEY .
    TYPES:
      tt_rstbl TYPE STANDARD TABLE OF rstbl WITH DEFAULT KEY .
    TYPES:
      tt_rsexc TYPE STANDARD TABLE OF rsexc WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_source,
        _ TYPE string,
      END OF ts_source .
    TYPES td_includename TYPE d010inc-include .
    TYPES:
      BEGIN OF ts_include,
        name   TYPE td_includename,
        source TYPE ts_source,
      END OF ts_include .
    TYPES:
      tt_includes TYPE SORTED TABLE OF ts_include WITH UNIQUE KEY name .
    TYPES:
      BEGIN OF ts_rawinclude,
        short  TYPE rs38l-suffix,   " Short name TOP, F01
        name   TYPE td_includename,
        source TYPE tt_abaprawsource,
      END OF ts_rawinclude .
    TYPES:
      tt_rawincludes TYPE STANDARD TABLE OF ts_rawinclude WITH NON-UNIQUE KEY name .
    TYPES ts_func TYPE zaplink_func_data=>ts_fm_data .
    TYPES:
      tt_funcs TYPE SORTED TABLE OF ts_func WITH UNIQUE KEY header-name .
    TYPES:
      BEGIN OF ts_fm_data,
        header      TYPE tlibg,
        texts       TYPE tt_tlibt,
        docs        TYPE tt_docs,
        textspool   TYPE tt_txtp_textpools,
        dynpros     TYPE tt_dynpros,
        menupainter TYPE to_menupainter,
        includes    TYPE tt_rawincludes,
        functions   TYPE tt_funcs,
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE tlibg AS hdr.
    TYPES:
      texts TYPE tt_texts,
      END OF ts_maindata .
    TYPES:
      BEGIN OF ts_textpool,
        id    TYPE  textpoolid,
        key   TYPE  textpoolky,
        texts TYPE  tt_texts,
      END OF ts_textpool .
    TYPES:
      tt_textpools TYPE SORTED TABLE OF ts_textpool WITH UNIQUE KEY id key .
    TYPES td_paramkind TYPE kind .
    TYPES:
      BEGIN OF ts_param,
        kind TYPE td_paramkind.
        INCLUDE TYPE rsimp AS hdr.
    TYPES:
      texts TYPE tt_texts,
      END OF ts_param .
    TYPES:
      tt_params TYPE SORTED TABLE OF ts_param WITH UNIQUE KEY parameter .
    TYPES:
      BEGIN OF ts_excep.
        INCLUDE TYPE rsexc AS hdr.
    TYPES:
      texts TYPE tt_texts,
      END OF ts_excep .
    TYPES:
      tt_exceptions TYPE SORTED TABLE OF ts_excep WITH UNIQUE KEY exception .
    TYPES to_function TYPE REF TO zaplink_func_raw .
    TYPES:
      BEGIN OF ts_function,
        zl_object TYPE to_function,
      END OF ts_function .
    TYPES:
      tt_functions TYPE STANDARD TABLE OF ts_function WITH DEFAULT KEY .
    CONSTANTS:
      BEGIN OF parameter_kinds,
        importing TYPE td_paramkind VALUE 'I',
        changing  TYPE td_paramkind VALUE 'C',
        exporting TYPE td_paramkind VALUE 'E',
        table     TYPE td_paramkind VALUE 'T',
      END OF parameter_kinds .
    DATA a0_maindata TYPE ts_maindata .
    DATA textspool TYPE tt_txtp_textpools .
    DATA source TYPE ts_source .
    DATA dynpros TYPE tt_dynpros .
    DATA menupainter TYPE to_menupainter .
    DATA functions TYPE tt_functions .
    DATA includes TYPE tt_includes .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data
      RAISING
        zaplink_cx .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
    CLASS-METHODS conv_function
      IMPORTING
        !fm_data      TYPE ts_fm_data
      RETURNING
        VALUE(result) TYPE tt_fm_data .
  PRIVATE SECTION.
    CONSTANTS:
      BEGIN OF markups,
        area TYPE string VALUE '[FUNCTIONGROUP NAME]',
      END OF markups .
    CONSTANTS:
      BEGIN OF suffixes,
        top TYPE rs38l-suffix VALUE 'TOP',
      END OF suffixes .
    CONSTANTS:
      BEGIN OF doc_ids,
        group    TYPE td_doc_id VALUE 'RE',    " Report
        function TYPE td_doc_id VALUE 'FU',
      END OF doc_ids .
    CLASS-DATA:
      BEGIN OF r_doc_ids,
        group    TYPE tr_docid,
        function TYPE tr_docid,
      END OF r_doc_ids .
ENDCLASS. "ZAPLINK_FUGR_DATA definition
CLASS zaplink_list DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS slis .
    INTERFACES zaplink_datatypes .
    ALIASES sel_actions
      FOR zaplink_datatypes~actions .
    ALIASES td_orderkind
      FOR zaplink_datatypes~td_orderkind .
    ALIASES td_sel_action
      FOR zaplink_datatypes~td_action .
    ALIASES ts_compkey
      FOR zaplink_datatypes~ts_compkey .
    ALIASES tt_compkeys
      FOR zaplink_datatypes~tt_compkeys .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    TYPES to_component TYPE REF TO zaplink_component .
    TYPES to_me TYPE REF TO zaplink_list .
    DATA order_kind TYPE td_orderkind .
    DATA display_progress TYPE abap_bool .
    CONSTANTS:
      BEGIN OF order_kinds,
        no_order  TYPE td_orderkind VALUE space,
        install   TYPE td_orderkind VALUE 'B',  " Bottom up
        uninstall TYPE td_orderkind VALUE 'T',  " Top down
      END OF order_kinds .
    DATA is_confirmed TYPE abap_bool .
    CLASS-DATA callback_program TYPE sy-repid VALUE sy-repid. "#EC NOTEXT .
    METHODS add
      IMPORTING
        !comp TYPE to_component
      RAISING
        zaplink_cx_list .
    METHODS add_keys
      IMPORTING
        !data TYPE tt_compkeys
      RAISING
        zaplink_cx .
    METHODS add_list
      IMPORTING
        !data TYPE to_me
      RAISING
        zaplink_cx_list .
    METHODS change_selection
      RAISING
        zaplink_cx_list .
    CLASS-METHODS class_constructor .
    METHODS clear .
    METHODS clone
      RETURNING
        VALUE(result) TYPE to_me
      RAISING
        zaplink_cx_list .
    METHODS display
      RAISING
        zaplink_cx_list .
    METHODS get_count
      IMPORTING
        !is_selected  TYPE abap_bool OPTIONAL
      RETURNING
        VALUE(result) TYPE i .
    METHODS get_next
      RETURNING
        VALUE(result) TYPE to_component
      RAISING
        zaplink_cx_list .
    METHODS get_keys
      RETURNING
        VALUE(result) TYPE tt_compkeys .
    METHODS has_any
      IMPORTING
        !list         TYPE to_me
      RETURNING
        VALUE(result) TYPE abap_bool
      RAISING
        zaplink_cx_list .
    METHODS init_iter
      RAISING
        zaplink_cx_list .
    METHODS init_sel_iter .
    METHODS is_empty
      RETURNING
        VALUE(result) TYPE abap_bool
      RAISING
        zaplink_cx_list .
    METHODS is_included
      IMPORTING
        !list         TYPE to_me
      RETURNING
        VALUE(result) TYPE abap_bool
      RAISING
        zaplink_cx_list .
    METHODS is_selected
      IMPORTING
        !comp         TYPE to_component
      RETURNING
        VALUE(result) TYPE abap_bool
      RAISING
        zaplink_cx_list .
    METHODS keep_commun_list
      IMPORTING
        !data TYPE to_me .
    METHODS remove
      IMPORTING
        !comp TYPE to_component
      RAISING
        zaplink_cx_list .
    METHODS remove_list
      IMPORTING
        !data TYPE to_me
      RAISING
        zaplink_cx_list .
    METHODS search
      IMPORTING
        !comp         TYPE to_component
      RETURNING
        VALUE(result) TYPE to_component
      RAISING
        zaplink_cx_list .
    METHODS select
      IMPORTING
        !comp TYPE to_component
      RAISING
        zaplink_cx_list .
    METHODS select_all
      RAISING
        zaplink_cx_list .
    METHODS select_default
      IMPORTING
        !sel_action TYPE td_sel_action
      RAISING
        zaplink_cx_list .
    METHODS unselect
      IMPORTING
        !comp TYPE to_component
      RAISING
        zaplink_cx_list .
    METHODS unselect_all
      RAISING
        zaplink_cx_list .
    METHODS reverse_selection
      RAISING
        zaplink_cx_list .
    METHODS selection_as_list
      RETURNING
        VALUE(result) TYPE to_me
      RAISING
        zaplink_cx_list .
    METHODS select_by_action
      RAISING
        zaplink_cx_list .
    METHODS refresh
      RETURNING
        VALUE(result) TYPE to_me
      RAISING
        zaplink_cx_list .
  PROTECTED SECTION.
    ALIASES td_checksum
      FOR zaplink_datatypes~td_checksum .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_light
      FOR zaplink_datatypes~td_light .
    ALIASES td_type_as_text
      FOR zaplink_datatypes~td_type_as_text .
    TYPES:
      BEGIN OF ts_cursor,
        key    TYPE ts_compkey,
        o_comp TYPE to_component,
        order  TYPE i,
      END OF ts_cursor .
    TYPES:
      tt_cursors TYPE STANDARD TABLE OF ts_cursor WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_complist,
        key      TYPE ts_compkey,
        o_comp   TYPE to_component,
        selected TYPE abap_bool,
      END OF ts_complist .
    TYPES:
      tt_complist TYPE SORTED TABLE OF ts_complist WITH UNIQUE KEY key .
    TYPES:
      BEGIN OF ts_allcomplist,
        key    TYPE ts_compkey,
        o_comp TYPE to_component,
        as_sub TYPE abap_bool,
      END OF ts_allcomplist .
    TYPES:
      tt_allcomplist TYPE SORTED TABLE OF ts_allcomplist WITH NON-UNIQUE KEY key .
    TYPES td_alvid TYPE guid_16 .
    TYPES:
      BEGIN OF ts_alv_conf,
        fields TYPE slis_t_fieldcat_alv,
        layout TYPE slis_layout_alv,
      END OF ts_alv_conf .
    TYPES:
      BEGIN OF ts_alv_confs,
        simple TYPE ts_alv_conf,
        hierar TYPE ts_alv_conf,
      END OF ts_alv_confs .
    TYPES:
      BEGIN OF ts_alv,
        action         TYPE td_light, "type pools ICON
        type           TYPE td_comptype,
        typ_txt        TYPE td_type_as_text,
        name           TYPE td_compname,
        connector      TYPE td_light, "type pools ICON
        status         TYPE td_light, "type pools ICON
        msg            TYPE string,
        devclass       TYPE tadir-devclass,
        srcsystem      TYPE tadir-srcsystem,
        checksum       TYPE td_checksum,
        code_signature TYPE td_checksum,
        select         TYPE flag,
        id             TYPE td_alvid,
        expand         TYPE flag,
      END OF ts_alv .
    TYPES:
      tt_alv TYPE STANDARD TABLE OF ts_alv WITH DEFAULT KEY .
    TYPES:
      BEGIN OF td_alv,
        headers TYPE tt_alv,
        items   TYPE tt_alv,
      END OF td_alv .
    CONSTANTS:
      BEGIN OF lights,
        no          TYPE td_light VALUE icon_light_out,
        red         TYPE td_light VALUE icon_red_light,
        yellow      TYPE td_light VALUE icon_yellow_light,
        green       TYPE td_light VALUE icon_green_light,
        export      TYPE td_light VALUE icon_arrow_left,
        import      TYPE td_light VALUE icon_arrow_right,
        uninst      TYPE td_light VALUE icon_delete,
        active      TYPE td_light VALUE icon_activate,
        inactive    TYPE td_light VALUE icon_deactivate,
        rep_error   TYPE td_light VALUE icon_message_error_small,   " ICON_STATUS_CRITICAL ICON_ALERT ICON_MESSAGE_CRITICAL_SMALL
        delete_file TYPE td_light VALUE icon_booking_stop,    " ICON_BEN_TERMINATION ICON_TERMINATED_ORG_UNIT ICON_TERMINATED_TASK ICON_MESSAGE_ORPHANED " ICON_CLOSED_FOLDER_ORPHANED doesn't exist on all SAP Systems :-(
      END OF lights .
    CLASS-DATA alv_conf TYPE ts_alv_confs .
    DATA _allcomp TYPE tt_allcomplist .
    DATA _index TYPE tt_complist .
    CONSTANTS pf_status TYPE slis_formname VALUE 'PF_STATUS_SET '. "#EC NOTEXT
    CONSTANTS pf_status_no_actions TYPE slis_formname VALUE 'PF_STATUS_NO_ACTION '. "#EC NOTEXT
    CONSTANTS user_command TYPE slis_formname VALUE 'USER_COMMAND_USER'. "#EC NOTEXT
    METHODS comp_to_alv
      IMPORTING
        !o_comp       TYPE to_component
        !selected     TYPE abap_bool
      RETURNING
        VALUE(result) TYPE ts_alv
      RAISING
        zaplink_cx_list .
    METHODS conv_to_alv
      IMPORTING
        !w_item       TYPE abap_bool OPTIONAL
      RETURNING
        VALUE(result) TYPE td_alv
      RAISING
        zaplink_cx_list .
    METHODS search_index
      IMPORTING
        !comp         TYPE to_component
      RETURNING
        VALUE(result) TYPE ts_complist .
    METHODS select_export
      RAISING
        zaplink_cx_list .
    METHODS select_import
      RAISING
        zaplink_cx_list .
    METHODS update_from_alv
      IMPORTING
        !data TYPE td_alv
      RAISING
        zaplink_cx_list .
    METHODS _add_subcomp
      IMPORTING
        !data TYPE to_component
      RAISING
        zaplink_cx_list .
    METHODS _select
      IMPORTING
        !comp  TYPE to_component
        !value TYPE abap_bool
      RAISING
        zaplink_cx_list .
    METHODS select_uninstall
      RAISING
        zaplink_cx_list .
  PRIVATE SECTION.
    TYPES td_iterator_type TYPE char1 .
    TYPES to_exception TYPE REF TO zaplink_cx_list .
    CONSTANTS:
      BEGIN OF iterator_types,
        all      TYPE td_iterator_type VALUE 'A',
        selected TYPE td_iterator_type VALUE 'S',
      END OF iterator_types .
    DATA o_exception TYPE to_exception .
    DATA _iterator_count TYPE sy-tabix .
    DATA _iterator_tabix TYPE sy-tabix .
    DATA _iterator_type TYPE td_iterator_type .
    CONSTANTS:
      BEGIN OF alv_h_tables,
        header TYPE slis_tabname VALUE 'HDR',
        item   TYPE slis_tabname VALUE 'ITM',
      END OF alv_h_tables .
    DATA t_cursors TYPE tt_cursors .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_LIST definition
CLASS zaplink_object_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PROTECTED
  FRIENDS zaplink_easyxml
                 zaplink_object .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS seof .
    TYPE-POOLS seok .
    TYPE-POOLS seoo .
    TYPE-POOLS seor .
    TYPE-POOLS seos .
    TYPE-POOLS seot .
    INTERFACES zaplink_datatypes .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES ts_lang
      FOR zaplink_datatypes~ts_lang .
    ALIASES ts_sourceasstruc
      FOR zaplink_datatypes~ts_sourceasstruc .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_dynpros
      FOR zaplink_datatypes~tt_dynpros .
    ALIASES tt_ltexts
      FOR zaplink_datatypes~tt_ltexts .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    ALIASES tt_txtp_texts
      FOR zaplink_datatypes~tt_txtp_texts .
    TYPES to_menupainter TYPE REF TO zaplink_menupainter_data .
    TYPES:
      BEGIN OF ts_deferred,                   " used to handle
        classes    TYPE seot_clsdeferrds_w,      " class * definition load
        interfaces TYPE seot_intdeferrds_r,   " interface * load
      END OF ts_deferred .
    TYPES:
      tt_seoclasstx TYPE STANDARD TABLE OF seoclasstx WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_seoclasstx.
        INCLUDE TYPE seoclasstx AS main.
    TYPES:
      documentation TYPE ts_lang,
      END OF ts_seoclasstx .
    TYPES:
      tt_seoclasstx_s TYPE SORTED TABLE OF ts_seoclasstx WITH UNIQUE KEY langu .
    TYPES:
      tt_seocompotx TYPE STANDARD TABLE OF seocompotx WITH DEFAULT KEY .
    TYPES:
      tt_seocompotx_s TYPE SORTED TABLE OF seocompotx WITH UNIQUE KEY cmpname langu .
    TYPES:
      BEGIN OF ts_seocompotx.
        INCLUDE TYPE seocompotx AS main.
    TYPES:
      documentation TYPE ts_lang,
      END OF ts_seocompotx .
    TYPES:
      tt_seocompotx_l TYPE SORTED TABLE OF ts_seocompotx WITH UNIQUE KEY langu .
    TYPES:
      tt_seosubcotx TYPE STANDARD TABLE OF seosubcotx WITH DEFAULT KEY .
    TYPES:
      tt_seosubcotx_s TYPE SORTED TABLE OF seosubcotx WITH UNIQUE KEY cmpname sconame langu .
    TYPES:
      tt_seosubcotx_l TYPE SORTED TABLE OF seosubcotx WITH UNIQUE KEY langu .
    TYPES:
      BEGIN OF ts_meth_inc.                                 " Issue 82
        INCLUDE TYPE seop_method_w_include AS hdr.
    TYPES:
      raw_source TYPE tt_abaprawsource,
      END OF ts_meth_inc .
    TYPES:
      tt_meth_incs TYPE STANDARD TABLE OF ts_meth_inc WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_include,                                  " Issue 82
        name       TYPE program,
        raw_source TYPE tt_abaprawsource,
      END OF ts_include .
    TYPES:
      BEGIN OF ts_includes,
        classpool      TYPE ts_include,
        pubsec         TYPE ts_include,
        prisec         TYPE ts_include,
        prosec         TYPE ts_include,
        cl             TYPE ts_include,
        ccimp          TYPE ts_include,
        ccdef          TYPE ts_include,
        ccmac          TYPE ts_include,
        interfacepool  TYPE ts_include,
        intfsec        TYPE ts_include,
        localtestclass TYPE ts_include,                 " Issue 82
        methods        TYPE tt_meth_incs,
      END OF ts_includes .
    TYPES:
      tt_sotr_texts TYPE SORTED TABLE OF sotr_text WITH UNIQUE KEY langu object .
    TYPES:
      tt_sotr_textus TYPE STANDARD TABLE OF sotr_textu WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_cx_text,
        cmpname TYPE seoo_attribute_r-cmpname.
        INCLUDE TYPE sotr_head AS hdr.
    TYPES:
      lhdr      TYPE sotr_headu,
      texts     TYPE tt_sotr_texts,
      longtexts TYPE tt_sotr_textus,
      END OF ts_cx_text .
    TYPES:
      tt_cx_texts TYPE SORTED TABLE OF ts_cx_text WITH UNIQUE KEY cmpname .
    TYPES:
      BEGIN OF t_fm_data,
        class                     TYPE  vseoclass,
        interface                 TYPE  vseointerf,
        attributes                TYPE  seoo_attributes_r,
        methods                   TYPE  seoo_methods_r,
        events                    TYPE  seoo_events_r,
        types                     TYPE  seoo_types_r,
        parameters                TYPE  seos_parameters_r,
        exceps                    TYPE  seos_exceptions_r,
        implementings             TYPE  seor_implementings_r,
        inheritance               TYPE  vseoextend,
        redefinitions             TYPE  seor_redefinitions_r,
        impl_details              TYPE  seor_redefinitions_r,
        friendships               TYPE  seof_friendships_r,
        typeusages                TYPE  seot_typepusages_r,
        clsdeferrds               TYPE  seot_clsdeferrds_r,
        intdeferrds               TYPE  seot_intdeferrds_r,
        comprisings               TYPE  seor_comprisings_r,
        explore_inheritance       TYPE  seok_cls_typeinfos,
        explore_implementings     TYPE  seok_int_typeinfos,
        explore_comprisings       TYPE  seok_int_typeinfos,
        aliases                   TYPE  seoo_aliases_r,
        enhancement_methods       TYPE  enhmeth_tabheader,
        enhancement_attributes    TYPE  enhclasstabattrib,
        enhancement_events        TYPE  enhclasstabevent,
        enhancement_implementings TYPE  enhclasstabimplementing,
        enhancement_comprisings   TYPE  enhclasstabintfcompri,
        class_desc                TYPE tt_seoclasstx,
        component_desc            TYPE  tt_seocompotx,
        subcomponent_desc         TYPE  tt_seosubcotx,
        includes                  TYPE ts_includes,
        enhancement_premeth       TYPE  enhmeth_tabkeys,
        enhancement_postmeth      TYPE  enhmeth_tabkeys,
        enhancement_owrmeth       TYPE  enhmeth_tabkeys,
        method_sources            TYPE seo_method_source_table,
        textspool                 TYPE tt_txtp_textpools,
        locals_def                TYPE  rswsourcet,
        locals_imp                TYPE  rswsourcet,
        locals_mac                TYPE  rswsourcet,
        locals_tst                TYPE  rswsourcet,   " Issue 82 : Test Class
        exceptions_texts          TYPE tt_cx_texts,
        dynpros                   TYPE tt_dynpros,
        menupainter               TYPE to_menupainter,
        documentation             TYPE tt_docs,
      END OF t_fm_data .
    TYPES:
      BEGIN OF ts_param_data.
        INCLUDE TYPE seos_parameter_r AS hdr.
    TYPES:
      texts TYPE tt_ltexts,     " tt_seosubcotx_l,
      END OF ts_param_data .
    TYPES:
      tt_parameters TYPE SORTED TABLE OF ts_param_data WITH UNIQUE KEY sconame .
    TYPES:
      BEGIN OF ts_excep_data.
        INCLUDE TYPE seos_exception_r AS hdr.
    TYPES:
      texts TYPE tt_ltexts,   " tt_seosubcotx_l,
      END OF ts_excep_data .
    TYPES:
      tt_exceptions TYPE SORTED TABLE OF ts_excep_data WITH UNIQUE KEY sconame .
    TYPES:
      BEGIN OF ts_event_data.
        INCLUDE TYPE seoo_event_r AS hdr.
    TYPES:
      texts      TYPE tt_ltexts,     " tt_seocompotx_l,
      parameters TYPE tt_parameters,
      END OF ts_event_data .
    TYPES:
      tt_events TYPE SORTED TABLE OF ts_event_data WITH UNIQUE KEY cmpname .
    TYPES:
      BEGIN OF ts_meth_data.
        INCLUDE TYPE seoo_method_r AS hdr.
    TYPES:
      texts      TYPE tt_ltexts,     " tt_seocompotx_l,
      parameters TYPE tt_parameters,
      exceptions TYPE tt_exceptions,
      source     TYPE ts_sourceasstruc,
      END OF ts_meth_data .
    TYPES:
      tt_methods TYPE SORTED TABLE OF ts_meth_data WITH UNIQUE KEY cmpname .
    TYPES:
      BEGIN OF ts_alias_data.
        INCLUDE TYPE seoo_alias_r AS hdr.
    TYPES:
      texts TYPE tt_ltexts,     " tt_seocompotx_l,
      END OF ts_alias_data .
    TYPES:
      tt_alias TYPE SORTED TABLE OF ts_alias_data WITH UNIQUE KEY cmpname .
    TYPES:
      BEGIN OF ts_attr_data.
        INCLUDE TYPE seoo_attribute_r AS hdr.
    TYPES:
      texts TYPE tt_ltexts,     " tt_seocompotx_l,
      _     TYPE td_abapsource,
      END OF ts_attr_data .
    TYPES:
      tt_attributs TYPE SORTED TABLE OF ts_attr_data WITH UNIQUE KEY cmpname .
    TYPES:
      BEGIN OF ts_type_data.
        INCLUDE TYPE seoo_type_r AS hdr.
    TYPES:
      texts TYPE tt_ltexts,     " tt_seocompotx_l,
      _     TYPE td_abapsource,
      END OF ts_type_data .
    TYPES:
      tt_types TYPE SORTED TABLE OF ts_type_data WITH UNIQUE KEY cmpname .
    TYPES:
      BEGIN OF ts_tgrp_data.
        INCLUDE TYPE seot_typepusage_r AS hdr.
    TYPES:
      defered TYPE seot_clsdeferrd_r,
      itf_def TYPE seot_intdeferrd_r,
      END OF ts_tgrp_data .
    TYPES:
      tt_typegroups TYPE SORTED TABLE OF ts_tgrp_data WITH UNIQUE KEY typegroup .
    TYPES:
      BEGIN OF ts_redef_data.
        INCLUDE TYPE seoredef AS hdr.
    TYPES:
      source TYPE ts_sourceasstruc,
      END OF ts_redef_data .
    TYPES:
      tt_comp_impl TYPE SORTED TABLE OF ts_redef_data WITH UNIQUE KEY mtdname .
    TYPES:
      BEGIN OF ts_interface.
        INCLUDE TYPE seor_implementing_r AS hdr.  " M#odes red#nies par relation d'h#tage
    TYPES:
      components TYPE tt_comp_impl,   " Interface public attribute default value & Method implementation
      END OF ts_interface .
    TYPES:
      tt_interfaces TYPE SORTED TABLE OF ts_interface WITH UNIQUE KEY refclsname .
    TYPES:
      BEGIN OF ts_sources,
        classpool   TYPE  ts_sourceasstruc,
        local_types TYPE  ts_sourceasstruc,
        local_imp   TYPE  ts_sourceasstruc,
        macros      TYPE  ts_sourceasstruc,
        public      TYPE  ts_sourceasstruc,
        private     TYPE  ts_sourceasstruc,
        protected   TYPE  ts_sourceasstruc,
      END OF ts_sources .
    DATA aliases TYPE tt_alias .
    DATA attributs TYPE tt_attributs .
    DATA documentation TYPE tt_docs .
    DATA events TYPE tt_events .
    DATA interfaces TYPE tt_interfaces .
    DATA methods TYPE tt_methods .
    DATA typegroups TYPE tt_typegroups .
    DATA types TYPE tt_types .
    DATA deferred TYPE ts_deferred .
    CLASS-METHODS class_constructor .
    METHODS from_data
      IMPORTING
        !fm_data TYPE t_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE t_fm_data .
    METHODS complete_data
      CHANGING
        !fm_data TYPE t_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES td_transport_kind
      FOR zaplink_datatypes~td_transport_kind .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    TYPES:
      BEGIN OF ts_doc_key,                                    " equiv DOKU_OBJ = CHAR 60
        name      TYPE seoclsname,                           " CHAR 30
        other(30) TYPE c,
      END OF ts_doc_key .
    TYPES:
      BEGIN OF ts_component,
        cmpname TYPE seoo_method_r-cmpname,
      END OF ts_component .
    TYPES:
      tt_components TYPE SORTED TABLE OF ts_component WITH UNIQUE KEY cmpname .
    TYPES to_exception TYPE REF TO zaplink_cx_connector .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    DATA components TYPE tt_components .
    DATA obj_name TYPE seoclsname .
    DATA obj_version TYPE seoversion .
    DATA obj_langu TYPE sylangu .
    CONSTANTS:
      BEGIN OF object_types,                                "#EC NOTEXT
        class     TYPE td_comptype VALUE 'CLAS',
        interface TYPE td_comptype VALUE 'INTF',
      END OF object_types .
    CONSTANTS line_separator TYPE abap_char1 VALUE cl_abap_char_utilities=>newline. "#EC NOTEXT
    CONSTANTS method_separator TYPE abap_char1 VALUE '~'.   "#EC NOTEXT
    CLASS-DATA:
      BEGIN OF r_doc_ids,
        class     TYPE tr_docid,
        interface TYPE tr_docid,
      END OF r_doc_ids .
    CONSTANTS:
      BEGIN OF doc_ids,
        BEGIN OF class,
          header    TYPE td_doc_id VALUE 'CL',
          attribute TYPE td_doc_id VALUE 'CA',
          method    TYPE td_doc_id VALUE 'CO',
          event     TYPE td_doc_id VALUE 'CE',
          type      TYPE td_doc_id VALUE 'CT',
        END OF class,
        BEGIN OF interface,
          header    TYPE td_doc_id VALUE 'IF',
          attribute TYPE td_doc_id VALUE 'IA',
          method    TYPE td_doc_id VALUE 'IO',
          event     TYPE td_doc_id VALUE 'IE',
          type      TYPE td_doc_id VALUE 'IT',   " does not exists yet
        END OF interface,
      END OF doc_ids .
    DATA obj_type TYPE td_comptype .
    METHODS fd_parameters
      IMPORTING
        !fm_data          TYPE t_fm_data
        !component        TYPE seocmpname
      RETURNING
        VALUE(parameters) TYPE tt_parameters .
    METHODS fd_exceptions
      IMPORTING
        !fm_data          TYPE t_fm_data
        !component        TYPE seocmpname
      RETURNING
        VALUE(exceptions) TYPE tt_exceptions .
    METHODS fd_subc_desc
      IMPORTING
        !descriptions  TYPE tt_seosubcotx
        !sub_component TYPE seosconame
        !component     TYPE seocmpname
      RETURNING
        VALUE(texts)   TYPE tt_ltexts .
    METHODS fd_comp_desc
      IMPORTING
        !descriptions  TYPE tt_seocompotx
        !component     TYPE seocmpname
        !id            TYPE doku_id
        !documentation TYPE tt_docs
      RETURNING
        VALUE(texts)   TYPE tt_ltexts .
    METHODS td_subc_desc
      IMPORTING
        !sub_component TYPE seosconame
        !component     TYPE seocmpname
        !texts         TYPE tt_ltexts
      CHANGING
        !descriptions  TYPE tt_seosubcotx .
    METHODS td_comp_desc
      IMPORTING
        !component     TYPE seocmpname
        !texts         TYPE tt_ltexts
        !id            TYPE doku_id
      CHANGING
        !documentation TYPE tt_docs
        !descriptions  TYPE tt_seocompotx .
    METHODS td_parameters
      IMPORTING
        !component  TYPE seocmpname
        !parameters TYPE tt_parameters
      CHANGING
        !fm_data    TYPE t_fm_data .
    METHODS td_exceptions
      IMPORTING
        !component TYPE seocmpname
        !exception TYPE tt_exceptions
      CHANGING
        !fm_data   TYPE t_fm_data .
    METHODS td_text
      IMPORTING
        !classname     TYPE seoclsname
        !texts         TYPE tt_ltexts
        !id            TYPE doku_id
      CHANGING
        !documentation TYPE tt_docs
        !descriptions  TYPE tt_seoclasstx .
    METHODS fd_text
      IMPORTING
        !descriptions  TYPE tt_seoclasstx
        !classname     TYPE seoclsname
        !id            TYPE doku_id
        !documentation TYPE tt_docs
      RETURNING
        VALUE(texts)   TYPE tt_ltexts .
    METHODS clear_tags .
    METHODS fix_included_type_pool
      IMPORTING
        !sourcecode     TYPE tt_abaprawsource
        !typepools      TYPE seot_typepusages_r
        !public         TYPE abap_bool OPTIONAL
      EXPORTING
        !new_sourcecode TYPE tt_abaprawsource
        !new_typepools  TYPE seot_typepusages_r .
  PRIVATE SECTION.
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_OBJECT_DATA definition
CLASS zaplink_options DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPES to_devclass TYPE REF TO zaplink_opt_devclass .
    TYPES to_directory TYPE REF TO zaplink_opt_directory .
    DATA devclass TYPE to_devclass READ-ONLY .
    DATA directory TYPE to_directory READ-ONLY .
    METHODS constructor .
    METHODS get_directory
      RETURNING
        VALUE(result) TYPE to_directory
      RAISING
        zaplink_cx_options .
    METHODS set_directory
      IMPORTING
        !data TYPE to_directory
      RAISING
        zaplink_cx_options .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_OPTIONS definition
CLASS zaplink_opt_directory DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES ballog_object
      FOR zaplink_datatypes~ballog_object .
    ALIASES td_substitutionkind
      FOR zaplink_datatypes~td_substitutionkind .
    ALIASES ts_directory
      FOR zaplink_datatypes~ts_directory .
    TYPES to_component TYPE REF TO zaplink_raw_base .
    TYPES to_devclass TYPE REF TO zaplink_opt_devclass .
    TYPES to_exception TYPE REF TO zaplink_cx_options .
    TYPES to_log TYPE REF TO zaplink_message_collector .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    TYPES to_tr TYPE REF TO zaplink_opt_transport_request .
    DATA application_log TYPE to_log READ-ONLY .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'DIRECTORY'. "#EC NOTEXT
    CONSTANTS:
      BEGIN OF substitutionkinds,
        fixed          TYPE td_substitutionkind VALUE 'F',    " Assign allways the same specified devclass
        keep_container TYPE td_substitutionkind VALUE 'K',    " Keep dev class in XML file
        use_component  TYPE td_substitutionkind VALUE 'C',    " Use devclass define in component
        local          TYPE td_substitutionkind VALUE 'L',    " Devclass = $TMP
      END OF substitutionkinds .
    METHODS constructor .
    METHODS get_devclass
      RETURNING
        VALUE(result) TYPE to_devclass
      RAISING
        zaplink_cx_options .
    METHODS get_transport_request
      RETURNING
        VALUE(result) TYPE to_tr
      RAISING
        zaplink_cx_options .
    METHODS set_devclass
      IMPORTING
        !data TYPE to_devclass
      RAISING
        zaplink_cx_options .
    METHODS set_directory
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(result) TYPE ts_directory
      RAISING
        zaplink_cx_options .
    METHODS set_transport_request
      IMPORTING
        !data TYPE to_tr
      RAISING
        zaplink_cx_options .
  PROTECTED SECTION.
    DATA o_mycx TYPE to_exception .
    DATA _devclass TYPE to_devclass .
    DATA _substitution TYPE td_substitutionkind .
    DATA _tr TYPE to_tr .
  PRIVATE SECTION.
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_OPT_DIRECTORY definition
CLASS zaplink_prog_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_program .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    ALIASES ts_sourceasstruc
      FOR zaplink_datatypes~ts_sourceasstruc .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_dynpros
      FOR zaplink_datatypes~tt_dynpros .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    CLASS-METHODS class_constructor .
  PROTECTED SECTION.
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    TYPES to_menupainter TYPE REF TO zaplink_menupainter_data .
    TYPES to_variant TYPE REF TO zaplink_vari_raw .
    TYPES:
      BEGIN OF ts_variant,
        zl_object TYPE to_variant,
      END OF ts_variant .
    TYPES:
      tt_variants TYPE STANDARD TABLE OF ts_variant WITH DEFAULT KEY .
    TYPES:
      tt_trdirti TYPE SORTED TABLE OF trdirti WITH UNIQUE KEY sprsl .
    TYPES:
      tt_vari_data TYPE STANDARD TABLE OF zaplink_vari_data=>ts_fm_data WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_fm_data,
        header      TYPE progdir,
        texts       TYPE tt_trdirti,
        docs        TYPE tt_docs,
        textspool   TYPE tt_txtp_textpools,
        dynpros     TYPE tt_dynpros,
        menupainter TYPE to_menupainter,
        source      TYPE td_abapsource,
        variants    TYPE tt_vari_data,                    " Issue 53
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE progdir.
    TYPES:
      END OF ts_maindata .
    DATA a0_maindata TYPE ts_maindata .
    DATA documentation_off TYPE tt_docs .
    DATA textspool TYPE tt_txtp_textpools .
    DATA source TYPE ts_sourceasstruc .
    DATA dynpros TYPE tt_dynpros .
    DATA menupainter TYPE to_menupainter .
    DATA texts TYPE tt_texts .
    DATA variants TYPE tt_variants .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data
      RAISING
        zaplink_cx .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize
      RAISING
        zaplink_cx .
    METHODS unanonymize .
  PRIVATE SECTION.
    CONSTANTS:
      BEGIN OF doc_ids,
        prog TYPE td_doc_id VALUE 'RE',    " Report
      END OF doc_ids .
    CLASS-DATA:
      BEGIN OF r_doc_ids,
        prog TYPE tr_docid,
      END OF r_doc_ids .
ENDCLASS. "ZAPLINK_PROG_DATA definition
CLASS zaplink_raw_base DEFINITION
  CREATE PUBLIC
  FRIENDS zaplink_container_4inst
                 zaplink_easyxml .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    INTERFACES zaplink_datatypes .
    ALIASES ballog_object
      FOR zaplink_datatypes~ballog_object .
    ALIASES comp_nodename
      FOR zaplink_datatypes~comp_nodename .
    ALIASES exists
      FOR zaplink_datatypes~exists .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES textpool_kinds
      FOR zaplink_datatypes~textpool_kinds .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_action
      FOR zaplink_datatypes~td_action .
    ALIASES td_checksum
      FOR zaplink_datatypes~td_checksum .
    ALIASES td_classname
      FOR zaplink_datatypes~td_classname .
    ALIASES td_compexists
      FOR zaplink_datatypes~td_compexists .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptext
      FOR zaplink_datatypes~td_comptext .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    ALIASES td_connexists
      FOR zaplink_datatypes~td_connexists .
    ALIASES td_connuuid
      FOR zaplink_datatypes~td_connuuid .
    ALIASES td_connver
      FOR zaplink_datatypes~td_connver .
    ALIASES td_contname
      FOR zaplink_datatypes~td_contname .
    ALIASES td_contver
      FOR zaplink_datatypes~td_contver .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES td_exists
      FOR zaplink_datatypes~td_exists .
    ALIASES td_filename
      FOR zaplink_datatypes~td_filename .
    ALIASES td_filetype
      FOR zaplink_datatypes~td_filetype .
    ALIASES td_lang
      FOR zaplink_datatypes~td_lang .
    ALIASES td_light
      FOR zaplink_datatypes~td_light .
    ALIASES td_obj_type
      FOR zaplink_datatypes~td_obj_type .
    ALIASES td_progname
      FOR zaplink_datatypes~td_progname .
    ALIASES td_substitutionkind
      FOR zaplink_datatypes~td_substitutionkind .
    ALIASES td_transport_kind
      FOR zaplink_datatypes~td_transport_kind .
    ALIASES td_transport_request
      FOR zaplink_datatypes~td_transport_request .
    ALIASES td_txtp_id
      FOR zaplink_datatypes~td_txtp_id .
    ALIASES td_txtp_kind
      FOR zaplink_datatypes~td_txtp_kind .
    ALIASES td_txtp_len
      FOR zaplink_datatypes~td_txtp_len .
    ALIASES td_txtp_text
      FOR zaplink_datatypes~td_txtp_text .
    ALIASES td_type_as_text
      FOR zaplink_datatypes~td_type_as_text .
    ALIASES to_xml
      FOR zaplink_datatypes~to_xml .
    ALIASES tr_dlvunit
      FOR zaplink_datatypes~tr_dlvunit .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    ALIASES tr_packages
      FOR zaplink_datatypes~tr_packages .
    ALIASES tr_tr
      FOR zaplink_datatypes~tr_tr .
    ALIASES ts_base_attributs
      FOR zaplink_datatypes~ts_base_attributs .
    ALIASES ts_compkey
      FOR zaplink_datatypes~ts_compkey .
    ALIASES ts_conndata
      FOR zaplink_datatypes~ts_conndata .
    ALIASES ts_conn_class
      FOR zaplink_datatypes~ts_conn_class .
    ALIASES ts_conn_def
      FOR zaplink_datatypes~ts_conn_def .
    ALIASES ts_contdata
      FOR zaplink_datatypes~ts_contdata .
    ALIASES ts_directory
      FOR zaplink_datatypes~ts_directory .
    ALIASES ts_doc
      FOR zaplink_datatypes~ts_doc .
    ALIASES ts_head
      FOR zaplink_datatypes~ts_head .
    ALIASES ts_lang
      FOR zaplink_datatypes~ts_lang .
    ALIASES ts_txtp_text
      FOR zaplink_datatypes~ts_txtp_text .
    ALIASES ts_txtp_textpool
      FOR zaplink_datatypes~ts_txtp_textpool .
    ALIASES ts_type
      FOR zaplink_datatypes~ts_type .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_compkeys
      FOR zaplink_datatypes~tt_compkeys .
    ALIASES tt_conn_classes
      FOR zaplink_datatypes~tt_conn_classes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_rawtext
      FOR zaplink_datatypes~tt_rawtext .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    ALIASES tt_txtp_texts
      FOR zaplink_datatypes~tt_txtp_texts .
    ALIASES tt_types
      FOR zaplink_datatypes~tt_types .
    TYPES to_connector TYPE REF TO zaplink_connector .
    TYPES to_ez_xml TYPE REF TO zaplink_easyxml .
    TYPES to_component TYPE REF TO zaplink_component .
    DATA type TYPE td_comptype .
    DATA name TYPE td_compname .
    DATA connector TYPE td_connuuid .
    DATA version TYPE td_connver .
    DATA directory TYPE ts_directory READ-ONLY .
    DATA dependencies TYPE tt_compkeys .
    CLASS-METHODS class_constructor .
    METHODS constructor
      IMPORTING
        !o_comp TYPE to_component OPTIONAL .
    METHODS update_connector_data
      IMPORTING
        !o_connector TYPE to_connector
      RAISING
        zaplink_cx .
    METHODS set_component
      IMPORTING
        !o_comp TYPE to_component
      RAISING
        zaplink_cx_container .
    METHODS get_component
      IMPORTING
        !without_cx   TYPE abap_bool OPTIONAL
      RETURNING
        VALUE(o_comp) TYPE to_component
      RAISING
        zaplink_cx .
    METHODS get_type
      RETURNING
        VALUE(result) TYPE td_comptype .
    METHODS get_name
      RETURNING
        VALUE(result) TYPE td_compname .
    METHODS get_checksum
      RETURNING
        VALUE(result) TYPE td_checksum .
    METHODS set_checksum
      RAISING
        zaplink_cx .
    METHODS anonymize
      RAISING
        zaplink_cx .
    METHODS unanonymize .
    METHODS get_code_signature
      RETURNING
        VALUE(result) TYPE td_checksum .
    METHODS get_typekind
      RETURNING
        VALUE(result) TYPE td_transport_kind .
  PROTECTED SECTION.
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    TYPES to_exception TYPE REF TO zaplink_cx_container .
    DATA checksum TYPE td_checksum .
    DATA code_signature TYPE td_checksum .
    METHODS conv_to_xml
      RETURNING
        VALUE(result) TYPE to_xml
      RAISING
        zaplink_cx .
    CLASS-METHODS xml_2_string
      IMPORTING
        !o_xml        TYPE to_xml
      RETURNING
        VALUE(result) TYPE string .
  PRIVATE SECTION.
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
    CLASS-DATA xmlengine TYPE REF TO if_ixml .
    METHODS refresh_directory
      RAISING
        zaplink_cx_container .
ENDCLASS. "ZAPLINK_RAW_BASE definition
CLASS zaplink_tabu_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_dictionary
                 zaplink_easyxml .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES td_table_name TYPE dd02l-tabname .
    DATA content TYPE REF TO data .
    METHODS from_data
      IMPORTING
        !table TYPE td_table_name
      RAISING
        zaplink_cx .
    METHODS to_data .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_TABU_DATA definition
INTERFACE zaplink_types.
  INTERFACES zaplink_kernel_types .
  ALIASES ballog_object
  FOR zaplink_kernel_types~ballog_object .
  TYPES to_component TYPE zaplink_kernel_types=>to_component .
  TYPES to_container TYPE zaplink_kernel_types=>to_container .
  TYPES to_file TYPE zaplink_kernel_types=>to_file .
  TYPES to_gui TYPE REF TO zaplink_gui .
  TYPES to_list TYPE zaplink_kernel_types=>to_list .
  TYPES to_msg_coll TYPE zaplink_kernel_types=>to_msg_coll .
  TYPES to_options TYPE zaplink_kernel_types=>to_options .
  TYPES to_opt_devclass TYPE zaplink_kernel_types=>to_opt_devclass .
  TYPES to_raw TYPE zaplink_kernel_types=>to_raw .
ENDINTERFACE.
CLASS zaplink_xinx_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_dictionary
                 zaplink_easyxml
                 zaplink_xinx_raw .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES:
      tt_dd17v TYPE STANDARD TABLE OF dd17v WITH DEFAULT KEY .
    TYPES:
      tt_dd12t TYPE STANDARD TABLE OF dd12t WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_idx_key,
        table TYPE tabname,
        index TYPE indexid,
      END OF ts_idx_key .
    TYPES:
      BEGIN OF ts_fm_data,
        header TYPE dd12v,
        texts  TYPE tt_dd12t,
        fields TYPE tt_dd17v,
        docs   TYPE tt_docs,
      END OF ts_fm_data .
    TYPES:
      tt_fields TYPE SORTED TABLE OF dd17v WITH UNIQUE KEY position .
    TYPES ts_maindata TYPE dd12v .
    DATA a0_maindata TYPE ts_maindata .
    DATA fields TYPE tt_fields .
    DATA texts TYPE tt_texts .
    CLASS-METHODS class_constructor .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize .
    METHODS unanonymize .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    TYPES to_exception TYPE REF TO zaplink_cx_connector .
    CLASS-DATA r_doc_ids TYPE tr_docid .
    CONSTANTS:
      BEGIN OF doc_ids,
        header TYPE td_doc_id VALUE 'TB',
      END OF doc_ids .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
    CLASS-METHODS name_2_key
      IMPORTING
        !data         TYPE td_compname
      RETURNING
        VALUE(result) TYPE ts_idx_key .
    CLASS-METHODS key_2_name
      IMPORTING
        !data         TYPE ts_idx_key
      RETURNING
        VALUE(result) TYPE td_compname .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_XINX_DATA definition
CLASS zaplink_connector_ DEFINITION
  ABSTRACT
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS rpyty .
    INTERFACES zaplink_cnx_ext_cleaner .
    INTERFACES zaplink_cnx_ext_code_signature .
    INTERFACES zaplink_connector
      ABSTRACT METHODS create_new_raw
      delete_from_sap
      do_exists
      is_supported_version
      read_from_sap
      write_to_sap .
    INTERFACES zaplink_datatypes .
    ALIASES application_log
      FOR zaplink_connector~application_log .
    ALIASES ballog_object
      FOR zaplink_connector~ballog_object .
    ALIASES comp_nodename
      FOR zaplink_connector~comp_nodename .
    ALIASES exists
      FOR zaplink_connector~exists .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES options
      FOR zaplink_connector~options .
    ALIASES sub_component
      FOR zaplink_datatypes~sub_component .
    ALIASES supported_types
      FOR zaplink_connector~supported_types .
    ALIASES textpool_kinds
      FOR zaplink_datatypes~textpool_kinds .
    ALIASES uuid
      FOR zaplink_connector~uuid .
    ALIASES version
      FOR zaplink_connector~version .
    ALIASES anonymize
      FOR zaplink_cnx_ext_cleaner~anonymize .
    ALIASES create_new_raw
      FOR zaplink_connector~create_new_raw .
    ALIASES delete_from_sap
      FOR zaplink_connector~delete_from_sap .
    ALIASES do_exists
      FOR zaplink_connector~do_exists .
    ALIASES export_from_sap
      FOR zaplink_connector~export_from_sap .
    ALIASES get_values
      FOR zaplink_connector~get_values .
    ALIASES import_to_sap
      FOR zaplink_connector~import_to_sap .
    ALIASES is_supported_version
      FOR zaplink_connector~is_supported_version .
    ALIASES read_from_sap
      FOR zaplink_connector~read_from_sap .
    ALIASES unanonymize
      FOR zaplink_cnx_ext_cleaner~unanonymize .
    ALIASES write_to_sap
      FOR zaplink_connector~write_to_sap .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_checksum
      FOR zaplink_datatypes~td_checksum .
    ALIASES td_classname
      FOR zaplink_datatypes~td_classname .
    ALIASES td_compexists
      FOR zaplink_connector~td_compexists .
    ALIASES td_compname
      FOR zaplink_connector~td_compname .
    ALIASES td_comptype
      FOR zaplink_connector~td_comptype .
    ALIASES td_connclass
      FOR zaplink_connector~td_connclass .
    ALIASES td_connexists
      FOR zaplink_connector~td_connexists .
    ALIASES td_connuuid
      FOR zaplink_connector~td_connuuid .
    ALIASES td_connver
      FOR zaplink_connector~td_connver .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES td_exists
      FOR zaplink_datatypes~td_exists .
    ALIASES td_lang
      FOR zaplink_datatypes~td_lang .
    ALIASES td_light
      FOR zaplink_datatypes~td_light .
    ALIASES td_obj_type
      FOR zaplink_datatypes~td_obj_type .
    ALIASES td_progname
      FOR zaplink_datatypes~td_progname .
    ALIASES td_transport_kind
      FOR zaplink_datatypes~td_transport_kind .
    ALIASES td_txtp_id
      FOR zaplink_datatypes~td_txtp_id .
    ALIASES td_txtp_kind
      FOR zaplink_datatypes~td_txtp_kind .
    ALIASES td_txtp_len
      FOR zaplink_datatypes~td_txtp_len .
    ALIASES td_txtp_text
      FOR zaplink_datatypes~td_txtp_text .
    ALIASES td_with_subcomp
      FOR zaplink_datatypes~td_with_subcomp .
    ALIASES ti_cleanning
      FOR zaplink_connector~ti_cleanning .
    ALIASES ti_cleanning_4data
      FOR zaplink_connector~ti_cleanning_4data .
    ALIASES to_component
      FOR zaplink_connector~to_component .
    ALIASES to_connector
      FOR zaplink_connector~to_connector .
    ALIASES to_ez_xml
      FOR zaplink_connector~to_ez_xml .
    ALIASES to_list
      FOR zaplink_connector~to_list .
    ALIASES to_msg_coll
      FOR zaplink_connector~to_msg_coll .
    ALIASES to_options
      FOR zaplink_connector~to_options .
    ALIASES to_raw
      FOR zaplink_connector~to_raw .
    ALIASES to_raw_base
      FOR zaplink_connector~to_raw_base .
    ALIASES to_raw_data
      FOR zaplink_connector~to_raw_data .
    ALIASES to_xml
      FOR zaplink_connector~to_xml .
    ALIASES tr_dlvunit
      FOR zaplink_datatypes~tr_dlvunit .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    ALIASES tr_packages
      FOR zaplink_datatypes~tr_packages .
    ALIASES tr_tr
      FOR zaplink_datatypes~tr_tr .
    ALIASES ts_base_attributs
      FOR zaplink_connector~ts_base_attributs .
    ALIASES ts_compkey
      FOR zaplink_datatypes~ts_compkey .
    ALIASES ts_comptype
      FOR zaplink_datatypes~ts_comptype .
    ALIASES ts_conndata
      FOR zaplink_connector~ts_conndata .
    ALIASES ts_conn_class
      FOR zaplink_datatypes~ts_conn_class .
    ALIASES ts_conn_def
      FOR zaplink_datatypes~ts_conn_def .
    ALIASES ts_doc
      FOR zaplink_datatypes~ts_doc .
    ALIASES ts_head
      FOR zaplink_datatypes~ts_head .
    ALIASES ts_lang
      FOR zaplink_datatypes~ts_lang .
    ALIASES ts_txtp_text
      FOR zaplink_datatypes~ts_txtp_text .
    ALIASES ts_txtp_textpool
      FOR zaplink_datatypes~ts_txtp_textpool .
    ALIASES ts_type
      FOR zaplink_datatypes~ts_type .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_compkeys
      FOR zaplink_datatypes~tt_compkeys .
    ALIASES tt_conn_classes
      FOR zaplink_datatypes~tt_conn_classes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_dynpros
      FOR zaplink_datatypes~tt_dynpros .
    ALIASES tt_rawtext
      FOR zaplink_datatypes~tt_rawtext .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    ALIASES tt_txtp_texts
      FOR zaplink_datatypes~tt_txtp_texts .
    ALIASES tt_types
      FOR zaplink_connector~tt_types .
    TYPES to_menupainter TYPE REF TO zaplink_menupainter_data .
    DATA class_name TYPE td_classname READ-ONLY .
    METHODS constructor .
    CLASS-METHODS class_constructor .
    CLASS-METHODS get_type_from_xml
      IMPORTING
        !object       TYPE to_xml
      RETURNING
        VALUE(result) TYPE td_comptype
      RAISING
        zaplink_cx .
  PROTECTED SECTION.
    ALIASES tt_flow_logic
      FOR zaplink_datatypes~tt_flow_logic .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    TYPES to_exception TYPE REF TO zaplink_cx_connector .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
    CLASS-DATA o_activate TYPE REF TO zaplink_activate .
    METHODS set_base_attributs
      IMPORTING
        !component       TYPE to_component
      RETURNING
        VALUE(attributs) TYPE ts_base_attributs .
    CLASS-METHODS get_prog_source
      IMPORTING
        !program      TYPE td_progname
      RETURNING
        VALUE(result) TYPE td_abapsource .
    CLASS-METHODS get_prog_rawsource
      IMPORTING
        !program      TYPE td_progname
      RETURNING
        VALUE(result) TYPE tt_abaprawsource .
    CLASS-METHODS conv_abap_raw2source
      IMPORTING
        !raw          TYPE tt_abaprawsource
      RETURNING
        VALUE(result) TYPE td_abapsource .
    CLASS-METHODS conv_abap_source2raw
      IMPORTING
        !source       TYPE td_abapsource
      RETURNING
        VALUE(result) TYPE tt_abaprawsource .
    CLASS-METHODS set_prog_rawsource
      IMPORTING
        !program TYPE td_progname
        !raw     TYPE tt_abaprawsource .
    CLASS-METHODS set_prog_source
      IMPORTING
        !program TYPE td_progname
        !source  TYPE td_abapsource .
    CLASS-METHODS get_prog_textpool
      IMPORTING
        !program      TYPE td_progname
      RETURNING
        VALUE(result) TYPE tt_txtp_textpools .
    CLASS-METHODS fusion_textpool
      IMPORTING
        !source       TYPE tt_txtp_textpools
        !completion   TYPE tt_txtp_textpools
      RETURNING
        VALUE(result) TYPE tt_txtp_textpools .
    CLASS-METHODS set_prog_textpool
      IMPORTING
        !program  TYPE td_progname
        !textpool TYPE tt_txtp_textpools .
    METHODS get_dynpros
      IMPORTING
        !program      TYPE td_progname
      RETURNING
        VALUE(result) TYPE tt_dynpros .
    METHODS set_dynpros
      IMPORTING
        !program       TYPE td_progname
        VALUE(dynpros) TYPE tt_dynpros
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS conv_flowlogic2abapsource
      IMPORTING
        !raw          TYPE tt_flow_logic
      RETURNING
        VALUE(result) TYPE td_abapsource .
    CLASS-METHODS conv_abapsource2flowlogic
      IMPORTING
        !source       TYPE td_abapsource
      RETURNING
        VALUE(result) TYPE tt_flow_logic .
    METHODS get_menus
      IMPORTING
        !program      TYPE td_progname
      RETURNING
        VALUE(result) TYPE to_menupainter
      RAISING
        zaplink_cx .
    METHODS set_menus
      IMPORTING
        !program TYPE td_progname
        !menus   TYPE to_menupainter
      RAISING
        zaplink_cx .
    METHODS check_component_list
      IMPORTING
        !object     TYPE to_raw
      CHANGING
        !components TYPE to_list
      RAISING
        zaplink_cx .
    CLASS-METHODS active_component
      IMPORTING
        !type         TYPE td_comptype
        !name         TYPE td_compname
      RETURNING
        VALUE(result) TYPE abap_bool .
  PRIVATE SECTION.
    TYPES:
      tr_scrntype TYPE RANGE OF scrntype .
    CLASS-DATA r_text_fields TYPE tr_scrntype .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_COMMUN'. "#EC NOTEXT
ENDCLASS. "ZAPLINK_CONNECTOR_ definition
CLASS zaplink_documentation DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPES to_log TYPE REF TO zaplink_message_collector .
    CONSTANTS node_name TYPE string VALUE 'DOCS'.           "#EC NOTEXT
    CLASS-DATA log TYPE to_msg_coll .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_DOCUMENTATION'. "#EC NOTEXT
    METHODS constructor .
    CLASS-METHODS class_constructor .
    CLASS-METHODS get_single
      IMPORTING
        !ids          TYPE td_doc_id
        !object       TYPE doku_obj
      RETURNING
        VALUE(result) TYPE ts_doc
      RAISING
        zaplink_cx .
    CLASS-METHODS get
      IMPORTING
        !ids          TYPE tr_docid
        !object       TYPE doku_obj
      RETURNING
        VALUE(t_docs) TYPE tt_docs
      RAISING
        zaplink_cx .
    CLASS-METHODS set
      IMPORTING
        !t_docs TYPE tt_docs
      RAISING
        zaplink_cx .
    CLASS-METHODS set_single
      IMPORTING
        !data TYPE ts_doc
      RAISING
        zaplink_cx .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES to_doc TYPE REF TO zaplink_docv_data .
    TYPES:
      BEGIN OF ts_name_mask,
        id     TYPE dokil-id,
        object TYPE dokil-object,
      END OF ts_name_mask .
  PRIVATE SECTION.
    CONSTANTS:
      BEGIN OF supportedtypes,                              "#EC NOTEXT
        general TYPE td_comptype VALUE 'DOCT',    " General Text
        indep   TYPE td_comptype VALUE 'DOCV',    " Documentation (Independent)
      END OF supportedtypes .
    CONSTANTS _uuid TYPE td_connuuid VALUE '3D34954BEABE5F12E1000000AC120173'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.0'.             "#EC NOTEXT
    CLASS-METHODS reset .
    CLASS-METHODS raw2string
      IMPORTING
        !raw          TYPE tt_rawtext
      RETURNING
        VALUE(string) TYPE string .
    CLASS-METHODS string2raw
      IMPORTING
        !string    TYPE string
      RETURNING
        VALUE(raw) TYPE tt_rawtext .
    CLASS-METHODS docu_get
      IMPORTING
        !docu TYPE dokil
      EXPORTING
        !head TYPE ts_head
        !lang TYPE ts_lang
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS name_2_mask
      IMPORTING
        !type         TYPE td_comptype
        !name         TYPE td_compname
      RETURNING
        VALUE(result) TYPE ts_name_mask .
ENDCLASS. "ZAPLINK_DOCUMENTATION definition
CLASS zaplink_list_4extractor DEFINITION
  INHERITING FROM zaplink_list
  CREATE PUBLIC
  FRIENDS zaplink_extractor .
  PUBLIC SECTION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_LIST_4EXTRACTOR definition
CLASS zaplink_message DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPES td_raw____ TYPE rswsourcet .
    TYPES:
      BEGIN OF ts_text,
        langu  TYPE spras,
        entry  TYPE textpooltx,
        length TYPE textpoolln,
      END OF ts_text .
    TYPES:
      tt_texts TYPE SORTED TABLE OF ts_text WITH UNIQUE KEY langu .
    TYPES:
      BEGIN OF ts_textpool,
        id    TYPE  textpoolid,
        key   TYPE  textpoolky,
        texts TYPE  tt_texts,
      END OF ts_textpool .
    TYPES:
      tt_textpools TYPE SORTED TABLE OF ts_textpool WITH UNIQUE KEY id key .
    TYPES ts_source TYPE string .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_MESSAGE'. "#EC NOTEXT
    METHODS constructor .
    CLASS-METHODS class_constructor .
    METHODS zaplink_cnx_ext_cleaner~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner~unanonymize
        REDEFINITION .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES to_data TYPE REF TO zaplink_msag_data .
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ts_prog_attr.
        INCLUDE TYPE ts_base_attributs AS base.
    TYPES:
      END OF ts_prog_attr .
    CONSTANTS st_msgclass TYPE td_comptype VALUE 'MSAG'.    "#EC NOTEXT
    CLASS-DATA r_doc_id TYPE tr_docid .
    CONSTANTS _uuid TYPE td_connuuid VALUE '1FAC0A4B07A5A05AE1000000AC120173'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.0'.             "#EC NOTEXT
    CONSTANTS c_msg_id TYPE td_doc_id VALUE 'NA'.           "#EC NOTEXT
ENDCLASS. "ZAPLINK_MESSAGE definition
CLASS zaplink_os_command DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPES:
      BEGIN OF ts_os_cmd_key,
        name     TYPE sxpgcostab-name,
        opsystem TYPE sxpgcostab-opsystem,
      END OF ts_os_cmd_key .
    CONSTANTS field_separator TYPE abap_char1 VALUE '~'.    "#EC NOTEXT
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_OS_COMMAND'. "#EC NOTEXT
    METHODS constructor .
    CLASS-METHODS class_constructor .
    CLASS-METHODS comp_to_key
      IMPORTING
        !data         TYPE td_compname
      RETURNING
        VALUE(result) TYPE ts_os_cmd_key .
    CLASS-METHODS key_to_comp
      IMPORTING
        VALUE(data)   TYPE ts_os_cmd_key
      RETURNING
        VALUE(result) TYPE td_compname .
    METHODS zaplink_cnx_ext_code_signature~get_signature
        REDEFINITION .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES to_data TYPE REF TO zaplink_excc_data .
    CLASS-METHODS calc_signature
      IMPORTING
        VALUE(data)   TYPE sxpgcolist
      RETURNING
        VALUE(result) TYPE td_checksum
      RAISING
        zaplink_cx_connector .
  PRIVATE SECTION.
    CONSTANTS st_os_cmd TYPE td_comptype VALUE 'EXCC'.      "#EC NOTEXT
    CLASS-DATA r_doc_id TYPE tr_docid .
    CONSTANTS _uuid TYPE td_connuuid VALUE 'DF0813D1BA8C0EF1BEAE000C291B645B'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.0'.             "#EC NOTEXT
    CONSTANTS c_msg_id TYPE td_doc_id VALUE 'NA'.           "#EC NOTEXT
ENDCLASS. "ZAPLINK_OS_COMMAND definition
CLASS zaplink_badi DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS seex .
    CONSTANTS st_badi_def TYPE td_comptype VALUE 'SXSD'.    "#EC NOTEXT
    CONSTANTS st_badi_impl TYPE td_comptype VALUE 'SXCI'.   "#EC NOTEXT
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_BADI'. "#EC NOTEXT
    METHODS constructor .
    CLASS-METHODS class_constructor .
    METHODS zaplink_cnx_ext_cleaner~anonymize
        REDEFINITION .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ts_doc_key,                                    " equiv DOKU_OBJ = CHAR 60
        simg(4) TYPE c,     "SIMG
        name    TYPE rsexscrn-exit_name,                   " CHAR 30
      END OF ts_doc_key .
    TYPES:
      BEGIN OF ts_clas_attr.
        INCLUDE TYPE ts_base_attributs AS base.
    TYPES:
      END OF ts_clas_attr .
    TYPES to_badi_def TYPE REF TO zaplink_sxsd_data .
    TYPES to_badi_impl TYPE REF TO zaplink_sxci_data .
    CLASS-DATA r_doc_id_definition TYPE tr_docid .
    CONSTANTS t_badi_itf TYPE td_comptype VALUE 'INTF'.     "#EC NOTEXT
    CONSTANTS t_badi_impl TYPE td_comptype VALUE 'CLAS'.    "#EC NOTEXT
    CLASS-DATA r_doc_id_implementation TYPE tr_docid .
    CONSTANTS _uuid TYPE td_connuuid VALUE '5DAA0A4B07A5A05AE1000000AC120173'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.0'.             "#EC NOTEXT
    CLASS-METHODS create_doc_key
      RETURNING
        VALUE(doc_key) TYPE ts_doc_key .
    CLASS-METHODS do_exists_impl
      IMPORTING
        !name          TYPE rsexscrn-imp_name
      RETURNING
        VALUE(_exists) TYPE td_compexists .
    METHODS export_from_sap_def
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(o_data) TYPE to_badi_def
      RAISING
        zaplink_cx_connector .
    METHODS export_from_sap_impl
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(o_data) TYPE to_badi_impl
      RAISING
        zaplink_cx_connector .
    METHODS import_to_sap_def
      IMPORTING
        !o_data           TYPE to_badi_def
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS import_to_sap_impl
      IMPORTING
        !o_data           TYPE to_badi_impl
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
ENDCLASS. "ZAPLINK_BADI definition
CLASS zaplink_badi_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PROTECTED
  FRIENDS zaplink_badi
                 zaplink_easyxml .
  PUBLIC SECTION.
    TYPE-POOLS seex .
    INTERFACES zaplink_datatypes .
    ALIASES exists
      FOR zaplink_datatypes~exists .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES textpool_kinds
      FOR zaplink_datatypes~textpool_kinds .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_classname
      FOR zaplink_datatypes~td_classname .
    ALIASES td_compexists
      FOR zaplink_datatypes~td_compexists .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    ALIASES td_connexists
      FOR zaplink_datatypes~td_connexists .
    ALIASES td_connver
      FOR zaplink_datatypes~td_connver .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_exists
      FOR zaplink_datatypes~td_exists .
    ALIASES td_lang
      FOR zaplink_datatypes~td_lang .
    ALIASES td_light
      FOR zaplink_datatypes~td_light .
    ALIASES td_obj_type
      FOR zaplink_datatypes~td_obj_type .
    ALIASES td_progname
      FOR zaplink_datatypes~td_progname .
    ALIASES td_txtp_id
      FOR zaplink_datatypes~td_txtp_id .
    ALIASES td_txtp_kind
      FOR zaplink_datatypes~td_txtp_kind .
    ALIASES td_txtp_len
      FOR zaplink_datatypes~td_txtp_len .
    ALIASES td_txtp_text
      FOR zaplink_datatypes~td_txtp_text .
    ALIASES to_xml
      FOR zaplink_datatypes~to_xml .
    ALIASES tr_dlvunit
      FOR zaplink_datatypes~tr_dlvunit .
    ALIASES tr_packages
      FOR zaplink_datatypes~tr_packages .
    ALIASES tr_tr
      FOR zaplink_datatypes~tr_tr .
    ALIASES ts_base_attributs
      FOR zaplink_datatypes~ts_base_attributs .
    ALIASES ts_compkey
      FOR zaplink_datatypes~ts_compkey .
    ALIASES ts_conn_class
      FOR zaplink_datatypes~ts_conn_class .
    ALIASES ts_conn_def
      FOR zaplink_datatypes~ts_conn_def .
    ALIASES ts_txtp_text
      FOR zaplink_datatypes~ts_txtp_text .
    ALIASES ts_txtp_textpool
      FOR zaplink_datatypes~ts_txtp_textpool .
    ALIASES ts_type
      FOR zaplink_datatypes~ts_type .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_compkeys
      FOR zaplink_datatypes~tt_compkeys .
    ALIASES tt_conn_classes
      FOR zaplink_datatypes~tt_conn_classes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    ALIASES tt_txtp_texts
      FOR zaplink_datatypes~tt_txtp_texts .
    ALIASES tt_types
      FOR zaplink_datatypes~tt_types .
    TYPES:
      tt_functions TYPE SORTED TABLE OF seex_fcode_struct WITH UNIQUE KEY gui_prog gui_code .
    TYPES:
      tt_controls TYPE SORTED TABLE OF seex_coco_struct WITH UNIQUE KEY coco_outer node_id .
    TYPES:
      tt_screens TYPE SORTED TABLE OF seex_screen_struct WITH UNIQUE KEY scr_a_prog scr_a_num scr_a_sscr .
    TYPES:
      tt_tables TYPE SORTED TABLE OF seex_table_struct WITH UNIQUE KEY tabname .
    TYPES:
      BEGIN OF t_fm_data,
        mast_langu         TYPE  sy-langu,
        fcodes             TYPE  seex_fcode_table,
        cocos              TYPE  seex_coco_table,
        intas              TYPE  seex_table_table,
        scrns              TYPE  seex_screen_table,
        definition         TYPE  badi_data,
        inactive_tabstrips TYPE  seex_inactive_tabstrips,
        ext_clname         TYPE  seoclsname,
        filter_obj         TYPE REF TO cl_badi_flt_struct,
        methods            TYPE  seex_mtd_table,
        implementation     TYPE impl_data,
        impl_w_filter      TYPE flt_ext,  " Filter active
        filter_datatype    TYPE rollname,
        filter_values      TYPE seex_filter_table,    "REF TO cl_badi_flt_values_alv,
      END OF t_fm_data .
    DATA functions_codes TYPE tt_functions .
    DATA controls_composites TYPE tt_controls .
    DATA subscreens TYPE tt_screens .
    DATA tables TYPE tt_tables .
    DATA documentation TYPE tt_docs .
    METHODS from_data
      IMPORTING
        !fm_data TYPE t_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE t_fm_data .
    METHODS anonymize
      RAISING
        zaplink_cx .
    METHODS unanonymize .
  PROTECTED SECTION.
    TYPES to_exception TYPE REF TO zaplink_cx_connector .
    TYPES to_raw TYPE REF TO zaplink_raw .
    TYPES to_connector TYPE zaplink_connectors=>to_connector .
    DATA def_name TYPE exit_def .
    CLASS-DATA o_mycx TYPE to_exception .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_BADI_DATA definition
CLASS zaplink_checkpoints DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_CHECKPOINTS'. "#EC NOTEXT
    CLASS-METHODS class_constructor .
    METHODS constructor .
    METHODS zaplink_cnx_ext_cleaner~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner~unanonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_code_signature~get_signature
        REDEFINITION .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES to_checkpoint TYPE REF TO zaplink_acid_data .
    TYPES to_variant TYPE REF TO zaplink_avar_data .
    TYPES td_checkpoint TYPE aab_id_name .
    TYPES td_variant TYPE string .
    TYPES ts_fmd_acid TYPE zaplink_acid_data=>ts_fm_data .
    TYPES ts_fmd_avar TYPE zaplink_avar_data=>ts_fm_data .
    CLASS-DATA:
      BEGIN OF supportedkinds,
        checkpoint TYPE td_transport_kind,
        variant    TYPE td_transport_kind,
      END OF supportedkinds .
    CONSTANTS:
      BEGIN OF supportedtypes,
        checkpoint TYPE td_comptype VALUE 'ACID',           "#EC NOTEXT
        variant    TYPE td_comptype VALUE 'AVAR',           "#EC NOTEXT
      END OF supportedtypes .
  PRIVATE SECTION.
    CONSTANTS _uuid TYPE td_connuuid VALUE 'D8638E4C3E11CC5AE1000000AC120173'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.0'.             "#EC NOTEXT
ENDCLASS. "ZAPLINK_CHECKPOINTS definition
CLASS zaplink_clas_data DEFINITION
  INHERITING FROM zaplink_object_data
  FINAL
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_object .
  PUBLIC SECTION.
    TYPE-POOLS seoc .
    TYPE-POOLS seof .
    TYPE-POOLS seok .
    TYPE-POOLS seoo .
    TYPE-POOLS seor .
    TYPE-POOLS seos .
    TYPE-POOLS seot .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES to_msg_col TYPE REF TO zaplink_message_collector .
    TYPES:
      BEGIN OF ts_message,
        class      TYPE symsgid,
        number     TYPE symsgno,
        attribut_1 TYPE scx_attrname,
        attribut_2 TYPE scx_attrname,
        attribut_3 TYPE scx_attrname,
        attribut_4 TYPE scx_attrname,
      END OF ts_message .
    TYPES:
      BEGIN OF ts_exception_text,
        cmpname   TYPE seoo_attribute_r-cmpname,      " Issue 62 : Reorg Exception text
        editorder TYPE seoo_attribute_r-editorder,    " Issue 71 : Keep SOTR Attribut order
        texts     TYPE tt_texts,
        message   TYPE ts_message,
      END OF ts_exception_text .
    TYPES:
      tt_exceptions_texts TYPE SORTED TABLE OF ts_exception_text WITH UNIQUE KEY cmpname .
    TYPES:
      BEGIN OF ts_locals,
        types            TYPE ts_sourceasstruc,
        implementations  TYPE ts_sourceasstruc,
        macros           TYPE ts_sourceasstruc,
        local_test_class TYPE ts_sourceasstruc,  " Issue 82
      END OF ts_locals .
    TYPES:
      BEGIN OF ts_redefinition.
        INCLUDE TYPE seoredef AS hdr.  " M#odes red#nies par relation d'h#tage
    TYPES:
      source TYPE ts_sourceasstruc,
      END OF ts_redefinition .
    TYPES:
      tt_redefinitions TYPE SORTED TABLE OF ts_redefinition WITH UNIQUE KEY mtdname .
    TYPES:
      tt_friends    TYPE SORTED TABLE OF seofriends WITH UNIQUE KEY refclsname friendtype .
    TYPES:
      BEGIN OF ts_class_data.
        INCLUDE TYPE vseoclass AS hdr.
    TYPES:
      inheritance TYPE vseoextend,
      texts       TYPE tt_ltexts,   " tt_seoclasstx_s,
      textpool    TYPE tt_txtp_textpools,
      sources     TYPE ts_sources,
      END OF ts_class_data .
    DATA a0_maindata TYPE ts_class_data .
    DATA friends TYPE tt_friends .
    DATA redefinitions TYPE tt_redefinitions .
    DATA local TYPE ts_locals .
    DATA exceptions_texts TYPE tt_exceptions_texts .
    DATA textspool TYPE tt_txtp_textpools .
    DATA dynpros TYPE tt_dynpros .
    EVENTS my_event2 .
    CLASS-METHODS class_constructor .
    CLASS-METHODS update_concept
      IMPORTING
        !msg_col TYPE to_msg_col
      CHANGING
        !fm_data TYPE t_fm_data
      RAISING
        zaplink_cx_connector .
    METHODS anonymize
        REDEFINITION .
    METHODS complete_data
        REDEFINITION .
    METHODS from_data
        REDEFINITION .
    METHODS to_data
        REDEFINITION .
  PROTECTED SECTION.
    DATA menupainter TYPE to_menupainter .
    CONSTANTS intf_4_message_exception_cl TYPE seoclsname VALUE 'IF_T100_MESSAGE'. "#EC NOTEXT
    CONSTANTS:
      BEGIN OF message_based_fields,
        class      TYPE string VALUE 'MSGID',
        number     TYPE string VALUE 'MSGNO',
        attribut_1 TYPE string VALUE 'ATTR1',
        attribut_2 TYPE string VALUE 'ATTR2',
        attribut_3 TYPE string VALUE 'ATTR3',
        attribut_4 TYPE string VALUE 'ATTR4',
      END OF message_based_fields .
    CLASS-DATA message_cx_type_source TYPE string .
  PRIVATE SECTION.
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
    CLASS-DATA c_kind TYPE td_transport_kind .
    CLASS-DATA c_type TYPE td_comptype VALUE object_types-class. "#EC NOTEXT .
    CLASS-METHODS conv_source
      IMPORTING
        VALUE(source) TYPE tt_abaprawsource
      RETURNING
        VALUE(result) TYPE td_abapsource .
    CLASS-METHODS value2sotr
      IMPORTING
        !data         TYPE seovalue
      RETURNING
        VALUE(result) TYPE sotr_conc .
    CLASS-METHODS sotr2value
      IMPORTING
        !data         TYPE sotr_conc
      RETURNING
        VALUE(result) TYPE seovalue .
ENDCLASS. "ZAPLINK_CLAS_DATA definition
CLASS zaplink_component_4inst DEFINITION
  INHERITING FROM zaplink_component
  CREATE PROTECTED
  FRIENDS zaplink_infos .
  PUBLIC SECTION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_COMPONENT_4INST definition
CLASS zaplink_connectors_4extractor DEFINITION
  INHERITING FROM zaplink_connectors
  CREATE PROTECTED
  FRIENDS zaplink_extractor
                 zaplink_infos
                 zaplink_kernel_types .
  PUBLIC SECTION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CONNECTORS_4EXTRACTOR definition
CLASS zaplink_connectors_4inst DEFINITION
  INHERITING FROM zaplink_connectors
  CREATE PROTECTED
  FRIENDS zaplink_infos .
  PUBLIC SECTION.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_CONNECTORS_4INST definition
CLASS zaplink_container_4inst DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    INTERFACES zaplink_datatypes .
    ALIASES ballog_object
      FOR zaplink_datatypes~ballog_object .
    ALIASES comp_nodename
      FOR zaplink_datatypes~comp_nodename .
    ALIASES exists
      FOR zaplink_datatypes~exists .
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES textpool_kinds
      FOR zaplink_datatypes~textpool_kinds .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_action
      FOR zaplink_datatypes~td_action .
    ALIASES td_checksum
      FOR zaplink_datatypes~td_checksum .
    ALIASES td_classname
      FOR zaplink_datatypes~td_classname .
    ALIASES td_compexists
      FOR zaplink_datatypes~td_compexists .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptext
      FOR zaplink_datatypes~td_comptext .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES td_connclass
      FOR zaplink_datatypes~td_connclass .
    ALIASES td_connexists
      FOR zaplink_datatypes~td_connexists .
    ALIASES td_connuuid
      FOR zaplink_datatypes~td_connuuid .
    ALIASES td_connver
      FOR zaplink_datatypes~td_connver .
    ALIASES td_contname
      FOR zaplink_datatypes~td_contname .
    ALIASES td_contver
      FOR zaplink_datatypes~td_contver .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES td_exists
      FOR zaplink_datatypes~td_exists .
    ALIASES td_filename
      FOR zaplink_datatypes~td_filename .
    ALIASES td_filetype
      FOR zaplink_datatypes~td_filetype .
    ALIASES td_lang
      FOR zaplink_datatypes~td_lang .
    ALIASES td_light
      FOR zaplink_datatypes~td_light .
    ALIASES td_obj_type
      FOR zaplink_datatypes~td_obj_type .
    ALIASES td_orderkind
      FOR zaplink_datatypes~td_orderkind .
    ALIASES td_progname
      FOR zaplink_datatypes~td_progname .
    ALIASES td_substitutionkind
      FOR zaplink_datatypes~td_substitutionkind .
    ALIASES td_transport_request
      FOR zaplink_datatypes~td_transport_request .
    ALIASES td_txtp_id
      FOR zaplink_datatypes~td_txtp_id .
    ALIASES td_txtp_kind
      FOR zaplink_datatypes~td_txtp_kind .
    ALIASES td_txtp_len
      FOR zaplink_datatypes~td_txtp_len .
    ALIASES td_txtp_text
      FOR zaplink_datatypes~td_txtp_text .
    ALIASES td_typeorder
      FOR zaplink_datatypes~td_typeorder .
    ALIASES td_type_as_text
      FOR zaplink_datatypes~td_type_as_text .
    ALIASES to_xml
      FOR zaplink_datatypes~to_xml .
    ALIASES tr_dlvunit
      FOR zaplink_datatypes~tr_dlvunit .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    ALIASES tr_packages
      FOR zaplink_datatypes~tr_packages .
    ALIASES tr_tr
      FOR zaplink_datatypes~tr_tr .
    ALIASES ts_base_attributs
      FOR zaplink_datatypes~ts_base_attributs .
    ALIASES ts_compkey
      FOR zaplink_datatypes~ts_compkey .
    ALIASES ts_component
      FOR zaplink_datatypes~ts_component .
    ALIASES ts_conndata
      FOR zaplink_datatypes~ts_conndata .
    ALIASES ts_conn_class
      FOR zaplink_datatypes~ts_conn_class .
    ALIASES ts_conn_def
      FOR zaplink_datatypes~ts_conn_def .
    ALIASES ts_contdata
      FOR zaplink_datatypes~ts_contdata .
    ALIASES ts_directory
      FOR zaplink_datatypes~ts_directory .
    ALIASES ts_doc
      FOR zaplink_datatypes~ts_doc .
    ALIASES ts_head
      FOR zaplink_datatypes~ts_head .
    ALIASES ts_lang
      FOR zaplink_datatypes~ts_lang .
    ALIASES ts_txtp_text
      FOR zaplink_datatypes~ts_txtp_text .
    ALIASES ts_txtp_textpool
      FOR zaplink_datatypes~ts_txtp_textpool .
    ALIASES ts_type
      FOR zaplink_datatypes~ts_type .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_compkeys
      FOR zaplink_datatypes~tt_compkeys .
    ALIASES tt_conn_classes
      FOR zaplink_datatypes~tt_conn_classes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_rawtext
      FOR zaplink_datatypes~tt_rawtext .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    ALIASES tt_txtp_texts
      FOR zaplink_datatypes~tt_txtp_texts .
    ALIASES tt_types
      FOR zaplink_datatypes~tt_types .
    TYPES to_raw_base TYPE REF TO zaplink_raw_base .
    TYPES to_exception TYPE REF TO zaplink_cx_container .
    TYPES to_options TYPE REF TO zaplink_options .
    TYPES to_raw TYPE REF TO zaplink_raw .
    TYPES to_log TYPE REF TO zaplink_message_collector .
    TYPES to_list TYPE REF TO zaplink_list .
    TYPES to_component TYPE REF TO zaplink_component .
    TYPES to_file TYPE REF TO zaplink_file .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    CONSTANTS tn_container_root TYPE string VALUE 'CONTAINER'. "#EC NOTEXT
    DATA file TYPE to_file .
    DATA log TYPE to_log READ-ONLY .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CONTAINER'. "#EC NOTEXT
    CLASS-METHODS class_constructor .
    METHODS constructor
      IMPORTING
        !o_file TYPE to_file .
    METHODS load_from_file
      IMPORTING
        !o_file TYPE to_file OPTIONAL
      RAISING
        zaplink_cx_container .
    METHODS load_from_xml
      IMPORTING
        !xml TYPE string
      RAISING
        zaplink_cx_container .
    METHODS transport_to_sap
      IMPORTING
        !object_list TYPE to_list
      RAISING
        zaplink_cx_container .
    METHODS get_content
      RETURNING
        VALUE(result) TYPE to_list
      RAISING
        zaplink_cx_container .
    METHODS get_options
      RETURNING
        VALUE(result) TYPE to_options
      RAISING
        zaplink_cx_container .
    METHODS uninstall_from_sap
      IMPORTING
        !object_list TYPE to_list
      RAISING
        zaplink_cx_container .
    METHODS set_options
      IMPORTING
        !data TYPE to_options
      RAISING
        zaplink_cx_container .
  PROTECTED SECTION.
    TYPES:
      BEGIN OF ts_nodeindex,
        key  TYPE REF TO zaplink_component,
        node TYPE REF TO if_ixml_node,
      END OF ts_nodeindex .
    TYPES:
      tt_nodeindex TYPE SORTED TABLE OF ts_nodeindex WITH UNIQUE KEY key .
    TYPES to_connector TYPE REF TO zaplink_connector .
    DATA xmldata TYPE REF TO if_ixml_document .
    DATA _options TYPE to_options .
    CLASS-DATA xmlengine TYPE REF TO if_ixml .
    DATA _complist TYPE to_list .
    DATA _nodeindex TYPE tt_nodeindex .
    METHODS _find_component_node
      IMPORTING
        !component  TYPE to_component
        !sub_comp   TYPE to_component OPTIONAL
      RETURNING
        VALUE(node) TYPE REF TO if_ixml_node
      RAISING
        zaplink_cx_container .
    METHODS _update_componentslist
      RAISING
        zaplink_cx_container .
    METHODS get_root
      RETURNING
        VALUE(root) TYPE REF TO if_ixml_node .
    METHODS _is_subcomponent
      IMPORTING
        !node         TYPE REF TO if_ixml_node
      RETURNING
        VALUE(result) TYPE abap_bool .
    METHODS _search_components
      IMPORTING
        !node TYPE REF TO if_ixml_node
      RAISING
        zaplink_cx_container .
    METHODS _add_to_componentslist
      IMPORTING
        !node TYPE REF TO if_ixml_node
      RAISING
        zaplink_cx_container .
    METHODS _uninstall_component
      IMPORTING
        !component TYPE to_component
      RAISING
        zaplink_cx_container .
  PRIVATE SECTION.
    CLASS-DATA o_mycx TYPE to_exception .
    DATA o_cursor TYPE REF TO if_ixml_node .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_CONTAINER_4INST definition
CLASS zaplink_dependencies_analyser DEFINITION
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS sana .
    TYPE-POOLS seop .
    INTERFACES zaplink_datatypes .
    INTERFACES zaplink_kernel_types .
    ALIASES td_abapsource
      FOR zaplink_datatypes~td_abapsource .
    ALIASES td_devclass
      FOR zaplink_datatypes~td_devclass .
    ALIASES td_progname
      FOR zaplink_datatypes~td_progname .
    ALIASES td_softcomp
      FOR zaplink_datatypes~td_softcomp .
    ALIASES td_transport_kind
      FOR zaplink_datatypes~td_transport_kind .
    ALIASES ts_compkey
      FOR zaplink_datatypes~ts_compkey .
    ALIASES tt_abaprawsource
      FOR zaplink_datatypes~tt_abaprawsource .
    ALIASES tt_txtp_textpools
      FOR zaplink_datatypes~tt_txtp_textpools .
    TYPES td_origin TYPE td_progname .
    TYPES td_classtype TYPE char01 .
    TYPES td_classcat TYPE seocategry .
    TYPES td_context TYPE string .
    TYPES:
      tr_packages TYPE RANGE OF tdevc-devclass .
    TYPES:
      tr_dlvunit TYPE RANGE OF tdevc-dlvunit .
    TYPES td_name TYPE seoclsname .
    TYPES:
      BEGIN OF ts_source,
        name  TYPE td_name,
        type  TYPE td_classtype,    " 0 Class 1 interface
        def   TYPE tt_abaprawsource,
        macro TYPE tt_abaprawsource,
        impl  TYPE tt_abaprawsource,
      END OF ts_source .
    TYPES:
      tt_sources TYPE SORTED TABLE OF ts_source WITH UNIQUE KEY name .
    TYPES:
      BEGIN OF ts_list,
        name TYPE td_name,
      END OF ts_list .
    TYPES:
      BEGIN OF ts_req_object,
        ori_name TYPE td_name,
        name     TYPE td_name,
        type     TYPE td_classtype,    " 0 Class 1 interface
        full_def TYPE flag,          " Full definition required
        source   TYPE td_context,
      END OF ts_req_object .
    TYPES:
      tt_req_objects TYPE STANDARD TABLE OF ts_req_object WITH NON-UNIQUE KEY name .
    TYPES:
      BEGIN OF ts_order.
        INCLUDE TYPE ts_list.
    TYPES:
      type    TYPE td_classtype,    " 0 Class 1 interface
      defered TYPE flag,          " 'X' if defered load required
      END OF ts_order .
    TYPES:
      tt_list TYPE STANDARD TABLE OF ts_order WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_context,
        context  TYPE td_context,
        type     TYPE td_classtype,    " 0 Class 1 interface
        full_def TYPE flag,          " Full definition required
      END OF ts_context .
    TYPES:
      tt_context TYPE STANDARD TABLE OF ts_context WITH DEFAULT KEY .
    TYPES:
      tt_order TYPE STANDARD TABLE OF ts_order WITH NON-UNIQUE KEY name .
    TYPES:
      BEGIN OF ts_typegroup,
        name TYPE seotpuname,
      END OF ts_typegroup .
    TYPES:
      tt_typegroups TYPE STANDARD TABLE OF ts_typegroup WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_comp.
        INCLUDE TYPE ts_compkey AS hdr.
    TYPES:
      kind     TYPE td_transport_kind,
      devclass TYPE td_devclass,
      softcomp TYPE td_softcomp,
      END OF ts_comp .
    TYPES:
      tt_comps TYPE SORTED TABLE OF ts_comp WITH UNIQUE KEY type name .
    TYPES td_message TYPE seoclassdf-msg_id .
    TYPES:
      BEGIN OF ts_message,
        name TYPE td_message,
      END OF ts_message .
    TYPES:
      tt_message_ids TYPE STANDARD TABLE OF ts_message WITH DEFAULT KEY .
    DATA classes TYPE tt_sources READ-ONLY .
    DATA order TYPE tt_order READ-ONLY .
    CONSTANTS:
      BEGIN OF typetype,
        like  TYPE seotyptype VALUE '0', "#EC NOTEXT      Attribute reference (LIKE)
        type  TYPE seotyptype VALUE '1', "#EC NOTEXT      Type reference (TYPE)
        otype TYPE seotyptype VALUE '2', "#EC NOTEXT      Object (TYPE)
        ref   TYPE seotyptype VALUE '3', "#EC NOTEXT      Object reference (TYPE REF TO)
        code  TYPE seotyptype VALUE '4',    "#EC NOTEXT      See coding
      END OF typetype .
    CONSTANTS:
      BEGIN OF objtype,
        class           TYPE td_classtype VALUE '0', "#EC NOTEXT      Object Type : Class
        exception_class TYPE td_classtype VALUE '5', "#EC NOTEXT      Local Object type : Exception_Class
        interface       TYPE td_classtype VALUE '1', "#EC NOTEXT      Object Type : Interface
      END OF objtype .
    CONSTANTS:
      BEGIN OF objcat,
        class      TYPE td_classcat VALUE '00',             "#EC NOTEXT
        exit       TYPE td_classcat VALUE '01',             "#EC NOTEXT
        test       TYPE td_classcat VALUE '05',             "#EC NOTEXT
        persistent TYPE td_classcat VALUE '10',             "#EC NOTEXT
        factory    TYPE td_classcat VALUE '11',             "#EC NOTEXT
        proxy      TYPE td_classcat VALUE '30',             "#EC NOTEXT
        exception  TYPE td_classcat VALUE '40',             "#EC NOTEXT
        bsp        TYPE td_classcat VALUE '60',             "#EC NOTEXT
      END OF objcat .
    DATA typegroups TYPE tt_typegroups .
    CLASS-DATA softcomponents TYPE tr_dlvunit READ-ONLY .
    DATA includes TYPE tt_abaprawsource .
    DATA packages TYPE tr_packages .
    DATA messages TYPE tt_message_ids READ-ONLY .
    DATA new_order TYPE tt_order .
    DATA remain_classes TYPE tt_sources .
    DATA all_components TYPE tt_comps READ-ONLY .
    DATA textspool TYPE tt_txtp_textpools READ-ONLY .
    METHODS add_object
      IMPORTING
        !name TYPE td_name
      RAISING
        zaplink_cx .
    METHODS add_source
      IMPORTING
        !code   TYPE tt_abaprawsource
        !origin TYPE td_origin OPTIONAL
      RAISING
        zaplink_cx .
    METHODS add_without_requirements
      RETURNING
        VALUE(result) TYPE abap_bool .
    CLASS-METHODS class_constructor .
    CLASS-METHODS get_source
      IMPORTING
        !name        TYPE td_name
      RETURNING
        VALUE(codes) TYPE ts_source
      RAISING
        zaplink_cx .
    METHODS resolve .
    METHODS set_textpool
      IMPORTING
        !name TYPE td_progname
      RAISING
        zaplink_cx .
    CLASS-METHODS source_2_string
      IMPORTING
        !data         TYPE tt_abaprawsource
      RETURNING
        VALUE(result) TYPE string .
  PROTECTED SECTION.
    ALIASES line_separator
      FOR zaplink_datatypes~line_separator .
    ALIASES td_compname
      FOR zaplink_datatypes~td_compname .
    ALIASES td_comptype
      FOR zaplink_datatypes~td_comptype .
    ALIASES to_component
      FOR zaplink_kernel_types~to_component .
    ALIASES to_raw
      FOR zaplink_kernel_types~to_raw .
    ALIASES ts_comptype
      FOR zaplink_datatypes~ts_comptype .
    TYPES:
      tt_classlist TYPE SORTED TABLE OF ts_list WITH UNIQUE KEY name .
    TYPES to_class TYPE REF TO zaplink_clas_data .
    TYPES to_object TYPE REF TO zaplink_object .
    TYPES to_interface TYPE REF TO zaplink_intf_data .
    TYPES to_exception TYPE REF TO zaplink_cx .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    DATA deferred_declaration TYPE tt_classlist .
    METHODS add_attributs
      IMPORTING
        !attributs TYPE zaplink_object_data=>tt_attributs
        !origin    TYPE td_origin
      RAISING
        zaplink_cx .
    METHODS add_class_dep
      IMPORTING
        !name TYPE td_name
        !full TYPE abap_bool DEFAULT abap_false
      RAISING
        zaplink_cx .
    METHODS add_deferred_code
      IMPORTING
        !type     TYPE td_classtype
        !name     TYPE td_name
      CHANGING
        !abapcode TYPE tt_abaprawsource .
    METHODS add_deferred_ok
      RETURNING
        VALUE(result) TYPE abap_bool .
    METHODS add_include
      IMPORTING
        !name TYPE td_progname .
    METHODS add_interfaces
      IMPORTING
        !interfaces TYPE zaplink_object_data=>tt_interfaces
      RAISING
        zaplink_cx .
    METHODS add_interface_dep
      IMPORTING
        !name TYPE td_name
        !full TYPE abap_bool DEFAULT abap_false
      RAISING
        zaplink_cx .
    METHODS add_methods
      IMPORTING
        !methods TYPE zaplink_object_data=>tt_methods
        !origin  TYPE td_origin OPTIONAL
      RAISING
        zaplink_cx .
    METHODS add_method_source
      IMPORTING
        !code   TYPE td_abapsource
        !origin TYPE td_origin
      RAISING
        zaplink_cx .
    METHODS add_object_to_list
      IMPORTING
        !name     TYPE td_name
        !full     TYPE abap_bool DEFAULT abap_false
        !position TYPE td_context
      RAISING
        zaplink_cx .
    METHODS add_prog_textpool
      IMPORTING
        !name TYPE td_progname .
    METHODS add_types
      IMPORTING
        !types  TYPE zaplink_object_data=>tt_types
        !origin TYPE td_origin
      RAISING
        zaplink_cx .
    METHODS analyse_source
      IMPORTING
        !code               TYPE td_abapsource
        !origin             TYPE td_origin
      RETURNING
        VALUE(objects_list) TYPE tt_abaprawsource .
    METHODS append_message
      IMPORTING
        !data TYPE td_message .
    METHODS append_typegroups
      IMPORTING
        !typegroups TYPE zaplink_object_data=>tt_typegroups .
    CLASS-METHODS convert_line
      IMPORTING
        !source       TYPE string
      RETURNING
        VALUE(target) TYPE string .
    CLASS-METHODS convert_source_upcase
      IMPORTING
        !sourcecode       TYPE tt_abaprawsource
      RETURNING
        VALUE(targetcode) TYPE tt_abaprawsource .
    CLASS-METHODS extract_strings
      IMPORTING
        !forward       TYPE flag OPTIONAL
        !search_term   TYPE string
        !code          TYPE string
          PREFERRED PARAMETER forward
      RETURNING
        VALUE(results) TYPE tt_abaprawsource .
    CLASS-METHODS get_class_source
      IMPORTING
        !name        TYPE td_name
      RETURNING
        VALUE(codes) TYPE ts_source .
    CLASS-METHODS get_interface_source
      IMPORTING
        !name        TYPE td_name
      RETURNING
        VALUE(codes) TYPE ts_source .
    METHODS handle_context
      RAISING
        zaplink_cx .
    CLASS-METHODS inverse_order
      CHANGING
        !order TYPE STANDARD TABLE .
    METHODS is_excluded_class
      IMPORTING
        !name         TYPE td_name
        !type         TYPE tadir-object OPTIONAL
      RETURNING
        VALUE(result) TYPE abap_bool .
    METHODS is_excluded_include
      IMPORTING
        !name         TYPE td_name
      RETURNING
        VALUE(result) TYPE abap_bool
      RAISING
        zaplink_cx .
    CLASS-METHODS is_predeftype
      IMPORTING
        !name         TYPE td_name
      RETURNING
        VALUE(result) TYPE abap_bool
      RAISING
        zaplink_cx .
    METHODS process_type
      IMPORTING
        !type   TYPE seotyptype
        !origin TYPE td_origin OPTIONAL
        !name   TYPE rs38l_typ
        !source TYPE string OPTIONAL
      RAISING
        zaplink_cx .
    CLASS-METHODS remove_def_load
      CHANGING
        !codes TYPE ts_source .
    METHODS search_for_include
      CHANGING
        !codes TYPE ts_source
      RAISING
        zaplink_cx .
    METHODS stack
      IMPORTING
        !context TYPE any
        !type    TYPE td_classtype OPTIONAL
        !full    TYPE abap_bool DEFAULT abap_false .
    METHODS unstack .
    METHODS _clean_up .
  PRIVATE SECTION.
    TYPES:
      tt_predeftypes TYPE HASHED TABLE OF sana_type_struct WITH UNIQUE KEY name .
    CLASS-DATA o_object TYPE to_object .
    DATA context TYPE tt_context .
    DATA circular_ref_on TYPE td_name .
    DATA circular_context TYPE tt_context .
    DATA required_objects TYPE tt_req_objects .
    DATA current_comp TYPE td_name .
    DATA excluded_includes TYPE tt_classlist .
    DATA excluded_classes TYPE tt_classlist .
    DATA requirements TYPE tt_req_objects .
    DATA s_comp TYPE ts_comp .
    CLASS-DATA c_class TYPE ts_comptype .
    CLASS-DATA c_interface TYPE ts_comptype .
    CLASS-DATA c_program TYPE ts_comptype .
    CLASS-DATA c_msg_class TYPE ts_comptype .
    CLASS-DATA c_typegroup TYPE ts_comptype .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
    CLASS-DATA predeftypes TYPE tt_predeftypes .
    DATA current_origin TYPE td_origin .
    DATA remain_requirements TYPE tt_req_objects .
    METHODS add_source_to_list
      IMPORTING
        !code     TYPE td_abapsource
        !origin   TYPE td_origin
        !position TYPE td_context
        !full     TYPE abap_bool DEFAULT abap_false
      RAISING
        zaplink_cx .
    METHODS do_class
      IMPORTING
        !name TYPE td_name
      RAISING
        zaplink_cx .
    METHODS do_object_list
      IMPORTING
        !name TYPE td_name
      RAISING
        zaplink_cx .
    METHODS insert_order
      IMPORTING
        !s_order       TYPE ts_order
        VALUE(context) TYPE tt_context .
ENDCLASS. "ZAPLINK_DEPENDENCIES_ANALYSER definition
CLASS zaplink_easyxml_4cnx DEFINITION
  INHERITING FROM zaplink_easyxml
  CREATE PUBLIC .
  PUBLIC SECTION.
  PROTECTED SECTION.
    METHODS read_object
        REDEFINITION .
  PRIVATE SECTION.
    TYPES to_raw_base TYPE REF TO zaplink_raw_base .
    TYPES to_connector TYPE REF TO zaplink_connector .
    TYPES to_raw TYPE REF TO zaplink_raw .
ENDCLASS. "ZAPLINK_EASYXML_4CNX definition
CLASS zaplink_enhancement DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC
  FRIENDS zaplink_enhancement_data .
  PUBLIC SECTION.
    TYPE-POOLS seex .
    ALIASES tt_ltexts
      FOR zaplink_datatypes~tt_ltexts .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_ENHENCEMENT'. "#EC NOTEXT
    CONSTANTS st_comp_enh_impl TYPE td_comptype VALUE 'ENHC'. "#EC NOTEXT
    CONSTANTS st_comp_enh_spot TYPE td_comptype VALUE 'ENSC'. "#EC NOTEXT
    CONSTANTS st_enh_impl TYPE td_comptype VALUE 'ENHO'.    "#EC NOTEXT
    CONSTANTS st_enh_spot TYPE td_comptype VALUE 'ENHS'.    "#EC NOTEXT
    CONSTANTS:
      BEGIN OF tooltypes,
        badi           TYPE enhheader-enhtooltype VALUE 'BADI_IMPL',
        class          TYPE enhheader-enhtooltype VALUE 'CLASENH',
        function_group TYPE enhheader-enhtooltype VALUE 'FUGRENH',
        interface      TYPE enhheader-enhtooltype VALUE 'INTFENH',
        hook           TYPE enhheader-enhtooltype VALUE 'HOOK_IMPL',
        web_dynpro     TYPE enhheader-enhtooltype VALUE 'WDYENH',
      END OF tooltypes .
    CLASS-METHODS class_constructor .
    METHODS constructor .
    CLASS-METHODS create_sotr_id
      RETURNING
        VALUE(result) TYPE zaplink_enhancement_data=>td_sotr_concept .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES td_sotr_concept TYPE sotr_text-concept .
    TYPES:
      BEGIN OF ts_sotr,
        short TYPE td_sotr_concept,
        long  TYPE td_sotr_concept,
      END OF ts_sotr .
    METHODS set_sotr
      IMPORTING
        !sotr  TYPE ts_sotr
        !texts TYPE tt_ltexts .
  PRIVATE SECTION.
    TYPES td_comp_enh_spot_name TYPE enhspotcompositename .
    TYPES td_enh_impl_name TYPE enhname .
    TYPES td_comp_enh_impl_name TYPE enhcompositename .
    TYPES td_enh_spot_name TYPE enhspotname .
    TYPES to_comp_enh_spot TYPE REF TO zaplink_ensc_data .
    TYPES to_comp_enh_spot_sap TYPE REF TO cl_enh_spot_composite .
    TYPES to_enh_spot TYPE REF TO zaplink_enhs_data .
    TYPES to_enh_spot_sap TYPE REF TO if_enh_spot_tool .
    TYPES to_enh_impl TYPE REF TO zaplink_enho_data .
    TYPES to_enh_impl_sap TYPE REF TO cl_abstract_enh_tool .
    TYPES to_enhancement_sap TYPE REF TO if_enh_object .
    TYPES to_comp_enh_impl TYPE REF TO zaplink_enhc_data .
    TYPES to_comp_enh_impl_sap TYPE REF TO cl_enh_composite .
    CLASS-DATA r_doc_id_definition TYPE tr_docid .
    CLASS-DATA r_doc_id_implementation TYPE tr_docid .
    CONSTANTS _uuid TYPE td_connuuid VALUE '4181014E2AC27D33E1000000AC1201D6'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '0.0'.             "#EC NOTEXT
    METHODS reverse_raw
      IMPORTING
        !off_sub_components TYPE td_with_subcomp OPTIONAL
        !components_list    TYPE to_list
        !raw_object         TYPE to_raw_data
        !name               TYPE td_compname
      RETURNING
        VALUE(sap_object)   TYPE to_enhancement_sap .
    METHODS reverse_comp_enh_spot
      IMPORTING
        !off_sub_components TYPE td_with_subcomp OPTIONAL
        !components_list    TYPE to_list
        !raw_object         TYPE to_comp_enh_spot
      RETURNING
        VALUE(sap_object)   TYPE to_comp_enh_spot_sap .
    METHODS reverse_enh_spot
      IMPORTING
        !off_sub_components TYPE td_with_subcomp OPTIONAL
        !components_list    TYPE to_list
        !raw_object         TYPE to_enh_spot
      RETURNING
        VALUE(sap_object)   TYPE to_enh_spot_sap .
    METHODS reverse_comp_enh_impl
      IMPORTING
        !off_sub_components TYPE td_with_subcomp OPTIONAL
        !components_list    TYPE to_list
        !raw_object         TYPE to_comp_enh_impl
      RETURNING
        VALUE(sap_object)   TYPE to_comp_enh_impl_sap .
    METHODS reverse_enh_impl
      IMPORTING
        !off_sub_components TYPE td_with_subcomp OPTIONAL
        !components_list    TYPE to_list
        !raw_object         TYPE to_enh_impl
      RETURNING
        VALUE(sap_object)   TYPE to_enh_impl_sap .
    METHODS convert_enhancement
      IMPORTING
        !sub_components   TYPE td_with_subcomp
        VALUE(sap_object) TYPE to_enhancement_sap
        !components_list  TYPE to_list
      RETURNING
        VALUE(raw_object) TYPE to_raw_data .
    METHODS convert_comp_enh_spot
      IMPORTING
        !sub_components   TYPE td_with_subcomp
        VALUE(sap_object) TYPE to_comp_enh_spot_sap
        !components_list  TYPE to_list
      RETURNING
        VALUE(raw_object) TYPE to_comp_enh_spot .
    METHODS convert_enh_spot
      IMPORTING
        !sub_components   TYPE td_with_subcomp
        VALUE(sap_object) TYPE to_enh_spot_sap
        !components_list  TYPE to_list
      RETURNING
        VALUE(raw_object) TYPE to_enh_spot .
    METHODS convert_comp_enh_impl
      IMPORTING
        !sub_components   TYPE td_with_subcomp
        VALUE(sap_object) TYPE to_comp_enh_impl_sap
        !components_list  TYPE to_list
      RETURNING
        VALUE(raw_object) TYPE to_comp_enh_impl .
    METHODS convert_enh_impl
      IMPORTING
        !sub_components   TYPE td_with_subcomp
        VALUE(sap_object) TYPE to_enh_impl_sap
        !components_list  TYPE to_list
      RETURNING
        VALUE(raw_object) TYPE to_enh_impl .
    METHODS off_export_from_enhancement
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_raw
      RAISING
        zaplink_cx_connector .
    METHODS off_export_from_comp_enh_spot
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_comp_enh_spot
      RAISING
        zaplink_cx_connector .
    METHODS off_export_from_enh_spot
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_enh_spot
      RAISING
        zaplink_cx_connector .
    METHODS off_export_from_comp_enh_impl
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_comp_enh_impl
      RAISING
        zaplink_cx_connector .
    METHODS off_export_from_enh_impl
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_enh_impl
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS get_version
      IMPORTING
        !enhancement   TYPE REF TO if_enh_object
      RETURNING
        VALUE(version) TYPE r3state .
    METHODS import_to_comp_enh_spot
      IMPORTING
        !o_data           TYPE to_comp_enh_spot
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS load_comp_enh_spot
      IMPORTING
        !component    TYPE to_component
        !locking      TYPE enhboolean OPTIONAL
      RETURNING
        VALUE(object) TYPE to_comp_enh_spot_sap .
    METHODS load_enh_spot
      IMPORTING
        !component    TYPE to_component
        !locking      TYPE enhboolean OPTIONAL
      RETURNING
        VALUE(object) TYPE to_enh_spot_sap .
    METHODS load_enh_impl
      IMPORTING
        !component    TYPE to_component
        !locking      TYPE enhboolean OPTIONAL
      RETURNING
        VALUE(object) TYPE to_enh_impl_sap .
    METHODS load_comp_enh_impl
      IMPORTING
        !component    TYPE to_component
        !locking      TYPE enhboolean OPTIONAL
      RETURNING
        VALUE(object) TYPE to_comp_enh_impl_sap
      RAISING
        zaplink_cx_connector .
    METHODS _load_enh_spot
      IMPORTING
        !name         TYPE td_enh_spot_name
        !locking      TYPE enhboolean OPTIONAL
      RETURNING
        VALUE(object) TYPE to_enh_spot_sap .
    METHODS _load_comp_enh_spot
      IMPORTING
        !name         TYPE td_comp_enh_spot_name
        !locking      TYPE enhboolean OPTIONAL
      RETURNING
        VALUE(object) TYPE to_comp_enh_spot_sap
      RAISING
        zaplink_cx_connector .
    METHODS _load_enh_impl
      IMPORTING
        !name         TYPE td_enh_impl_name
        !locking      TYPE enhboolean OPTIONAL
      RETURNING
        VALUE(object) TYPE to_enh_impl_sap .
    METHODS _load_comp_enh_impl
      IMPORTING
        !name         TYPE td_comp_enh_impl_name
        !locking      TYPE enhboolean OPTIONAL
      RETURNING
        VALUE(object) TYPE to_comp_enh_impl_sap .
    METHODS load_enhancement
      IMPORTING
        !component    TYPE to_component
        !locking      TYPE enhboolean OPTIONAL
      RETURNING
        VALUE(object) TYPE to_enhancement_sap
      RAISING
        zaplink_cx_connector .
    METHODS _enh_spot_exists
      IMPORTING
        !name         TYPE td_enh_spot_name
      RETURNING
        VALUE(exists) TYPE td_compexists .
    METHODS _comp_enh_spot_exists
      IMPORTING
        !name         TYPE td_comp_enh_spot_name
      RETURNING
        VALUE(exists) TYPE td_compexists .
    METHODS _enh_impl_exists
      IMPORTING
        !name         TYPE td_enh_impl_name
      RETURNING
        VALUE(exists) TYPE td_compexists .
    METHODS _comp_enh_impl_exists
      IMPORTING
        !name         TYPE td_comp_enh_impl_name
      RETURNING
        VALUE(exists) TYPE td_compexists .
ENDCLASS. "ZAPLINK_ENHANCEMENT definition
CLASS zaplink_enhc_data DEFINITION
  INHERITING FROM zaplink_enhancement_data
  CREATE PROTECTED
  FRIENDS zaplink_easyxml
                 zaplink_enhancement .
  PUBLIC SECTION.
    TYPES:
      BEGIN OF ts_header.
        INCLUDE TYPE enhcompheader AS main.
    TYPES:
      texts TYPE tt_ltexts,
      END OF ts_header .
    TYPES:
      BEGIN OF ts_comp_enh,
        name      TYPE enhcompositename,
        zl_object TYPE to_raw,
      END OF ts_comp_enh .
    TYPES:
      tt_comp_enh TYPE STANDARD TABLE OF ts_comp_enh WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_enh,
        name      TYPE enhcompositename,
        zl_object TYPE to_raw,
      END OF ts_enh .
    TYPES:
      tt_enh TYPE STANDARD TABLE OF ts_enh WITH DEFAULT KEY .
    TYPES to_comp_enh TYPE REF TO cl_enh_spot_composite .
    TYPES:
      BEGIN OF ts_fm_data,
        header   TYPE enhcompheader,
        comp_enh TYPE enhcompositename_it,
        enh      TYPE enhname_it,
      END OF ts_fm_data .
    DATA a0_maindata TYPE ts_header .
    DATA enhancement_implementations TYPE tt_enh .
    DATA composit_enh_implementations TYPE tt_comp_enh .
    METHODS from_data
      IMPORTING
        !data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(data) TYPE ts_fm_data .
    METHODS zaplink_cnx_ext_cleaner_4data~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner_4data~unanonymize
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_ENHC_DATA definition
CLASS zaplink_enho_data DEFINITION
  INHERITING FROM zaplink_enhancement_data
  CREATE PROTECTED
  FRIENDS zaplink_easyxml
                 zaplink_enhancement .
  PUBLIC SECTION.
    TYPES:
      BEGIN OF ts_meth_src,
        name     TYPE seocpdname,
        redefine TYPE td_checkbox,
        source   TYPE ts_sourceasstruc,
      END OF ts_meth_src .
    TYPES:
      tt_meth_src TYPE SORTED TABLE OF ts_meth_src WITH UNIQUE KEY name .
    TYPES:
      BEGIN OF ts_event.
        INCLUDE TYPE enhclassevent AS hdr.
    TYPES:
      parameters TYPE enheventtabparam,
      END OF ts_event .
    TYPES:
      tt_events TYPE SORTED TABLE OF ts_event WITH UNIQUE KEY cmpname .
    TYPES:
      BEGIN OF ts_clif_impl,
        name                  TYPE seoclsname,
        attributes            TYPE enhclasstabattrib,
        methodes              TYPE enhmethtab,
        pre_methodes          TYPE enhmeth_tabkeys,
        post_methodes         TYPE enhmeth_tabkeys,
        save_enhincinx        TYPE enhincinx_it,
        new_methodes          TYPE enhnewmeth_tab,
        sources               TYPE tt_meth_src,
        methodes_includes     TYPE enhnewmeth_tabincl,
        events                TYPE tt_events,     " enhevent_tab,
        implementings         TYPE enhclasstabimplementing,
        overwrite_methodes    TYPE enhmeth_tabkeys,
        types                 TYPE enhtype_tab,
        implementation_source TYPE ts_sourceasstruc,
        access_pri_pro        TYPE td_checkbox,
      END OF ts_clif_impl .
    TYPES:
      BEGIN OF ts_header_add,
        type      TYPE enhheader-type,
        tool_type TYPE enhheader-enhtooltype,
        upgrade   TYPE enhheader-upgrade,
      END OF ts_header_add .
    TYPES:
      BEGIN OF ts_fm_hdr.
        INCLUDE TYPE enh_dy_spot AS scr.
    TYPES:
      hdr      TYPE enhheader,
      text_ids TYPE ts_sotr,
      END OF ts_fm_hdr .
    TYPES:
      BEGIN OF ts_header.
        INCLUDE TYPE enh_dy_spot AS scr.
        INCLUDE TYPE ts_header_add AS add.
    TYPES:
      texts TYPE tt_ltexts,
      END OF ts_header .
    TYPES:
      BEGIN OF ts_comp_enh_spot,
        name      TYPE enhspotcompositename,
        zl_object TYPE to_raw,
      END OF ts_comp_enh_spot .
    TYPES to_comp_enh TYPE REF TO cl_enh_spot_composite .
    TYPES:
      BEGIN OF ts_hook,   " both data from CL_ENH_TOOL_HOOK_IMPL
        admin TYPE enh_hook_admin,
        enh   TYPE enhincinx_it,
      END OF ts_hook .
    TYPES:
      BEGIN OF ts_hook_impl.
        INCLUDE TYPE enh_hook_admin AS main.
    TYPES:
      texts       TYPE tt_ltexts,
      enhancement TYPE enhincinx_it,
      END OF ts_hook_impl .
    TYPES:
      tt_hook_impls TYPE SORTED TABLE OF ts_hook_impl WITH UNIQUE KEY org_obj_type org_obj_name .
    TYPES:
      BEGIN OF ts_badi,   " both data from CL_ENH_TOOL_BADI_IMPL
        admin TYPE enh_badi_main,
        enh   TYPE enh_badi_impl_it,
      END OF ts_badi .
    TYPES:
      BEGIN OF ts_badi_impl.
        INCLUDE TYPE enh_badi_impl_data AS main.
    TYPES:
      texts TYPE tt_ltexts,
      END OF ts_badi_impl .
    TYPES:
      tt_badi_impls TYPE SORTED TABLE OF ts_badi_impl WITH UNIQUE KEY badi_name impl_name .
    TYPES:
      BEGIN OF ts_fm_data,
        header    TYPE ts_fm_hdr,
        badi_impl TYPE ts_badi,
        fugr_impl TYPE enhfugrdata,
        clif_impl TYPE enhclassmethdata,
        wdyn_impl TYPE enhwdyn,
        hook_impl TYPE ts_hook,
      END OF ts_fm_data .
    DATA a0_maindata TYPE ts_header READ-ONLY .
    DATA badi_implementations TYPE tt_badi_impls READ-ONLY .
    DATA hook_implementations TYPE tt_hook_impls READ-ONLY .
    DATA function_group_implementation TYPE enhfugrdata READ-ONLY .
    DATA class_implementation TYPE ts_clif_impl READ-ONLY .
    DATA interface_implementation TYPE ts_clif_impl READ-ONLY .
    DATA web_dynpro_implementation TYPE enhwdyn READ-ONLY .
    METHODS from_data
      IMPORTING
        !data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS zaplink_cnx_ext_cleaner_4data~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner_4data~unanonymize
        REDEFINITION .
  PROTECTED SECTION.
    METHODS clif_sap2int
      IMPORTING
        !sap_data       TYPE enhclassmethdata
      RETURNING
        VALUE(int_data) TYPE ts_clif_impl .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_ENHO_DATA definition
CLASS zaplink_enhs_data DEFINITION
  INHERITING FROM zaplink_enhancement_data
  CREATE PROTECTED
  FRIENDS zaplink_easyxml
                 zaplink_enhancement .
  PUBLIC SECTION.
    TYPES:
      BEGIN OF ts_badi_def_main,
        badi_name          TYPE enh_badi_data-badi_name,
        interface_name     TYPE enh_badi_data-interface_name,
        single_use         TYPE enh_badi_data-single_use,
        context_mode       TYPE enh_badi_data-context_mode,
        sorter_badi        TYPE enh_badi_data-sorter_badi,
        default_class      TYPE enh_badi_data-default_class,
        mig_from_badi      TYPE enh_badi_data-mig_from_badi,
        img_docu_id        TYPE enh_badi_data-img_docu_id,
        use_fallback_class TYPE enh_badi_data-use_fallback_class,
        filter_limitation  TYPE enh_badi_data-filter_limitation,
        exception_expected TYPE enh_badi_data-exception_expected,
      END OF ts_badi_def_main .
    TYPES:
      BEGIN OF ts_filter_main,
        filter_name       TYPE enh_badi_filter-filter_name,
        filter_type       TYPE enh_badi_filter-filter_type,
        constant          TYPE enh_badi_filter-constant,
        check_type        TYPE enh_badi_filter-check_type,
        check_type_is_dom TYPE enh_badi_filter-check_type_is_dom,
        check_class       TYPE enh_badi_filter-check_class,
        check_length      TYPE enh_badi_filter-check_length,
        check_decs        TYPE enh_badi_filter-check_decs,
      END OF ts_filter_main .
    TYPES:
      BEGIN OF ts_filter_def.
        INCLUDE TYPE ts_filter_main AS main.
    TYPES:
      texts TYPE tt_ltexts,
      END OF ts_filter_def .
    TYPES:
      tt_filter_defs TYPE SORTED TABLE OF ts_filter_def WITH UNIQUE KEY filter_name .
    TYPES:
      BEGIN OF ts_badi_def.
        INCLUDE TYPE ts_badi_def_main AS main.
    TYPES:
      texts   TYPE tt_ltexts,
      filters TYPE tt_filter_defs,
      END OF ts_badi_def .
    TYPES:
      tt_badi_defs TYPE SORTED TABLE OF ts_badi_def WITH UNIQUE KEY badi_name .
    TYPES:
      BEGIN OF ts_get_language,
        language TYPE  spras,
      END OF ts_get_language .
    TYPES:
      BEGIN OF ts_get_attributes,
        author    TYPE  cnam,
        createdon TYPE  rdir_cdate,
        changedby TYPE  unam,
        changedon TYPE  rdir_udate,
      END OF ts_get_attributes .
    TYPES:
      BEGIN OF ts_enhspotcomphead,
        name         TYPE enhspotcompositename,
        version      TYPE r3state,
        comp_type    TYPE enhspotcomptype,
        tool_type    TYPE enhspottooltype,
        composite    TYPE enhspotcompositename,
        internal_use TYPE enh_dy_spot-internal_use.
        INCLUDE TYPE ts_get_language AS lang.
        INCLUDE TYPE ts_get_attributes AS attrs.
    TYPES:
      END OF ts_enhspotcomphead .
    TYPES:
      BEGIN OF ts_header.
        INCLUDE TYPE ts_enhspotcomphead AS main.
    TYPES:
      texts TYPE tt_ltexts,
      END OF ts_header .
    TYPES:
      BEGIN OF ts_fm_data,
        header   TYPE ts_enhspotcomphead,
        texts    TYPE tt_ltexts,
        def_data TYPE enh_badi_data_it,
      END OF ts_fm_data .
    DATA a0_maindata TYPE ts_header READ-ONLY .
    DATA badi_definitions TYPE tt_badi_defs READ-ONLY .
    METHODS from_data
      IMPORTING
        !data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(data) TYPE ts_fm_data .
    METHODS zaplink_cnx_ext_cleaner_4data~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner_4data~unanonymize
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_ENHS_DATA definition
CLASS zaplink_ensc_data DEFINITION
  INHERITING FROM zaplink_enhancement_data
  CREATE PROTECTED
  FRIENDS zaplink_easyxml
                 zaplink_enhancement .
  PUBLIC SECTION.
    TYPE-POOLS seex .
    TYPES:
      BEGIN OF ts_header.
        INCLUDE TYPE enhspotcomphead AS main.
    TYPES:
      texts TYPE tt_ltexts,
      END OF ts_header .
    TYPES:
      BEGIN OF ts_comp_enh,
        name      TYPE enhspotcompositename,
        zl_object TYPE to_raw,
      END OF ts_comp_enh .
    TYPES:
      tt_comp_enh TYPE STANDARD TABLE OF ts_comp_enh WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_enh,
        name      TYPE enhspotname,
        zl_object TYPE to_raw,
      END OF ts_enh .
    TYPES:
      tt_enh TYPE STANDARD TABLE OF ts_enh WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_fm_data,
        header   TYPE enhspotcomphead,
        comp_enh TYPE enhspotcompositename_it,
        enh      TYPE enhspotname_it,
      END OF ts_fm_data .
    DATA a0_maindata TYPE ts_header READ-ONLY .
    DATA enhancements TYPE tt_enh READ-ONLY .
    DATA composit_enhancements TYPE tt_comp_enh READ-ONLY .
    METHODS zaplink_cnx_ext_cleaner_4data~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner_4data~unanonymize
        REDEFINITION .
  PROTECTED SECTION.
    METHODS from_data
      IMPORTING
        !data TYPE ts_fm_data .
    METHODS to_data
      RETURNING
        VALUE(data) TYPE ts_fm_data .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_ENSC_DATA definition
CLASS zaplink_function_group DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC
  FRIENDS zaplink_fugr_data
                 zaplink_func_data
                 zaplink_func_raw .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPES td_function_name TYPE rs38l-name .
    TYPES t_raw TYPE rswsourcet .
    TYPES:
      BEGIN OF ts_text,
        langu  TYPE spras,
        entry  TYPE textpooltx,
        length TYPE textpoolln,
      END OF ts_text .
    TYPES td_functiongroup_name TYPE tlibg-area .
    TYPES:
      tt_texts TYPE SORTED TABLE OF ts_text WITH UNIQUE KEY langu .
    TYPES:
      BEGIN OF ts_textpool,
        id    TYPE  textpoolid,
        key   TYPE  textpoolky,
        texts TYPE  tt_texts,
      END OF ts_textpool .
    TYPES:
      tt_textpools TYPE SORTED TABLE OF ts_textpool WITH UNIQUE KEY id key .
    TYPES ts_source TYPE string .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_FUNCTION_GROUP'. "#EC NOTEXT
    CLASS-METHODS class_constructor .
    METHODS constructor .
    METHODS get_group_signature
      IMPORTING
        !group_name   TYPE td_functiongroup_name
      RETURNING
        VALUE(result) TYPE zaplink_datatypes~td_checksum .
    METHODS get_function_signature
      IMPORTING
        !name         TYPE td_function_name
      RETURNING
        VALUE(result) TYPE zaplink_datatypes~td_checksum
      RAISING
        zaplink_cx_connector .
    METHODS zaplink_cnx_ext_cleaner~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner~unanonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_code_signature~get_signature
        REDEFINITION .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES to_group TYPE REF TO zaplink_fugr_data .
    TYPES to_function TYPE REF TO zaplink_func_data .
    TYPES tt_includes TYPE zaplink_fugr_data=>tt_rawincludes .
    TYPES td_includename TYPE zaplink_fugr_data=>td_includename .
    TYPES ts_fmd_fugr TYPE zaplink_fugr_data=>ts_fm_data .
    TYPES ts_fmd_func TYPE zaplink_func_data=>ts_fm_data .
    TYPES ts_include TYPE zaplink_fugr_data=>ts_rawinclude .
    CLASS-DATA:
      BEGIN OF supportedkinds,
        group    TYPE td_transport_kind,
        function TYPE td_transport_kind,
      END OF supportedkinds .
    CONSTANTS:
      BEGIN OF supportedtypes,
        group    TYPE td_comptype VALUE 'FUGR',             "#EC NOTEXT
        function TYPE td_comptype VALUE 'FUNC',             "#EC NOTEXT
      END OF supportedtypes .
    METHODS calc_function_signature
      IMPORTING
        !function     TYPE ts_fmd_func
      RETURNING
        VALUE(result) TYPE zaplink_datatypes~td_checksum .
    METHODS read_function
      IMPORTING
        !name         TYPE td_function_name
      RETURNING
        VALUE(result) TYPE ts_fmd_func
      RAISING
        zaplink_cx_connector .
    METHODS del_function
      IMPORTING
        VALUE(func) TYPE ts_fmd_func
      RAISING
        zaplink_cx_connector .
    METHODS write_function
      IMPORTING
        VALUE(func) TYPE ts_fmd_func
      RAISING
        zaplink_cx_connector .
    METHODS write_include
      IMPORTING
        VALUE(include) TYPE ts_include
        !mainprogram   TYPE trdir-name
        !area          TYPE tlibg-area
      CHANGING
        !source        TYPE tt_abaprawsource
      RAISING
        zaplink_cx_connector .
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ts_prog_attr.
        INCLUDE TYPE ts_base_attributs AS base.
    TYPES:
      END OF ts_prog_attr .
    TYPES:
      tt_rs38l_incl TYPE STANDARD TABLE OF rs38l_incl WITH DEFAULT KEY .
    TYPES to_raw_function TYPE zaplink_fugr_data=>to_function .
    CONSTANTS _uuid TYPE td_connuuid VALUE 'F1838F4B202C2806E1000000AC120173'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.0'.             "#EC NOTEXT
    CONSTANTS c_mainprog_prefix TYPE trdir-name VALUE 'SAPL'. "#EC NOTEXT
    DATA:
      BEGIN OF prev_func,
        name TYPE  td_function_name,
        data TYPE  ts_fmd_func,
      END OF prev_func .
    CLASS-METHODS get_all_includes
      IMPORTING
        !name          TYPE td_functiongroup_name
        !with_code     TYPE abap_bool OPTIONAL
      RETURNING
        VALUE(results) TYPE tt_includes .
    CLASS-METHODS get_mainprogram
      IMPORTING
        !name         TYPE rs38l-area
      RETURNING
        VALUE(result) TYPE trdir-name .
ENDCLASS. "ZAPLINK_FUNCTION_GROUP definition
CLASS zaplink_gui DEFINITION
  INHERITING FROM zaplink_tools
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS icon .
    TYPE-POOLS slis .
    INTERFACES zaplink_kernel_types .
    INTERFACES zaplink_types .
    ALIASES ballog_object
      FOR zaplink_kernel_types~ballog_object .
    ALIASES to_component
      FOR zaplink_types~to_component .
    ALIASES to_container
      FOR zaplink_types~to_container .
    ALIASES to_file
      FOR zaplink_types~to_file .
    ALIASES to_gui
      FOR zaplink_types~to_gui .
    ALIASES to_list
      FOR zaplink_types~to_list .
    ALIASES to_msg_coll
      FOR zaplink_types~to_msg_coll .
    ALIASES to_options
      FOR zaplink_types~to_options .
    ALIASES to_opt_devclass
      FOR zaplink_types~to_opt_devclass .
    ALIASES to_raw
      FOR zaplink_types~to_raw .
    TYPES to_exception TYPE REF TO zaplink_cx_gui .
    TYPES to_root_exception TYPE REF TO zaplink_cx .
    CLASS-DATA application_log TYPE to_msg_coll .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'GUI'.  "#EC NOTEXT
    CLASS-DATA o_options TYPE to_options .
    CLASS-METHODS class_constructor .
    CLASS-METHODS export
      IMPORTING
        !file         TYPE to_file
        !with_subcomp TYPE td_with_subcomp DEFAULT abap_true
      CHANGING
        !objlist      TYPE to_list
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS import
      IMPORTING
        !file            TYPE to_file
        !with_subcomp    TYPE td_with_subcomp DEFAULT abap_true
        !activate        TYPE abap_bool DEFAULT abap_false
        !activate_anyway TYPE abap_bool DEFAULT abap_false
      EXPORTING
        !name            TYPE td_contname
        !list            TYPE to_list
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS create
      IMPORTING
        !name TYPE td_contname
        !file TYPE to_file OPTIONAL
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS add_object
      IMPORTING
        !objtype      TYPE td_comptype
        !name         TYPE td_compname
        !file         TYPE to_file
        !with_subcomp TYPE td_with_subcomp DEFAULT abap_true
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS update_subobj
      IMPORTING
        !o_list TYPE to_list
        !f_sub  TYPE td_with_subcomp
      RAISING
        zaplink_cx .
    CLASS-METHODS get_objlist
      IMPORTING
        !file       TYPE to_file
      RETURNING
        VALUE(list) TYPE to_list
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS uninstall
      IMPORTING
        !file         TYPE to_file
        !with_subcomp TYPE td_with_subcomp DEFAULT abap_true
      EXPORTING
        !name         TYPE td_contname
      CHANGING
        !list         TYPE to_list
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS change_selection
      IMPORTING
        !action TYPE td_action
        !list   TYPE to_list
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS containerfile_select
      CHANGING
        !filename TYPE td_filename .
    CLASS-METHODS get_values
      IMPORTING
        !type  TYPE td_comptype
      CHANGING
        !value TYPE td_compname
      RAISING
        zaplink_cx .
    CLASS-METHODS refresh
      IMPORTING
        !file          TYPE to_file
        !with_subcomp  TYPE td_with_subcomp DEFAULT abap_true
      RETURNING
        VALUE(objlist) TYPE to_list
      RAISING
        zaplink_cx_gui .
  PROTECTED SECTION.
    TYPES:
      BEGIN OF t_alv,
        fields TYPE slis_t_fieldcat_alv,
        layout TYPE slis_layout_alv,
      END OF t_alv .
    TYPES to_connector TYPE REF TO zaplink_connector .
    TYPES to_activate TYPE REF TO zaplink_activate .
    CLASS-METHODS _save
      IMPORTING
        !file      TYPE to_file
      EXPORTING
        !container TYPE to_container
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS _load
      IMPORTING
        !file      TYPE to_file
      EXPORTING
        !container TYPE to_container
        !cont_name TYPE td_contname
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS _get_objlist
      IMPORTING
        !file      TYPE to_file
      EXPORTING
        !list      TYPE to_list
        !container TYPE to_container
        !cont_name TYPE td_contname
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS create_file
      IMPORTING
        !filename     TYPE td_filename
        !filetype     TYPE td_filetype DEFAULT zaplink_file=>c_ft_local
      RETURNING
        VALUE(o_file) TYPE to_file
      RAISING
        zaplink_cx_gui .
    CLASS-METHODS _update_subobj
      IMPORTING
        !o_list TYPE to_list
        !f_sub  TYPE td_with_subcomp
      RAISING
        zaplink_cx .
    CLASS-METHODS _update_selection
      IMPORTING
        !o_list TYPE to_list
      RAISING
        zaplink_cx .
  PRIVATE SECTION.
    CONSTANTS:
      BEGIN OF c_light,
        no     TYPE td_light VALUE icon_light_out,
        red    TYPE td_light VALUE icon_red_light,
        yellow TYPE td_light VALUE icon_yellow_light,
        green  TYPE td_light VALUE icon_green_light,
      END OF c_light .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_GUI definition
CLASS zaplink_intf_data DEFINITION
  INHERITING FROM zaplink_object_data
  FINAL
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_object .
  PUBLIC SECTION.
    TYPE-POOLS seof .
    TYPE-POOLS seok .
    TYPE-POOLS seoo .
    TYPE-POOLS seor .
    TYPE-POOLS seos .
    TYPE-POOLS seot .
    TYPES:
      BEGIN OF ts_main_data.
        INCLUDE TYPE vseointerf AS hdr.
    TYPES:
      texts    TYPE tt_ltexts,   " tt_seoclasstx_s,
      textpool TYPE tt_txtp_textpools,
      END OF ts_main_data .
    DATA a0_maindata TYPE ts_main_data .
    METHODS anonymize
        REDEFINITION .
    METHODS complete_data
        REDEFINITION .
    METHODS from_data
        REDEFINITION .
    METHODS to_data
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_INTF_DATA definition
CLASS zaplink_object DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC
  FRIENDS zaplink_object_data .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS seof .
    TYPE-POOLS seok .
    TYPE-POOLS seop .
    TYPE-POOLS seor .
    TYPE-POOLS seos .
    TYPE-POOLS seot .
    TYPE-POOLS seox .
    TYPES td_sourcecode TYPE seop_source_string .
    CLASS-METHODS check_class_sections
      IMPORTING
        !application_log TYPE to_msg_coll
        !classkey        TYPE seoclskey
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS cleanup_class
      IMPORTING
        !classkey         TYPE seoclskey
      RETURNING
        VALUE(has_change) TYPE abap_bool
      RAISING
        zaplink_cx_connector .
    METHODS constructor .
    CLASS-METHODS get_class_globalsource
      IMPORTING
        !class_name   TYPE seoclskey
      RETURNING
        VALUE(result) TYPE td_sourcecode .
    CLASS-METHODS get_class_signature
      IMPORTING
        !class_name   TYPE seoclskey
      RETURNING
        VALUE(result) TYPE zaplink_datatypes~td_checksum
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS get_includes
      IMPORTING
        !clsname        TYPE seoclsname
      RETURNING
        VALUE(includes) TYPE zaplink_object_data=>ts_includes .
    CLASS-METHODS get_interface_globalsource
      IMPORTING
        !interface_name TYPE seoclskey
      RETURNING
        VALUE(result)   TYPE td_sourcecode
      EXCEPTIONS
        failed
        not_a_class .
    CLASS-METHODS get_interface_signature
      IMPORTING
        !interface_name TYPE seoclskey
      RETURNING
        VALUE(result)   TYPE zaplink_datatypes~td_checksum
      RAISING
        zaplink_cx_connector .
    METHODS zaplink_cnx_ext_cleaner~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner~unanonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_code_signature~get_signature
        REDEFINITION .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES to_class TYPE REF TO zaplink_clas_data .
    TYPES to_interface TYPE REF TO zaplink_intf_data .
    TYPES ts_include TYPE zaplink_object_data=>ts_include .
    TYPES tt_typeusages TYPE seot_typepusages_r .
    TYPES t_fm_data TYPE zaplink_object_data=>t_fm_data .
    METHODS check_clas_sections
      IMPORTING
        !class TYPE t_fm_data
      RAISING
        zaplink_cx_connector .
    METHODS check_intf_section
      IMPORTING
        !interface TYPE t_fm_data
      RAISING
        zaplink_cx_connector .
    METHODS cleanup_typeusage
      IMPORTING
        !include          TYPE ts_include
        !text             TYPE bal_s_msg-msgv4
      RETURNING
        VALUE(has_change) TYPE abap_bool
      RAISING
        zaplink_cx_connector .
    METHODS export_from_sap_class
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_class
      RAISING
        zaplink_cx_connector .
    METHODS export_from_sap_interface
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_interface
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS generate_class
      IMPORTING
        VALUE(class)  TYPE seoclsname
      RETURNING
        VALUE(result) TYPE abap_bool
      RAISING
        zaplink_cx .
    CLASS-METHODS get_classsource_4signature
      IMPORTING
        !class_name   TYPE seoclskey
      RETURNING
        VALUE(result) TYPE td_sourcecode
      EXCEPTIONS
        not_a_class .
    METHODS import_to_sap_class
      IMPORTING
        !o_data           TYPE to_class
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS import_to_sap_interface
      IMPORTING
        !o_data           TYPE to_interface
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS search_defered_declaration
      IMPORTING
        !sourcecode     TYPE tt_abaprawsource
        !typepools      TYPE seot_typepusages_r
      EXPORTING
        !new_sourcecode TYPE tt_abaprawsource
        !new_typepools  TYPE seot_typepusages_r .
    CLASS-METHODS _check_class_sections
      IMPORTING
        !application_log TYPE to_msg_coll
        !classkey        TYPE seoclskey
        !pri_source      TYPE tt_abaprawsource
        !pro_source      TYPE tt_abaprawsource
        !pub_source      TYPE tt_abaprawsource
      RAISING
        zaplink_cx_connector .
    METHODS _cleanup_class
      RETURNING
        VALUE(has_change) TYPE abap_bool
      RAISING
        zaplink_cx_connector .
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ts_bapi_data,
        class                     TYPE  vseoclass,
        attributes                TYPE  seoo_attributes_r,
        methods                   TYPE  seoo_methods_r,
        events                    TYPE  seoo_events_r,
        types                     TYPE  seoo_types_r,
        parameters                TYPE  seos_parameters_r,
        exceps                    TYPE  seos_exceptions_r,
        implementings             TYPE  seor_implementings_r,
        inheritance               TYPE  vseoextend,
        redefinitions             TYPE  seor_redefinitions_r,
        impl_details              TYPE  seor_redefinitions_r,
        friendships               TYPE  seof_friendships_r,
        typepusages               TYPE  seot_typepusages_r,
        clsdeferrds               TYPE  seot_clsdeferrds_r,
        intdeferrds               TYPE  seot_intdeferrds_r,
        explore_inheritance       TYPE  seok_cls_typeinfos,
        explore_implementings     TYPE  seok_int_typeinfos,
        aliases                   TYPE  seoo_aliases_r,
        enhancement_methods       TYPE  enhmeth_tabheader,
        enhancement_attributes    TYPE  enhclasstabattrib,
        enhancement_events        TYPE  enhclasstabevent,
        enhancement_implementings TYPE enhclasstabimplementing,
      END OF ts_bapi_data .
    TYPES:
      BEGIN OF ts_clas_attr.
        INCLUDE TYPE ts_base_attributs AS base.
    TYPES:
      END OF ts_clas_attr .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_OBJECT'. "#EC NOTEXT
    DATA object_data TYPE t_fm_data .
    CONSTANTS _uuid TYPE td_connuuid VALUE '39AC0A4B07A5A05AE1000000AC120173'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.01'.            "#EC NOTEXT
    METHODS load_clas
      IMPORTING
        !classkey TYPE seoclskey
      RAISING
        zaplink_cx_connector .
ENDCLASS. "ZAPLINK_OBJECT definition
CLASS zaplink_package DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS seof .
    TYPE-POOLS seok .
    TYPE-POOLS seop .
    TYPE-POOLS seor .
    TYPE-POOLS seos .
    TYPE-POOLS seot .
    TYPE-POOLS seox .
    TYPE-POOLS slis .
    DATA transport_request TYPE e070-trkorr .
    CLASS-METHODS class_constructor .
    METHODS constructor .
    METHODS zaplink_cnx_ext_cleaner~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner~unanonymize
        REDEFINITION .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES to_package TYPE REF TO zaplink_devc_data .
    TYPES to_interface TYPE REF TO zaplink_pinf_data .
    TYPES td_package TYPE devclass .
    TYPES td_interface TYPE scomifnam .
    TYPES to_package_raw TYPE REF TO zaplink_devc_raw .
    TYPES to_interface_raw TYPE REF TO zaplink_pinf_raw .
    METHODS conv_package_raw
      IMPORTING
        !package       TYPE REF TO if_package
        !subcomponents TYPE to_list
      RETURNING
        VALUE(o_data)  TYPE to_package_raw
      RAISING
        zaplink_cx_connector .
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ts_ele,
        select    TYPE flag,
        elem_type TYPE trobjtype,
        elem_key  TYPE elemgenkey,
        td_pack   TYPE devclass,
        elem_pack TYPE devclass,
      END OF ts_ele .
    TYPES:
      tt_ele TYPE STANDARD TABLE OF ts_ele WITH NON-UNIQUE DEFAULT KEY .
    TYPES:
      BEGIN OF ts_doc_key,                                    " equiv DOKU_OBJ = CHAR 60
        name      TYPE seoclsname,                             " CHAR 30
        other(30) TYPE c,
      END OF ts_doc_key .
    TYPES:
      BEGIN OF ts_clas_attr.
        INCLUDE TYPE ts_base_attributs AS base.
    TYPES:
      END OF ts_clas_attr .
    TYPES to_raw_interface TYPE zaplink_devc_data=>to_pinf_raw .
    TYPES to_raw_package TYPE zaplink_devc_data=>to_devc_raw .
    CONSTANTS st_package TYPE td_comptype VALUE 'DEVC'.     "#EC NOTEXT
    CONSTANTS st_interface TYPE td_comptype VALUE 'PINF'.   "#EC NOTEXT
    CLASS-DATA cat_ele TYPE slis_t_fieldcat_alv .
    CLASS-DATA cat_layout TYPE slis_layout_alv .
    CONSTANTS _uuid TYPE td_connuuid VALUE '29AD0A4B07A5A05AE1000000AC120173'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.0'.             "#EC NOTEXT
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_PACKAGE'. "#EC NOTEXT
    METHODS add_elements_list
      IMPORTING
        !interface  TYPE to_interface
        !ask_user   TYPE flag OPTIONAL
        !add_remain TYPE flag DEFAULT 'X'
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS build_error_msg
      IMPORTING
        !elements       TYPE scomeldata
      RETURNING
        VALUE(errormsg) TYPE string .
    METHODS change_tadir
      CHANGING
        !alv_data TYPE tt_ele .
    METHODS conv_interface
      IMPORTING
        !interface     TYPE REF TO if_package_interface
        !subcomponents TYPE to_list
      RETURNING
        VALUE(o_data)  TYPE to_interface
      RAISING
        zaplink_cx_connector .
    METHODS conv_interface_raw
      IMPORTING
        !interface     TYPE REF TO if_package_interface
        !subcomponents TYPE to_list
      RETURNING
        VALUE(o_data)  TYPE to_interface_raw
      RAISING
        zaplink_cx_connector .
    METHODS conv_package
      IMPORTING
        !package       TYPE REF TO if_package
        !subcomponents TYPE to_list
        !with_subcomp  TYPE td_with_subcomp DEFAULT abap_true
      RETURNING
        VALUE(o_data)  TYPE to_package
      RAISING
        zaplink_cx_connector .
    METHODS create_interface
      IMPORTING
        !overwrite  TYPE flag
        !interface  TYPE to_interface
        !components TYPE to_list
      RAISING
        zaplink_cx .
    METHODS create_package
      IMPORTING
        !overwrite  TYPE flag
        !package    TYPE to_package
        !components TYPE to_list
      RAISING
        zaplink_cx .
    CLASS-METHODS elements2alv
      IMPORTING
        !elements       TYPE scomeldata
      RETURNING
        VALUE(alv_data) TYPE tt_ele .
    METHODS export_from_sap_interface
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_interface
      RAISING
        zaplink_cx_connector .
    METHODS export_from_sap_package
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_package
      RAISING
        zaplink_cx_connector .
    METHODS import_to_sap_interface
      IMPORTING
        !o_data           TYPE to_interface
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS import_to_sap_package
      IMPORTING
        !o_data           TYPE to_package
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS load_devc
      IMPORTING
        !key       TYPE td_package
      RETURNING
        VALUE(obj) TYPE REF TO if_package
      RAISING
        zaplink_cx_connector .
    METHODS load_intf
      IMPORTING
        !key       TYPE td_interface
      RETURNING
        VALUE(obj) TYPE REF TO if_package_interface
      RAISING
        zaplink_cx_connector .
    METHODS set_interface_attrib
      IMPORTING
        !interface TYPE to_interface
      RAISING
        zaplink_cx_connector .
    METHODS set_package_attrib
      IMPORTING
        !package TYPE to_package
      RAISING
        zaplink_cx_connector .
    CLASS-METHODS update_interface
      IMPORTING
        !data      TYPE scompidtln
      CHANGING
        !interface TYPE REF TO if_package_interface
      RAISING
        zaplink_cx_connector .
    METHODS update_package
      IMPORTING
        !data    TYPE scompkdtln
      CHANGING
        !package TYPE REF TO if_package
      RAISING
        zaplink_cx_connector .
    METHODS _delete_devc
      IMPORTING
        !package TYPE REF TO if_package
      RAISING
        zaplink_cx_connector .
    METHODS _delete_elements
      IMPORTING
        !package TYPE REF TO if_package
      RAISING
        zaplink_cx_connector .
    METHODS _delete_intf
      IMPORTING
        !interface TYPE REF TO if_package_interface
      RAISING
        zaplink_cx_connector .
ENDCLASS. "ZAPLINK_PACKAGE definition
CLASS zaplink_program DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC
  FRIENDS zaplink_prog_data
                 zaplink_vari_data
                 zaplink_vari_raw .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS rsds .
    TYPES tr_so_value TYPE zaplink_vari_data=>tr_string .
    TYPES td_variant TYPE varid-variant .
    TYPES tt_variant_data TYPE zaplink_vari_data=>tt_params .
    TYPES t_raw TYPE rswsourcet .
    TYPES:
      BEGIN OF ts_text,
        langu  TYPE spras,
        entry  TYPE textpooltx,
        length TYPE textpoolln,
      END OF ts_text .
    TYPES:
      tt_texts TYPE SORTED TABLE OF ts_text WITH UNIQUE KEY langu .
    TYPES:
      BEGIN OF ts_textpool,
        id    TYPE  textpoolid,
        key   TYPE  textpoolky,
        texts TYPE  tt_texts,
      END OF ts_textpool .
    TYPES:
      tt_textpools TYPE SORTED TABLE OF ts_textpool WITH UNIQUE KEY id key .
    TYPES ts_source TYPE string .
    TYPES:
      BEGIN OF ts_so_value,
        sign   TYPE bapisign,
        option TYPE bapioption,
        low    TYPE string,
        high   TYPE string,
      END OF ts_so_value .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_PROGRAM'. "#EC NOTEXT
    METHODS constructor .
    CLASS-METHODS class_constructor .
    METHODS get_program_signature
      IMPORTING
        !program_name TYPE td_progname
      RETURNING
        VALUE(result) TYPE zaplink_datatypes~td_checksum .
    METHODS get_variant_params
      IMPORTING
        !program      TYPE td_progname
        !variant      TYPE td_variant
      RETURNING
        VALUE(result) TYPE tt_variant_data .
    METHODS set_param_value
      RETURNING
        VALUE(value) TYPE string .
    METHODS set_selectoption_value
      RETURNING
        VALUE(value) TYPE tr_so_value .
    METHODS set_variant_params
      IMPORTING
        !program      TYPE td_progname
        !variant      TYPE td_variant
        VALUE(data)   TYPE tt_variant_data
      RETURNING
        VALUE(result) TYPE abap_bool .
    METHODS get_param_value
      IMPORTING
        VALUE(value) TYPE string .
    METHODS get_selectoption_value
      IMPORTING
        !value TYPE ANY TABLE .
    METHODS zaplink_cnx_ext_cleaner~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner~unanonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_code_signature~get_signature
        REDEFINITION .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~get_values
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES to_program TYPE REF TO zaplink_prog_data .
    TYPES to_variant TYPE REF TO zaplink_vari_data .
    TYPES:
      tt_variant_list TYPE STANDARD TABLE OF varid WITH DEFAULT KEY .
    TYPES tt_variants TYPE zaplink_prog_data=>tt_vari_data .
    TYPES to_raw_variant TYPE zaplink_prog_data=>to_variant .
    CONSTANTS:
      BEGIN OF supportedtypes,
        program      TYPE td_comptype VALUE 'PROG',         "#EC NOTEXT
        sys_variant  TYPE td_comptype VALUE 'VARI',         "#EC NOTEXT
        appl_variant TYPE td_comptype VALUE 'VARX',         "#EC NOTEXT
      END OF supportedtypes .
    METHODS read_variants
      IMPORTING
        !variants     TYPE tt_variant_list
      RETURNING
        VALUE(result) TYPE tt_variants .
    METHODS write_variants
      IMPORTING
        !variants     TYPE tt_variants
      RETURNING
        VALUE(result) TYPE tt_variants .
  PRIVATE SECTION.
    TYPES:
      BEGIN OF ts_prog_attr.
        INCLUDE TYPE ts_base_attributs AS base.
    TYPES:
      END OF ts_prog_attr .
    TYPES ts_fm_data TYPE zaplink_prog_data=>ts_fm_data .
    TYPES ts_variant_key TYPE zaplink_vari_data=>ts_variant_key .
    TYPES ts_fmd_vari TYPE zaplink_vari_data=>ts_fm_data .
    CLASS-DATA r_doc_id TYPE tr_docid .
    CONSTANTS _uuid TYPE td_connuuid VALUE 'AAAD0A4B07A5A05AE1000000AC120173'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.0'.             "#EC NOTEXT
    DATA current_param TYPE zaplink_vari_data=>ts_param_data .
    CONSTANTS:
      BEGIN OF flags,       " include RSDBCOM2
        BEGIN OF varid,
          noimp           TYPE x VALUE '10',
          imp             TYPE x VALUE 'EF',
          allscreens      TYPE x VALUE '20',
          not_all_screens TYPE x VALUE '20',
          screens         TYPE x VALUE 'DF',
        END OF varid,
        BEGIN OF vari,
          nospagpa TYPE x VALUE '40',
          spagpa   TYPE x VALUE 'BF',
          noint    TYPE x VALUE '80',
          obli     TYPE x VALUE '01',
          int      TYPE x VALUE '7F',
          no_obli  TYPE x VALUE 'FE',
        END OF vari,
      END OF flags .
    CLASS-DATA report TYPE sy-repid .
ENDCLASS. "ZAPLINK_PROGRAM definition
CLASS zaplink_raw DEFINITION
  INHERITING FROM zaplink_raw_base
  CREATE PUBLIC
  FRIENDS zaplink_connector
                 zaplink_container_4inst
                 zaplink_easyxml
                 zaplink_raw .
  PUBLIC SECTION.
    TYPES to_me TYPE REF TO zaplink_raw .
    TYPES to_raw_data TYPE REF TO zaplink_raw_data .
    DATA raw TYPE to_raw_data .
    METHODS constructor
      IMPORTING
        !o_comp TYPE to_component OPTIONAL .
    METHODS copy_as
      IMPORTING
        !raw TYPE to_me .
    METHODS update_connector_data
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_RAW definition
CLASS zaplink_tabl_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_dictionary
                 zaplink_easyxml .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES tt_docs
      FOR zaplink_datatypes~tt_docs .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES:
      tt_dd03p TYPE STANDARD TABLE OF dd03p WITH DEFAULT KEY .
    TYPES:
      tt_dd05m TYPE STANDARD TABLE OF dd05m WITH DEFAULT KEY .
    TYPES:
      tt_dd08v TYPE STANDARD TABLE OF dd08v WITH DEFAULT KEY .
    TYPES:
      tt_dd12v TYPE STANDARD TABLE OF dd12v WITH DEFAULT KEY .
    TYPES:
      tt_dd12t TYPE STANDARD TABLE OF dd12t WITH DEFAULT KEY .
    TYPES:
      tt_dd17v TYPE STANDARD TABLE OF dd17v WITH DEFAULT KEY .
    TYPES:
      tt_dd35v TYPE STANDARD TABLE OF dd35v WITH DEFAULT KEY .
    TYPES:
      tt_dd36m TYPE STANDARD TABLE OF dd36m WITH DEFAULT KEY .
    TYPES:
      tt_dd02t TYPE SORTED TABLE OF dd02t WITH UNIQUE KEY ddlanguage .
    TYPES:
      tt_dd03t TYPE SORTED TABLE OF dd03t WITH UNIQUE KEY fieldname ddlanguage .
    TYPES:
      BEGIN OF ts_fm_data,
        header       TYPE dd02v,
        tech         TYPE dd09v,
        texts        TYPE tt_dd02t,
        docs         TYPE tt_docs,
        fields       TYPE tt_dd03p,
        fields_texts TYPE tt_dd03t,
        forein_keys  TYPE tt_dd08v,      " Header
        fk_fields    TYPE tt_dd05m,
        indexes      TYPE tt_dd12v,
        idx_texts    TYPE tt_dd12t,
        idx_fields   TYPE tt_dd17v,
        search_helps TYPE tt_dd35v,
        sh_fields    TYPE tt_dd36m,
        with_content TYPE abap_bool,     " With table content
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_search_help.
        INCLUDE TYPE dd35v AS hdr.
    TYPES:
      fields TYPE SORTED TABLE OF dd36m WITH UNIQUE KEY shlpfield,
      END OF ts_search_help .
    TYPES:
      BEGIN OF ts_forein_key.
        INCLUDE TYPE dd08v AS hdr.
    TYPES:
      fields TYPE SORTED TABLE OF dd05m WITH UNIQUE KEY primpos,
      END OF ts_forein_key .
    TYPES:
      BEGIN OF ts_field.
        INCLUDE TYPE dd03p AS hdr.
    TYPES:
      texts       TYPE tt_texts,
      search_help TYPE ts_search_help,
      forein_key  TYPE ts_forein_key,
      END OF ts_field .
    TYPES:
      tt_fields TYPE SORTED TABLE OF ts_field WITH UNIQUE KEY position .
    TYPES to_index TYPE REF TO zaplink_xinx_raw .
    TYPES:
      BEGIN OF ts_index,
        zl_object TYPE to_index,
      END OF ts_index .
    TYPES:
      tt_indexes TYPE STANDARD TABLE OF ts_index WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE dd02v AS hdr.
    TYPES:
      technical_settings TYPE dd09v,
      END OF ts_maindata .
    DATA a0_maindata TYPE ts_maindata .
    DATA texts TYPE tt_texts .
    DATA fields TYPE tt_fields .
    DATA indexes TYPE tt_indexes .
    DATA content TYPE REF TO data .
    CLASS-METHODS class_constructor .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data
      RAISING
        zaplink_cx .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize
      RAISING
        zaplink_cx .
    METHODS unanonymize .
  PROTECTED SECTION.
    ALIASES td_doc_id
      FOR zaplink_datatypes~td_doc_id .
    ALIASES tr_docid
      FOR zaplink_datatypes~tr_docid .
    TYPES:
      tt_fm_data TYPE STANDARD TABLE OF zaplink_xinx_data=>ts_fm_data WITH DEFAULT KEY .
    CLASS-DATA r_doc_ids TYPE tr_docid .
    CONSTANTS:
      BEGIN OF doc_ids,
        header TYPE td_doc_id VALUE 'TB',
      END OF doc_ids .
    CLASS-METHODS conv_index
      IMPORTING
        !fm_data      TYPE ts_fm_data
      RETURNING
        VALUE(result) TYPE tt_fm_data .
    CLASS-METHODS conv_indexes
      IMPORTING
        !indexes TYPE tt_fm_data
      CHANGING
        !fm_data TYPE ts_fm_data .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_TABL_DATA definition
CLASS zaplink_transaction DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPES:
      BEGIN OF ts_text,
        langu  TYPE spras,
        entry  TYPE textpooltx,
        length TYPE textpoolln,
      END OF ts_text .
    TYPES:
      tt_texts TYPE SORTED TABLE OF ts_text WITH UNIQUE KEY langu .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_TRANSACTION'. "#EC NOTEXT
    METHODS constructor .
    CLASS-METHODS class_constructor .
    METHODS zaplink_cnx_ext_cleaner~anonymize
        REDEFINITION .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES to_data TYPE REF TO zaplink_tran_data .
  PRIVATE SECTION.
    CONSTANTS st_transaction TYPE td_comptype VALUE 'TRAN'. "#EC NOTEXT
    CLASS-DATA r_doc_id TYPE tr_docid .
    CONSTANTS _uuid TYPE td_connuuid VALUE 'A816684B5215E22AE1000000AC120173'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.0'.             "#EC NOTEXT
    CONSTANTS c_msg_id TYPE td_doc_id VALUE 'NA'.           "#EC NOTEXT
    CONSTANTS:
      BEGIN OF t_component,
        program      TYPE td_comptype VALUE 'PROG',
        object       TYPE td_comptype VALUE 'CLAS',
        transaction  TYPE td_comptype VALUE st_transaction,
        functionpool TYPE td_comptype VALUE 'FUGR',
      END OF t_component .
    CONSTANTS:
      BEGIN OF transaction_types,   " FROM LSEUKTOP(93)
        transaction  TYPE x VALUE '00',               " Transaktion         T
        menu         TYPE x VALUE '01',               " Bereichsmen??     M
        parameter    TYPE x VALUE '02',               " Parametertrans.     P
        program      TYPE x VALUE '80',               " Report              R
        prog_variant TYPE x VALUE '10',               " Report  with Variant
        object       TYPE x VALUE '08',               " Transactional object
        check        TYPE x VALUE '04',               " With autjority check
        enqueue      TYPE x VALUE '20',                       " With SM01
      END OF transaction_types .
ENDCLASS. "ZAPLINK_TRANSACTION definition
CLASS zaplink_tran_data DEFINITION
  INHERITING FROM zaplink_raw_data
  CREATE PUBLIC
  FRIENDS zaplink_easyxml
                 zaplink_transaction .
  PUBLIC SECTION.
    TYPE-POOLS ststc .
    INTERFACES zaplink_datatypes .
    ALIASES ts_lang
      FOR zaplink_datatypes~ts_lang .
    ALIASES tt_texts
      FOR zaplink_datatypes~tt_texts .
    TYPES to_raw TYPE zaplink_connector=>to_raw .
    TYPES:
      BEGIN OF ts_sub_obj,
        zl_object TYPE  to_raw,
      END OF ts_sub_obj .
    TYPES:
      tt_doc_usr TYPE STANDARD TABLE OF rpy_objtab WITH DEFAULT KEY .
    TYPES:
      tt_doc_tech TYPE STANDARD TABLE OF tline WITH DEFAULT KEY .
    TYPES:
      tt_params TYPE STANDARD TABLE OF rsparam WITH DEFAULT KEY .
    TYPES:
      tt_values TYPE SORTED TABLE OF tstca WITH UNIQUE KEY objct field .
    TYPES:
      tt_tstct TYPE SORTED TABLE OF tstct WITH UNIQUE KEY sprsl .
    TYPES:
      BEGIN OF ts_fm_data,
        tstc       TYPE tstc,
        tstct      TYPE tt_tstct,
        tstcc      TYPE tstcc,
        tstca      TYPE tt_values,
        rsstcd     TYPE rsstcd,
        gui_inh    TYPE s_gui_inhe,  " (SAPLSEUK)G_GUI_INHE
        t_doc_user TYPE tt_doc_usr,
        t_doc_tech TYPE tt_doc_tech,
        t_params   TYPE tt_params,
      END OF ts_fm_data .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE tstc.
        INCLUDE TYPE rsstcd.
    TYPES:
      gui_inh   TYPE s_gui_inhe,
      s_webgui  TYPE tstcc-s_webgui,
      s_win32   TYPE tstcc-s_win32,
      s_platin  TYPE tstcc-s_platin,
      s_service TYPE tstcc-s_service,
      s_pervas  TYPE tstcc-s_pervas,
      END OF ts_maindata .
    TYPES:
      BEGIN OF ts_authority,
        object TYPE tstca-objct,
        values TYPE tt_values,
      END OF ts_authority .
    CONSTANTS:
      BEGIN OF tran_types,
        dialog  TYPE sychar01 VALUE ststc_c_type_dialog,
        report  TYPE sychar01 VALUE ststc_c_type_report,
        param   TYPE sychar01 VALUE ststc_c_type_parameters,
        variant TYPE sychar01 VALUE ststc_c_type_variant,
        object  TYPE sychar01 VALUE ststc_c_type_object,    " Not supported yet
      END OF tran_types .
    DATA a0_maindata TYPE ts_maindata .
    DATA texts TYPE tt_texts .
    DATA authorization TYPE ts_authority .
    DATA parameters TYPE tt_params .
    DATA zl_object TYPE to_raw .
    METHODS from_data
      IMPORTING
        !fm_data TYPE ts_fm_data .
    METHODS data_2_type
      IMPORTING
        !fm_data      TYPE ts_fm_data
      RETURNING
        VALUE(result) TYPE rglif-docutype .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
  PROTECTED SECTION.
    DATA transaction TYPE ts_sub_obj .
    DATA program TYPE ts_sub_obj .
    DATA object TYPE ts_sub_obj .
    METHODS anonymize .
    METHODS unanonymize .
  PRIVATE SECTION.
    CONSTANTS:
      BEGIN OF tran_kinds,
        trans_d TYPE tstc-cinfo VALUE '00',
        report  TYPE tstc-cinfo VALUE '80',
        param   TYPE tstc-cinfo VALUE '02',
        variant TYPE tstc-cinfo VALUE '10',    " Variant mask with report
        object  TYPE tstc-cinfo VALUE '08',    " Not supported yet
      END OF tran_kinds .
ENDCLASS. "ZAPLINK_TRAN_DATA definition
CLASS zaplink_container DEFINITION
  INHERITING FROM zaplink_container_4inst
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPES t_xml TYPE string .
    CONSTANTS version TYPE td_contver VALUE '1.0'.          "#EC NOTEXT
    CLASS-METHODS class_constructor .
    CLASS-METHODS create_new
      IMPORTING
        !o_file       TYPE to_file
        !data         TYPE ts_contdata
      RETURNING
        VALUE(result) TYPE REF TO zaplink_container
      RAISING
        zaplink_cx_container .
    METHODS save_to_file
      IMPORTING
        VALUE(o_file) TYPE to_file OPTIONAL
      RAISING
        zaplink_cx_container .
    METHODS add_components
      IMPORTING
        !object_list TYPE to_list
      RAISING
        zaplink_cx_container .
    METHODS remove_components
      IMPORTING
        !object_list TYPE to_list
      RAISING
        zaplink_cx_container .
    METHODS compact
      RAISING
        zaplink_cx_container .
  PROTECTED SECTION.
    TYPES:
      BEGIN OF ts_contdata_full.
        INCLUDE TYPE ts_contdata AS public.
    TYPES:
      version TYPE td_contver,
      class   TYPE td_connclass,
      END OF ts_contdata_full .
    DATA data TYPE ts_contdata_full .
    METHODS _add_component
      IMPORTING
        !component TYPE to_component
      RAISING
        zaplink_cx_container .
    METHODS _remove_component
      IMPORTING
        !component TYPE to_component
      RAISING
        zaplink_cx_container .
    METHODS _update_header
      RAISING
        zaplink_cx_container .
  PRIVATE SECTION.
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_CONTAINER definition
CLASS zaplink_devc_raw DEFINITION
  INHERITING FROM zaplink_raw
  CREATE PUBLIC
  FRIENDS zaplink_easyxml .
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        !o_comp TYPE to_component OPTIONAL .
    METHODS anonymize
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES to_mydata TYPE REF TO zaplink_devc_data .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_DEVC_RAW definition
CLASS zaplink_func_raw DEFINITION
  INHERITING FROM zaplink_raw
  CREATE PUBLIC
  FRIENDS zaplink_easyxml .
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        !fm_data TYPE zaplink_func_data=>ts_fm_data OPTIONAL
      RAISING
        zaplink_cx .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE zaplink_func_data=>ts_fm_data .
    METHODS anonymize
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES to_mydata TYPE REF TO zaplink_func_data .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_FUNC_RAW definition
CLASS zaplink_infos DEFINITION
  FINAL
  CREATE PUBLIC .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes .
    ALIASES framework_version
      FOR zaplink_datatypes~framework_version .
    ALIASES td_connuuid
      FOR zaplink_datatypes~td_connuuid .
    ALIASES td_connver
      FOR zaplink_datatypes~td_connver .
    ALIASES td_frameworkver
      FOR zaplink_datatypes~td_frameworkver .
    ALIASES ts_compkey
      FOR zaplink_datatypes~ts_compkey .
    ALIASES tt_types
      FOR zaplink_datatypes~tt_types .
    TYPES:
      BEGIN OF ts_zl_comp.
        INCLUDE TYPE ts_compkey AS hdr.
    TYPES:
      devclass      TYPE string,
      signature     TYPE string,
      raw_data_type TYPE abap_bool,        " component that can't be removed
      END OF ts_zl_comp .
    TYPES:
      tt_zl_comps TYPE SORTED TABLE OF ts_zl_comp WITH UNIQUE KEY type name .
    TYPES:
      BEGIN OF ts_zl_cnx,
        uuid TYPE td_connuuid.
        INCLUDE TYPE ts_zl_comp.
    TYPES:
      version         TYPE td_connver,
      supported_types TYPE tt_types,
      _components     TYPE tt_zl_comps,
      END OF ts_zl_cnx .
    TYPES:
      tt_zl_cnx TYPE SORTED TABLE OF ts_zl_cnx WITH UNIQUE KEY uuid .
    TYPES:
      BEGIN OF ts_comp_detail.
        INCLUDE TYPE spam_cvers AS hdr.
    TYPES:
      level        TYPE spam_fpdef-version,
      high_package TYPE pat03-patch,
      high_spp     TYPE pat03-patch,
      spp_level    TYPE spam_fpdef-version,
      state        TYPE comp_state,
      active       TYPE spam_cvers-comp_type,
      patchable    TYPE spam_cvers-comp_type,
      END OF ts_comp_detail .
    TYPES:
      tt_hot_pack TYPE STANDARD TABLE OF pat03 WITH DEFAULT KEY .
    TYPES:
      tt_comps TYPE STANDARD TABLE OF ts_comp_detail WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ts_status_info,
        sap_ver      TYPE string,
        os           TYPE string,
        machine_type TYPE string,
        unicode      TYPE string,
        db_sys       TYPE string,
        db_release   TYPE string,
        db_lib       TYPE string,
        kernel       TYPE string,
        abap_ver     TYPE string,
        cua_ver      TYPE string,
      END OF ts_status_info .
    TYPES:
      BEGIN OF ts_sap,
        status        TYPE ts_status_info,
        _hot_packages TYPE tt_hot_pack,
        _components   TYPE tt_comps,
      END OF  ts_sap .
    TYPES:
      BEGIN OF ts_zl,
        framework_version TYPE td_frameworkver,
        components        TYPE tt_zl_comps,
        connectors        TYPE tt_zl_cnx,
      END OF  ts_zl .
    DATA sap TYPE ts_sap READ-ONLY .
    DATA zaplink TYPE ts_zl READ-ONLY .
    DATA o_cx TYPE REF TO zaplink_cx .
    DATA o_mycx TYPE REF TO zaplink_cx .
    CLASS-METHODS class_constructor .
    METHODS constructor
      RAISING
        zaplink_cx .
  PROTECTED SECTION.
    ALIASES td_transport_kind
      FOR zaplink_datatypes~td_transport_kind .
    ALIASES tr_packages
      FOR zaplink_datatypes~tr_packages .
    ALIASES ts_component
      FOR zaplink_datatypes~ts_component .
    ALIASES ts_comptype
      FOR zaplink_datatypes~ts_comptype .
    ALIASES tt_compkeys
      FOR zaplink_datatypes~tt_compkeys .
    TYPES to_list TYPE REF TO zaplink_list .
    TYPES to_connector TYPE REF TO zaplink_connector .
    TYPES to_component TYPE REF TO zaplink_component .
    TYPES ti_code_signature TYPE REF TO zaplink_cnx_ext_code_signature .
    TYPES to_generator TYPE REF TO zaplink_dependencies_analyser .
    TYPES to_raw TYPE REF TO zaplink_raw .
    TYPES td_classname TYPE zaplink_dependencies_analyser=>td_name .
    CLASS-DATA cnx_packages TYPE tr_packages .
    METHODS get_sap_data .
    METHODS get_zl_data
      RAISING
        zaplink_cx .
  PRIVATE SECTION.
    CLASS-DATA c_class TYPE ts_comptype .
    CLASS-DATA c_interface TYPE ts_comptype .
    CLASS-DATA c_program TYPE ts_comptype .
    CLASS-DATA c_msg_class TYPE ts_comptype .
    CLASS-DATA c_typegroup TYPE ts_comptype .
ENDCLASS. "ZAPLINK_INFOS definition
CLASS zaplink_pinf_raw DEFINITION
  INHERITING FROM zaplink_raw
  CREATE PUBLIC
  FRIENDS zaplink_easyxml .
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        !o_comp TYPE to_component OPTIONAL .
    METHODS anonymize
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES to_mydata TYPE REF TO zaplink_pinf_data .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_PINF_RAW definition
CLASS zaplink_program_4dep_analyser DEFINITION
  INHERITING FROM zaplink_program
  FINAL
  CREATE PUBLIC
  FRIENDS zaplink_dependencies_analyser .
  PUBLIC SECTION.
    METHODS constructor .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_PROGRAM_4DEP_ANALYSER definition
CLASS zaplink_standalone_generator DEFINITION
  INHERITING FROM zaplink_dependencies_analyser
  CREATE PUBLIC .
  PUBLIC SECTION.
    TYPE-POOLS abap .
    TYPE-POOLS seop .
    ALIASES tt_compkeys
      FOR zaplink_datatypes~tt_compkeys .
    TYPES td_uc_name TYPE wbcrossgt-name .
    DATA master_program TYPE td_progname READ-ONLY .
    DATA saved_program TYPE td_progname READ-ONLY .
    METHODS constructor
      IMPORTING
        !master TYPE td_progname OPTIONAL
      RAISING
        zaplink_cx .
    METHODS generate
      RETURNING
        VALUE(code) TYPE tt_abaprawsource .
    METHODS add_connectors
      RAISING
        zaplink_cx .
    METHODS save_report
      IMPORTING
        !report  TYPE td_progname
        !code    TYPE tt_abaprawsource OPTIONAL
        !package TYPE td_devclass DEFAULT '$TMP'
      RAISING
        zaplink_cx .
    METHODS scan_report
      IMPORTING
        !program      TYPE td_progname OPTIONAL
      RETURNING
        VALUE(result) TYPE abap_bool
      RAISING
        zaplink_cx .
    METHODS add_data_element
      IMPORTING
        !name TYPE td_uc_name
      RAISING
        zaplink_cx .
    METHODS active_report
      IMPORTING
        !name TYPE td_progname
      RAISING
        zaplink_cx .
  PROTECTED SECTION.
    TYPES:
      BEGIN OF ts_uc_comp,
        c_type TYPE wbcrossgt-otype,
        t_type TYPE tadir-object,
        name   TYPE td_uc_name,
      END OF ts_uc_comp .
    TYPES:
      tt_uc_comps TYPE STANDARD TABLE OF ts_uc_comp .
    TYPES:
      BEGIN OF ts_data_comp,
        name TYPE dd04l-rollname,
        type TYPE dd04l-datatype,
        len  TYPE dd04l-leng,
      END OF ts_data_comp .
    TYPES:
      tt_data_comps TYPE STANDARD TABLE OF ts_data_comp .
    TYPES:
      BEGIN OF ts_abap_comp.
        INCLUDE TYPE ts_uc_comp.
    TYPES:
      source TYPE string,
      END OF ts_abap_comp .
    TYPES:
      tt_abap_comps TYPE STANDARD TABLE OF ts_abap_comp .
    DATA connectors_sourcecode TYPE tt_abaprawsource .
    DATA abap_sourcecode TYPE tt_abaprawsource .
    DATA master_sourcecode TYPE tt_abaprawsource .
    DATA other_comps TYPE tt_abap_comps .
    DATA data_order TYPE tt_data_comps .
    CLASS-METHODS remove_checkpoints
      CHANGING
        !code TYPE tt_abaprawsource .
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_STANDALONE_GENERATOR definition
CLASS zaplink_sxci_data DEFINITION
  INHERITING FROM zaplink_badi_data
  CREATE PUBLIC
  FRIENDS zaplink_badi
                 zaplink_easyxml .
  PUBLIC SECTION.
    TYPE-POOLS seex .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE impl_data AS main.
    TYPES:
      mast_langu TYPE  sy-langu,
      END OF ts_maindata .
    TYPES:
      BEGIN OF ts_filter,
        enhanceable TYPE rsexscrn-flt_ext,
        datatype    TYPE rsexscrn-flt_type,
        values      TYPE seex_filter_table,
      END OF ts_filter .
    DATA a0_maindata TYPE ts_maindata .
    DATA filter TYPE ts_filter .
    DATA implementation TYPE to_raw .
    METHODS anonymize
        REDEFINITION .
    METHODS from_data
        REDEFINITION .
    METHODS to_data
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_SXCI_DATA definition
CLASS zaplink_sxsd_data DEFINITION
  INHERITING FROM zaplink_badi_data
  CREATE PUBLIC
  FRIENDS zaplink_badi
                 zaplink_easyxml .
  PUBLIC SECTION.
    TYPE-POOLS seex .
    TYPES:
      BEGIN OF ts_maindata.
        INCLUDE TYPE badi_data AS main.
    TYPES:
      mast_langu TYPE  sy-langu,
      ext_clname TYPE  seoclsname,
      END OF ts_maindata .
    DATA a0_maindata TYPE ts_maindata .
    DATA interface TYPE to_raw .
    METHODS constructor .
    METHODS anonymize
        REDEFINITION .
    METHODS from_data
        REDEFINITION .
    METHODS to_data
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS. "ZAPLINK_SXSD_DATA definition
CLASS zaplink_vari_raw DEFINITION
  INHERITING FROM zaplink_raw
  CREATE PUBLIC
  FRIENDS zaplink_easyxml .
  PUBLIC SECTION.
    TYPES ts_fm_data TYPE zaplink_vari_data=>ts_fm_data .
    METHODS constructor
      IMPORTING
        !fm_data TYPE ts_fm_data OPTIONAL
      RAISING
        zaplink_cx .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE ts_fm_data .
    METHODS anonymize
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
    TYPES to_mydata TYPE REF TO zaplink_vari_data .
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_VARI_RAW definition
CLASS zaplink_dictionary DEFINITION
  INHERITING FROM zaplink_connector_
  CREATE PUBLIC
  FRIENDS zaplink_xinx_data
                 zaplink_xinx_raw .
  PUBLIC SECTION.
    TYPES td_typegroup TYPE typegroup .
    CONSTANTS ballog_subobject TYPE balsubobj VALUE 'CNX_DICTIONARY'. "#EC NOTEXT
    CLASS-METHODS class_constructor .
    METHODS constructor .
    CLASS-METHODS get_typegroup_signature
      IMPORTING
        !type_group   TYPE td_typegroup
      RETURNING
        VALUE(result) TYPE zaplink_datatypes~td_checksum
      RAISING
        zaplink_cx_connector .
    METHODS zaplink_cnx_ext_cleaner~anonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_cleaner~unanonymize
        REDEFINITION .
    METHODS zaplink_cnx_ext_code_signature~get_signature
        REDEFINITION .
    METHODS zaplink_connector~create_new_raw
        REDEFINITION .
    METHODS zaplink_connector~delete_from_sap
        REDEFINITION .
    METHODS zaplink_connector~do_exists
        REDEFINITION .
    METHODS zaplink_connector~is_supported_version
        REDEFINITION .
    METHODS zaplink_connector~read_from_sap
        REDEFINITION .
    METHODS zaplink_connector~write_to_sap
        REDEFINITION .
  PROTECTED SECTION.
    TYPES to_typegroup TYPE REF TO zaplink_type_data .
    TYPES to_domain TYPE REF TO zaplink_doma_data .
    TYPES to_data_element TYPE REF TO zaplink_dtel_data .
    TYPES to_view TYPE REF TO zaplink_view_data .
    TYPES to_table TYPE REF TO zaplink_tabl_data .
    TYPES to_table_type TYPE REF TO zaplink_ttyp_data .
    TYPES to_search_help TYPE REF TO zaplink_shlp_data .
    TYPES to_lock_object TYPE REF TO zaplink_enqu_data .
    TYPES to_index TYPE REF TO zaplink_xinx_data .
    TYPES ts_idx_key TYPE zaplink_xinx_data=>ts_idx_key .
    TYPES to_content TYPE REF TO zaplink_tabu_data .
    CONSTANTS:
      BEGIN OF supportedtypes,
        type_group     TYPE td_comptype VALUE 'TYPE',       "#EC NOTEXT
        domain         TYPE td_comptype VALUE 'DOMA',       "#EC NOTEXT
        data_element   TYPE td_comptype VALUE 'DTEL',       "#EC NOTEXT
        table_type     TYPE td_comptype VALUE 'TTYP',       "#EC NOTEXT
        search_help    TYPE td_comptype VALUE 'SHLP',       "#EC NOTEXT
        mactchcode_id  TYPE td_comptype VALUE 'MCID',       "#EC NOTEXT
        lock_object    TYPE td_comptype VALUE 'ENQU',       "#EC NOTEXT
        matchcode_obj  TYPE td_comptype VALUE 'MCOB',       "#EC NOTEXT
        table_index    TYPE td_comptype VALUE 'INDX', "#EC NOTEXT : N  Table Index
        ext_index      TYPE td_comptype VALUE 'XINX', "#EC NOTEXT : O  Extention Index MF INTERN_TRANSL_EUTYPE
        table          TYPE td_comptype VALUE 'TABL',       "#EC NOTEXT
        table_content  TYPE td_comptype VALUE 'TABU',       "#EC NOTEXT
        view           TYPE td_comptype VALUE 'VIEW',       "#EC NOTEXT
        t_cluster_pool TYPE td_comptype VALUE 'SQLT',       "#EC NOTEXT
      END OF supportedtypes .
    CONSTANTS:
      BEGIN OF dd_eu_type,          " Domain DDEUTYPE
        table_type      TYPE ddeutype VALUE 'A', "#EC NOTEXT : A  Table Type
        domain          TYPE ddeutype VALUE 'D', "#EC NOTEXT : D  Domain
        data_element    TYPE ddeutype VALUE 'E', "#EC NOTEXT : E  Data Element
        table_field     TYPE ddeutype VALUE 'F', "#EC NOTEXT : F  Table Field
        type_group      TYPE ddeutype VALUE 'G', "#EC NOTEXT : G  Type Group
        search_help     TYPE ddeutype VALUE 'H', "#EC NOTEXT : H  Search Help
        mactchcode_id   TYPE ddeutype VALUE 'I', "#EC NOTEXT : I  Matchcode ID
        lock_object     TYPE ddeutype VALUE 'L', "#EC NOTEXT : L  Lock Object
        matchcode_obj   TYPE ddeutype VALUE 'M', "#EC NOTEXT : M  Matchcode Object
        table_index     TYPE ddeutype VALUE 'N', "#EC NOTEXT : N  Table Index
        ext_index       TYPE ddeutype VALUE 'N', "#EC NOTEXT : O  Extention Index MF INTERN_TRANSL_EUTYPE
        internal_struct TYPE ddeutype VALUE 'S', "#EC NOTEXT : S  Internal Structure
        transp_table    TYPE ddeutype VALUE 'T', "#EC NOTEXT : T  Transparent Table
        structure       TYPE ddeutype VALUE 'U', "#EC NOTEXT : U  Table/Structure
        view            TYPE ddeutype VALUE 'V',  "#EC NOTEXT : V  View
        table_pool      TYPE ddeutype VALUE 'X', "#EC NOTEXT : X  Table Pool
        table_cluster   TYPE ddeutype VALUE 'Y', "#EC NOTEXT : Y  Table Cluster
        t_cluster_pool  TYPE ddeutype VALUE 'Z', "#EC NOTEXT : Z  Table cluster/pool
      END OF dd_eu_type .
    CLASS-METHODS get_type_group
      IMPORTING
        !type_group   TYPE td_typegroup
      RETURNING
        VALUE(result) TYPE REF TO cl_wb_source
      RAISING
        zaplink_cx_connector .
    METHODS export_type_group
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_typegroup
      RAISING
        zaplink_cx_connector .
    METHODS import_type_group
      IMPORTING
        !o_data           TYPE to_typegroup
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS export_domain
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_domain
      RAISING
        zaplink_cx_connector .
    METHODS import_domain
      IMPORTING
        !o_data           TYPE to_domain
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS export_data_element
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_data_element
      RAISING
        zaplink_cx_connector .
    METHODS import_data_element
      IMPORTING
        !o_data           TYPE to_data_element
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS export_view
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_view
      RAISING
        zaplink_cx_connector .
    METHODS import_view
      IMPORTING
        !o_data           TYPE to_view
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS export_table
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_table
      RAISING
        zaplink_cx_connector .
    METHODS import_table
      IMPORTING
        !o_data           TYPE to_table
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS export_table_type
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_table_type
      RAISING
        zaplink_cx_connector .
    METHODS import_table_type
      IMPORTING
        !o_data           TYPE to_table_type
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS export_search_help
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_search_help
      RAISING
        zaplink_cx_connector .
    METHODS import_search_help
      IMPORTING
        !o_data           TYPE to_search_help
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS export_lock_object
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_lock_object
      RAISING
        zaplink_cx_connector .
    METHODS import_lock_object
      IMPORTING
        !o_data           TYPE to_lock_object
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS export_index
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_index
      RAISING
        zaplink_cx_connector .
    METHODS import_index
      IMPORTING
        !o_data           TYPE to_index
      RETURNING
        VALUE(components) TYPE to_list
      RAISING
        zaplink_cx_connector .
    METHODS export_table_content
      IMPORTING
        !component    TYPE to_component
      RETURNING
        VALUE(object) TYPE to_content
      RAISING
        zaplink_cx_connector .
  PRIVATE SECTION.
    TYPES to_raw_index TYPE zaplink_tabl_data=>to_index .
    CONSTANTS _uuid TYPE td_connuuid VALUE '5079624B82531D63E1000000AC120173'. "#EC NOTEXT
    CONSTANTS _ver TYPE td_connver VALUE '1.0'.             "#EC NOTEXT
    CLASS-DATA c_typegroup TYPE ts_comptype .
ENDCLASS. "ZAPLINK_DICTIONARY definition
CLASS zaplink_xinx_raw DEFINITION
  INHERITING FROM zaplink_raw
  CREATE PUBLIC
  FRIENDS zaplink_easyxml .
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        !fm_data TYPE zaplink_xinx_data=>ts_fm_data OPTIONAL
      RAISING
        zaplink_cx .
    METHODS to_data
      RETURNING
        VALUE(fm_data) TYPE zaplink_xinx_data=>ts_fm_data .
    METHODS anonymize
        REDEFINITION .
  PROTECTED SECTION.
  PRIVATE SECTION.
    CLASS-DATA o_mycx TYPE to_exception .
    CLASS-DATA o_cx TYPE to_root_exception .
ENDCLASS. "ZAPLINK_XINX_RAW definition
TYPE-POOLS: slis.
TYPES to_list TYPE REF TO zaplink_list.
TYPES td_action TYPE rsmpe-func.
DATA o_list_u0zi0gu276j00cars51w  TYPE to_list.
CONSTANTS:
  c_act_cancel  TYPE td_action VALUE 'CANCEL',
  c_act_confirm TYPE td_action VALUE 'CONFIRM'.
FORM pf_status_set USING rt_extab TYPE slis_t_extab.
  SET PF-STATUS 'SELECT_TOOLBAR' OF PROGRAM 'ZAPLINK_LIST' EXCLUDING rt_extab.
ENDFORM.                    "pf_status_set
FORM pf_status_no_action USING rt_extab TYPE slis_t_extab.
  DATA lt_extab TYPE slis_t_extab.
  DATA s_fcode LIKE LINE OF rt_extab.
  lt_extab = rt_extab.
  s_fcode-fcode = c_act_confirm.     APPEND s_fcode TO lt_extab.
  s_fcode-fcode = c_act_cancel.      APPEND s_fcode TO lt_extab.
  PERFORM pf_status_set USING lt_extab.
ENDFORM.                    "pf_status_set
FORM user_command_user USING r_ucomm LIKE sy-ucomm
                  rs_selfield TYPE slis_selfield.
  rs_selfield-exit = 'X'.
  CASE r_ucomm.
    WHEN c_act_confirm.
      IF o_list_u0zi0gu276j00cars51w IS BOUND.   o_list_u0zi0gu276j00cars51w->is_confirmed = abap_true.   ENDIF.
    WHEN c_act_cancel.
      IF o_list_u0zi0gu276j00cars51w IS BOUND.   o_list_u0zi0gu276j00cars51w->is_confirmed = abap_false.   ENDIF.
    WHEN OTHERS.
      CLEAR rs_selfield-exit.
  ENDCASE.
ENDFORM.                    "user_command_user
FORM set_list USING list TYPE to_list.
  o_list_u0zi0gu276j00cars51w = list.
  IF o_list_u0zi0gu276j00cars51w IS BOUND.   o_list_u0zi0gu276j00cars51w->is_confirmed = abap_false.   ENDIF.
ENDFORM.                    "set_list
FORM clear_list.
  CLEAR o_list_u0zi0gu276j00cars51w.
ENDFORM.                    "clear_list
DEFINE mac_raise_symsg.
  TRY.
      o_mycx ?= zaplink_cx=>create_from_symsg( classname = &1 " 'ZAPLINK_CX_CONNECTOR'
                                               textid    = &2 ). " zaplink_cx_connector=>system_error
    CATCH zaplink_cx INTO o_cx.
      RAISE EXCEPTION o_cx.
  ENDTRY.
  RAISE EXCEPTION o_mycx.
END-OF-DEFINITION.
DEFINE mac_raise_type_not_supported.
  RAISE EXCEPTION TYPE zaplink_cx_connector
    EXPORTING
      textid = zaplink_cx_connector=>type_not_supported
      type   = &2
      connclass = &1.
END-OF-DEFINITION.
DEFINE mac_cascade_raise.
  CREATE OBJECT &1
    EXPORTING
      textid  = zaplink_cx=>system_error
      previous = &2.
  &1->update( ).
  RAISE EXCEPTION &1.
END-OF-DEFINITION.
DEFINE mac_add_log.
  CLEAR sy-subrc.
  IF &1 IS BOUND AND &2 IS BOUND.             " for security
    IF &1->has_messages_of_msgt( id_msgty = &3 ) = abap_true.
      &2->add_from_instance( io_msglist = &1
                      if_add_as_subnode = abap_true ).
      sy-subrc = 8.
    ENDIF.
  ENDIF.
END-OF-DEFINITION.
DEFINE mac_create_log.
  IF NOT &1 IS BOUND. CREATE OBJECT &1. ENDIF.
  IF &1->get_handle( ) IS INITIAL.
    CALL METHOD &1->init
      EXPORTING
        id_object      = zaplink_datatypes=>ballog_object
        id_subobject   = &2
        id_extnumber   = &3
        auto_upd_custo = abap_true
        id_activity    = zaplink_message_collector=>actions-create
      EXCEPTIONS
        error          = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE 'I' NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDIF.
END-OF-DEFINITION.
DEFINE mac_add_mf_and_raise.
  o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = &1
                                              subrc = &2
                                          classname = 'ZAPLINK_CX_CONNECTOR' ).
  application_log->add_symsg( ).
  application_log->add_exception( o_mycx ).
  RAISE EXCEPTION o_mycx.
END-OF-DEFINITION.
DEFINE mac_raise_mf.
  o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = &1
                                              subrc = &2
                                          classname = 'ZAPLINK_CX_CONNECTOR' ).
  RAISE EXCEPTION o_mycx.
END-OF-DEFINITION.
DEFINE mac_add_mf_and_raise_class.
  o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = &2
                                              subrc = &3
                                          classname = &1 ).
  application_log->add_symsg( ).
  application_log->add_exception( o_mycx ).
  RAISE EXCEPTION o_mycx.
END-OF-DEFINITION.
DEFINE mac_add_name_meth_and_raise.
  o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = &1
                                                   method = &2
                                                    subrc = &3
                                             cx_classname = &4 ).
  application_log->add_symsg( ).
  application_log->add_exception( o_mycx ).
  RAISE EXCEPTION o_mycx.
END-OF-DEFINITION.
DEFINE mac_add_obj_meth_and_raise.
  o_mycx ?= zaplink_cx=>create_from_method_cx( class = &1
                                              method = &2
                                               subrc = &3
                                        cx_classname = 'ZAPLINK_CX_CONNECTOR').
  application_log->add_symsg( ).
  application_log->add_exception( o_mycx ).
  RAISE EXCEPTION o_mycx.
END-OF-DEFINITION.
DEFINE mac_raise_obj_meth_by_name.
  o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = &1
                                                   method = &2
                                                    subrc = &3
                                             cx_classname = 'ZAPLINK_CX_CONNECTOR').
  application_log->add_symsg( ).
  application_log->add_exception( o_mycx ).
  RAISE EXCEPTION o_mycx.
END-OF-DEFINITION.
DEFINE mac_def_catch.
  CATCH &1 INTO o_mycx.
    RAISE EXCEPTION o_mycx.
    CATCH zaplink_cx INTO o_cx.
      mac_cascade_raise o_mycx o_cx.
END-OF-DEFINITION.
TYPE-POOLS: abap.
TYPES to_vari_object TYPE REF TO zaplink_program.
DATA o_vari_prog TYPE to_vari_object.
FORM check_vari_form_exists  CHANGING ok TYPE abap_bool.
  ok = abap_true.
ENDFORM.                    "check_vari_form_exists
FORM set_object USING object TYPE to_vari_object
  .
  CHECK o_vari_prog IS NOT BOUND.
  o_vari_prog = object.
ENDFORM.                    "set_object
FORM clear_object USING object TYPE to_vari_object
  .
  CHECK o_vari_prog = object.
  CLEAR o_vari_prog.
ENDFORM.                    "clear_object
FORM get_val_p USING p_param VALUE(p_text) p_subrc
  .
  DATA l_value TYPE string.
  CHECK o_vari_prog IS BOUND.
  CHECK NOT p_param IS INITIAL.
  l_value = p_param.
  o_vari_prog->get_param_value( l_value ).
ENDFORM.                    "get_val
FORM get_val_s TABLES p_selopt                              "#EC *
                USING p_sign p_option p_low p_high
                      p_desc STRUCTURE rsselint p_subrc
  .
  CHECK o_vari_prog IS BOUND.
  o_vari_prog->get_selectoption_value( p_selopt[] ).
ENDFORM.                    "get_val_s
FORM set_val_p USING p_param VALUE(p_text) p_subrc
  .
  DATA l_value TYPE string.
  CHECK o_vari_prog IS BOUND.
  l_value = o_vari_prog->set_param_value( ).
  p_param = l_value.
ENDFORM.                    "set_val_p
FORM set_val_s TABLES p_selopt                              "#EC *
                USING p_sign p_option p_low p_high
                      p_desc STRUCTURE rsselint p_subrc
  .
  DATA t_value  TYPE zaplink_program=>tr_so_value.
  FIELD-SYMBOLS:
    <v> LIKE LINE OF t_value.
  CHECK o_vari_prog IS BOUND.
  t_value = o_vari_prog->set_selectoption_value( ).
  REFRESH p_selopt.       " always set value : Clearing (blank in variant) default not null value
  LOOP AT t_value ASSIGNING <v>.
    CLEAR p_selopt.   MOVE-CORRESPONDING <v> TO p_selopt.   APPEND p_selopt.
  ENDLOOP.
ENDFORM.                    "set_val_s
.
.
DEFINE mac_symsg_send.
  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
END-OF-DEFINITION.
DEFINE mac_symsg_send_as_type.
  MESSAGE ID sy-msgid TYPE &1 NUMBER sy-msgno
          DISPLAY LIKE sy-msgty
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
END-OF-DEFINITION.
DEFINE mac_symsg_raise.
  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
          RAISING &1.
END-OF-DEFINITION.
DEFINE mac_symsg_raise_as_type.
  MESSAGE ID sy-msgid TYPE &1 NUMBER sy-msgno
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
          RAISING &2.
END-OF-DEFINITION.
DEFINE mac_symsg_raise_on_subrc.
  IF sy-subrc = &1.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
            RAISING &2.
  ENDIF.
END-OF-DEFINITION.
DEFINE mac_symsg_into_text.
  MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
          WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
          INTO &1.
END-OF-DEFINITION.
DEFINE mac_symsg_set.
  sy-msgid = &1.
  sy-msgty = &2.
  sy-msgno = &3.
  sy-msgv1 = &4.
  sy-msgv2 = &5.
  sy-msgv3 = &6.
  sy-msgv4 = &7.
END-OF-DEFINITION.
DEFINE mac_symsg_set_from_msg.
  sy-msgid = &1-msgid.
  sy-msgty = &1-msgty.
  sy-msgno = &1-msgno.
  sy-msgv1 = &1-msgv1.
  sy-msgv2 = &1-msgv2.
  sy-msgv3 = &1-msgv3.
  sy-msgv4 = &1-msgv4.
END-OF-DEFINITION.
DEFINE mac_msg_set_from_symsg.
  &1-msgid = sy-msgid.
  &1-msgty = sy-msgty.
  &1-msgno = sy-msgno.
  &1-msgv1 = sy-msgv1.
  &1-msgv2 = sy-msgv2.
  &1-msgv3 = sy-msgv3.
  &1-msgv4 = sy-msgv4.
END-OF-DEFINITION.
DEFINE mac_bapimsg_to_symsg.
  sy-msgty = &1-type.
  sy-msgid = &1-id.
  sy-msgno = &1-number.
  sy-msgv1 = &1-message_v1.
  sy-msgv2 = &1-message_v2.
  sy-msgv3 = &1-message_v3.
  sy-msgv4 = &1-message_v4.
END-OF-DEFINITION.
DEFINE mac_msg_to_bapimsg.
  CALL FUNCTION 'BALW_BAPIRETURN_GET2'
    EXPORTING
      type       = &1-msgty
      cl         = &1-msgid
      number     = &1-msgno
      par1       = &1-msgv1
      par2       = &1-msgv2
      par3       = &1-msgv3
      par4       = &1-msgv4
    IMPORTING
      return     = &2.
END-OF-DEFINITION.
DEFINE mac_msglist_add.
  CALL METHOD &1->add
    EXPORTING
      id_msgty = &2
      id_msgid = &3
      id_msgno = &4
      id_msgv1 = &5
      id_msgv2 = &6
      id_msgv3 = &7
      id_msgv4 = &8.
END-OF-DEFINITION.
DEFINE mac_symsg_format_out.
  WRITE &1 TO &2 LEFT-JUSTIFIED.
  CONDENSE &2.
END-OF-DEFINITION.
DEFINE mac_symsg_format_num.
  IF &1 IS NOT INITIAL.
    WRITE &1 TO &2 NO-ZERO.
    CONDENSE &2.
  ELSE.
    CLEAR &2.
  ENDIF.
END-OF-DEFINITION.
DEFINE mac_invalid_precondition.
  ASSERT 0 = 1.
END-OF-DEFINITION.
DEFINE mac_invalid_postcondition.
  ASSERT 0 = 1.
END-OF-DEFINITION.
DEFINE mac_assert_initial.
  ASSERT FIELDS &1 CONDITION &1 IS INITIAL.
END-OF-DEFINITION.
DEFINE mac_assert_not_initial.
  ASSERT &1 IS NOT INITIAL.
END-OF-DEFINITION.
DEFINE mac_assert_ref.
  ASSERT &1 IS BOUND.
END-OF-DEFINITION.
DEFINE mac_assert_subrc.
  ASSERT FIELDS sy-subrc CONDITION sy-subrc = 0.
END-OF-DEFINITION.
DEFINE mac_switch_flag.
  IF &1 <> ' '.
    &1 = ' '.
  ELSE.
    &1 = 'X'.
  ENDIF.
END-OF-DEFINITION.
DEFINE mac_clear_date_if_initial.
  IF is_date_initial( &1 ) = abap_true.
    CLEAR &1.
  ENDIF.
END-OF-DEFINITION.
.
.
.
DEFINE mac_syserr_log.
  IF &1 <> 0.
    SET EXTENDED CHECK OFF.
    IF 1 = 2. MESSAGE ID msgid TYPE 'E' NUMBER 000 WITH abap_true abap_true abap_true. ENDIF.
    SET EXTENDED CHECK ON.
    crc = &1.
    CALL METHOD application_log->add_error
      EXPORTING
        id_msgno     = '000'
        id_msgv1     = crc
        id_msgv2     = &2
        id_msgv3     = &3
        .
  ENDIF.
END-OF-DEFINITION.
.
.
DEFINE lmac_create_data.
  CREATE OBJECT &1.
  &1->o_file = &2-o_file.
  &1->o_xml = &2-o_xml.
  &1->o_raw_base = &2-o_raw_base.
  &1->o_raw = &2-o_raw.
  &1->filename = &2-filename.
  IF &2-o_raw_base IS BOUND.
    &1->type = &2-o_raw_base->get_type( ).
    &1->name = &2-o_raw_base->get_name( ).
    &1->package = &2-o_raw_base->directory-devclass.
    &1->checksum = &2-o_raw_base->get_checksum( ).
    &1->signature = &2-o_raw_base->get_code_signature( ).
  ELSEIF &2-o_raw IS BOUND.
    &1->type = &2-o_raw->get_type( ).
    &1->name = &2-o_raw->get_name( ).
    &1->package = &2-o_raw->directory-devclass.
    &1->checksum = &2-o_raw->get_checksum( ).
    &1->signature = &2-o_raw->get_code_signature( ).
  ENDIF.
END-OF-DEFINITION.
CLASS lcl_data DEFINITION
  CREATE PUBLIC
  FRIENDS zaplink_extractor
  .
  PUBLIC SECTION.
    INTERFACES zaplink_datatypes.       " OK Used by parent
    ALIASES td_filename FOR zaplink_datatypes~td_filename.
    ALIASES td_checksum FOR zaplink_datatypes~td_checksum.
    ALIASES to_xml      FOR zaplink_datatypes~to_xml.
    ALIASES td_comptype FOR zaplink_datatypes~td_comptype.
    ALIASES td_compname FOR zaplink_datatypes~td_compname.
    ALIASES td_devclass FOR zaplink_datatypes~td_devclass.
    INTERFACES zaplink_kernel_types.    " OK Used by parent
    ALIASES to_file     FOR zaplink_kernel_types~to_file.
    ALIASES to_raw      FOR zaplink_kernel_types~to_raw.
    ALIASES to_raw_base FOR zaplink_kernel_types~to_raw_base.
    TYPES:
      BEGIN OF ts_key,        " TYPE zaplink_directory=>ts_key.
        type TYPE  trobjtype,
        name TYPE  sobj_name,
      END OF  ts_key.
    TYPES:
      BEGIN OF ts_data,       " TYPE zaplink_directory=>ts_data.
        checksum  TYPE  guid_32,
        signature TYPE  guid_32,
      END OF ts_data.
    DATA type        TYPE td_comptype.
    DATA name        TYPE td_compname.
    DATA package     TYPE td_devclass.
    DATA o_raw       TYPE to_raw.
    DATA o_file      TYPE to_file.
    DATA o_raw_base  TYPE to_raw_base.
    DATA filename    TYPE td_filename.
    DATA checksum    TYPE td_checksum.
    DATA signature   TYPE td_checksum.
    DATA o_xml       TYPE to_xml.
    METHODS join
      IMPORTING
        VALUE(data) TYPE REF TO lcl_data.
    METHODS get_key
      RETURNING
        VALUE(result) TYPE ts_key.
    METHODS get_file_data
      RETURNING
        VALUE(result) TYPE ts_data.
    METHODS get_sap_data
      RETURNING
        VALUE(result) TYPE ts_data.
  PROTECTED SECTION.
  PRIVATE SECTION.
ENDCLASS.                    "lcl_data  DEFINITIO
CLASS lcl_data IMPLEMENTATION.
  METHOD join.
    DEFINE lmac_join.
      IF me->&1 IS INITIAL.   me->&1 = data->&1.    ENDIF.
    END-OF-DEFINITION.
    lmac_join: o_xml, o_raw_base, o_raw, filename, checksum, type, name, package, checksum, signature.
  ENDMETHOD.                    "Join
  METHOD get_key.
    result-type = type.
    result-name = name.
  ENDMETHOD.                    "get_key
  METHOD get_file_data.
    DATA xml_str TYPE string.
    CHECK o_raw_base IS BOUND.
    result-checksum = o_raw_base->get_checksum( ).
    result-signature = o_raw_base->get_code_signature( ).
  ENDMETHOD.                    "get_file_data
  METHOD get_sap_data.
    DATA xml_str TYPE string.
    CHECK o_raw IS BOUND.
    result-checksum = o_raw->get_checksum( ).
    result-signature = o_raw->get_code_signature( ).
  ENDMETHOD.                    "get_sap_data
ENDCLASS.                    "lcl_data IMPLEMENTATION
.
.
.
.
.
.
DEFINE lmac_add_mf_and_raise.
  o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = &1
                                              subrc = &2
                                          classname = 'ZAPLINK_CX_CONNECTOR' ).
  log->add_symsg( ).
  log->add_exception( o_mycx ).
  RAISE EXCEPTION o_mycx.
END-OF-DEFINITION.
.
.
.
.
.
.
DEFINE mac_read_tadir.
  SELECT SINGLE devclass dlvunit INTO (&4, &5)
    FROM v_tralan
    WHERE pgmid = &1
      AND object = &2
      AND obj_name = &3.
END-OF-DEFINITION.
DEFINE mac_add_comp.
  IF NOT s_comp-kind IS INITIAL AND NOT s_comp-type IS INITIAL AND NOT s_comp-name IS INITIAL.
    mac_read_tadir s_comp-kind s_comp-type s_comp-name s_comp-devclass s_comp-softcomp.
    IF s_comp-devclass IN packages AND s_comp-softcomp IN softcomponents.
      INSERT s_comp INTO TABLE all_components.
    ENDIF.
  ENDIF.
END-OF-DEFINITION.
.
.
.
.
.
.
.
.
.
DEFINE mac_read_tadir.
  SELECT SINGLE devclass dlvunit INTO (&4, &5)
    FROM v_tralan
    WHERE pgmid = &1
      AND object = &2
      AND obj_name = &3.
END-OF-DEFINITION.
DEFINE mac_add_comp.
  IF NOT s_comp-kind IS INITIAL AND NOT s_comp-type IS INITIAL AND NOT s_comp-name IS INITIAL.
    mac_read_tadir s_comp-kind s_comp-type s_comp-name s_comp-devclass s_comp-softcomp.
    IF s_comp-devclass IN packages AND s_comp-softcomp IN softcomponents.
      INSERT s_comp INTO TABLE all_components.
    ENDIF.
  ENDIF.
END-OF-DEFINITION.
.
DEFINE mac_obj_data.
  DATA o_typegroup TYPE to_typegroup.
  DATA o_domain    TYPE to_domain.
  DATA o_data_e    TYPE to_data_element.
  DATA o_view      TYPE to_view.
  DATA o_table     TYPE to_table.
  DATA o_content   TYPE to_content.
  DATA o_index     TYPE to_index.
  DATA o_tab_type  TYPE to_table_type.
  DATA o_s_help    TYPE to_search_help.
  DATA o_lock_obj  TYPE to_lock_object.
END-OF-DEFINITION.
CLASS zaplink_raw_data IMPLEMENTATION.
ENDCLASS. "ZAPLINK_RAW_DATA implementation
CLASS zaplink_checkpoints_data IMPLEMENTATION.
  METHOD conv_activation2mode.
    CALL METHOD cl_aab_tool=>convert_input_to_mode
      EXPORTING
        bp_inactive            = activation-breakpoints-inactive
        bp_stop                = activation-breakpoints-break
        lp_inactive            = activation-logpoints-inactive
        lp_log                 = activation-logpoints-log
        as_fg_inactive         = activation-assertions-inactive
        as_fg_stop_bg_protocol = activation-assertions-break-log
        as_fg_stop_bg_rabax    = activation-assertions-break-abort
        as_fg_protocol         = activation-assertions-log
        as_fg_rabax            = activation-assertions-abort
      IMPORTING
        mode                   = result
      EXCEPTIONS
        mode_not_valid         = 1
        OTHERS                 = 2.
    ASSERT sy-subrc = 0.
  ENDMETHOD.
  METHOD conv_mode2activation.
    CALL METHOD cl_aab_tool=>convert_mode_to_output
      EXPORTING
        mode                   = mode
      IMPORTING
        bp_inactive            = result-breakpoints-inactive
        bp_stop                = result-breakpoints-break
        lp_inactive            = result-logpoints-inactive
        lp_log                 = result-logpoints-log
        as_fg_inactive         = result-assertions-inactive
        as_fg_stop_bg_protocol = result-assertions-break-log
        as_fg_stop_bg_rabax    = result-assertions-break-abort
        as_fg_protocol         = result-assertions-log
        as_fg_rabax            = result-assertions-abort.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CHECKPOINTS_DATA implementation
CLASS zaplink_cx IMPLEMENTATION.
  METHOD class_constructor.
    DATA _exceptions TYPE REF TO cl_oo_class_relations.
    DATA s_list      LIKE LINE OF _cx_list.
    DATA t_list      LIKE STANDARD TABLE OF s_list.
    FIELD-SYMBOLS:
      <s_cl> LIKE LINE OF _exceptions->subclasses.
    CLEAR _cx_list.
    CREATE OBJECT _exceptions
      EXPORTING
        clsname      = 'ZAPLINK_CX'
      EXCEPTIONS
        is_interface = 1
        not_existing = 0  " For installer ignore not existing class
        OTHERS       = 3.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                 WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    CHECK _exceptions IS BOUND.
    LOOP AT _exceptions->subclasses ASSIGNING <s_cl>
            WHERE state <> '0'      " Only modeled
              AND version = '1'     " Active
              .
      CLEAR s_list. s_list-class = <s_cl>-clsname. APPEND s_list TO t_list.
    ENDLOOP.
    SORT t_list BY class.
    DELETE ADJACENT DUPLICATES FROM t_list.
    _cx_list = t_list.
  ENDMETHOD.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous = previous.
    me->messages = messages .
    me->object = object .
    me->subobject = subobject .
    me->ext_id = ext_id .
    me->cx_name = cx_name .
    me->_cx_list = _cx_list .
    me->systemstack = systemstack .
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
  METHOD conv_progname.
    DATA p_wb_request TYPE REF TO cl_wb_request.
    DATA p_ex_request TYPE REF TO cl_wb_request.
    DATA p_wb_source_req_dispatcher TYPE REF TO cl_wb_source_req_dispatcher.
    DATA kind TYPE  seoclsname.
    CREATE OBJECT p_wb_source_req_dispatcher.
    CREATE OBJECT p_wb_request
      EXPORTING
        p_object_type                = 'P'
        p_object_name                = object_name
        p_operation                  = 'DISPLAY'
      EXCEPTIONS
        illegal_object_type          = 1
        illegal_operation            = 2
        illegal_new_window_parameter = 3
        OTHERS                       = 4.
    IF sy-subrc <> 0.
      source-str = source-name = object_name.
      EXIT.
    ENDIF.
    CALL METHOD p_wb_source_req_dispatcher->if_wb_decision_class~get_tool_for_request
      EXPORTING
        p_wb_request            = p_wb_request
      IMPORTING
        p_execution_request     = p_ex_request
        p_toolname              = kind
      EXCEPTIONS
        no_tool_found           = 1
        object_not_found        = 2
        operation_not_supported = 3
        OTHERS                  = 4.
    IF sy-subrc <> 0.
      source-str = source-name = object_name.
      EXIT.
    ENDIF.
    IF NOT p_ex_request IS BOUND.
      p_ex_request = p_wb_request.
    ENDIF.
    source-name = p_ex_request->object_name.
    IF NOT context IS INITIAL.
      REPLACE FIRST OCCURRENCE OF context IN source-name WITH ` `.
      CONDENSE source-name.
    ENDIF.
    SELECT SINGLE singular INTO source-type_txt
      FROM euobjt
      WHERE spras = sy-langu
        AND type = p_ex_request->object_type.
    IF sy-subrc <> 0.
      SELECT SINGLE singular INTO source-type_txt
        FROM euobjt
        WHERE spras = 'E'
          AND type = p_ex_request->object_type.
      IF sy-subrc <> 0.
        SELECT SINGLE singular INTO source-type_txt
          FROM euobjt
          WHERE type = p_ex_request->object_type.
      ENDIF.
    ENDIF.
    IF sy-subrc = 0.
      CONCATENATE source-type_txt source-name INTO source-str SEPARATED BY space.
    ELSE.
      source-str = source-name.
    ENDIF.
  ENDMETHOD.
  METHOD create_from_application_log.
    result = _create_cx( cx_name = cx_name
                          textid = textid ).
    result->systemstack_up( ).  " remove this method from stack
    result->messages = message_collector.
    result->previous = prev_cx.
    result->update( ).
  ENDMETHOD.
  METHOD create_from_method_cx.
    DATA o_desc   TYPE REF TO cl_abap_objectdescr.
    DATA t_excep  TYPE abap_excpdescr_tab.
    FIELD-SYMBOLS:
      <m> LIKE LINE OF o_desc->methods,
      <e> LIKE LINE OF <m>-exceptions.
    result = _create_cx( cx_name = cx_classname
                          textid = textid ).
    result->systemstack_up( ).  " remove this method from stack
    CHECK class IS BOUND OR NOT class_name IS INITIAL.
    IF class IS BOUND.
      o_desc ?= cl_abap_objectdescr=>describe_by_object_ref( class ).
    ELSE.
      o_desc ?= cl_abap_objectdescr=>describe_by_name( class_name ).
    ENDIF.
    TRANSLATE method TO UPPER CASE.
    READ TABLE o_desc->methods ASSIGNING <m>
         WITH TABLE KEY name = method.
    ASSERT sy-subrc = 0.
    ASSERT subrc >= 1 AND subrc <= lines( <m>-exceptions ).
    t_excep = <m>-exceptions.   SORT t_excep.
    READ TABLE t_excep ASSIGNING <e> INDEX subrc.
    ASSERT sy-subrc = 0.
    result->cx_name = <e>-name.
  ENDMETHOD.
  METHOD create_from_mf_cx.
    CONSTANTS c_cx_kind TYPE funct-kind VALUE 'X'. " Exception
    DATA _funcname      TYPE rs38l-name.
    DATA lt_ptfdir      TYPE STANDARD TABLE OF tfdir WITH DEFAULT KEY.
    DATA lt_ptftit      TYPE STANDARD TABLE OF tftit WITH DEFAULT KEY.
    DATA lt_pfunct      TYPE STANDARD TABLE OF funct WITH DEFAULT KEY.
    DATA lt_penlfdir    TYPE STANDARD TABLE OF enlfdir WITH DEFAULT KEY.
    DATA lt_ptrdir      TYPE STANDARD TABLE OF trdir WITH DEFAULT KEY.
    DATA lt_pfupararef  TYPE STANDARD TABLE OF sfupararef WITH DEFAULT KEY.
    DATA lt_uincl       TYPE STANDARD TABLE OF abaptxt255 WITH DEFAULT KEY.
    DATA _cx            TYPE REF TO zaplink_cx.
    DATA _subrc         TYPE sy-subrc.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF lt_pfunct,
      <p> LIKE LINE OF lt_pfupararef.
    _funcname = funcname.
    TRANSLATE _funcname TO UPPER CASE.                    "#EC SYNTCHAR
    result = _create_cx( cx_name = classname
                          textid = textid ).
    result->systemstack_up( ).  " remove this method from stack
    CALL FUNCTION 'FUNC_GET_OBJECT'
      EXPORTING
        funcname           = _funcname
      TABLES
        ptfdir             = lt_ptfdir
        ptftit             = lt_ptftit
        pfunct             = lt_pfunct
        penlfdir           = lt_penlfdir
        ptrdir             = lt_ptrdir
        pfupararef         = lt_pfupararef
        uincl              = lt_uincl
      EXCEPTIONS
        function_not_exist = 1
        version_not_found  = 2
        OTHERS             = 3.
    IF sy-subrc <> 0.
      _cx = create_from_mf_cx( funcname = 'FUNC_GET_OBJECT'
                                  subrc = sy-subrc ).
      result->previous = _cx.
      result->textid_msg = zaplink_cx=>system_error.
      EXIT.
    ENDIF.
    DELETE lt_pfunct WHERE kind <> c_cx_kind.
    DELETE lt_pfupararef WHERE paramtype <> c_cx_kind.
    READ TABLE lt_pfupararef ASSIGNING <p>
         WITH KEY pposition = subrc.
    IF sy-subrc <> 0.
      _subrc = subrc - 1.
      READ TABLE lt_pfupararef ASSIGNING <p>
           WITH KEY pposition = _subrc.
      IF sy-subrc = 0.
        result->cx_name = 'OTHERS'.   " #EC NOTEXT
        EXIT.
      ENDIF.
    ENDIF.
    result->cx_name = <p>-parameter.
    READ TABLE lt_pfunct ASSIGNING <t>
         WITH KEY parameter = <p>-parameter
                      spras = sy-langu.
    IF <t> IS ASSIGNED. IF <t>-stext IS INITIAL.     UNASSIGN <t>.      ENDIF. ENDIF.
    IF NOT <t> IS ASSIGNED.
      READ TABLE lt_pfunct ASSIGNING <t>
           WITH KEY parameter = <p>-parameter
                        spras = 'E'.
      IF <t> IS ASSIGNED. IF <t>-stext IS INITIAL.     UNASSIGN <t>.      ENDIF. ENDIF.
    ENDIF.
    IF NOT <t> IS ASSIGNED.
      READ TABLE lt_pfunct ASSIGNING <t>
           WITH KEY parameter = <p>-parameter.
      IF <t> IS ASSIGNED. IF <t>-stext IS INITIAL.     UNASSIGN <t>.      ENDIF. ENDIF.
    ENDIF.
    IF <t> IS ASSIGNED.
      CONCATENATE result->cx_name '(' <t>-stext ')' INTO result->cx_name.
    ENDIF.
  ENDMETHOD.
  METHOD create_from_symsg.
    result = _create_cx( cx_name = classname
                          textid = textid ).
    result->systemstack_up( ).  " remove this method from stack
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4 INTO result->cx_name.
  ENDMETHOD.
  METHOD get_source_position_as_string.
    str = source_position_as_string( me ).
  ENDMETHOD.
  METHOD is_exception_text.
    IF textid_msg = textid.     result = abap_true.   ENDIF.
  ENDMETHOD.
  METHOD load_systemstack.
    IF systemstack IS INITIAL OR force_reload = abap_true.
      CALL FUNCTION 'SYSTEM_CALLSTACK'
        IMPORTING
          callstack = systemstack.
      systemstack_up( ).   " Remove load systemstack
    ENDIF.
  ENDMETHOD.
  METHOD source_position_as_string.
    DATA _pos TYPE ts_source_pos.
    CALL METHOD exception->get_source_position
      IMPORTING
        program_name = _pos-mainprogram
        include_name = _pos-include
        source_line  = _pos-line.
    str = stack_position_as_string( _pos ).
  ENDMETHOD.
  METHOD stack_position_as_string.
    DATA _key TYPE seu_objkey.
    DATA _prog TYPE ts_source_def.
    DATA _include TYPE ts_source_def.
    _key = source-mainprogram. _prog = conv_progname( _key ).
    IF source-mainprogram = source-include.
      MESSAGE i102 WITH _prog-str source-line INTO str.
    ELSE.
      _key = source-include.     _include = conv_progname( object_name = _key   context = _prog-name ).
      MESSAGE i100 WITH _prog-str _include-str source-line INTO str.
    ENDIF.
  ENDMETHOD.
  METHOD systemstack_up.
    CHECK systemstack IS NOT INITIAL.   DELETE systemstack INDEX 1.
  ENDMETHOD.
  METHOD update.
    DATA desc TYPE REF TO cl_abap_objectdescr.
    IF messages IS BOUND.
      object = messages->object.
      subobject = messages->subobject.
      ext_id = messages->ext_id.
      messages->store( ).
    ENDIF.
    IF cx_name IS INITIAL AND previous IS BOUND.
      desc ?= cl_abap_objectdescr=>describe_by_object_ref( previous ).
      cx_name = desc->absolute_name.
    ENDIF.
  ENDMETHOD.
  METHOD write.
    DATA _exceptions  TYPE STANDARD TABLE OF string.
    DATA _msg         TYPE string.
    DATA _pos         TYPE string.
    DATA _cx          TYPE REF TO cx_root.
    DATA _order       TYPE STANDARD TABLE OF string.
    DATA _offset      TYPE string.
    DATA _messages    TYPE bapirettab.
    DATA _light       TYPE icon_d.
    DATA t_stack      TYPE abap_callstack.
    FIELD-SYMBOLS:
      <s> LIKE LINE OF t_stack,
      <e> LIKE LINE OF _exceptions.
    _cx = me.
    WHILE _cx IS BOUND.
      _msg = _cx->get_text( ).
      _pos = zaplink_cx=>source_position_as_string( _cx ).
      CONCATENATE _msg _pos INTO _msg SEPARATED BY space.
      APPEND _msg TO _exceptions.
      _cx = _cx->previous.
    ENDWHILE.
    LOOP AT _exceptions ASSIGNING <e>.
      INSERT <e> INTO _order INDEX 1.
    ENDLOOP.
    FREE _exceptions.
    LOOP AT _order ASSIGNING <e>.
      IF sy-tabix = 1.
        WRITE:/ icon_message_critical_small AS ICON, <e>.
      ELSE.
        CONCATENATE ` ` _offset INTO _offset.
        WRITE:/ _offset, icon_arrow_right AS ICON, <e>.
      ENDIF.
    ENDLOOP.
    CONCATENATE ` ` _offset INTO _offset.
    LOOP AT t_stack ASSIGNING <s>.
      _msg = stack_position_as_string( <s> ).
      WRITE:/ _offset, icon_stack AS ICON, _msg.
    ENDLOOP.
    IF me->messages IS BOUND.   messages->write( _offset ).   ENDIF.
  ENDMETHOD.
  METHOD _create_cx.
    DATA f_exists TYPE abap_bool.
    IF NOT cx_name IS INITIAL.
      READ TABLE _cx_list TRANSPORTING NO FIELDS
           WITH TABLE KEY class = cx_name.
      IF sy-subrc = 0.
        f_exists = abap_true.
      ELSE.
        f_exists = abap_false.
      ENDIF.
      TRY.
          CREATE OBJECT result
            TYPE
              (cx_name)
            EXPORTING
              textid    = textid.
        CATCH cx_root INTO o_cx.
          ASSERT f_exists = abap_false.
      ENDTRY.
    ENDIF.
    IF result IS NOT BOUND.
      CREATE OBJECT result
        EXPORTING
          textid = textid.
    ENDIF.
    result->load_systemstack( ).
    result->systemstack_up( ).  " remove this method from stack
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX implementation
CLASS zaplink_devc_data IMPLEMENTATION.
  METHOD anonymize.
    DATA o_raw_i     LIKE LINE OF me->interfaces.
    DATA o_interface TYPE to_interface.
    DATA o_raw_p     LIKE LINE OF me->packages.
    DATA o_package   TYPE to_mykind.
    CLEAR:
      me->a0_maindata-created_by,
      me->a0_maindata-created_on,
      me->a0_maindata-changed_by,
      me->a0_maindata-changed_on.
    LOOP AT me->interfaces INTO o_raw_i.
      o_interface ?= o_raw_i-zl_object->raw.
      o_interface->anonymize( ).
    ENDLOOP.
    LOOP AT me->packages INTO o_raw_p.
      o_package ?= o_raw_p-zl_object->raw.
      o_package->anonymize( ).
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
    DATA o_raw_i     LIKE LINE OF me->interfaces.
    DATA o_interface TYPE to_interface.
    DATA o_raw_p     LIKE LINE OF me->packages.
    DATA o_package   TYPE to_mykind.
    IF me->a0_maindata-created_by IS INITIAL. me->a0_maindata-created_by = sy-uname. ENDIF.
    IF me->a0_maindata-created_on IS INITIAL. me->a0_maindata-created_on = sy-datum. ENDIF.
    IF me->a0_maindata-as4user IS INITIAL. me->a0_maindata-as4user = sy-uname. ENDIF. " Person responsible
    LOOP AT me->interfaces INTO o_raw_i.
      o_interface ?= o_raw_i-zl_object->raw.
      o_interface->unanonymize( ).
    ENDLOOP.
    LOOP AT me->packages INTO o_raw_p.
      o_package ?= o_raw_p-zl_object->raw.
      o_package->unanonymize( ).
    ENDLOOP.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_DEVC_DATA implementation
CLASS zaplink_docv_data IMPLEMENTATION.
  METHOD from_data.
    DATA s_text LIKE LINE OF texts.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF fm_data-texts.
    a0_maindata = fm_data-hdr.    a0_maindata-masterlang = a0_maindata-langu.   CLEAR a0_maindata-langu.
    LOOP AT fm_data-texts ASSIGNING <t>.
      CLEAR s_text.   s_text-langu = <t>-tdspras.   s_text-_ = <t>-_.   INSERT s_text INTO TABLE texts.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_text LIKE LINE OF fm_data-texts.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF texts.
    fm_data-hdr = a0_maindata.    fm_data-hdr-langu = a0_maindata-masterlang. fm_data-hdr-masterlang = abap_true.
    LOOP AT texts ASSIGNING <t>.
      CLEAR s_text.   s_text-tdspras = <t>-langu.   s_text-_ = <t>-_.   INSERT s_text INTO TABLE fm_data-texts.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_DOCV_DATA implementation
CLASS zaplink_doma_data IMPLEMENTATION.
  METHOD anonymize.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF texts.
    CLEAR: a0_maindata-as4user, a0_maindata-as4date, a0_maindata-as4time.
    LOOP AT texts ASSIGNING <t>.
      CLEAR: <t>-long_txt-tdfuser, <t>-long_txt-tdfdate, <t>-long_txt-tdftime.
    ENDLOOP.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = doc_ids-header. APPEND _id TO r_doc_ids.
  ENDMETHOD.
  METHOD from_data.
    DATA s_value LIKE LINE OF values.
    DATA s_vtext LIKE LINE OF s_value-texts.
    DATA s_text  LIKE LINE OF texts.
    FIELD-SYMBOLS:
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <vt> LIKE LINE OF fm_data-values_texts,
      <t>  LIKE LINE OF fm_data-texts,
      <v>  LIKE LINE OF fm_data-values.
    a0_maindata-hdr = fm_data-header.
    LOOP AT fm_data-values ASSIGNING <v>.
      CLEAR s_value. s_value-main = <v>. CLEAR s_value-domname.
      LOOP AT fm_data-values_texts ASSIGNING <vt>
        WHERE valpos = <v>-valpos.
        CLEAR s_vtext.
        s_vtext-langu = <vt>-ddlanguage.
        s_vtext-short_txt = <vt>-ddtext.
        INSERT s_vtext INTO TABLE s_value-texts.
      ENDLOOP.
      INSERT s_value INTO TABLE values.
    ENDLOOP.
    LOOP AT fm_data-texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-langu = <t>-ddlanguage.
      s_text-short_txt = <t>-ddtext.
      READ TABLE fm_data-docs ASSIGNING <d>
           WITH KEY id = doc_ids-header
                object = a0_maindata-domname.
      IF sy-subrc = 0.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_text-langu.
        IF sy-subrc = 0.
          s_text-long_txt = <dt>.
          CLEAR s_text-long_txt-tdspras.
        ENDIF.
      ENDIF.
      INSERT s_text INTO TABLE texts.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_value LIKE LINE OF fm_data-values.
    DATA s_vtext LIKE LINE OF fm_data-values_texts.
    DATA s_text  LIKE LINE OF fm_data-texts.
    DATA s_doc   LIKE LINE OF fm_data-docs.
    DATA s_dtxt  LIKE LINE OF s_doc-texts.
    FIELD-SYMBOLS:
      <v>  LIKE LINE OF values,
      <t>  LIKE LINE OF texts,
      <d>  LIKE LINE OF fm_data-docs,
      <vt> LIKE LINE OF <v>-texts.
    fm_data-header = a0_maindata-hdr.
    LOOP AT values ASSIGNING <v>.
      CLEAR s_value. s_value = <v>-main. s_value-domname = fm_data-header-domname.
      INSERT s_value INTO TABLE fm_data-values.
      LOOP AT <v>-texts ASSIGNING <vt>.
        CLEAR s_vtext.
        MOVE-CORRESPONDING <v> TO s_vtext.
        s_vtext-domname = fm_data-header-domname.
        s_vtext-ddlanguage = <vt>-langu.
        s_vtext-as4local = 'A'. " Active
        s_vtext-valpos = <v>-valpos.
        s_vtext-as4vers = '0000'. " Active
        s_vtext-ddtext = <vt>-short_txt.
        INSERT s_vtext INTO TABLE fm_data-values_texts.
      ENDLOOP.
    ENDLOOP.
    LOOP AT texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-domname = fm_data-header-domname.
      s_text-ddlanguage = <t>-langu.
      s_text-as4local = 'A'. " Active
      s_text-as4vers = '0000'. " Active
      s_text-ddtext = <t>-short_txt.
      INSERT s_text INTO TABLE fm_data-texts.
      IF NOT <t>-long_txt IS INITIAL.
        IF fm_data-docs IS INITIAL.
          CLEAR s_doc.
          s_doc-application = 'DOKU'.
          s_doc-id = doc_ids-header.
          s_doc-object = fm_data-header-domname.
          s_doc-langu = <t>-langu.
          s_doc-masterlang = abap_true.
          s_doc-typ = 'T'.
          s_doc-dokform = 'S_DOCU_SHOW'.
          s_doc-dokstyle = 'S_DOCUS1'.
          INSERT s_doc INTO TABLE fm_data-docs.
        ENDIF.
        s_dtxt = <t>-long_txt.
        s_dtxt-tdspras = <t>-langu.
        INSERT s_dtxt INTO TABLE s_doc-texts.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_DOMA_DATA implementation
CLASS zaplink_dtel_data IMPLEMENTATION.
  METHOD anonymize.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF texts.
    CLEAR: a0_maindata-as4user, a0_maindata-as4date, a0_maindata-as4time.
    LOOP AT texts ASSIGNING <t>.
      CLEAR: <t>-long_txt-tdfuser, <t>-long_txt-tdfdate, <t>-long_txt-tdftime.
    ENDLOOP.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = doc_ids-header. APPEND _id TO r_doc_ids.
  ENDMETHOD.
  METHOD from_data.
    DATA s_text  LIKE LINE OF texts.
    FIELD-SYMBOLS:
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <t>  LIKE LINE OF fm_data-texts.
    a0_maindata-hdr = fm_data-header.
    a0_maindata-param = fm_data-param.
    LOOP AT fm_data-texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-langu = <t>-ddlanguage.
      s_text-short_txt = <t>-ddtext.
      READ TABLE fm_data-docs ASSIGNING <d>
           WITH KEY id = doc_ids-header
                object = a0_maindata-rollname.
      IF sy-subrc = 0.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_text-langu.
        IF sy-subrc = 0.
          s_text-long_txt = <dt>.
          CLEAR s_text-long_txt-tdspras.
        ENDIF.
      ENDIF.
      INSERT s_text INTO TABLE texts.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_text  LIKE LINE OF fm_data-texts.
    DATA s_doc   LIKE LINE OF fm_data-docs.
    DATA s_dtxt  LIKE LINE OF s_doc-texts.
    FIELD-SYMBOLS:
      <d> LIKE LINE OF fm_data-docs,
      <t> LIKE LINE OF texts.
    fm_data-header = a0_maindata-hdr.
    LOOP AT texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-rollname = fm_data-header-rollname.
      s_text-ddlanguage = <t>-langu.
      s_text-as4local = 'A'. " Active
      s_text-as4vers = '0000'. " Active
      s_text-ddtext = <t>-short_txt.
      INSERT s_text INTO TABLE fm_data-texts.
      IF NOT <t>-long_txt IS INITIAL.
        IF fm_data-docs IS INITIAL.
          s_doc-application = 'DOKU'.
          s_doc-id = doc_ids-header.
          s_doc-object = fm_data-header-rollname.
          s_doc-langu = <t>-langu.
          s_doc-masterlang = abap_true.
          s_doc-typ = 'T'.
          s_doc-dokform = 'S_DOCU_SHOW'.
          s_doc-dokstyle = 'S_DOCUS1'.
          INSERT s_doc INTO TABLE fm_data-docs.
        ENDIF.
        READ TABLE fm_data-docs ASSIGNING <d> INDEX 1.
        s_dtxt = <t>-long_txt.
        s_dtxt-tdspras = <t>-langu.
        INSERT s_dtxt INTO TABLE <d>-texts.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_DTEL_DATA implementation
CLASS zaplink_enqu_data IMPLEMENTATION.
  METHOD anonymize.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = doc_ids-header. APPEND _id TO r_doc_ids.
  ENDMETHOD.
  METHOD from_data.
    DATA s_text    LIKE LINE OF texts.
    DATA s_field   LIKE LINE OF fields.
    DATA s_table   LIKE LINE OF tables.
    DATA t_docs    TYPE tt_docs.
    FIELD-SYMBOLS:
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <f>  LIKE LINE OF fm_data-fields,
      <ta> LIKE LINE OF fm_data-tables,
      <t>  LIKE LINE OF fm_data-texts.
    a0_maindata-hdr = fm_data-header.   CLEAR a0_maindata-ddtext.
    t_docs = fm_data-docs.
    READ TABLE t_docs ASSIGNING <d>
         WITH KEY id = doc_ids-header
              object = a0_maindata-viewname.
    LOOP AT fm_data-texts ASSIGNING <t>
            WHERE viewname = a0_maindata-viewname.
      CLEAR s_text.   s_text-langu = <t>-ddlanguage.    s_text-short_txt = <t>-ddtext.
      IF <d> IS ASSIGNED.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_text-langu.
        IF sy-subrc = 0.    s_text-long_txt = <dt>.   CLEAR s_text-long_txt-tdspras.    DELETE TABLE <d>-texts FROM <dt>.    ENDIF.
      ENDIF.
      INSERT s_text INTO TABLE texts.
    ENDLOOP.
    IF <d> IS ASSIGNED.
      LOOP AT <d>-texts ASSIGNING <dt>.
        CLEAR s_text.    s_text-langu = <dt>-tdspras.   s_text-long_txt = <dt>.   CLEAR s_text-long_txt-tdspras.    INSERT s_text INTO TABLE texts.
      ENDLOOP.
    ENDIF.
    LOOP AT fm_data-tables ASSIGNING <ta>
            WHERE viewname = a0_maindata-viewname.
      CLEAR s_table.   s_table = <ta>.   CLEAR: s_table-viewname, s_table-ddlanguage, s_table-fordir. ", s_table-forfield.
      IF s_table-tabpos = '0001'.  CLEAR s_table-fortabname.  ENDIF.    " Primary Table
      INSERT s_table INTO TABLE tables.
    ENDLOOP.
    LOOP AT fm_data-fields ASSIGNING <f>
            WHERE viewname = a0_maindata-viewname.
      CLEAR s_field.   MOVE-CORRESPONDING <f> TO s_field.   CLEAR: s_field-keyflag, s_field-rollnamevi, s_field-rollname, s_field-rollchange, s_field-datatype, s_field-flength, s_field-rdonly, s_field-ddtext.
      INSERT s_field INTO TABLE fields.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_txt      LIKE LINE OF fm_data-texts.
    DATA s_doc      LIKE LINE OF fm_data-docs.
    DATA s_doc_txt  LIKE LINE OF s_doc-texts.
    DATA s_field    LIKE LINE OF fm_data-fields.
    DATA s_table    LIKE LINE OF fm_data-tables.
    FIELD-SYMBOLS:
      <d>  LIKE LINE OF fm_data-docs,
      <f>  LIKE LINE OF fields,
      <ta> LIKE LINE OF tables,
      <t>  LIKE LINE OF texts.
    fm_data-header = a0_maindata-hdr.
    s_doc-application = 'DOKU'.   s_doc-id = doc_ids-header.   s_doc-object = fm_data-header-viewname.
    s_doc-masterlang = abap_true.   s_doc-typ = 'E'.    s_doc-dokform = 'S_DOCU_SHOW'.    s_doc-dokstyle = 'S_DOCUS1'.
    LOOP AT texts ASSIGNING <t>.
      IF NOT <t>-short_txt IS INITIAL.    CLEAR s_txt.    s_txt-viewname = fm_data-header-viewname.   s_txt-ddlanguage = <t>-langu.   s_txt-ddtext = <t>-short_txt.   INSERT s_txt INTO TABLE fm_data-texts.    ENDIF.
      IF NOT <t>-long_txt IS INITIAL.
        CLEAR s_doc_txt.    s_doc_txt = <t>-long_txt.   s_doc_txt-tdspras = <t>-langu.    INSERT s_doc_txt INTO TABLE s_doc-texts.
        IF s_doc-langu IS INITIAL.    s_doc-langu = s_doc_txt-tdspras.    ENDIF.
      ENDIF.
    ENDLOOP.
    IF NOT s_doc-texts IS INITIAL.    INSERT s_doc INTO TABLE fm_data-docs.   ENDIF.
    LOOP AT tables ASSIGNING <ta>.
      CLEAR s_table.   s_table = <ta>.   s_table-viewname = a0_maindata-viewname.
      IF s_table-tabpos = '0001'.  s_table-fortabname = s_table-tabname.  ENDIF.    " Primary Table
      INSERT s_table INTO TABLE fm_data-tables.
    ENDLOOP.
    LOOP AT fields ASSIGNING <f>.
      CLEAR s_field.   s_field-objpos = sy-tabix.   MOVE-CORRESPONDING <f> TO s_field.   s_field-keyflag = abap_true.    s_field-viewname = a0_maindata-viewname.
      INSERT s_field INTO TABLE fm_data-fields.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_ENQU_DATA implementation
CLASS zaplink_excc_data IMPLEMENTATION.
ENDCLASS. "ZAPLINK_EXCC_DATA implementation
CLASS zaplink_func_data IMPLEMENTATION.
  METHOD anonymize.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids-group.
    _id-sign = 'I'.
    _id-option = 'EQ'.
    _id-low = doc_ids-group.      APPEND _id TO r_doc_ids-group.
    _id-low = doc_ids-function.   APPEND _id TO r_doc_ids-function.
  ENDMETHOD.
  METHOD from_data.
    DATA s_txt     LIKE LINE OF texts.
    DATA s_param   LIKE LINE OF parameters.
    DATA s_excep   LIKE LINE OF exceptions.
    DATA d_suffix  TYPE rs38l-suffix.
    DATA d_group   TYPE rs38l-area.
    DATA t_abapsrc TYPE tt_abaprawsource.
    DATA d_search  TYPE string.
    DATA d_replace TYPE string.
    DATA d_lcount  TYPE i.
    DATA d_doc     TYPE doku_obj.
    DATA d_doc_p   TYPE ts_doc_param.
    DATA t_docs    TYPE tt_docs.
    FIELD-SYMBOLS:
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <t>  LIKE LINE OF fm_data-texts,
      <s>  LIKE LINE OF fm_data-source,
      <im> LIKE LINE OF fm_data-import_p,
      <ch> LIKE LINE OF fm_data-changing_p,
      <ex> LIKE LINE OF fm_data-export_p,
      <pa> LIKE LINE OF parameters,
      <pt> LIKE LINE OF fm_data-param_texts,
      <cx> LIKE LINE OF fm_data-exceptions,
      <ta> LIKE LINE OF fm_data-tables.
    MOVE-CORRESPONDING fm_data-header TO a0_maindata.
    _code_signature = fm_data-code_signature.
    IF NOT fm_data-source IS INITIAL.
      t_abapsrc = fm_data-source.
      READ TABLE t_abapsrc ASSIGNING <s> INDEX 1.
      TRANSLATE <s> TO UPPER CASE.                        "#EC SYNTCHAR
      IF <s> CP 'FUNCTION *.'.    DELETE t_abapsrc INDEX 1.   ENDIF.
      d_lcount = lines( t_abapsrc ).
      READ TABLE t_abapsrc ASSIGNING <s> INDEX d_lcount.
      TRANSLATE <s> TO UPPER CASE.                        "#EC SYNTCHAR
      IF <s> CP 'ENDFUNCTION*.'.    DELETE t_abapsrc INDEX d_lcount.   ENDIF.
      source-_ = zaplink_function_group=>conv_abap_raw2source( t_abapsrc ).
    ENDIF.
    UNASSIGN <d>.
    READ TABLE t_docs ASSIGNING <d>
         WITH KEY id = doc_ids-function
              object = a0_maindata-name.
    LOOP AT fm_data-texts ASSIGNING <t>
            WHERE funcname = a0_maindata-name.
      CLEAR s_txt.    s_txt-langu = <t>-spras.   s_txt-short_txt = <t>-stext.
      IF <d> IS ASSIGNED.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_txt-langu.
        IF sy-subrc = 0.    s_txt-long_txt = <dt>.   CLEAR s_txt-long_txt-tdspras.    DELETE TABLE <d>-texts FROM <dt>.   ENDIF.
      ENDIF.
      INSERT s_txt INTO TABLE texts.
    ENDLOOP.
    IF <d> IS ASSIGNED.
      LOOP AT <d>-texts ASSIGNING <dt>.
        CLEAR s_txt.    s_txt-langu = <dt>-tdspras.   s_txt-long_txt = <dt>.   CLEAR s_txt-long_txt-tdspras.    INSERT s_txt INTO TABLE texts.
      ENDLOOP.
    ENDIF.
    LOOP AT fm_data-import_p ASSIGNING <im>.
      CLEAR s_param.    s_param-hdr = <im>.    s_param-kind = parameter_kinds-importing.   INSERT s_param INTO TABLE parameters.
    ENDLOOP.
    LOOP AT fm_data-changing_p ASSIGNING <ch>.
      CLEAR s_param.    s_param-hdr = <ch>.    s_param-kind = parameter_kinds-changing.   INSERT s_param INTO TABLE parameters.
    ENDLOOP.
    LOOP AT fm_data-export_p ASSIGNING <ex>.
      CLEAR s_param.    MOVE-CORRESPONDING <ex> TO s_param-hdr.    s_param-kind = parameter_kinds-exporting.   INSERT s_param INTO TABLE parameters.
    ENDLOOP.
    LOOP AT fm_data-tables ASSIGNING <ta>.
      CLEAR s_param.    MOVE-CORRESPONDING <ta> TO s_param-hdr.    s_param-dbfield = <ta>-dbstruct.   s_param-kind = parameter_kinds-table.   INSERT s_param INTO TABLE parameters.
    ENDLOOP.
    d_doc_p-func = a0_maindata-name.
    LOOP AT parameters ASSIGNING <pa>.
      d_doc_p-param = <pa>-parameter.   UNASSIGN <d>.
      READ TABLE t_docs ASSIGNING <d>
           WITH KEY id = doc_ids-function
                object = d_doc_p.
      LOOP AT fm_data-param_texts ASSIGNING <pt>
           WHERE funcname = a0_maindata-name
             AND parameter = <pa>-parameter
             AND kind = 'P'.
        CLEAR s_txt.    s_txt-langu = <pt>-spras.   s_txt-short_txt = <pt>-stext.
        IF <d> IS ASSIGNED.
          READ TABLE <d>-texts ASSIGNING <dt>
              WITH KEY tdspras = s_txt-langu.
          IF sy-subrc = 0.    s_txt-long_txt = <dt>.   CLEAR s_txt-long_txt-tdspras.    DELETE TABLE <d>-texts FROM <dt>.   ENDIF.
        ENDIF.
        INSERT s_txt INTO TABLE <pa>-texts.
      ENDLOOP.
      IF <d> IS ASSIGNED.
        LOOP AT <d>-texts ASSIGNING <dt>.
          CLEAR s_txt.    s_txt-langu = <dt>-tdspras.   s_txt-long_txt = <dt>.   CLEAR s_txt-long_txt-tdspras.    INSERT s_txt INTO TABLE <pa>-texts.
        ENDLOOP.
      ENDIF.
    ENDLOOP.
    LOOP AT fm_data-exceptions ASSIGNING <cx>.
      CLEAR s_excep.    s_excep-hdr = <cx>.
      LOOP AT fm_data-param_texts ASSIGNING <pt>
           WHERE funcname = a0_maindata-name
             AND parameter = <cx>-exception
             AND kind = 'X'.
        CLEAR s_txt.    s_txt-langu = <pt>-spras.   s_txt-short_txt = <pt>-stext.    INSERT s_txt INTO TABLE s_excep-texts.
      ENDLOOP.
      INSERT s_excep INTO TABLE exceptions.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_line    LIKE LINE OF fm_data-source.
    DATA s_txt     LIKE LINE OF fm_data-texts.
    DATA s_f_txt   LIKE LINE OF fm_data-texts.
    DATA s_p_im    LIKE LINE OF fm_data-import_p.
    DATA s_p_ch    LIKE LINE OF fm_data-changing_p.
    DATA s_p_ex    LIKE LINE OF fm_data-export_p.
    DATA s_p_ta    LIKE LINE OF fm_data-tables.
    DATA s_p_txt   LIKE LINE OF fm_data-param_texts.
    DATA s_excep   LIKE LINE OF fm_data-exceptions.
    DATA d_suffix  TYPE rs38l-suffix.
    DATA d_group   TYPE rs38l-area.
    DATA d_search  TYPE string.
    DATA d_replace TYPE string.
    DATA d_lcount  TYPE i.
    DATA s_doc     LIKE LINE OF fm_data-docs.
    DATA s_doc_txt LIKE LINE OF s_doc-texts.
    DATA d_doc_p   TYPE ts_doc_param.
    FIELD-SYMBOLS:
      <ft> LIKE LINE OF texts,
      <s>  LIKE LINE OF fm_data-source,
      <pa> LIKE LINE OF parameters,
      <pt> LIKE LINE OF <pa>-texts,
      <cx> LIKE LINE OF exceptions.
    MOVE-CORRESPONDING a0_maindata TO fm_data-header.
    IF NOT source-_ IS INITIAL.
      fm_data-source = zaplink_function_group=>conv_abap_source2raw( source-_ ).
      READ TABLE fm_data-source ASSIGNING <s> INDEX 1.   TRANSLATE <s> TO UPPER CASE. "#EC SYNTCHAR
      IF NOT <s> CP 'FUNCTION *.'.    CONCATENATE `FUNCTION ` a0_maindata-name '.' INTO s_line.   INSERT s_line INTO fm_data-source INDEX 1.   ENDIF.
      d_lcount = lines( fm_data-source ).    READ TABLE fm_data-source ASSIGNING <s> INDEX d_lcount.    TRANSLATE <s> TO UPPER CASE. "#EC SYNTCHAR
      IF NOT <s> CP 'ENDFUNCTION*.'.    APPEND 'ENDFUNCTION.' TO fm_data-source.   ENDIF.
    ENDIF.
    CLEAR s_doc.    s_doc-application = 'DOKU'.   s_doc-id = doc_ids-function.   s_doc-object = a0_maindata-name.
    s_doc-masterlang = abap_true.   s_doc-typ = 'T'.    s_doc-dokform = 'S_DOCU_SHOW'.    s_doc-dokstyle = 'S_DOCUS1'.
    LOOP AT texts ASSIGNING <ft>.
      IF NOT <ft>-short_txt IS INITIAL.    CLEAR s_f_txt.    s_f_txt-spras = <ft>-langu.   s_f_txt-stext = <ft>-short_txt.   s_f_txt-funcname = a0_maindata-name.   INSERT s_f_txt INTO TABLE fm_data-texts.    ENDIF.
      IF NOT <ft>-long_txt IS INITIAL.
        CLEAR s_doc_txt.    s_doc_txt = <ft>-long_txt.   s_doc_txt-tdspras = <ft>-langu.    INSERT s_doc_txt INTO TABLE s_doc-texts.
        IF s_doc-langu IS INITIAL.    s_doc-langu = s_doc_txt-tdspras.    ENDIF.
      ENDIF.
    ENDLOOP.
    IF NOT s_doc-texts IS INITIAL.    INSERT s_doc INTO TABLE fm_data-docs.   ENDIF.
    LOOP AT parameters ASSIGNING <pa>.
      CASE <pa>-kind.
        WHEN parameter_kinds-importing.
          CLEAR s_p_im.   s_p_im = <pa>-hdr.    INSERT s_p_im INTO TABLE fm_data-import_p.
        WHEN parameter_kinds-changing.
          CLEAR s_p_ch.   s_p_ch = <pa>-hdr.    INSERT s_p_ch INTO TABLE fm_data-changing_p.
        WHEN parameter_kinds-exporting.
          CLEAR s_p_ex.   MOVE-CORRESPONDING <pa>-hdr TO s_p_ex.    INSERT s_p_ex INTO TABLE fm_data-export_p.
        WHEN parameter_kinds-table.
          CLEAR s_p_ta.   MOVE-CORRESPONDING <pa>-hdr TO s_p_ta.    s_p_ta-dbstruct = <pa>-dbfield.    INSERT s_p_ta INTO TABLE fm_data-tables.
        WHEN OTHERS.
      ENDCASE.
      CLEAR: d_doc_p, s_doc.    d_doc_p-func = a0_maindata-name.    d_doc_p-param = <pa>-parameter.    s_doc-application = 'DOKU'.   s_doc-id = doc_ids-function.
      s_doc-object = d_doc_p.   s_doc-masterlang = abap_true.   s_doc-typ = 'T'.    s_doc-dokform = 'S_DOCU_SHOW'.    s_doc-dokstyle = 'S_DOCUS1'.
      LOOP AT <pa>-texts ASSIGNING <pt>.
        IF NOT <pt>-short_txt IS INITIAL.
          CLEAR s_p_txt. s_p_txt-spras = <pt>-langu. s_f_txt-stext = <pt>-short_txt. s_p_txt-funcname = a0_maindata-name. s_p_txt-parameter = <pa>-parameter. s_p_txt-kind = 'P'. INSERT s_p_txt INTO TABLE fm_data-param_texts.
        ENDIF.
        IF NOT <pt>-long_txt IS INITIAL.
          CLEAR s_doc_txt.    s_doc_txt = <pt>-long_txt.   s_doc_txt-tdspras = <pt>-langu.    INSERT s_doc_txt INTO TABLE s_doc-texts.
          IF s_doc-langu IS INITIAL.    s_doc-langu = s_doc_txt-tdspras.    ENDIF.
        ENDIF.
      ENDLOOP.
      IF NOT s_doc-texts IS INITIAL.    INSERT s_doc INTO TABLE fm_data-docs.   ENDIF.
    ENDLOOP.
    LOOP AT exceptions ASSIGNING <cx>.
      CLEAR s_excep.    s_excep = <cx>-hdr.
      LOOP AT <cx>-texts ASSIGNING <pt>.
        CLEAR s_p_txt.    s_p_txt-spras = <pt>-langu.   s_f_txt-stext = <pt>-short_txt.   s_p_txt-funcname = a0_maindata-name.    s_p_txt-parameter = <cx>-exception.   s_p_txt-kind = 'X'.    INSERT s_p_txt INTO TABLE fm_data-param_texts.
      ENDLOOP.
      INSERT s_excep INTO TABLE fm_data-exceptions.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_FUNC_DATA implementation
CLASS zaplink_menupainter_data IMPLEMENTATION.
  METHOD anonymize.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = doc_ids-header. APPEND _id TO r_doc_ids.
  ENDMETHOD.
  METHOD from_data.
    DATA t_tmp   TYPE tt_atrt.
    DATA t_attr  TYPE SORTED TABLE OF rsmpe_atrt WITH UNIQUE KEY obj_code sub_code obj_type.
    DATA s_attr  LIKE LINE OF t_attr.
    DATA t_tmp_m TYPE tt_mnlt.
    DATA t_menus TYPE SORTED TABLE OF rsmpe_mnlt WITH UNIQUE KEY code.
    DATA s_mnu   LIKE LINE OF t_menus.
    DATA s_title LIKE LINE OF titles.
    DATA s_func  LIKE LINE OF functions.
    DATA s_statu LIKE LINE OF status.
    DATA s_s_fu  LIKE LINE OF s_statu-functions.
    DATA s_menu  LIKE LINE OF menu_list.
    DATA s_m_det LIKE LINE OF s_menu-composition.
    DATA s_bar   LIKE LINE OF menu_bars.
    DATA s_b_det LIKE LINE OF s_bar-composition.
    DATA s_key   LIKE LINE OF key_settings.
    DATA s_k_det LIKE LINE OF s_key-keys.
    DATA s_but   LIKE LINE OF s_key-pushbuttons.
    DATA s_u_det LIKE LINE OF s_but-composition.
    FIELD-SYMBOLS:
      <k>  LIKE LINE OF key_settings,
      <at> LIKE LINE OF fm_data-attributes,
      <bd> LIKE LINE OF fm_data-bars_det,
      <kb> LIKE LINE OF fm_data-keyboards,
      <bu> LIKE LINE OF fm_data-buttons_det,
      <sf> LIKE LINE OF fm_data-stat_funcs,
      <st> LIKE LINE OF fm_data-status,
      <mn> LIKE LINE OF fm_data-menus,
      <md> LIKE LINE OF fm_data-menus_det,
      <fu> LIKE LINE OF fm_data-functions,
      <ti> LIKE LINE OF fm_data-titles.
    bar = fm_data-header-actcode.
    menu = fm_data-header-mencode.
    function = fm_data-header-pfkcode.
    default_bar = fm_data-header-defaultact.
    default_function = fm_data-header-defaultpfk.
    master_lang = fm_data-header-mod_langu.
    LOOP AT fm_data-titles ASSIGNING <ti>.
      CLEAR s_title.
      MOVE-CORRESPONDING <ti> TO s_title-hdr.
      s_title-texts = get_texts( texts = fm_data-texts
                              obj_type = obj_types-title
                              obj_code = s_title-code
                              sub_code = space
                              texttype = text_types-tech_info ).
      INSERT s_title INTO TABLE titles.
    ENDLOOP.
    LOOP AT fm_data-functions ASSIGNING <fu>.
      CLEAR s_func.
      MOVE-CORRESPONDING <fu> TO s_func-hdr.
      s_func-texts = get_func_texts( texts = fm_data-texts
                                  obj_code = s_func-code
                                  sub_code = s_func-textno ).
      INSERT s_func INTO TABLE functions.
    ENDLOOP.
    t_tmp_m = fm_data-menus.
    SORT t_tmp_m                                   BY code.
    DELETE ADJACENT DUPLICATES FROM t_tmp_m COMPARING code.
    t_menus = t_tmp_m.
    LOOP AT fm_data-menus_det ASSIGNING <md>.
      READ TABLE t_menus TRANSPORTING NO FIELDS
           WITH TABLE KEY code = <md>-code.
      IF sy-subrc <> 0.
        CLEAR s_mnu.        s_mnu-code = <md>-code.
        INSERT s_mnu INTO TABLE t_menus.
      ENDIF.
    ENDLOOP.
    LOOP AT t_menus ASSIGNING <mn>.
      CLEAR s_menu.
      MOVE-CORRESPONDING <mn> TO s_menu-hdr.
      s_menu-texts = get_texts( texts = fm_data-texts
                             obj_type = obj_types-menu
                             obj_code = s_menu-code
                             sub_code = space
                             texttype = text_types-object ).
      LOOP AT fm_data-menus_det ASSIGNING <md>
              WHERE code = <mn>-code.
        CLEAR s_m_det.
        MOVE-CORRESPONDING <md> TO s_m_det.
        CLEAR: s_m_det-code.
        INSERT s_m_det INTO TABLE s_menu-composition.
      ENDLOOP.
      INSERT s_menu INTO TABLE menu_list.
    ENDLOOP.
    t_tmp = fm_data-attributes.
    SORT t_tmp                                   BY obj_code sub_code obj_type.
    DELETE ADJACENT DUPLICATES FROM t_tmp COMPARING obj_code sub_code obj_type.
    t_attr = t_tmp.
    LOOP AT fm_data-bars_det ASSIGNING <bd>.
      READ TABLE t_attr TRANSPORTING NO FIELDS
           WITH TABLE KEY obj_code = <bd>-code
                          sub_code = space
                          obj_type = obj_types-menu_bar.
      IF sy-subrc <> 0.
        CLEAR s_attr.        s_attr-obj_type = obj_types-menu_bar.         s_attr-obj_code = <bd>-code.
        INSERT s_attr INTO TABLE t_attr.
      ENDIF.
    ENDLOOP.
    LOOP AT fm_data-keyboards ASSIGNING <kb>.
      READ TABLE t_attr TRANSPORTING NO FIELDS
           WITH TABLE KEY obj_code = <kb>-code
                          sub_code = space
                          obj_type = obj_types-key_set.
      IF sy-subrc <> 0.
        CLEAR s_attr.        s_attr-obj_type = obj_types-key_set.         s_attr-obj_code = <kb>-code.
        INSERT s_attr INTO TABLE t_attr.
      ENDIF.
    ENDLOOP.
    LOOP AT fm_data-buttons_det ASSIGNING <bu>.
      READ TABLE t_attr TRANSPORTING NO FIELDS
           WITH TABLE KEY obj_code = <bu>-pfk_code
                          sub_code = <bu>-code
                          obj_type = obj_types-button.
      IF sy-subrc <> 0.
        CLEAR s_attr.        s_attr-obj_type = obj_types-button.         s_attr-obj_code = <bu>-pfk_code.     s_attr-sub_code = <bu>-code.
        INSERT s_attr INTO TABLE t_attr.
      ENDIF.
    ENDLOOP.
    LOOP AT t_attr ASSIGNING <at>.
      CASE <at>-obj_type.
        WHEN obj_types-menu_bar.
          CLEAR s_bar.        MOVE-CORRESPONDING <at> TO s_bar-hdr.
          s_bar-texts = get_texts( texts = fm_data-texts
                                obj_type = obj_types-menu_bar
                                obj_code = s_bar-obj_code
                                sub_code = space
                                texttype = text_types-tech_info ).
          LOOP AT fm_data-bars_det ASSIGNING <bd>
                  WHERE code = <at>-obj_code.
            CLEAR s_b_det.        MOVE-CORRESPONDING <bd> TO s_b_det.         CLEAR: s_b_det-code.
            INSERT s_b_det INTO TABLE s_bar-composition.
          ENDLOOP.
          CLEAR s_bar-obj_type.
          INSERT s_bar INTO TABLE menu_bars.
        WHEN obj_types-key_set.
          CLEAR s_key.          MOVE-CORRESPONDING <at> TO s_key-hdr.
          s_key-texts = get_texts( texts = fm_data-texts
                                obj_type = obj_types-key_set
                                obj_code = s_key-obj_code
                                sub_code = space
                                texttype = text_types-tech_info ).
          LOOP AT fm_data-keyboards ASSIGNING <kb>
                  WHERE code = <at>-obj_code.
            CLEAR s_k_det.          MOVE-CORRESPONDING <kb> TO s_k_det.       CLEAR: s_k_det-code.
            INSERT s_k_det INTO TABLE s_key-keys.
          ENDLOOP.
          CLEAR s_key-obj_type.
          INSERT s_key INTO TABLE key_settings.
        WHEN obj_types-button.
          READ TABLE key_settings ASSIGNING <k>
               WITH TABLE KEY obj_code = <at>-obj_code.
          IF sy-subrc <> 0.
            WRITE:/ 'button without key', <at>-obj_code.
          ELSE.
            CLEAR s_but.        MOVE-CORRESPONDING <at> TO s_but-hdr.
            s_but-texts = get_texts( texts = fm_data-texts
                                  obj_type = obj_types-button
                                  obj_code = s_but-obj_code
                                  sub_code = s_but-sub_code
                                  texttype = text_types-tech_info ).
            LOOP AT fm_data-buttons_det ASSIGNING <bu>
                    WHERE pfk_code = <at>-obj_code
                      AND code = <at>-sub_code.
              CLEAR s_u_det.        MOVE-CORRESPONDING <bu> TO s_u_det.       CLEAR: s_u_det-pfk_code, s_u_det-code.
              INSERT s_u_det INTO TABLE s_but-composition.
            ENDLOOP.
            CLEAR: s_but-obj_type, s_but-obj_code.
            INSERT s_but INTO TABLE <k>-pushbuttons.
          ENDIF.
      ENDCASE.
    ENDLOOP.
    LOOP AT fm_data-status ASSIGNING <st>.
      CLEAR s_statu.     MOVE-CORRESPONDING <st> TO s_statu-hdr.
      s_statu-texts = get_texts( texts = fm_data-texts
                              obj_type = obj_types-status
                              obj_code = s_statu-code
                              sub_code = space
                              texttype = text_types-tech_info ).
      LOOP AT fm_data-stat_funcs ASSIGNING <sf>
              WHERE status = <st>-code.
        s_s_fu = <sf>-function.
        INSERT s_s_fu INTO TABLE s_statu-functions.
      ENDLOOP.
      INSERT s_statu INTO TABLE status.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_func_texts.
    DATA s_txt LIKE LINE OF result.
    FIELD-SYMBOLS:
      <r> LIKE LINE OF result,
      <t> LIKE LINE OF texts.
    LOOP AT texts ASSIGNING <t>
         WHERE obj_type = obj_types-function
           AND obj_code = obj_code
           AND sub_code = sub_code.
      READ TABLE result ASSIGNING <r>
           WITH TABLE KEY langu = <t>-sprsl.
      IF sy-subrc <> 0.
        s_txt-langu = <t>-sprsl.
        INSERT s_txt INTO TABLE result.
        READ TABLE result ASSIGNING <r>
             WITH TABLE KEY langu = <t>-sprsl.
        IF sy-subrc <> 0.
        ENDIF.
      ENDIF.
      CASE <t>-texttype.
        WHEN text_types-object.
          <r>-text = <t>-text.
        WHEN text_types-icon.
          <r>-icon = <t>-text.
        WHEN text_types-quick_info.
          <r>-info = <t>-text.
        WHEN OTHERS.
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_texts.
    DATA s_txt LIKE LINE OF result.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF texts.
    LOOP AT texts ASSIGNING <t>
         WHERE obj_type = obj_type
           AND obj_code = obj_code
           AND sub_code = sub_code
           AND texttype = texttype.
      s_txt-langu = <t>-sprsl.
      s_txt-text = <t>-text.
      INSERT s_txt INTO TABLE result.
    ENDLOOP.
  ENDMETHOD.
  METHOD set_func_texts.
    DATA s_txt LIKE LINE OF result.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF texts.
    LOOP AT texts ASSIGNING <t>.
      CLEAR s_txt.
      s_txt-obj_type = obj_types-function.
      s_txt-obj_code = obj_code.
      s_txt-sub_code = sub_code.
      s_txt-sprsl = <t>-langu.
      s_txt-texttype = text_types-object.     s_txt-text = <t>-text.
      IF NOT s_txt-text IS INITIAL. INSERT s_txt INTO TABLE result. ENDIF.
      s_txt-texttype = text_types-icon.       s_txt-text = <t>-icon.
      IF NOT s_txt-text IS INITIAL. INSERT s_txt INTO TABLE result. ENDIF.
      s_txt-texttype = text_types-quick_info. s_txt-text = <t>-info.
      IF NOT s_txt-text IS INITIAL. INSERT s_txt INTO TABLE result. ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD set_texts.
    DATA s_txt LIKE LINE OF result.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF texts.
    LOOP AT texts ASSIGNING <t>.
      s_txt-obj_type = obj_type.
      s_txt-obj_code = obj_code.
      s_txt-sub_code = sub_code.
      s_txt-texttype = texttype.
      s_txt-sprsl = <t>-langu.
      s_txt-text = <t>-text.
      INSERT s_txt INTO TABLE result.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_title LIKE LINE OF fm_data-titles.
    DATA s_func  LIKE LINE OF fm_data-functions.
    DATA s_statu LIKE LINE OF fm_data-status.
    DATA s_s_fu  LIKE LINE OF fm_data-stat_funcs.
    DATA s_menu  LIKE LINE OF fm_data-menus.
    DATA s_m_det LIKE LINE OF fm_data-menus_det.
    DATA s_attr  LIKE LINE OF fm_data-attributes.
    DATA s_b_det LIKE LINE OF fm_data-bars_det.
    DATA s_k_det LIKE LINE OF fm_data-keyboards.
    DATA s_but   LIKE LINE OF fm_data-buttons_det.
    DATA s_text  LIKE LINE OF fm_data-texts.
    DATA d_lang  TYPE sy-langu.
    FIELD-SYMBOLS:
      <mb> LIKE LINE OF menu_bars,
      <bc> LIKE LINE OF <mb>-composition,
      <ks> LIKE LINE OF key_settings,
      <kk> LIKE LINE OF <ks>-keys,
      <pb> LIKE LINE OF <ks>-pushbuttons,
      <pc> LIKE LINE OF <pb>-composition,
      <st> LIKE LINE OF status,
      <sf> LIKE LINE OF <st>-functions,
      <mn> LIKE LINE OF menu_list,
      <md> LIKE LINE OF <mn>-composition,
      <fu> LIKE LINE OF functions,
      <ti> LIKE LINE OF titles,
      <tl> LIKE LINE OF <fu>-texts,
      <t>  LIKE LINE OF <st>-texts.
    fm_data-header-actcode = bar.
    fm_data-header-mencode = menu.
    fm_data-header-pfkcode = function.
    fm_data-header-defaultact = default_bar.
    fm_data-header-defaultpfk = default_function.
    fm_data-header-mod_langu = d_lang = master_lang.
    IF d_lang IS INITIAL.  d_lang = sy-langu.    ENDIF.
    LOOP AT titles ASSIGNING <ti>.
      CLEAR s_title.        MOVE-CORRESPONDING <ti>-hdr TO s_title.
      INSERT s_title INTO TABLE fm_data-titles.
      CALL METHOD set_texts
        EXPORTING
          obj_type = obj_types-title
          obj_code = s_title-code
          sub_code = space
          texttype = text_types-tech_info
          texts    = <ti>-texts
        CHANGING
          result   = fm_data-texts.
    ENDLOOP.
    LOOP AT functions ASSIGNING <fu>.
      CLEAR s_func.     MOVE-CORRESPONDING <fu>-hdr TO s_func.
      READ TABLE <fu>-texts ASSIGNING <tl> WITH TABLE KEY langu = d_lang.
      IF sy-subrc = 0.    s_func-fun_text = <tl>-text.  s_func-icon_text = <tl>-icon.  s_func-info_text = <tl>-info.  ENDIF.    " Issue 116
      INSERT s_func INTO TABLE fm_data-functions.
      CALL METHOD set_func_texts
        EXPORTING
          obj_code = s_func-code
          sub_code = s_func-textno
          texts    = <fu>-texts
        CHANGING
          result   = fm_data-texts.
    ENDLOOP.
    LOOP AT menu_list ASSIGNING <mn>.
      CLEAR s_menu.     MOVE-CORRESPONDING <mn>-hdr TO s_menu.
      INSERT s_menu INTO TABLE fm_data-menus.
      CALL METHOD set_texts
        EXPORTING
          obj_type = obj_types-menu
          obj_code = s_menu-code
          sub_code = space
          texttype = text_types-object
          texts    = <mn>-texts
        CHANGING
          result   = fm_data-texts.
      LOOP AT <mn>-composition ASSIGNING <md>.
        CLEAR s_m_det.      MOVE-CORRESPONDING <md> TO s_m_det.       s_m_det-code = <mn>-code.
        INSERT s_m_det INTO TABLE fm_data-menus_det.
      ENDLOOP.
    ENDLOOP.
    LOOP AT menu_bars ASSIGNING <mb>.
      CLEAR s_attr.         MOVE-CORRESPONDING <mb>-hdr TO s_attr.    s_attr-obj_type = obj_types-menu_bar.
      READ TABLE <mb>-texts ASSIGNING <t> WITH TABLE KEY langu = d_lang.
      IF sy-subrc = 0.    s_attr-int_note = <t>-text.  ENDIF.
      INSERT s_attr INTO TABLE fm_data-attributes.
      CALL METHOD set_texts
        EXPORTING
          obj_type = obj_types-menu_bar
          obj_code = s_attr-obj_code
          sub_code = space
          texttype = text_types-tech_info
          texts    = <mb>-texts
        CHANGING
          result   = fm_data-texts.
      LOOP AT <mb>-composition ASSIGNING <bc>.
        CLEAR s_b_det.      MOVE-CORRESPONDING <bc> TO s_b_det.       s_b_det-code = <mb>-obj_code.
        INSERT s_b_det INTO TABLE fm_data-bars_det.
      ENDLOOP.
    ENDLOOP.
    LOOP AT key_settings ASSIGNING <ks>.
      CLEAR s_attr.         MOVE-CORRESPONDING <ks>-hdr TO s_attr.    s_attr-obj_type = obj_types-key_set.
      READ TABLE <ks>-texts ASSIGNING <t> WITH TABLE KEY langu = d_lang.
      IF sy-subrc = 0.    s_attr-int_note = <t>-text.  ENDIF.
      INSERT s_attr INTO TABLE fm_data-attributes.
      CALL METHOD set_texts
        EXPORTING
          obj_type = obj_types-key_set
          obj_code = s_attr-obj_code
          sub_code = space
          texttype = text_types-tech_info
          texts    = <ks>-texts
        CHANGING
          result   = fm_data-texts.
      LOOP AT <ks>-keys ASSIGNING <kk>.
        CLEAR s_k_det.      MOVE-CORRESPONDING <kk> TO s_k_det.       s_k_det-code = <ks>-obj_code.
        INSERT s_k_det INTO TABLE fm_data-keyboards.
      ENDLOOP.
      LOOP AT <ks>-pushbuttons ASSIGNING <pb>.
        CLEAR s_attr.       MOVE-CORRESPONDING <pb> TO s_attr.        s_attr-obj_type = obj_types-button.       s_attr-obj_code = <ks>-obj_code.
        READ TABLE <pb>-texts ASSIGNING <t> WITH TABLE KEY langu = d_lang.
        IF sy-subrc = 0.    s_attr-int_note = <t>-text.  ENDIF.
        INSERT s_attr INTO TABLE fm_data-attributes.
        CALL METHOD set_texts
          EXPORTING
            obj_type = obj_types-button
            obj_code = s_attr-obj_code
            sub_code = s_attr-sub_code
            texttype = text_types-tech_info
            texts    = <pb>-texts
          CHANGING
            result   = fm_data-texts.
        LOOP AT <pb>-composition ASSIGNING <pc>.
          CLEAR s_but.      MOVE-CORRESPONDING <pc> TO s_but.         s_but-pfk_code = <ks>-obj_code.        s_but-code = <pb>-sub_code.
          INSERT s_but INTO TABLE fm_data-buttons_det.
        ENDLOOP.
      ENDLOOP.
    ENDLOOP.
    LOOP AT status ASSIGNING <st>.
      CLEAR s_statu.        MOVE-CORRESPONDING <st>-hdr TO s_statu.
      READ TABLE <st>-texts ASSIGNING <t> WITH TABLE KEY langu = d_lang.
      IF sy-subrc = 0.    s_statu-int_note = <t>-text.  ENDIF.
      INSERT s_statu INTO TABLE fm_data-status.
      CALL METHOD set_texts
        EXPORTING
          obj_type = obj_types-status
          obj_code = s_statu-code
          sub_code = space
          texttype = text_types-tech_info
          texts    = <st>-texts
        CHANGING
          result   = fm_data-texts.
      LOOP AT <st>-functions ASSIGNING <sf>.
        CLEAR s_s_fu.     s_s_fu-status = <st>-code.      s_s_fu-function = <sf>.
        INSERT s_s_fu INTO TABLE fm_data-stat_funcs.
      ENDLOOP.
    ENDLOOP.
    s_text-progname = program.
    MODIFY fm_data-texts FROM s_text TRANSPORTING progname WHERE progname <> program.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_MENUPAINTER_DATA implementation
CLASS zaplink_msag_data IMPLEMENTATION.
  METHOD anonymize.
    DATA s_msg LIKE LINE OF messages.
    CLEAR:
      a0_maindata-lastuser,
      a0_maindata-ldate,
      a0_maindata-ltime.
    MODIFY messages FROM s_msg TRANSPORTING name datum
           WHERE NOT msgnr IS INITIAL OR msgnr IS INITIAL.
  ENDMETHOD.
  METHOD unanonymize.
    DATA s_msg LIKE LINE OF messages.
    IF a0_maindata-respuser IS INITIAL. a0_maindata-respuser = sy-uname. ENDIF.
    s_msg-name = a0_maindata-respuser.
    MODIFY messages FROM s_msg TRANSPORTING name WHERE name IS INITIAL.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_MSAG_DATA implementation
CLASS zaplink_opt_base IMPLEMENTATION.
ENDCLASS. "ZAPLINK_OPT_BASE implementation
CLASS zaplink_pinf_data IMPLEMENTATION.
  METHOD anonymize.
    CLEAR:
      me->a0_maindata-created_by,
      me->a0_maindata-created_on,
      me->a0_maindata-changed_by,
      me->a0_maindata-changed_on.
  ENDMETHOD.
  METHOD unanonymize.
    IF me->a0_maindata-created_by IS INITIAL. me->a0_maindata-created_by = sy-uname. ENDIF.
    IF me->a0_maindata-created_on IS INITIAL. me->a0_maindata-created_on = sy-datum. ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_PINF_DATA implementation
CLASS zaplink_shlp_data IMPLEMENTATION.
  METHOD anonymize.
    FIELD-SYMBOLS   <s> LIKE LINE OF sub_search_helps.
    CLEAR: a0_maindata-as4user, a0_maindata-as4date, a0_maindata-as4time.
    LOOP AT sub_search_helps ASSIGNING <s>.
      IF <s>-zl_object IS BOUND.    <s>-zl_object->anonymize( ).    ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = doc_ids-header. APPEND _id TO r_doc_ids.
  ENDMETHOD.
  METHOD from_data.
    DATA s_text    LIKE LINE OF texts.
    DATA s_param   LIKE LINE OF params.
    DATA s_ssh     LIKE LINE OF sub_search_helps.
    DATA s_sshp    LIKE LINE OF s_ssh-params.
    DATA t_docs    TYPE tt_docs.
    FIELD-SYMBOLS:
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <s>  LIKE LINE OF fm_data-sub_sh,
      <sp> LIKE LINE OF fm_data-ssh_params,
      <t>  LIKE LINE OF fm_data-texts.
    a0_maindata-hdr = fm_data-header.   CLEAR a0_maindata-ddtext.
    params = fm_data-fields.    MODIFY params FROM s_param TRANSPORTING shlpname WHERE table_line IS NOT INITIAL.
    t_docs = fm_data-docs.
    READ TABLE t_docs ASSIGNING <d>
         WITH KEY id = doc_ids-header
              object = a0_maindata-shlpname.
    LOOP AT fm_data-texts ASSIGNING <t>
            WHERE shlpname = a0_maindata-shlpname.
      CLEAR s_text.   s_text-langu = <t>-ddlanguage.    s_text-short_txt = <t>-ddtext.
      IF <d> IS ASSIGNED.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_text-langu.
        IF sy-subrc = 0.    s_text-long_txt = <dt>.   CLEAR s_text-long_txt-tdspras.    DELETE TABLE <d>-texts FROM <dt>.    ENDIF.
      ENDIF.
      INSERT s_text INTO TABLE texts.
    ENDLOOP.
    IF <d> IS ASSIGNED.
      LOOP AT <d>-texts ASSIGNING <dt>.
        CLEAR s_text.    s_text-langu = <dt>-tdspras.   s_text-long_txt = <dt>.   CLEAR s_text-long_txt-tdspras.    INSERT s_text INTO TABLE texts.
      ENDLOOP.
    ENDIF.
    LOOP AT fm_data-sub_sh ASSIGNING <s>
            WHERE shlpname = a0_maindata-shlpname.
      CLEAR s_ssh.   s_ssh-hdr = <s>.   CLEAR s_ssh-shlpname.
      IF s_ssh-viashlp = a0_maindata-shlpname.  CLEAR s_ssh-viashlp.  ENDIF.
      LOOP AT fm_data-ssh_params ASSIGNING <sp>
              WHERE shlpname = a0_maindata-shlpname
                AND subshlp = s_ssh-subshlp.
        CLEAR s_sshp.   s_sshp = <sp>.    CLEAR: s_sshp-shlpname, s_sshp-subshlp, s_sshp-valuedirec.    "auto determinded
        INSERT s_sshp INTO TABLE s_ssh-params.
      ENDLOOP.
      DELETE s_ssh-params WHERE fieldname IS INITIAL.
      INSERT s_ssh INTO TABLE sub_search_helps.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_txt      LIKE LINE OF fm_data-texts.
    DATA s_field    LIKE LINE OF fm_data-fields.
    DATA s_doc      LIKE LINE OF fm_data-docs.
    DATA s_doc_txt  LIKE LINE OF s_doc-texts.
    DATA s_ssh      LIKE LINE OF fm_data-sub_sh.
    DATA s_sshp     LIKE LINE OF fm_data-ssh_params.
    FIELD-SYMBOLS:
      <d>  LIKE LINE OF fm_data-docs,
      <s>  LIKE LINE OF sub_search_helps,
      <sp> LIKE LINE OF <s>-params,
      <t>  LIKE LINE OF texts.
    fm_data-header = a0_maindata-hdr.
    s_field-shlpname = fm_data-header-shlpname.   fm_data-fields = params.    MODIFY fm_data-fields FROM s_field TRANSPORTING shlpname WHERE table_line IS NOT INITIAL.
    s_doc-application = 'DOKU'.   s_doc-id = doc_ids-header.   s_doc-object = fm_data-header-shlpname.
    s_doc-masterlang = abap_true.   s_doc-typ = 'E'.    s_doc-dokform = 'S_DOCU_SHOW'.    s_doc-dokstyle = 'S_DOCUS1'.
    LOOP AT texts ASSIGNING <t>.
      IF NOT <t>-short_txt IS INITIAL.    CLEAR s_txt.    s_txt-shlpname = fm_data-header-shlpname.   s_txt-ddlanguage = <t>-langu.   s_txt-ddtext = <t>-short_txt.   INSERT s_txt INTO TABLE fm_data-texts.    ENDIF.
      IF NOT <t>-long_txt IS INITIAL.
        CLEAR s_doc_txt.    s_doc_txt = <t>-long_txt.   s_doc_txt-tdspras = <t>-langu.    INSERT s_doc_txt INTO TABLE s_doc-texts.
        IF s_doc-langu IS INITIAL.    s_doc-langu = s_doc_txt-tdspras.    ENDIF.
      ENDIF.
    ENDLOOP.
    IF NOT s_doc-texts IS INITIAL.    INSERT s_doc INTO TABLE fm_data-docs.   ENDIF.
    LOOP AT sub_search_helps ASSIGNING <s>.
      CLEAR s_ssh.   s_ssh = <s>-hdr.   s_ssh-shlpname = a0_maindata-shlpname.
      IF s_ssh-viashlp IS INITIAL.    s_ssh-viashlp = a0_maindata-shlpname.  ENDIF.
      INSERT s_ssh INTO TABLE fm_data-sub_sh.
      LOOP AT <s>-params ASSIGNING <sp>.
        CLEAR s_sshp.   s_sshp = <sp>.    s_sshp-shlpname = a0_maindata-shlpname.   s_sshp-subshlp = <s>-subshlp.
        INSERT s_sshp INTO TABLE fm_data-ssh_params.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_SHLP_DATA implementation
CLASS zaplink_ttyp_data IMPLEMENTATION.
  METHOD anonymize.
    FIELD-SYMBOLS   <t> LIKE LINE OF texts.
    CLEAR: a0_maindata-as4user, a0_maindata-as4date, a0_maindata-as4time.
    LOOP AT texts ASSIGNING <t>.    CLEAR: <t>-long_txt-tdfuser, <t>-long_txt-tdfdate, <t>-long_txt-tdftime.    ENDLOOP.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = doc_ids-header. APPEND _id TO r_doc_ids.
  ENDMETHOD.
  METHOD from_data.
    DATA s_text    LIKE LINE OF texts.
    DATA s_key     LIKE LINE OF keys.
    DATA t_docs    TYPE tt_docs.
    FIELD-SYMBOLS:
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <t>  LIKE LINE OF fm_data-texts.
    a0_maindata-hdr = fm_data-header.   CLEAR a0_maindata-ddtext.
    keys = fm_data-keys.    MODIFY keys FROM s_key TRANSPORTING typename rowtypepos WHERE table_line IS NOT INITIAL.
    t_docs = fm_data-docs.
    READ TABLE t_docs ASSIGNING <d>
         WITH KEY id = doc_ids-header
              object = a0_maindata-typename.
    LOOP AT fm_data-texts ASSIGNING <t>.
      CLEAR s_text.   s_text-langu = <t>-ddlanguage.    s_text-short_txt = <t>-ddtext.
      IF <d> IS ASSIGNED.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_text-langu.
        IF sy-subrc = 0.    s_text-long_txt = <dt>.   CLEAR s_text-long_txt-tdspras.    DELETE TABLE <d>-texts FROM <dt>.    ENDIF.
      ENDIF.
      INSERT s_text INTO TABLE texts.
    ENDLOOP.
    IF <d> IS ASSIGNED.
      LOOP AT <d>-texts ASSIGNING <dt>.
        CLEAR s_text.    s_text-langu = <dt>-tdspras.   s_text-long_txt = <dt>.   CLEAR s_text-long_txt-tdspras.    INSERT s_text INTO TABLE texts.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD to_data.
    DATA s_txt      LIKE LINE OF fm_data-texts.
    DATA s_key      LIKE LINE OF fm_data-keys.
    DATA s_doc      LIKE LINE OF fm_data-docs.
    DATA s_doc_txt  LIKE LINE OF s_doc-texts.
    FIELD-SYMBOLS:
      <d> LIKE LINE OF fm_data-docs,
      <t> LIKE LINE OF texts.
    fm_data-header = a0_maindata-hdr.
    s_key-typename = fm_data-header-typename.   fm_data-keys = keys.    MODIFY fm_data-keys FROM s_key TRANSPORTING typename WHERE table_line IS NOT INITIAL.
    s_doc-application = 'DOKU'.   s_doc-id = doc_ids-header.   s_doc-object = fm_data-header-typename.
    s_doc-masterlang = abap_true.   s_doc-typ = 'E'.    s_doc-dokform = 'S_DOCU_SHOW'.    s_doc-dokstyle = 'S_DOCUS1'.
    LOOP AT texts ASSIGNING <t>.
      IF NOT <t>-short_txt IS INITIAL.    CLEAR s_txt.    s_txt-typename = fm_data-header-typename.   s_txt-ddlanguage = <t>-langu.   s_txt-ddtext = <t>-short_txt.   INSERT s_txt INTO TABLE fm_data-texts.    ENDIF.
      IF NOT <t>-long_txt IS INITIAL.
        CLEAR s_doc_txt.    s_doc_txt = <t>-long_txt.   s_doc_txt-tdspras = <t>-langu.    INSERT s_doc_txt INTO TABLE s_doc-texts.
        IF s_doc-langu IS INITIAL.    s_doc-langu = s_doc_txt-tdspras.    ENDIF.
      ENDIF.
    ENDLOOP.
    IF NOT s_doc-texts IS INITIAL.    INSERT s_doc INTO TABLE fm_data-docs.   ENDIF.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_TTYP_DATA implementation
CLASS zaplink_type_data IMPLEMENTATION.
  METHOD anonymize.
  ENDMETHOD.
  METHOD get_source.
    SPLIT me->source AT cl_abap_char_utilities=>newline
            INTO TABLE source.
  ENDMETHOD.
  METHOD set_source.
    me->source = zaplink_tools=>table_2_string( source ).
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_TYPE_DATA implementation
CLASS zaplink_vari_data IMPLEMENTATION.
  METHOD anonymize.
    CLEAR: a0_maindata-mandt, a0_maindata-ename, a0_maindata-edat, a0_maindata-etime, a0_maindata-aename, a0_maindata-aedat, a0_maindata-aetime.
  ENDMETHOD.
  METHOD from_data.
    DATA s_txt     LIKE LINE OF texts.
    DATA t_docs    TYPE tt_docs.
    DATA s_value   LIKE LINE OF values.
    DATA s_scr     LIKE LINE OF screens.
    FIELD-SYMBOLS:
      <s> LIKE LINE OF fm_data-screens,
      <t> LIKE LINE OF fm_data-texts.
    a0_maindata = fm_data-header.
    values = fm_data-params.
    MODIFY values FROM s_value TRANSPORTING olen  from  to  text kind WHERE name <> space OR name = space.
    MODIFY values FROM s_value TRANSPORTING vname WHERE vtype = space.
    LOOP AT fm_data-texts ASSIGNING <t>.
      CLEAR s_txt.    s_txt-lang = <t>-langu.   s_txt-text = <t>-vtext.
      INSERT s_txt INTO TABLE texts.
    ENDLOOP.
    screens = fm_data-screens.
  ENDMETHOD.
  METHOD key_2_name.
    result = data.
  ENDMETHOD.
  METHOD name_2_key.
    result = data.
  ENDMETHOD.
  METHOD to_data.
    DATA s_txt     LIKE LINE OF fm_data-texts.
    DATA s_scr     LIKE LINE OF fm_data-screens.
    FIELD-SYMBOLS:
      <s> LIKE LINE OF screens,
      <t> LIKE LINE OF texts.
    fm_data-header = a0_maindata.
    fm_data-params = values.
    LOOP AT texts ASSIGNING <t>.
      CLEAR s_txt.    s_txt-mandt = a0_maindata-mandt.    s_txt-report = a0_maindata-report.    s_txt-variant = a0_maindata-variant.    s_txt-langu = <t>-lang.   s_txt-vtext = <t>-text.
      INSERT s_txt INTO TABLE fm_data-texts.
    ENDLOOP.
    fm_data-screens = screens.
  ENDMETHOD.
  METHOD unanonymize.
    a0_maindata-ename = a0_maindata-aename = sy-uname.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_VARI_DATA implementation
CLASS zaplink_view_data IMPLEMENTATION.
  METHOD anonymize.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF texts.
    CLEAR: a0_maindata-as4user, a0_maindata-as4date, a0_maindata-as4time,
           a0_maindata-technical_settings-as4user, a0_maindata-technical_settings-as4date, a0_maindata-technical_settings-as4time.
    LOOP AT texts ASSIGNING <t>.
      CLEAR: <t>-long_txt-tdfuser, <t>-long_txt-tdfdate, <t>-long_txt-tdftime.
    ENDLOOP.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = doc_ids-header. APPEND _id TO r_doc_ids.
  ENDMETHOD.
  METHOD from_data.
    DATA s_text  LIKE LINE OF texts.
    DATA s_table LIKE LINE OF tables.
    DATA s_field LIKE LINE OF fields.
    DATA s_join  LIKE LINE OF inner_join.
    DATA s_where LIKE LINE OF conditions.
    FIELD-SYMBOLS:
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <t>  LIKE LINE OF fm_data-texts.
    a0_maindata-hdr = fm_data-header.
    a0_maindata-technical_settings = fm_data-tech.
    CLEAR: a0_maindata-technical_settings-tabname,
           a0_maindata-technical_settings-as4local,
           a0_maindata-technical_settings-as4vers.
    LOOP AT fm_data-texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-langu = <t>-ddlanguage.
      s_text-short_txt = <t>-ddtext.
      READ TABLE fm_data-docs ASSIGNING <d>
           WITH KEY id = doc_ids-header
                object = a0_maindata-viewname.
      IF sy-subrc = 0.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_text-langu.
        IF sy-subrc = 0.
          s_text-long_txt = <dt>.
          CLEAR s_text-long_txt-tdspras.
        ENDIF.
      ENDIF.
      INSERT s_text INTO TABLE texts.
    ENDLOOP.
    tables = fm_data-tables.
    MODIFY tables FROM s_table TRANSPORTING viewname WHERE NOT viewname IS INITIAL.
    fields = fm_data-fields.
    MODIFY fields FROM s_field TRANSPORTING viewname WHERE NOT viewname IS INITIAL.
    inner_join = fm_data-joins.
    MODIFY inner_join FROM s_join TRANSPORTING viewname WHERE NOT viewname IS INITIAL.
    conditions = fm_data-wheres.
    MODIFY conditions FROM s_where TRANSPORTING condname WHERE NOT condname IS INITIAL.
  ENDMETHOD.
  METHOD to_data.
    DATA s_text  LIKE LINE OF fm_data-texts.
    DATA s_doc   LIKE LINE OF fm_data-docs.
    DATA s_dtxt  LIKE LINE OF s_doc-texts.
    DATA s_table LIKE LINE OF fm_data-tables.
    DATA s_field LIKE LINE OF fm_data-fields.
    DATA s_join  LIKE LINE OF fm_data-joins.
    DATA s_where LIKE LINE OF fm_data-wheres.
    FIELD-SYMBOLS:
      <d> LIKE LINE OF fm_data-docs,
      <t> LIKE LINE OF texts.
    fm_data-header = a0_maindata-hdr.
    fm_data-tech = a0_maindata-technical_settings.
    fm_data-tech-tabname = a0_maindata-viewname.
    fm_data-tech-as4local = a0_maindata-as4local.
    fm_data-tech-as4vers = a0_maindata-as4vers.
    LOOP AT texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-viewname = fm_data-header-viewname.
      s_text-ddlanguage = <t>-langu.
      s_text-as4local = 'A'. " Active
      s_text-as4vers = '0000'. " Active
      s_text-ddtext = <t>-short_txt.
      INSERT s_text INTO TABLE fm_data-texts.
      IF NOT <t>-long_txt IS INITIAL.
        IF fm_data-docs IS INITIAL.
          s_doc-application = 'DOKU'.
          s_doc-id = doc_ids-header.
          s_doc-object = fm_data-header-viewname.
          s_doc-langu = <t>-langu.
          s_doc-masterlang = abap_true.
          s_doc-typ = 'E'.
          s_doc-dokform = 'S_DOCU_SHOW'.
          s_doc-dokstyle = 'S_DOCUS1'.
          INSERT s_doc INTO TABLE fm_data-docs.
        ENDIF.
        READ TABLE fm_data-docs ASSIGNING <d> INDEX 1.
        s_dtxt = <t>-long_txt.
        s_dtxt-tdspras = <t>-langu.
        INSERT s_dtxt INTO TABLE <d>-texts.
      ENDIF.
    ENDLOOP.
    fm_data-tables = tables.        s_table-viewname = a0_maindata-viewname.
    MODIFY fm_data-tables FROM s_table TRANSPORTING viewname WHERE viewname <> s_table-viewname.
    fm_data-fields = fields.        s_field-viewname = a0_maindata-viewname.
    MODIFY fm_data-fields FROM s_field TRANSPORTING viewname WHERE viewname <> s_field-viewname.
    fm_data-joins = inner_join.     s_join-viewname = a0_maindata-viewname.
    MODIFY fm_data-joins FROM s_join TRANSPORTING viewname WHERE viewname <> s_join-viewname.
    fm_data-wheres = conditions.    s_where-condname = a0_maindata-viewname.
    MODIFY fm_data-wheres FROM s_where TRANSPORTING condname WHERE condname <> s_where-condname.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_VIEW_DATA implementation
CLASS zaplink_cx_component IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    me->name = name .
    me->type = type .
    me->connclass = connclass .
    me->objtype = objtype .
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_component .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_COMPONENT implementation
CLASS zaplink_cx_connector IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    me->name = name .
    me->type = type .
    me->devclass = devclass .
    me->connclass = connclass .
    me->connuuid = connuuid .
    me->node_name = node_name .
    me->conn_ver = conn_ver .
    me->otherclass = otherclass .
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_connector .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_CONNECTOR implementation
CLASS zaplink_cx_container IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    me->name = name .
    me->type = type .
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_container .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_CONTAINER implementation
CLASS zaplink_cx_file IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    me->filename = filename .
    me->filetype = filetype .
    me->filekind = filekind .
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_file .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_FILE implementation
CLASS zaplink_cx_gui IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    me->type = type .
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_gui .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_GUI implementation
CLASS zaplink_cx_import_not_allowed IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_import_not_allowed .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_IMPORT_NOT_ALLOWED implementation
CLASS zaplink_cx_installer_create IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    me->installer_name = installer_name .
    me->master_name = master_name .
    me->include_name = include_name .
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_installer_create .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_INSTALLER_CREATE implementation
CLASS zaplink_cx_list IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    me->name = name .
    me->type = type .
    me->connclass = connclass .
    me->sel_action = sel_action .
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_list .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_LIST implementation
CLASS zaplink_cx_options IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_options .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_OPTIONS implementation
CLASS zaplink_cx_opt_devclass IMPLEMENTATION.
  METHOD class_constructor.
    opt_cat = 'Package'(cat).
  ENDMETHOD.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    me->substkind = substkind .
    me->devclass = devclass .
    me->opt_cat = opt_cat .
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_opt_devclass .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_OPT_DEVCLASS implementation
CLASS zaplink_cx_opt_transport_req IMPLEMENTATION.
  METHOD class_constructor.
    opt_cat = 'Transport Request'(cat).
  ENDMETHOD.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    me->substkind = substkind .
    me->transport_request = transport_request .
    me->opt_cat = opt_cat .
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zaplink_cx_opt_transport_req .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_OPT_TRANSPORT_REQ implementation
CLASS zaplink_cx_release IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack.
    me->master_program = master_program .
    me->target_program = target_program .
    CLEAR me->textid.
    IF textid IS INITIAL AND me->if_t100_message~t100key IS INITIAL.
      if_t100_message~t100key = if_t100_message=>default_textid.
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CX_RELEASE implementation
CLASS zaplink_file IMPLEMENTATION.
  METHOD class_constructor.
    CALL METHOD cl_gui_frontend_services=>get_file_separator
      CHANGING
        file_separator       = file_sep
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        not_supported_by_gui = 3
        OTHERS               = 4.
    IF sy-subrc <> 0.
      file_sep = '\'.
    ENDIF.
  ENDMETHOD.
  METHOD delete.
    DATA d_rc TYPE i.
    DATA cx   TYPE REF TO cx_root.
    IF _filetype = c_ft_local.
      CALL METHOD cl_gui_frontend_services=>file_delete
        EXPORTING
          filename             = _filename
        CHANGING
          rc                   = d_rc
        EXCEPTIONS
          access_denied        = 1
          cntl_error           = 2
          error_no_gui         = 3
          file_delete_failed   = 4
          file_not_found       = 5
          not_supported_by_gui = 6
          unknown_error        = 7
          wrong_parameter      = 8
          OTHERS               = 9.
      IF d_rc <> 0 AND sy-subrc = 0.     sy-subrc = 9.   ENDIF.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = 'CL_GUI_FRONTEND_SERVICES'
                                                         method = 'FILE_DELETE'
                                                          subrc = sy-subrc
                                                   cx_classname = 'ZAPLINK_CX_FILE' ).
        RAISE EXCEPTION o_mycx.
      ENDIF.
    ELSEIF _filetype = c_ft_server.
      TRY.
          DELETE DATASET _filename.
        CATCH cx_root INTO cx.
          CREATE OBJECT o_mycx
            EXPORTING
              textid   = zaplink_cx_file=>delete_error
              filename = _filename
              filetype = _filetype
              previous = cx.
          o_mycx->update( ).
          RAISE EXCEPTION o_mycx.
      ENDTRY.
      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE zaplink_cx_file
          EXPORTING
            textid   = zaplink_cx_file=>delete_error
            filename = _filename
            filetype = _filetype
            cx_name  = 'DELETE DATASET'.
      ENDIF.
    ELSE.
      RAISE EXCEPTION TYPE zaplink_cx_file
        EXPORTING
          textid   = zaplink_cx_file=>invalid_filetype
          filetype = _filetype.
    ENDIF.
  ENDMETHOD.
  METHOD file_exists.
    DATA tmptable TYPE table_of_strings.
    DATA cx_name TYPE string.
    DATA cx TYPE REF TO cx_root.
    DATA _str LIKE LINE OF tmptable.
    FIELD-SYMBOLS:
      <s> LIKE LINE OF tmptable.
    CASE _filetype.
      WHEN c_ft_local.
        CALL METHOD cl_gui_frontend_services=>file_exist
          EXPORTING
            file                 = _filename
          RECEIVING
            result               = result
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            not_supported_by_gui = 3
            wrong_parameter      = 4
            OTHERS               = 5.
        IF sy-subrc <> 0.
          o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = 'CL_GUI_FRONTEND_SERVICES'
                                                           method = 'FILE_EXIST'
                                                            subrc = sy-subrc
                                                           textid = zaplink_cx_file=>load_error
                                                     cx_classname = 'ZAPLINK_CX_FILE' ).
          RAISE EXCEPTION o_mycx.
        ENDIF.
      WHEN c_ft_server.
        TRY.
            OPEN DATASET _filename FOR INPUT IN TEXT MODE ENCODING DEFAULT.
          CATCH cx_root INTO cx.
            CREATE OBJECT o_mycx
              EXPORTING
                textid   = zaplink_cx_file=>load_error
                filename = _filename
                filetype = _filetype
                previous = cx.
            o_mycx->update( ).
            RAISE EXCEPTION o_mycx.
        ENDTRY.
        IF sy-subrc <> 0.
          result = abap_false.
          EXIT.
        ENDIF.
        result = abap_true.
        TRY.
            CLOSE DATASET _filename.
          CATCH cx_root INTO cx.
            EXIT.
        ENDTRY.
      WHEN OTHERS.
        RAISE EXCEPTION TYPE zaplink_cx_file
          EXPORTING
            textid   = zaplink_cx_file=>invalid_filetype
            filetype = _filetype.
    ENDCASE.
  ENDMETHOD.
  METHOD get_filecontent.
    result = _content.
  ENDMETHOD.
  METHOD get_filename.
    result = _filename.
  ENDMETHOD.
  METHOD get_filetype.
    result = _filetype.
  ENDMETHOD.
  METHOD get_temp_directory.
    DATA d_is_ok   TYPE abap_bool.
    IF _filetype = c_ft_local.
      CALL METHOD cl_gui_frontend_services=>get_temp_directory
        CHANGING
          temp_dir             = result
        EXCEPTIONS
          cntl_error           = 1
          error_no_gui         = 2
          not_supported_by_gui = 3
          OTHERS               = 4.
      IF sy-subrc = 0.
        CALL METHOD cl_gui_frontend_services=>directory_exist
          EXPORTING
            directory            = result
          RECEIVING
            result               = d_is_ok
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            wrong_parameter      = 3
            not_supported_by_gui = 4
            OTHERS               = 5.
        IF sy-subrc <> 0 OR d_is_ok IS INITIAL.
          CLEAR result.
        ENDIF.
      ENDIF.
      IF result IS INITIAL.
        CALL METHOD cl_gui_frontend_services=>get_sapgui_workdir
          CHANGING
            sapworkdir           = result
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            not_supported_by_gui = 3
            OTHERS               = 4.
        IF sy-subrc = 0.
          CALL METHOD cl_gui_frontend_services=>directory_exist
            EXPORTING
              directory            = result
            RECEIVING
              result               = d_is_ok
            EXCEPTIONS
              cntl_error           = 1
              error_no_gui         = 2
              wrong_parameter      = 3
              not_supported_by_gui = 4
              OTHERS               = 5.
          IF sy-subrc <> 0 OR d_is_ok IS INITIAL.
            CLEAR result.
          ENDIF.
        ENDIF.
      ENDIF.
      IF result IS INITIAL.
        CALL METHOD cl_gui_frontend_services=>get_desktop_directory
          CHANGING
            desktop_directory    = result
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            not_supported_by_gui = 3
            OTHERS               = 4.
        IF sy-subrc = 0.
          CALL METHOD cl_gui_frontend_services=>directory_exist
            EXPORTING
              directory            = result
            RECEIVING
              result               = d_is_ok
            EXCEPTIONS
              cntl_error           = 1
              error_no_gui         = 2
              wrong_parameter      = 3
              not_supported_by_gui = 4
              OTHERS               = 5.
          IF sy-subrc <> 0 OR d_is_ok IS INITIAL.
            CLEAR result.
          ENDIF.
        ENDIF.
      ENDIF.
    ELSEIF _filetype = c_ft_server.
    ELSE.
      RAISE EXCEPTION TYPE zaplink_cx_file
        EXPORTING
          textid   = zaplink_cx_file=>invalid_filetype
          filetype = _filetype.
    ENDIF.
  ENDMETHOD.
  METHOD load.
    DATA tmptable TYPE table_of_strings.
    DATA cx_name TYPE string.
    DATA cx TYPE REF TO cx_root.
    DATA _str LIKE LINE OF tmptable.
    FIELD-SYMBOLS:
      <s> LIKE LINE OF tmptable.
    IF _filetype = c_ft_local.
      CALL METHOD cl_gui_frontend_services=>gui_upload
        EXPORTING
          filename                = _filename
        CHANGING
          data_tab                = tmptable
        EXCEPTIONS
          access_denied           = 1
          bad_data_format         = 2
          disk_full               = 3
          dp_out_of_memory        = 4
          dp_timeout              = 5
          error_no_gui            = 6
          file_open_error         = 7
          file_read_error         = 8
          gui_refuse_filetransfer = 9
          header_not_allowed      = 10
          header_too_long         = 11
          invalid_type            = 12
          no_authority            = 13
          no_batch                = 14
          not_supported_by_gui    = 15
          separator_not_allowed   = 16
          unknown_dp_error        = 17
          unknown_error           = 18
          OTHERS                  = 19.
      IF sy-subrc <> 0.
        DATA(lv_subrc) = sy-subrc.
        o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = 'CL_GUI_FRONTEND_SERVICES'
                                                         method = 'GUI_UPLOAD'
                                                          subrc = lv_subrc
                                                   cx_classname = 'ZAPLINK_CX_FILE' ).
        RAISE EXCEPTION o_mycx.
      ENDIF.
    ELSEIF _filetype = c_ft_server.
      TRY.
          OPEN DATASET _filename FOR INPUT IN TEXT MODE ENCODING DEFAULT.
        CATCH cx_root INTO cx.
          CREATE OBJECT o_mycx
            EXPORTING
              textid   = zaplink_cx_file=>load_error
              filename = _filename
              filetype = _filetype
              previous = cx.
          o_mycx->update( ).
          RAISE EXCEPTION o_mycx.
      ENDTRY.
      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE zaplink_cx_file
          EXPORTING
            textid   = zaplink_cx_file=>load_error
            filename = _filename
            filetype = _filetype
            cx_name  = 'OPEN DATASET'.
      ENDIF.
      DO.
        TRY.
            READ DATASET _filename INTO _str.
          CATCH cx_root INTO cx.
            CREATE OBJECT o_mycx
              EXPORTING
                textid   = zaplink_cx_file=>load_error
                filename = _filename
                filetype = _filetype
                previous = cx.
            o_mycx->update( ).
            RAISE EXCEPTION o_mycx.
        ENDTRY.
        IF sy-subrc <> 0.
          EXIT.
        ENDIF.
        APPEND _str TO tmptable.
      ENDDO.
      TRY.
          CLOSE DATASET _filename.
        CATCH cx_root INTO cx.
          CREATE OBJECT o_mycx
            EXPORTING
              textid   = zaplink_cx_file=>load_error
              filename = _filename
              filetype = _filetype
              previous = cx.
          o_mycx->update( ).
          RAISE EXCEPTION o_mycx.
      ENDTRY.
      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE zaplink_cx_file
          EXPORTING
            textid   = zaplink_cx_file=>load_error
            filename = _filename
            filetype = _filetype
            cx_name  = 'CLOSE DATASET'.
      ENDIF.
    ELSE.
      RAISE EXCEPTION TYPE zaplink_cx_file
        EXPORTING
          textid   = zaplink_cx_file=>invalid_filetype
          filetype = _filetype.
    ENDIF.
    CLEAR _content.
    LOOP AT tmptable ASSIGNING <s>.
      CONCATENATE _content <s> cl_abap_char_utilities=>newline
                  INTO _content.
    ENDLOOP.
  ENDMETHOD.
  METHOD load_dialog.
    DATA ft TYPE filetable.
    DATA filecount TYPE i.
    DATA cx_name TYPE string.
    IF _filetype = c_ft_local.
      CALL METHOD cl_gui_frontend_services=>file_open_dialog
        EXPORTING
          default_filename        = filename
        CHANGING
          file_table              = ft
          rc                      = filecount
        EXCEPTIONS
          cntl_error              = 1
          error_no_gui            = 2
          file_open_dialog_failed = 3
          not_supported_by_gui    = 4
          OTHERS                  = 5.
      IF sy-subrc <> 0.   " OR filecount < 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = 'CL_GUI_FRONTEND_SERVICES'
                                                         method = 'FILE_OPEN_DIALOG'
                                                          subrc = sy-subrc
                                                         textid = zaplink_cx_file=>load_error
                                                   cx_classname = 'ZAPLINK_CX_FILE' ).
        o_mycx->filename = filename.
        o_mycx->filetype = _filetype.
        RAISE EXCEPTION o_mycx.
      ENDIF.
      IF filecount = 0 OR ft IS INITIAL.
        RAISE EXCEPTION TYPE zaplink_cx_file
          EXPORTING
            textid   = zaplink_cx_file=>dialog_canceled
            filename = filename
            filetype = _filetype.
      ENDIF.
      READ TABLE ft INTO _filename INDEX 1.
    ELSEIF _filetype = c_ft_server.
    ELSE.
      RAISE EXCEPTION TYPE zaplink_cx_file
        EXPORTING
          textid   = zaplink_cx_file=>invalid_filetype
          filetype = _filetype.
    ENDIF.
  ENDMETHOD.
  METHOD save.
    DATA tmptable  TYPE table_of_strings.
    DATA o_cx      TYPE REF TO cx_root.
    DATA o_cx_file TYPE REF TO zaplink_cx_file.
    FIELD-SYMBOLS:
      <s> LIKE LINE OF tmptable.
    SPLIT _content AT cl_abap_char_utilities=>newline
              INTO TABLE tmptable.
    IF _filetype = c_ft_local.
      IF _filename IS INITIAL.
        save_dialog( ).
      ELSE.
        CALL FUNCTION 'GUI_DOWNLOAD'
          EXPORTING
            filename                = _filename
            filetype                = 'DAT'
            show_transfer_status    = abap_false
          TABLES
            data_tab                = tmptable
          EXCEPTIONS
            file_write_error        = 1
            no_batch                = 2
            gui_refuse_filetransfer = 3
            invalid_type            = 4
            no_authority            = 5
            unknown_error           = 6
            header_not_allowed      = 7
            separator_not_allowed   = 8
            filesize_not_allowed    = 9
            header_too_long         = 10
            dp_error_create         = 11
            dp_error_send           = 12
            dp_error_write          = 13
            unknown_dp_error        = 14
            access_denied           = 15
            dp_out_of_memory        = 16
            disk_full               = 17
            dp_timeout              = 18
            file_not_found          = 19
            dataprovider_exception  = 20
            control_flush_error     = 21
            OTHERS                  = 22.
        IF sy-subrc <> 0.
          o_cx_file ?= zaplink_cx=>create_from_mf_cx( funcname = 'GUI_DOWNLOAD'
                                                         subrc = sy-subrc
                                                     classname = 'ZAPLINK_CX_FILE'
                                                        textid = zaplink_cx_file=>save_error ).
          o_cx_file->filename = _filename.
          o_cx_file->filetype = _filetype.
          RAISE EXCEPTION o_cx_file.
        ENDIF.
      ENDIF.
    ELSEIF _filetype = c_ft_server.
      TRY.
          OPEN DATASET _filename FOR OUTPUT IN TEXT MODE ENCODING DEFAULT.
        CATCH cx_root INTO o_cx.
          CREATE OBJECT o_cx_file
            EXPORTING
              textid   = zaplink_cx_file=>save_error
              filename = _filename
              filetype = _filetype
              previous = o_cx.
          o_cx_file->update( ).
          RAISE EXCEPTION o_cx_file.
      ENDTRY.
      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE zaplink_cx_file
          EXPORTING
            textid   = zaplink_cx_file=>save_error
            filename = _filename
            filetype = _filetype
            cx_name  = 'OPEN DATASET'.
      ENDIF.
      LOOP AT tmptable ASSIGNING <s>.
        TRY.
            TRANSFER <s> TO _filename.
          CATCH cx_root INTO o_cx.
            CREATE OBJECT o_cx_file
              EXPORTING
                textid   = zaplink_cx_file=>save_error
                filename = _filename
                filetype = _filetype
                previous = o_cx.
            o_cx_file->update( ).
            RAISE EXCEPTION o_cx_file.
        ENDTRY.
      ENDLOOP.
      TRY.
          CLOSE DATASET _filename.
        CATCH cx_root INTO o_cx.
          CREATE OBJECT o_cx_file
            EXPORTING
              textid   = zaplink_cx_file=>save_error
              filename = _filename
              filetype = _filetype
              previous = o_cx.
          o_cx_file->update( ).
          RAISE EXCEPTION o_cx_file.
      ENDTRY.
      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE zaplink_cx_file
          EXPORTING
            textid   = zaplink_cx_file=>save_error
            filename = _filename
            filetype = _filetype
            cx_name  = 'CLOSE DATASET'.
      ENDIF.
    ELSE.
      RAISE EXCEPTION TYPE zaplink_cx_file
        EXPORTING
          textid   = zaplink_cx_file=>invalid_filetype
          filetype = _filetype.
    ENDIF.
  ENDMETHOD.
  METHOD save_dialog.
    DATA retfilename TYPE string.
    DATA retpath TYPE string.
    DATA retfullpath TYPE string.
    DATA retuseract TYPE i.
    IF filename IS INITIAL.
      retfilename = _filename.
    ELSE.
      retfilename = filename.
    ENDIF.
    IF _filetype = c_ft_local.
      CALL METHOD cl_gui_frontend_services=>file_save_dialog
        EXPORTING
          default_file_name = retfilename
        CHANGING
          filename          = retfilename
          path              = retpath
          fullpath          = retfullpath
          user_action       = retuseract.
      IF retuseract <> 0.
        RAISE EXCEPTION TYPE zaplink_cx_file
          EXPORTING
            textid   = zaplink_cx_file=>dialog_canceled
            filename = filename
            filetype = _filetype.
      ENDIF.
      _filename = retfullpath.                                " Issue 69
    ELSEIF _filetype = c_ft_server.
    ELSE.
      RAISE EXCEPTION TYPE zaplink_cx_file
        EXPORTING
          textid   = zaplink_cx_file=>invalid_filetype
          filetype = _filetype.
    ENDIF.
  ENDMETHOD.
  METHOD search.
    DATA d_tmpdir  TYPE string.
    DATA d_tmpfile TYPE string.
    DATA d_guid    TYPE guid_32.
    DATA d_is_ok   TYPE abap_bool.
    DATA d_cmdline TYPE string.
    DATA t_filelst TYPE STANDARD TABLE OF string.
    DATA s_file    LIKE LINE OF result.
    DATA d_rc      TYPE sy-subrc.
    FIELD-SYMBOLS <f> LIKE LINE OF t_filelst.
    IF _filetype = c_ft_local.
      d_tmpdir = get_temp_directory( ).
      IF d_tmpdir IS INITIAL.
        RAISE EXCEPTION TYPE zaplink_cx_file
          EXPORTING
            textid   = zaplink_cx_file=>invalid_filetype
            filetype = _filetype.
      ENDIF.
      DO.
        CALL FUNCTION 'GUID_CREATE'
          IMPORTING
            ev_guid_32 = d_guid.
        CONCATENATE d_tmpdir file_sep d_guid INTO d_tmpfile.
        CALL METHOD cl_gui_frontend_services=>file_exist
          EXPORTING
            file                 = d_tmpfile
          RECEIVING
            result               = d_is_ok
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            wrong_parameter      = 3
            not_supported_by_gui = 4
            OTHERS               = 5.
        IF sy-subrc = 0 AND d_is_ok IS INITIAL.
          EXIT.
        ENDIF.
      ENDDO.
      CONCATENATE '/c' ' "dir /S /B "' root_dir file_sep mask '" > "' d_tmpfile '""' INTO d_cmdline. "#EC NOTEXT
      CALL METHOD cl_gui_frontend_services=>execute
        EXPORTING
          application            = 'CMD'
          parameter              = d_cmdline
          minimized              = 'X'
          synchronous            = 'X'                        " Issue 83
        EXCEPTIONS
          bad_parameter          = 1
          cntl_error             = 2
          error_execute_failed   = 3
          error_no_gui           = 4
          file_extension_unknown = 5
          file_not_found         = 6
          path_not_found         = 7
          not_supported_by_gui   = 8
          synchronous_failed     = 9
          OTHERS                 = 10.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = 'CL_GUI_FRONTEND_SERVICES'
                                                         method = 'EXECUTE'
                                                          subrc = sy-subrc
                                                         textid = zaplink_cx_file=>search_error
                                                   cx_classname = 'ZAPLINK_CX_FILE' ).
        RAISE EXCEPTION o_mycx.
      ENDIF.
      CALL METHOD cl_gui_frontend_services=>file_exist
        EXPORTING
          file                 = d_tmpfile
        RECEIVING
          result               = d_is_ok
        EXCEPTIONS
          cntl_error           = 1
          error_no_gui         = 2
          not_supported_by_gui = 3
          wrong_parameter      = 4
          OTHERS               = 5.
      IF sy-subrc <> 0 OR d_is_ok IS INITIAL.
        o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = 'CL_GUI_FRONTEND_SERVICES'
                                                         method = 'FILE_EXIST'
                                                          subrc = sy-subrc
                                                         textid = zaplink_cx_file=>search_error
                                                   cx_classname = 'ZAPLINK_CX_FILE' ).
        RAISE EXCEPTION o_mycx.
      ENDIF.
      CALL METHOD cl_gui_frontend_services=>gui_upload
        EXPORTING
          filename                = d_tmpfile
        CHANGING
          data_tab                = t_filelst
        EXCEPTIONS
          access_denied           = 1
          bad_data_format         = 2
          disk_full               = 3
          dp_out_of_memory        = 4
          dp_timeout              = 5
          error_no_gui            = 6
          file_open_error         = 7
          file_read_error         = 8
          gui_refuse_filetransfer = 9
          header_not_allowed      = 10
          header_too_long         = 11
          invalid_type            = 12
          not_supported_by_gui    = 13
          no_authority            = 14
          no_batch                = 15
          separator_not_allowed   = 16
          unknown_dp_error        = 17
          unknown_error           = 18
          OTHERS                  = 19.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = 'CL_GUI_FRONTEND_SERVICES'
                                                         method = 'FILE_EXIST'
                                                          subrc = sy-subrc
                                                         textid = zaplink_cx_file=>search_error
                                                   cx_classname = 'ZAPLINK_CX_FILE' ).
        RAISE EXCEPTION o_mycx.
      ENDIF.
      LOOP AT t_filelst ASSIGNING <f>.
        CLEAR s_file.   s_file-name = <f>.
        CALL METHOD cl_gui_frontend_services=>file_exist
          EXPORTING
            file                 = d_tmpfile
          RECEIVING
            result               = d_is_ok
          EXCEPTIONS
            cntl_error           = 1
            error_no_gui         = 2
            wrong_parameter      = 3
            not_supported_by_gui = 4
            OTHERS               = 5.
        IF sy-subrc = 0 AND d_is_ok = abap_true.
          s_file-kind = filedirkinds-file.
        ELSE.
          CALL METHOD cl_gui_frontend_services=>directory_exist
            EXPORTING
              directory            = d_tmpfile
            RECEIVING
              result               = d_is_ok
            EXCEPTIONS
              cntl_error           = 1
              error_no_gui         = 2
              wrong_parameter      = 3
              not_supported_by_gui = 4
              OTHERS               = 5.
          IF sy-subrc = 0 AND d_is_ok = abap_true.
            s_file-kind = filedirkinds-directory.
          ELSE.
            s_file-kind = filedirkinds-unknown.
          ENDIF.
        ENDIF.
        APPEND s_file TO result.
      ENDLOOP.
      CALL METHOD cl_gui_frontend_services=>file_delete
        EXPORTING
          filename             = d_tmpfile
        CHANGING
          rc                   = d_rc
        EXCEPTIONS
          file_delete_failed   = 1
          cntl_error           = 2
          error_no_gui         = 3
          file_not_found       = 4
          access_denied        = 5
          unknown_error        = 6
          not_supported_by_gui = 7
          wrong_parameter      = 8
          OTHERS               = 9.
      IF sy-subrc <> 0.
      ELSEIF d_rc <> 0.
      ENDIF.
    ELSEIF _filetype = c_ft_server.
    ELSE.
      RAISE EXCEPTION TYPE zaplink_cx_file
        EXPORTING
          textid   = zaplink_cx_file=>invalid_filetype
          filetype = _filetype.
    ENDIF.
  ENDMETHOD.
  METHOD set_filecontent.
    _content = data.
  ENDMETHOD.
  METHOD set_filename.
    IF data IS INITIAL.
      RAISE EXCEPTION TYPE zaplink_cx_file
        EXPORTING
          textid   = zaplink_cx_file=>invalid_filename
          filename = data
          filetype = _filetype.
    ENDIF.
    IF NOT _filetype IS INITIAL.
    ENDIF.
    _filename = data.
  ENDMETHOD.
  METHOD set_filetype.
    IF data <> c_ft_local AND data <> c_ft_server.
      RAISE EXCEPTION TYPE zaplink_cx_file
        EXPORTING
          textid   = zaplink_cx_file=>invalid_filetype
          filetype = data.
    ENDIF.
    IF NOT _filename IS INITIAL.
    ENDIF.
    _filetype = data.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_FILE implementation
CLASS zaplink_message_collector IMPLEMENTATION.
  METHOD add.
    DATA:
      ls_message    TYPE bal_s_msg,
      ls_par        LIKE LINE OF ls_message-params-t_par,
      ld_parcontext TYPE balpval.
    CLEAR es_message.
    IF is_message IS NOT INITIAL.
      ls_message = is_message.
    ELSE.
      ls_message-msgty = id_msgty.
      IF id_msgid IS INITIAL.
        ls_message-msgid = msgid.
      ELSE.
        ls_message-msgid = id_msgid.
      ENDIF.
      ls_message-msgno = id_msgno.
      IF id_msgv1 IS SUPPLIED.
        ls_message-msgv1 = id_msgv1.
      ELSEIF id_msgd1 IS SUPPLIED.
        CALL METHOD convert_date_to_string
          EXPORTING
            id_date        = id_msgd1
          IMPORTING
            ed_date_string = ls_message-msgv1.
      ENDIF.
      IF id_msgv2 IS SUPPLIED.
        ls_message-msgv2 = id_msgv2.
      ELSEIF id_msgd2 IS SUPPLIED.
        CALL METHOD convert_date_to_string
          EXPORTING
            id_date        = id_msgd2
          IMPORTING
            ed_date_string = ls_message-msgv2.
      ENDIF.
      IF id_msgv3 IS SUPPLIED.
        ls_message-msgv3 = id_msgv3.
      ELSEIF id_msgd3 IS SUPPLIED.
        CALL METHOD convert_date_to_string
          EXPORTING
            id_date        = id_msgd3
          IMPORTING
            ed_date_string = ls_message-msgv3.
      ENDIF.
      IF id_msgv4 IS SUPPLIED.
        ls_message-msgv4 = id_msgv4.
      ELSEIF id_msgd4 IS SUPPLIED.
        CALL METHOD convert_date_to_string
          EXPORTING
            id_date        = id_msgd4
          IMPORTING
            ed_date_string = ls_message-msgv4.
      ENDIF.
      ls_message-detlevel  = id_detlevel.
      ls_message-probclass = id_probclass.
    ENDIF.
    IF ( ls_message-msgty NA 'ISWEAX' ) OR
       ( ls_message-msgid IS INITIAL  ).
      MESSAGE ID ls_message-msgid TYPE ls_message-msgty NUMBER ls_message-msgno
              WITH ls_message-msgv1 ls_message-msgv2 ls_message-msgv3 ls_message-msgv4.
    ENDIF.
    IF ls_message-detlevel NOT BETWEEN mc_min_level AND mc_max_level.
      ls_message-detlevel = md_level.
    ENDIF.
    IF ls_message-probclass IS INITIAL.
      CASE ls_message-msgty.
        WHEN 'I' OR 'S'.       ls_message-probclass = '4'.
        WHEN 'W'.              ls_message-probclass = '3'.
        WHEN 'E'.              ls_message-probclass = '2'.
        WHEN 'A' OR 'X'.       ls_message-probclass = '1'.
      ENDCASE.
    ENDIF.
    IF if_cumulate = abap_true.
      CALL FUNCTION 'BAL_LOG_MSG_CUMULATE'
        EXPORTING
          i_log_handle         = md_handle
          i_s_msg              = ls_message
          i_compare_attributes = abap_true       " compare attributes
          i_compare_context    = abap_true       " and context
          i_compare_parameters = abap_false
        EXCEPTIONS
          log_not_found        = 1
          msg_inconsistent     = 2
          log_is_full          = 3
          OTHERS               = 4.
    ELSE.
      CALL FUNCTION 'BAL_LOG_MSG_ADD'
        EXPORTING
          i_log_handle     = md_handle
          i_s_msg          = ls_message
        EXCEPTIONS
          log_not_found    = 1
          msg_inconsistent = 2
          log_is_full      = 3
          OTHERS           = 4.
    ENDIF.
    IF sy-subrc <> 0.
      mac_symsg_send_as_type 'A'.
    ELSE.
      es_message = ls_message.
    ENDIF.
  ENDMETHOD.
  METHOD add_abend.
    DATA: _detlevel TYPE ballevel.
    IF id_detlevel IS INITIAL.
      _detlevel = md_level.
    ELSE.
      _detlevel = id_detlevel.
    ENDIF.
    CALL METHOD add
      EXPORTING
        id_msgty     = 'A'
        id_msgid     = id_msgid
        id_msgno     = id_msgno
        id_msgv1     = id_msgv1
        id_msgv2     = id_msgv2
        id_msgv3     = id_msgv3
        id_msgv4     = id_msgv4
        id_detlevel  = _detlevel
        id_probclass = id_probclass.
  ENDMETHOD.
  METHOD add_error.
    DATA: _detlevel TYPE ballevel.
    IF id_detlevel IS INITIAL.
      _detlevel = md_level.
    ELSE.
      _detlevel = id_detlevel.
    ENDIF.
    CALL METHOD add
      EXPORTING
        id_msgty     = 'E'
        id_msgid     = id_msgid
        id_msgno     = id_msgno
        id_msgv1     = id_msgv1
        id_msgv2     = id_msgv2
        id_msgv3     = id_msgv3
        id_msgv4     = id_msgv4
        id_detlevel  = _detlevel
        id_probclass = id_probclass.
  ENDMETHOD.
  METHOD add_exception.
    DATA _detlevel  TYPE ballevel.
    DATA o_zl_cx    TYPE REF TO zaplink_cx.
    IF id_detlevel IS INITIAL.    _detlevel = md_level.   ELSE.   _detlevel = id_detlevel.    ENDIF.
    TRY.
        o_zl_cx ?= exception.
      CATCH cx_root.
    ENDTRY.
    IF o_zl_cx IS BOUND.
      CALL METHOD _add_zl_cx
        EXPORTING
          exception    = o_zl_cx
          id_detlevel  = _detlevel
          id_probclass = id_probclass.
    ELSE.
      CALL METHOD _add_exception
        EXPORTING
          exception    = exception
          id_detlevel  = _detlevel
          id_probclass = id_probclass.
    ENDIF.
  ENDMETHOD.
  METHOD add_from_bapi.
    FIELD-SYMBOLS:
        <ls_bapiret> LIKE is_bapiret.
    ef_add_error   = abap_false.
    ef_add_warning = abap_false.
    LOOP AT it_bapiret ASSIGNING <ls_bapiret>.
      CALL METHOD add
        EXPORTING
          id_msgty    = <ls_bapiret>-type
          id_msgid    = <ls_bapiret>-id
          id_msgno    = <ls_bapiret>-number
          id_msgv1    = <ls_bapiret>-message_v1
          id_msgv2    = <ls_bapiret>-message_v2
          id_msgv3    = <ls_bapiret>-message_v3
          id_msgv4    = <ls_bapiret>-message_v4
          if_cumulate = if_cumulate.
      IF ( <ls_bapiret>-type = 'E' ) OR
         ( <ls_bapiret>-type = 'A' ).
        ef_add_error   = abap_true.
      ELSEIF ( <ls_bapiret>-type = 'W' ).
        ef_add_warning = abap_true.
      ENDIF.
    ENDLOOP.
    IF is_bapiret IS NOT INITIAL.
      CALL METHOD add
        EXPORTING
          id_msgty    = is_bapiret-type
          id_msgid    = is_bapiret-id
          id_msgno    = is_bapiret-number
          id_msgv1    = is_bapiret-message_v1
          id_msgv2    = is_bapiret-message_v2
          id_msgv3    = is_bapiret-message_v3
          id_msgv4    = is_bapiret-message_v4
          if_cumulate = if_cumulate.
      IF ( is_bapiret-type = 'E' ) OR
         ( is_bapiret-type = 'A' ).
        ef_add_error   = abap_true.
      ELSEIF ( is_bapiret-type = 'W' ).
        ef_add_warning = abap_true.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD add_from_instance.
    DATA:
      lt_msglist            TYPE t_msg,
      ls_msglist            TYPE bal_s_msg,
      ld_num_max_level      TYPE int1 VALUE mc_max_level,
      ld_num_detlevel_diff  TYPE int1,
      ld_num_detlevel_other TYPE int1,
      lf_cumulate           TYPE abap_bool.
    FIELD-SYMBOLS:
      <ls_msglist>          LIKE LINE OF lt_msglist.
    CHECK io_msglist IS BOUND.
    lt_msglist = io_msglist->get_list( ).
    CHECK lt_msglist IS NOT INITIAL.
    lf_cumulate = if_cumulate.
    IF if_add_as_subnode = abap_true.
      set_detail_level( id_relative = 1 ).
      lf_cumulate = abap_false.
    ENDIF.
    LOOP AT lt_msglist ASSIGNING <ls_msglist>.
      MOVE-CORRESPONDING <ls_msglist> TO ls_msglist.
      CLEAR:
        ls_msglist-time_stmp,
        ls_msglist-msg_count.
      IF ls_msglist-detlevel NOT BETWEEN mc_min_level AND mc_max_level.
        ls_msglist-detlevel = md_level.
      ELSEIF md_level = mc_min_level.
      ELSE.
        ld_num_detlevel_diff  = md_level - 1.
        ld_num_detlevel_other = ls_msglist-detlevel.
        ADD ld_num_detlevel_diff TO ld_num_detlevel_other.
        IF ld_num_detlevel_other <= ld_num_max_level.
          ls_msglist-detlevel = ld_num_detlevel_other.
        ELSE.
          ls_msglist-detlevel = mc_max_level.
        ENDIF.
      ENDIF.
      add( is_message  = ls_msglist
           if_cumulate = lf_cumulate ).
    ENDLOOP.
    IF if_add_as_subnode = abap_true.
      set_detail_level( id_relative = -1 ).
    ENDIF.
  ENDMETHOD.
  METHOD add_info.
    DATA _detlevel  TYPE ballevel.
    IF id_detlevel IS INITIAL.
      _detlevel = md_level.
    ELSE.
      _detlevel = id_detlevel.
    ENDIF.
    CALL METHOD add
      EXPORTING
        id_msgty     = 'I'
        id_msgid     = id_msgid
        id_msgno     = id_msgno
        id_msgv1     = id_msgv1
        id_msgv2     = id_msgv2
        id_msgv3     = id_msgv3
        id_msgv4     = id_msgv4
        id_detlevel  = _detlevel
        id_probclass = id_probclass.
  ENDMETHOD.
  METHOD add_success.
    DATA: _detlevel TYPE ballevel.
    IF id_detlevel IS INITIAL.
      _detlevel = md_level.
    ELSE.
      _detlevel = id_detlevel.
    ENDIF.
    CALL METHOD add
      EXPORTING
        id_msgty     = 'S'
        id_msgid     = id_msgid
        id_msgno     = id_msgno
        id_msgv1     = id_msgv1
        id_msgv2     = id_msgv2
        id_msgv3     = id_msgv3
        id_msgv4     = id_msgv4
        id_detlevel  = _detlevel
        id_probclass = id_probclass.
  ENDMETHOD.
  METHOD add_symsg.
    DATA ls_symsg TYPE symsg.
    CHECK NOT sy-msgid IS INITIAL AND
          NOT sy-msgno IS INITIAL.
    ls_symsg-msgty = id_msgty.
    ls_symsg-msgid = sy-msgid.
    ls_symsg-msgno = sy-msgno.
    ls_symsg-msgv1 = sy-msgv1.
    ls_symsg-msgv2 = sy-msgv2.
    ls_symsg-msgv3 = sy-msgv3.
    ls_symsg-msgv4 = sy-msgv4.
    CALL METHOD add
      EXPORTING
        id_msgty     = ls_symsg-msgty
        id_msgid     = ls_symsg-msgid
        id_msgno     = ls_symsg-msgno
        id_msgv1     = ls_symsg-msgv1
        id_msgv2     = ls_symsg-msgv2
        id_msgv3     = ls_symsg-msgv3
        id_msgv4     = ls_symsg-msgv4
        if_cumulate  = if_cumulate
        id_detlevel  = id_detlevel
        id_probclass = id_probclass
        id_index     = id_index
      IMPORTING
        es_message   = es_message.
  ENDMETHOD.
  METHOD add_warning.
    DATA: _detlevel TYPE ballevel.
    IF id_detlevel IS INITIAL.
      _detlevel = md_level.
    ELSE.
      _detlevel = id_detlevel.
    ENDIF.
    CALL METHOD add
      EXPORTING
        id_msgty     = 'W'
        id_msgid     = id_msgid
        id_msgno     = id_msgno
        id_msgv1     = id_msgv1
        id_msgv2     = id_msgv2
        id_msgv3     = id_msgv3
        id_msgv4     = id_msgv4
        id_detlevel  = _detlevel
        id_probclass = id_probclass.
  ENDMETHOD.
  METHOD as_char.
    CALL FUNCTION 'CONVERT_DATE_TO_EXTERNAL'
      EXPORTING
        date_internal            = id_date
      IMPORTING
        date_external            = rd_date
      EXCEPTIONS
        date_internal_is_invalid = 1
        OTHERS                   = 2.
    IF sy-subrc <> 0.
      CLEAR rd_date.
    ENDIF.
  ENDMETHOD.
  METHOD change_msg_type.
    DATA:
      lt_log_handle TYPE bal_t_logh,
      lt_msg_handle TYPE bal_t_msgh,
      ls_msg        TYPE bal_s_msg.
    FIELD-SYMBOLS:
      <ls_msg_handle> LIKE LINE OF lt_msg_handle.
    IF ( id_msgty_src NA ' AEISWX' ) OR
       ( id_msgty_trg NA 'AEISWX'  ).
      mac_invalid_precondition.
    ENDIF.
    CHECK id_msgty_src <> id_msgty_trg.
    INSERT md_handle INTO TABLE lt_log_handle.
    CALL FUNCTION 'BAL_GLB_SEARCH_MSG'
      EXPORTING
        i_t_log_handle = lt_log_handle
      IMPORTING
        e_t_msg_handle = lt_msg_handle
      EXCEPTIONS
        msg_not_found  = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    LOOP AT lt_msg_handle ASSIGNING <ls_msg_handle>.
      CALL FUNCTION 'BAL_LOG_MSG_READ'
        EXPORTING
          i_s_msg_handle = <ls_msg_handle>
        IMPORTING
          e_s_msg        = ls_msg
        EXCEPTIONS
          log_not_found  = 1
          msg_not_found  = 2
          OTHERS         = 3.
      IF sy-subrc = 0.
        IF ( id_msgty_src IS INITIAL     ) OR
           ( id_msgty_src = ls_msg-msgty ).
          ls_msg-msgty = id_msgty_trg.
          CALL FUNCTION 'BAL_LOG_MSG_CHANGE'
            EXPORTING
              i_s_msg_handle = <ls_msg_handle>
              i_s_msg        = ls_msg
            EXCEPTIONS
              OTHERS         = 1.
          IF sy-subrc = 0.
            ADD 1 TO rd_changed.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD check_custo.
    DATA _commit  TYPE flag.
    DATA obj      TYPE balobj.
    DATA obj_t    TYPE balobjt.
    DATA sobj     TYPE balsub.
    DATA sobj_t   TYPE balsubt.
    DATA str      TYPE string.
    FIELD-SYMBOLS:
      <t_balobj> TYPE any,
      <s_balobj> TYPE any,
      <t_balsub> TYPE any,
      <s_balsub> TYPE any.
    obj-object = id_object.
    CALL FUNCTION 'BAL_OBJECT_SELECT'
      EXPORTING
        i_object         = id_object
      EXCEPTIONS
        object_not_found = 1
        OTHERS           = 2.
    IF sy-subrc <> 0.
      INSERT balobj FROM obj.
      obj_t-spras = sy-langu.
      obj_t-object = obj-object.
      obj_t-objtxt = 'Entry auto created by ZAPLINK_MESSAGE_COLLECTOR'(blt).
      INSERT balobjt FROM obj_t.
      _commit = abap_true.
    ENDIF.
    sobj-object = obj-object.
    sobj-subobject = id_subobject.
    SELECT SINGLE * INTO sobj
      FROM balsub
      WHERE    object = sobj-object
        AND subobject = sobj-subobject.
    IF sy-subrc <> 0.
      INSERT balsub FROM sobj.
      sobj_t-spras = sy-langu.
      sobj_t-object = sobj-object.
      sobj_t-subobject = sobj-subobject.
      sobj_t-subobjtxt = 'Entry auto created by ZAPLINK_MESSAGE_COLLECTOR'(blt).
      INSERT balsubt FROM sobj_t.
      _commit = abap_true.
    ENDIF.
    IF NOT _commit IS INITIAL.
      str = '(SAPLSBAL_SERVICE)g_balobj[]'.  ASSIGN (str) TO <t_balobj>.
      IF sy-subrc = 0. CLEAR <t_balobj>.  UNASSIGN <t_balobj>.  ENDIF.
      str = '(SAPLSBAL_SERVICE)g_balobj'.    ASSIGN (str) TO <s_balobj>.
      IF sy-subrc = 0. CLEAR <s_balobj>.  UNASSIGN <s_balobj>.  ENDIF.
      str = '(SAPLSBAL_SERVICE)g_balsub[]'.  ASSIGN (str) TO <t_balsub>.
      IF sy-subrc = 0. CLEAR <t_balsub>.  UNASSIGN <t_balsub>.  ENDIF.
      str = '(SAPLSBAL_SERVICE)g_balsub'.    ASSIGN (str) TO <s_balsub>.
      IF sy-subrc = 0. CLEAR <s_balsub>.  UNASSIGN <s_balsub>.  ENDIF.
      COMMIT WORK AND WAIT.
      CALL FUNCTION 'BAL_OBJECT_SELECT'
        EXPORTING
          i_object         = id_object
        EXCEPTIONS
          object_not_found = 1
          OTHERS           = 2.
      IF sy-subrc <> 0.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD clear.
    CALL FUNCTION 'BAL_LOG_MSG_DELETE_ALL'
      EXPORTING
        i_log_handle = md_handle
      EXCEPTIONS
        OTHERS       = 0.
    md_level = mc_min_level.
    CLEAR:
      md_sup_count,
      mt_sup_msg.
  ENDMETHOD.
  METHOD convert_date_to_string.
    DATA:
      ld_date     TYPE sydatum,
      ld_char(10) TYPE c.
    ld_date = id_date.
    mac_clear_date_if_initial ld_date.
    ld_char = as_char( ld_date ).
    IF ld_char IS INITIAL.
      ld_date = '11111111'.
      ld_char = as_char( ld_date ).
      REPLACE '1' WITH '0' INTO ld_char.
    ENDIF.
    ed_date_string = ld_char.
  ENDMETHOD.
  METHOD count.
    DATA:
      lt_log_handle TYPE bal_t_logh,
      lt_msg_handle TYPE bal_t_msgh.
    INSERT md_handle INTO TABLE lt_log_handle.
    CALL FUNCTION 'BAL_GLB_SEARCH_MSG'
      EXPORTING
        i_t_log_handle = lt_log_handle
      IMPORTING
        e_t_msg_handle = lt_msg_handle
      EXCEPTIONS
        msg_not_found  = 1
        OTHERS         = 2.
    IF sy-subrc = 0.
      rd_count = lines( lt_msg_handle ).
    ELSE.
      rd_count = 0.
    ENDIF.
  ENDMETHOD.
  METHOD delete_message.
    DATA:
      ls_msg_handle TYPE balmsghndl.
    ls_msg_handle-log_handle = md_handle.
    ls_msg_handle-msgnumber  = id_msgnumber.
    CALL FUNCTION 'BAL_LOG_MSG_DELETE'
      EXPORTING
        i_s_msg_handle = ls_msg_handle
      EXCEPTIONS
        msg_not_found  = 1
        log_not_found  = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      mac_symsg_raise not_found.
    ENDIF.
  ENDMETHOD.
  METHOD free.
    IF mf_log_not_stored = abap_false.
      CALL FUNCTION 'BAL_LOG_REFRESH'
        EXPORTING
          i_log_handle = md_handle
        EXCEPTIONS
          OTHERS       = 0.
    ENDIF.
    CLEAR md_handle.
    CLEAR ms_log.
  ENDMETHOD.
  METHOD get_first_message.
    DATA:
      lt_log_handle TYPE bal_t_logh,
      lt_msg_handle TYPE bal_t_msgh,
      ls_msg_filter TYPE bal_s_mfil,
      ld_msg_handle TYPE balmsghndl,
      ls_msg        TYPE bal_s_msg.
    CLEAR es_message.
    IF id_msgty NA 'IWEA'.
      mac_invalid_precondition.
    ENDIF.
    CALL METHOD get_msg_filter
      EXPORTING
        id_msgty      = id_msgty
        if_or_higher  = if_or_higher
      IMPORTING
        es_msg_filter = ls_msg_filter.
    INSERT md_handle INTO TABLE lt_log_handle.
    CALL FUNCTION 'BAL_GLB_SEARCH_MSG'
      EXPORTING
        i_t_log_handle = lt_log_handle
        i_s_msg_filter = ls_msg_filter
      IMPORTING
        e_t_msg_handle = lt_msg_handle
      EXCEPTIONS
        msg_not_found  = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      mac_symsg_raise not_found.
    ENDIF.
    READ TABLE lt_msg_handle INDEX 1 INTO ld_msg_handle.
    CALL FUNCTION 'BAL_LOG_MSG_READ'
      EXPORTING
        i_s_msg_handle = ld_msg_handle
      IMPORTING
        e_s_msg        = ls_msg
      EXCEPTIONS
        log_not_found  = 1
        msg_not_found  = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      mac_symsg_raise not_found.
    ENDIF.
    es_message = ls_msg.
  ENDMETHOD.
  METHOD get_handle.
    rd_handle = md_handle.
  ENDMETHOD.
  METHOD get_last_message.
    DATA:
      lt_log_handle TYPE bal_t_logh,
      lt_msg_handle TYPE bal_t_msgh,
      ls_msg_filter TYPE bal_s_mfil,
      ld_msg_handle TYPE balmsghndl,
      ls_msg        TYPE bal_s_msg,
      ld_count      TYPE i.
    CLEAR es_message.
    IF id_msgty NA 'IWEA'.
      mac_invalid_precondition.
    ENDIF.
    CALL METHOD get_msg_filter
      EXPORTING
        id_msgty      = id_msgty
        if_or_higher  = if_or_higher
      IMPORTING
        es_msg_filter = ls_msg_filter.
    INSERT md_handle INTO TABLE lt_log_handle.
    CALL FUNCTION 'BAL_GLB_SEARCH_MSG'
      EXPORTING
        i_t_log_handle = lt_log_handle
        i_s_msg_filter = ls_msg_filter
      IMPORTING
        e_t_msg_handle = lt_msg_handle
      EXCEPTIONS
        msg_not_found  = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      mac_symsg_raise not_found.
    ENDIF.
    ld_count = lines( lt_msg_handle ).
    READ TABLE lt_msg_handle INDEX ld_count INTO ld_msg_handle.
    CALL FUNCTION 'BAL_LOG_MSG_READ'
      EXPORTING
        i_s_msg_handle = ld_msg_handle
      IMPORTING
        e_s_msg        = ls_msg
      EXCEPTIONS
        log_not_found  = 1
        msg_not_found  = 2
        OTHERS         = 3.
    IF sy-subrc <> 0.
      mac_symsg_raise not_found.
    ENDIF.
    es_message = ls_msg.
  ENDMETHOD.
  METHOD get_list.
    DATA lt_msglist_x   TYPE t_msg_x.
    FIELD-SYMBOLS <ls_msglist_x> LIKE LINE OF lt_msglist_x.
    CLEAR et_list.
    CALL METHOD get_list_x
      IMPORTING
        et_list_x = lt_msglist_x.
    LOOP AT lt_msglist_x ASSIGNING <ls_msglist_x>.
      APPEND <ls_msglist_x>-msg TO et_list.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_list_as_bapiret.
    DATA:
      lt_msglist_x  TYPE t_msg_x,
      ls_list       LIKE LINE OF et_list,
      ls_par        TYPE bal_s_par,
      ld_bapi_par   TYPE bapiret2-parameter,
      ld_bapi_field TYPE bapiret2-field,
      ld_bapi_row   TYPE bapiret2-row.
    FIELD-SYMBOLS <ls_msglist_x> LIKE LINE OF lt_msglist_x.
    CLEAR et_list.
    CALL METHOD get_list_x
      IMPORTING
        et_list_x = lt_msglist_x.
    LOOP AT lt_msglist_x ASSIGNING <ls_msglist_x>.
      READ TABLE <ls_msglist_x>-params-t_par INTO ls_par
        WITH KEY parname = 'TABNAME'.
      IF sy-subrc = 0.
        ld_bapi_par = ls_par-parvalue.
      ELSE.
        CLEAR ld_bapi_par.
      ENDIF.
      READ TABLE <ls_msglist_x>-params-t_par INTO ls_par
        WITH KEY parname = 'FIELDNAME'.
      IF sy-subrc = 0.
        ld_bapi_field = ls_par-parvalue.
      ELSE.
        CLEAR ld_bapi_field.
      ENDIF.
      READ TABLE <ls_msglist_x>-params-t_par INTO ls_par
        WITH KEY parname = 'INDEX'.
      IF sy-subrc = 0.
        ld_bapi_row = ls_par-parvalue.
      ELSE.
        ld_bapi_row = 0.
      ENDIF.
      CALL FUNCTION 'BALW_BAPIRETURN_GET2'
        EXPORTING
          type      = <ls_msglist_x>-msgty
          cl        = <ls_msglist_x>-msgid
          number    = <ls_msglist_x>-msgno
          par1      = <ls_msglist_x>-msgv1
          par2      = <ls_msglist_x>-msgv2
          par3      = <ls_msglist_x>-msgv3
          par4      = <ls_msglist_x>-msgv4
          parameter = ld_bapi_par
          row       = ld_bapi_row
          field     = ld_bapi_field
        IMPORTING
          return    = ls_list.
      APPEND ls_list TO et_list.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_list_x.
    DATA:
      lt_log_handle TYPE bal_t_logh,
      lt_msg_handle TYPE bal_t_msgh,
      ls_msg_filter TYPE bal_s_mfil,
      ls_msg        TYPE bal_s_msg,
      ls_list_x     LIKE LINE OF et_list_x.
    FIELD-SYMBOLS <ls_msg_handle> LIKE LINE OF lt_msg_handle.
    CLEAR et_list_x.
    IF id_msgty NA 'IWEA'.
      mac_invalid_precondition.
    ENDIF.
    CALL METHOD get_msg_filter
      EXPORTING
        id_msgty      = id_msgty
        if_or_higher  = abap_true
      IMPORTING
        es_msg_filter = ls_msg_filter.
    INSERT md_handle INTO TABLE lt_log_handle.
    CALL FUNCTION 'BAL_GLB_SEARCH_MSG'
      EXPORTING
        i_t_log_handle = lt_log_handle
        i_s_msg_filter = ls_msg_filter
      IMPORTING
        e_t_msg_handle = lt_msg_handle
      EXCEPTIONS
        msg_not_found  = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    LOOP AT lt_msg_handle ASSIGNING <ls_msg_handle>.
      CALL FUNCTION 'BAL_LOG_MSG_READ'
        EXPORTING
          i_s_msg_handle = <ls_msg_handle>
        IMPORTING
          e_s_msg        = ls_msg
        EXCEPTIONS
          log_not_found  = 1
          msg_not_found  = 2
          OTHERS         = 3.
      IF sy-subrc = 0.
        ls_list_x-msg       = ls_msg.
        ls_list_x-msgnumber = <ls_msg_handle>-msgnumber.
        APPEND ls_list_x TO et_list_x.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_msg_filter.
    DATA ls_so_msgty LIKE LINE OF es_msg_filter-msgty.
    DEFINE mac_add_msgty.
      CLEAR ls_so_msgty.
      ls_so_msgty-sign   = 'I'.
      ls_so_msgty-option = 'EQ'.
      ls_so_msgty-low    = &1.
      APPEND ls_so_msgty TO es_msg_filter-msgty.
    END-OF-DEFINITION.
    CLEAR es_msg_filter.
    IF id_msgty NA 'AEISWX'.
      mac_invalid_precondition.
    ENDIF.
    IF ( id_msgty     CA 'IS'     ) AND
       ( if_or_higher = abap_true ).
      RETURN.
    ENDIF.
    mac_add_msgty id_msgty.
    CASE id_msgty.
      WHEN 'I'.     mac_add_msgty 'S'.
      WHEN 'S'.     mac_add_msgty 'I'.
      WHEN 'A'.     mac_add_msgty 'X'.
      WHEN 'X'.     mac_add_msgty 'A'.
    ENDCASE.
    IF if_or_higher = abap_true.
      CASE id_msgty.
        WHEN 'I' OR 'S'.
          mac_add_msgty 'W'.
          mac_add_msgty 'E'.
          mac_add_msgty 'A'.
          mac_add_msgty 'X'.
        WHEN 'W'.
          mac_add_msgty 'E'.
          mac_add_msgty 'A'.
          mac_add_msgty 'X'.
        WHEN 'E'.
          mac_add_msgty 'A'.
          mac_add_msgty 'X'.
      ENDCASE.
    ENDIF.
  ENDMETHOD.
  METHOD get_ref_type.
    DATA o_ref      TYPE REF TO cl_abap_refdescr.
    IF typedesc->kind = cl_abap_datadescr=>kind_ref.
      o_ref ?= typedesc.
      ref_type = o_ref->get_referenced_type( ).
    ELSE.
      ref_type = typedesc.
    ENDIF.
  ENDMETHOD.
  METHOD get_statistics.
    CLEAR rs_statistics.
    CALL FUNCTION 'BAL_LOG_HDR_READ'
      EXPORTING
        i_log_handle = md_handle
      IMPORTING
        e_statistics = rs_statistics
      EXCEPTIONS
        OTHERS       = 0.
  ENDMETHOD.
  METHOD get_statistics_as_text.
    DATA:
      ls_statistics   TYPE bal_s_scnt,
      ld_result       TYPE string,
      ld_result_cnt   TYPE string,
      ld_result_cnt_e TYPE string,
      ld_result_cnt_w TYPE string,
      ld_result_cnt_i TYPE string.
    CLEAR ed_text.
    ls_statistics = get_statistics( ).
    ADD ls_statistics-msg_cnt_a TO ls_statistics-msg_cnt_e.
    ADD ls_statistics-msg_cnt_s TO ls_statistics-msg_cnt_i.
    IF if_output_e_messages = abap_true.
      IF ls_statistics-msg_cnt_e > 1.
        ld_result_cnt = ls_statistics-msg_cnt_e.
        ld_result_cnt_e = TEXT-se0.
        REPLACE '&1' WITH ld_result_cnt INTO ld_result_cnt_e.
        CONDENSE ld_result_cnt_e.
      ELSEIF ls_statistics-msg_cnt_e = 1.
        ld_result_cnt_e = TEXT-se1.
      ENDIF.
    ENDIF.
    IF if_output_w_messages = abap_true.
      IF ls_statistics-msg_cnt_w > 1.
        ld_result_cnt = ls_statistics-msg_cnt_w.
        ld_result_cnt_w = TEXT-sw0.
        REPLACE '&1' IN ld_result_cnt_w WITH ld_result_cnt.
        CONDENSE ld_result_cnt_w.
      ELSEIF ls_statistics-msg_cnt_w = 1.
        ld_result_cnt_w = TEXT-sw1.
      ENDIF.
    ENDIF.
    IF if_output_i_messages = abap_true.
      IF ls_statistics-msg_cnt_i > 1.
        ld_result_cnt = ls_statistics-msg_cnt_i.
        ld_result_cnt_i = TEXT-si0.
        REPLACE '&1' WITH ld_result_cnt INTO ld_result_cnt_i.
        CONDENSE ld_result_cnt_i.
      ELSEIF ls_statistics-msg_cnt_i = 1.
        ld_result_cnt_i = TEXT-si1.
      ENDIF.
    ENDIF.
    IF ld_result_cnt_e IS NOT INITIAL.
      ld_result = ld_result_cnt_e.
    ENDIF.
    IF ld_result_cnt_w IS NOT INITIAL.
      IF ld_result IS INITIAL.
        ld_result = ld_result_cnt_w.
      ELSEIF if_output_highest_only = abap_false.
        CONCATENATE ld_result ', &1'
               INTO ld_result.
        REPLACE '&1' IN ld_result WITH ld_result_cnt_w.
      ENDIF.
    ENDIF.
    IF ld_result_cnt_i IS NOT INITIAL.
      IF ld_result IS INITIAL.
        ld_result = ld_result_cnt_i.
      ELSEIF if_output_highest_only = abap_false.
        CONCATENATE ld_result ', &1'
               INTO ld_result.
        REPLACE '&1' IN ld_result WITH ld_result_cnt_i.
      ENDIF.
    ENDIF.
    ed_text = ld_result.
  ENDMETHOD.
  METHOD has_messages_of_msgt.
    DATA:
      ls_statistics TYPE bal_s_scnt,
      ld_msg_count  TYPE i.
    IF id_msgty NA 'IWEA'.
      mac_invalid_precondition.
    ENDIF.
    IF ( id_msgty     = 'I'       ) AND
       ( if_or_higher = abap_true ).
      IF is_empty( ) = abap_false.
        rf_exists = abap_true.
      ENDIF.
    ELSE.
      ls_statistics = get_statistics( ).
      ld_msg_count  = 0.
      CASE id_msgty.
        WHEN 'I'.
          ld_msg_count = ls_statistics-msg_cnt_i +
                         ls_statistics-msg_cnt_s.
        WHEN 'W'.
          ld_msg_count = ls_statistics-msg_cnt_w.
          IF ( if_or_higher = abap_true ) AND ( ld_msg_count = 0 ).
            ld_msg_count = ls_statistics-msg_cnt_e +
                           ls_statistics-msg_cnt_a.
          ENDIF.
        WHEN 'E'.
          ld_msg_count = ls_statistics-msg_cnt_e.
          IF ( if_or_higher = abap_true ) AND ( ld_msg_count = 0 ).
            ld_msg_count = ls_statistics-msg_cnt_a.
          ENDIF.
        WHEN 'A'.
          ld_msg_count = ls_statistics-msg_cnt_a.
      ENDCASE.
      IF ld_msg_count > 0.
        rf_exists = abap_true.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD init.
    DATA:
      lt_log_header TYPE balhdr_t,
      ls_log_header TYPE balhdr,
      ls_log_filter TYPE bal_s_lfil,
      ld_guid       TYPE guid_32.
    IF NOT auto_upd_custo IS INITIAL.
      check_custo( id_object = id_object
                id_subobject = id_subobject ).
    ENDIF.
    IF id_activity = actions-create.                    "create
      ms_log-object     = id_object.
      ms_log-subobject  = id_subobject.
      ms_log-aluser     = sy-uname.
      ms_log-alprog     = sy-cprog.
      ms_log-aldate_del = sy-datum + 30.      "expiration in 30 days
      IF id_extnumber IS NOT INITIAL.
        ms_log-extnumber = id_extnumber.
      ELSE.
        CALL FUNCTION 'GUID_CREATE'
          IMPORTING
            ev_guid_32 = ld_guid.
        ms_log-extnumber = ld_guid.
      ENDIF.
      CALL FUNCTION 'BAL_LOG_CREATE'
        EXPORTING
          i_s_log                 = ms_log
        IMPORTING
          e_log_handle            = md_handle
        EXCEPTIONS
          log_header_inconsistent = 1
          OTHERS                  = 2.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ELSE.
      CALL FUNCTION 'BAL_FILTER_CREATE'
        EXPORTING
          i_object       = id_object
          i_subobject    = id_subobject
          i_extnumber    = id_extnumber
        IMPORTING
          e_s_log_filter = ls_log_filter.
      CALL FUNCTION 'BAL_DB_SEARCH'
        EXPORTING
          i_s_log_filter     = ls_log_filter
        IMPORTING
          e_t_log_header     = lt_log_header
        EXCEPTIONS
          log_not_found      = 1
          no_filter_criteria = 2
          OTHERS             = 3.
      IF sy-subrc <> 0.
        mac_symsg_raise error.
      ENDIF.
      CALL FUNCTION 'BAL_DB_LOAD'
        EXPORTING
          i_t_log_header     = lt_log_header
        EXCEPTIONS
          no_logs_specified  = 1
          log_not_found      = 2
          log_already_loaded = 3
          OTHERS             = 4.
      IF sy-subrc <> 0.
        mac_symsg_raise error.
      ENDIF.
      READ TABLE lt_log_header INDEX 1 INTO ls_log_header.
      MOVE-CORRESPONDING ls_log_header TO ms_log.
      md_handle = ls_log_header-log_handle.
    ENDIF.
    object = id_object.
    subobject = id_subobject.
    ext_id = md_extnumber = ms_log-extnumber.
    md_level = mc_min_level.
  ENDMETHOD.
  METHOD init_by_handle.
    DATA:
      lt_log_handle TYPE bal_t_logh,
      lf_load_error TYPE abap_bool.
    INSERT id_handle INTO TABLE lt_log_handle.
    CALL FUNCTION 'BAL_DB_LOAD'
      EXPORTING
        i_t_log_handle     = lt_log_handle
      EXCEPTIONS
        no_logs_specified  = 1
        log_not_found      = 2
        log_already_loaded = 3
        OTHERS             = 4.
    IF sy-subrc <> 0.
      lf_load_error = abap_true.
    ENDIF.
    CALL FUNCTION 'BAL_LOG_HDR_READ'
      EXPORTING
        i_log_handle = id_handle
      IMPORTING
        e_s_log      = ms_log
      EXCEPTIONS
        OTHERS       = 1.
    IF sy-subrc <> 0.
      mac_symsg_raise error.
    ENDIF.
    IF lf_load_error = abap_true.
      mf_log_not_stored = abap_true.
    ENDIF.
    md_handle    = id_handle.
    ext_id = md_extnumber = ms_log-extnumber.
    md_level     = mc_min_level.
  ENDMETHOD.
  METHOD insert.
    DATA:
      lt_msglist_x              TYPE t_msg_x,
      ld_insert_index           TYPE i,
      ld_delete_index           TYPE i,
      ld_num_detlevel_new       TYPE i,
      ld_num_detlevel_next      TYPE i,
      ld_num_detlevel_diff      TYPE i,
      ld_num_detlevel_following TYPE i.
    FIELD-SYMBOLS <ls_msglist_x>            LIKE LINE OF lt_msglist_x.
    IF id_insert_index > 0.
      ld_insert_index = id_insert_index.
    ELSE.
      ld_insert_index = 1.
    ENDIF.
    CALL METHOD get_list_x
      IMPORTING
        et_list_x = lt_msglist_x.
    IF ld_insert_index > lines( lt_msglist_x ).
      CALL METHOD add
        EXPORTING
          is_message   = is_message
          id_msgty     = id_msgty
          id_msgid     = id_msgid
          id_msgno     = id_msgno
          id_msgv1     = id_msgv1
          id_msgv2     = id_msgv2
          id_msgv3     = id_msgv3
          id_msgv4     = id_msgv4
          id_msgd1     = id_msgd1
          id_msgd2     = id_msgd2
          id_msgd3     = id_msgd3
          id_msgd4     = id_msgd4
          id_detlevel  = id_detlevel
          id_probclass = id_probclass
          id_index     = id_index
        IMPORTING
          es_message   = es_message.
    ELSE.
      IF ld_insert_index > 1.
        ld_delete_index = ld_insert_index - 1.
        DELETE lt_msglist_x TO ld_delete_index.
        LOOP AT lt_msglist_x ASSIGNING <ls_msglist_x>.
          CALL METHOD delete_message
            EXPORTING
              id_msgnumber = <ls_msglist_x>-msgnumber
            EXCEPTIONS
              OTHERS       = 0.
        ENDLOOP.
      ELSE.
        clear( ).
      ENDIF.
      CALL METHOD add
        EXPORTING
          is_message   = is_message
          id_msgty     = id_msgty
          id_msgid     = id_msgid
          id_msgno     = id_msgno
          id_msgv1     = id_msgv1
          id_msgv2     = id_msgv2
          id_msgv3     = id_msgv3
          id_msgv4     = id_msgv4
          id_msgd1     = id_msgd1
          id_msgd2     = id_msgd2
          id_msgd3     = id_msgd3
          id_msgd4     = id_msgd4
          id_detlevel  = id_detlevel
          id_probclass = id_probclass
          id_index     = id_index
        IMPORTING
          es_message   = es_message.
      IF if_set_following_as_subnode = abap_true.
        READ TABLE lt_msglist_x INDEX 1 ASSIGNING <ls_msglist_x>.
        ld_num_detlevel_next = <ls_msglist_x>-detlevel.
        ld_num_detlevel_new  = es_message-detlevel.
        ld_num_detlevel_diff = ld_num_detlevel_new  -
                               ld_num_detlevel_next + 1.
      ENDIF.
      LOOP AT lt_msglist_x ASSIGNING <ls_msglist_x>.
        CLEAR:
          <ls_msglist_x>-time_stmp,
          <ls_msglist_x>-msg_count.
        IF if_set_following_as_subnode = abap_true.
          ld_num_detlevel_following = <ls_msglist_x>-detlevel +
                                      ld_num_detlevel_diff.
          IF ld_num_detlevel_following < 0.
            <ls_msglist_x>-detlevel = 0.
          ELSEIF ld_num_detlevel_following > mc_max_level.
            <ls_msglist_x>-detlevel = mc_max_level.
          ELSE.
            <ls_msglist_x>-detlevel = ld_num_detlevel_following.
          ENDIF.
        ENDIF.
        CALL METHOD add( is_message = <ls_msglist_x>-msg ).
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD is_date_initial.
    IF ( id_date(1) >= '1' ).
      rf_initial = abap_false.
      RETURN.
    ENDIF.
    IF ( id_date IS INITIAL    ) OR
       ( id_date  = space      ) OR
       ( id_date  = '00000000' ).
      rf_initial = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD is_empty.
    DATA lt_log_handle TYPE bal_t_logh.
    INSERT md_handle INTO TABLE lt_log_handle.
    CALL FUNCTION 'BAL_GLB_SEARCH_MSG'
      EXPORTING
        i_t_log_handle = lt_log_handle
      EXCEPTIONS
        msg_not_found  = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      rf_empty = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD new.
    CREATE OBJECT obj.
  ENDMETHOD.
  METHOD raise_first_message.
    DATA ls_msg TYPE bal_s_msg.
    CALL METHOD get_first_message
      EXPORTING
        id_msgty     = id_msgty
        if_or_higher = if_or_higher
      IMPORTING
        es_message   = ls_msg
      EXCEPTIONS
        not_found    = 1
        OTHERS       = 2.
    IF sy-subrc = 0.
      MESSAGE ID ls_msg-msgid TYPE ls_msg-msgty NUMBER ls_msg-msgno
              WITH ls_msg-msgv1 ls_msg-msgv2 ls_msg-msgv3 ls_msg-msgv4
              RAISING first_message.
    ENDIF.
  ENDMETHOD.
  METHOD raise_on_error.
    DATA o_exception TYPE REF TO zaplink_cx.
    IF NOT has_messages_of_msgt( id_msgty = 'E' ) IS INITIAL.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE e012(zaplink_package) WITH space space space. ENDIF.
      SET EXTENDED CHECK ON.
      add_abend( id_msgid = 'ZAPLINK_PACKAGE'
                 id_msgno = '012'
                 id_msgv1 = object
                 id_msgv2 = subobject
                 id_msgv3 = ext_id
                  ).
      o_exception = zaplink_cx=>create_from_application_log( message_collector = me ).
      RAISE EXCEPTION o_exception.
    ENDIF.
  ENDMETHOD.
  METHOD set_detail_level.
    DATA:
      ld_num_min_level    LIKE id_relative,
      ld_num_max_level    LIKE id_relative,
      ld_num_level_signed LIKE id_relative.
    IF ( id_absolute IS NOT INITIAL ) AND
       ( id_relative IS NOT INITIAL ).
      mac_invalid_precondition.
    ENDIF.
    IF id_absolute IS NOT INITIAL.
      IF id_absolute BETWEEN mc_min_level AND mc_max_level.
        md_level = id_absolute.
      ENDIF.
    ELSEIF id_relative IS NOT INITIAL .
      ld_num_min_level = mc_min_level.
      ld_num_max_level = mc_max_level.
      ld_num_level_signed = md_level.
      ADD id_relative TO ld_num_level_signed.
      IF ld_num_level_signed < ld_num_min_level.
        md_level = mc_min_level.
      ELSEIF ld_num_level_signed > ld_num_max_level.
        md_level = mc_max_level.
      ELSE.
        md_level = ld_num_level_signed.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD set_extnumber.
    DATA ls_log_temp LIKE ms_log.
    CHECK id_extnumber IS NOT INITIAL.
    ls_log_temp           = ms_log.
    ls_log_temp-extnumber = id_extnumber.
    CALL FUNCTION 'BAL_LOG_HDR_CHANGE'
      EXPORTING
        i_log_handle            = md_handle
        i_s_log                 = ls_log_temp
      EXCEPTIONS
        log_not_found           = 1
        log_header_inconsistent = 2
        OTHERS                  = 3.
    IF sy-subrc <> 0.
      RETURN.
    ENDIF.
    ms_log-extnumber = id_extnumber.
    ext_id = md_extnumber     = id_extnumber.
  ENDMETHOD.
  METHOD store.
    DATA lt_log_handle TYPE bal_t_logh.
    INSERT md_handle INTO TABLE lt_log_handle.
    CALL FUNCTION 'BAL_DB_SAVE'
      EXPORTING
        i_in_update_task = if_in_update_task
        i_t_log_handle   = lt_log_handle
      EXCEPTIONS
        log_not_found    = 1
        save_not_allowed = 2
        numbering_error  = 3
        OTHERS           = 4.
    IF sy-subrc <> 0.
      mac_symsg_raise error.
    ENDIF.
  ENDMETHOD.
  METHOD write.
    DATA lt_messages  TYPE t_msg_x.
    DATA _msg TYPE string.
    DATA _light TYPE icon_d.
    FIELD-SYMBOLS <m> LIKE LINE OF lt_messages.
    CALL METHOD get_list_x
      IMPORTING
        et_list_x = lt_messages.
    LOOP AT lt_messages ASSIGNING <m>.
      CASE <m>-msgty.
        WHEN 'X'. _light = icon_red_xcircle.
        WHEN 'A'. _light = icon_message_critical_small.
        WHEN 'E'. _light = icon_red_light.
        WHEN 'W'. _light = icon_yellow_light.
        WHEN 'I'. _light = icon_light_out.
        WHEN 'S'. _light = icon_green_light.
        WHEN OTHERS. _light = icon_light_out.
      ENDCASE.
      MESSAGE ID <m>-msgid TYPE 'I' NUMBER <m>-msgno WITH <m>-msgv1 <m>-msgv2 <m>-msgv3 <m>-msgv4 INTO _msg.
      WRITE:/ _offset, _light AS ICON, _msg.
    ENDLOOP.
  ENDMETHOD.
  METHOD _add_exception.
    DATA _detlevel  TYPE ballevel.
    DATA cx_text    TYPE string.
    DATA o_ref      TYPE REF TO cl_abap_refdescr.
    DATA o_obj      TYPE REF TO cl_abap_classdescr.
    DATA cx_src_pos TYPE string.
    DATA f_toolong  TYPE abap_bool.
    DATA:
      BEGIN OF s_msg,
        msgv1 TYPE symsgv,
        msgv2 TYPE symsgv,
        msgv3 TYPE symsgv,
        msgv4 TYPE symsgv,
      END OF s_msg.
    IF exception->previous IS BOUND.
      _detlevel = id_detlevel + 1.
      CALL METHOD add_exception
        EXPORTING
          exception    = exception->previous
          id_detlevel  = _detlevel
          id_probclass = id_probclass.
    ENDIF.
    o_ref ?= cl_abap_classdescr=>describe_by_data( p_data = exception ).
    o_obj ?= get_ref_type( o_ref ).
    cx_src_pos = zaplink_cx=>source_position_as_string( exception ).
    s_msg = o_obj->absolute_name.
    IF NOT s_msg-msgv2 IS INITIAL OR NOT s_msg-msgv3 IS INITIAL OR NOT s_msg-msgv4 IS INITIAL.    f_toolong = abap_true.    ENDIF.
    s_msg = cx_src_pos.
    IF NOT s_msg-msgv2 IS INITIAL OR NOT s_msg-msgv3 IS INITIAL OR NOT s_msg-msgv4 IS INITIAL.    f_toolong = abap_true.    ENDIF.
    s_msg = cx_text = exception->if_message~get_text( ).
    IF NOT s_msg-msgv3 IS INITIAL OR NOT s_msg-msgv4 IS INITIAL.    f_toolong = abap_true.    ENDIF.
    IF f_toolong IS INITIAL.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE e002(zaplink_easyxml) WITH abap_true abap_true abap_true abap_true. ENDIF.
      SET EXTENDED CHECK ON.
      CALL METHOD add_error
        EXPORTING
          id_msgid     = 'ZAPLINK_EASYXML'
          id_msgno     = '002'
          id_msgv1     = o_obj->absolute_name
          id_msgv2     = s_msg-msgv1
          id_msgv3     = s_msg-msgv2
          id_msgv4     = cx_src_pos
          id_detlevel  = id_detlevel
          id_probclass = id_probclass.
    ELSE.
      s_msg = o_obj->absolute_name.   s_msg+100 = cx_src_pos.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE e012(zaplink_easyxml) WITH abap_true abap_true abap_true abap_true. ENDIF.
      SET EXTENDED CHECK ON.
      CALL METHOD add_error
        EXPORTING
          id_msgid     = 'ZAPLINK_EASYXML'
          id_msgno     = '012'
          id_msgv1     = s_msg-msgv1
          id_msgv2     = s_msg-msgv2
          id_msgv3     = s_msg-msgv3
          id_msgv4     = s_msg-msgv4
          id_detlevel  = id_detlevel
          id_probclass = id_probclass.
      WHILE NOT cx_text IS INITIAL.
        s_msg = cx_text.
        SET EXTENDED CHECK OFF.
        IF 1 = 2. MESSAGE e011(zaplink_easyxml) WITH abap_true abap_true abap_true abap_true. ENDIF.
        SET EXTENDED CHECK ON.
        CALL METHOD add_info
          EXPORTING
            id_msgid     = 'ZAPLINK_EASYXML'
            id_msgno     = '011'
            id_msgv1     = s_msg-msgv1
            id_msgv2     = s_msg-msgv2
            id_msgv3     = s_msg-msgv3
            id_msgv4     = s_msg-msgv4
            id_detlevel  = id_detlevel
            id_probclass = id_probclass.
        IF strlen( cx_text ) < 200.   CLEAR cx_text.    ELSE.   SHIFT cx_text BY 200 PLACES LEFT.    ENDIF.
      ENDWHILE.
    ENDIF.
  ENDMETHOD.
  METHOD _add_zl_cx.
    DATA _detlevel  TYPE ballevel.
    IF exception->previous IS BOUND.
      _detlevel = id_detlevel + 1.
      CALL METHOD add_exception
        EXPORTING
          exception    = exception->previous
          id_detlevel  = _detlevel
          id_probclass = id_probclass.
    ENDIF.
    CALL METHOD _add_exception
      EXPORTING
        exception    = exception
        id_detlevel  = id_detlevel
        id_probclass = id_probclass.
    IF exception->messages IS BOUND.
      CALL METHOD add_from_instance
        EXPORTING
          io_msglist        = exception->messages
          if_add_as_subnode = abap_true.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_MESSAGE_COLLECTOR implementation
CLASS zaplink_opt_devclass IMPLEMENTATION.
  METHOD constructor.
    super->constructor( ).
    _substitution = substitutionkinds-keep_existing.
  ENDMETHOD.
  METHOD do_exists.
    result = abap_false.
    CHECK NOT data IS INITIAL.
    CALL FUNCTION 'TRINT_DEVCLASS_GET'
      EXPORTING
        iv_devclass        = data
      EXCEPTIONS
        devclass_not_found = 1
        OTHERS             = 2.
    IF sy-subrc = 0.
      result = abap_true.
    ELSEIF sy-subrc <> 1.
      RAISE EXCEPTION TYPE zaplink_cx_opt_devclass
        EXPORTING
          textid   = zaplink_cx_opt_devclass=>missing_devclass
          devclass = data.
    ENDIF.
  ENDMETHOD.
  METHOD get_devclass.
    result = _devclass.
  ENDMETHOD.
  METHOD get_existing.
    DATA _name        TYPE tadir-obj_name.
    DATA _type        TYPE tadir-object.
    DATA _exists      TYPE saus_dpara-tadirexist.
    DATA _kind        TYPE tadir-pgmid.
    CHECK component IS BOUND.
    TRY.
        _type = component->get_type( ).
        _name = component->get_name( ).
        _kind = component->get_typekind( ).
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
    CALL FUNCTION 'TRINT_TADIR_QUERY'
      EXPORTING
        iv_pgmid    = _kind
        iv_object   = _type
        iv_obj_name = _name
      IMPORTING
        ev_devclass = result
        ev_exist    = _exists.
    IF _exists IS INITIAL.
      CLEAR result.
    ENDIF.
  ENDMETHOD.
  METHOD get_substitutionkind.
    result = _substitution.
  ENDMETHOD.
  METHOD set_devclass.
    CHECK data <> _devclass.
    IF _devclass IS INITIAL AND _substitution = substitutionkinds-fixed.
      RAISE EXCEPTION TYPE zaplink_cx_opt_devclass
        EXPORTING
          textid    = zaplink_cx_opt_devclass=>missing_devclass
          substkind = _substitution.
    ENDIF.
    _devclass = data.
  ENDMETHOD.
  METHOD set_substitutionkind.
    CHECK data <> _substitution.
    CASE data.
      WHEN substitutionkinds-keep_existing OR
           substitutionkinds-use_container OR
           substitutionkinds-no_overwrite  OR
           substitutionkinds-local.
      WHEN substitutionkinds-fixed.
        IF _devclass IS INITIAL.
          RAISE EXCEPTION TYPE zaplink_cx_opt_devclass
            EXPORTING
              textid    = zaplink_cx_opt_devclass=>missing_devclass
              substkind = data.
        ENDIF.
      WHEN OTHERS.
        RAISE EXCEPTION TYPE zaplink_cx_opt_devclass
          EXPORTING
            textid    = zaplink_cx_opt_devclass=>invalid_substitutionkind
            substkind = data.
    ENDCASE.
    _substitution = data.
  ENDMETHOD.
  METHOD substitute.
    DATA comp_devc TYPE td_devclass.
    CHECK component IS BOUND.
    comp_devc = component->directory-devclass.
    TRY.
        IF component->get_type( ) = 'DEVC'.
          result = component->get_name( ).
        ELSE.
          CASE _substitution.
            WHEN substitutionkinds-no_overwrite.
              result = get_existing( component ).
              IF NOT result IS INITIAL.
                EXIT.
              ENDIF.
              IF do_exists( comp_devc ) = abap_true.
                result = comp_devc.
                EXIT.
              ENDIF.
              result = me->_devclass.
            WHEN substitutionkinds-keep_existing.
              result = get_existing( component ).
              IF result IS INITIAL.
                result = local_devclass.
              ENDIF.
            WHEN substitutionkinds-use_container.
              IF do_exists( comp_devc ) = abap_true.
                result = comp_devc.
              ELSE.
                result = local_devclass.
              ENDIF.
            WHEN substitutionkinds-local.
              result = local_devclass.
            WHEN substitutionkinds-fixed.
              result = me->_devclass.
            WHEN OTHERS.
              RAISE EXCEPTION TYPE zaplink_cx_opt_devclass
                EXPORTING
                  textid    = zaplink_cx_opt_devclass=>invalid_substitutionkind
                  substkind = _substitution.
          ENDCASE.
        ENDIF.
        mac_def_catch zaplink_cx_opt_devclass.
    ENDTRY.
    IF result IS INITIAL.   result = local_devclass.    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_OPT_DEVCLASS implementation
CLASS zaplink_opt_transport_request IMPLEMENTATION.
  METHOD constructor.
    super->constructor( ).
    _substitution = substitutionkinds-input.
  ENDMETHOD.
  METHOD get_substitutionkind.
    result = _substitution.
  ENDMETHOD.
  METHOD get_transport_request.
    result = _transport_request.
  ENDMETHOD.
  METHOD set_substitutionkind.
    CHECK data <> _substitution.
    CLEAR _user_input.
    CASE data.
      WHEN substitutionkinds-same_as_container OR
           substitutionkinds-user OR
           substitutionkinds-custom OR
           substitutionkinds-input.
      WHEN substitutionkinds-fixed.
        IF _transport_request IS INITIAL.
          RAISE EXCEPTION TYPE zaplink_cx_opt_transport_req
            EXPORTING
              textid    = zaplink_cx_opt_transport_req=>missing_transport_request
              substkind = data.
        ENDIF.
      WHEN OTHERS.
        RAISE EXCEPTION TYPE zaplink_cx_opt_transport_req
          EXPORTING
            textid    = zaplink_cx_opt_transport_req=>invalid_substitutionkind
            substkind = data.
    ENDCASE.
    _substitution = data.
  ENDMETHOD.
  METHOD set_transport_request.
    CHECK data <> _transport_request.
    IF _transport_request IS INITIAL AND _substitution = substitutionkinds-fixed.
      RAISE EXCEPTION TYPE zaplink_cx_opt_transport_req
        EXPORTING
          textid    = zaplink_cx_opt_transport_req=>missing_transport_request
          substkind = _substitution.
    ENDIF.
    _transport_request = data.
  ENDMETHOD.
  METHOD substitute.
    DATA t_e071   TYPE STANDARD TABLE OF e071.
    DATA t_e071k  TYPE STANDARD TABLE OF e071k.
    FIELD-SYMBOLS:
      <s> LIKE LINE OF _tr_mapping.
    CHECK component IS BOUND.
    CASE _substitution.
      WHEN substitutionkinds-input.
        CLEAR result.
        EXIT. " all ways empty to let use choose the right transport request
      WHEN substitutionkinds-fixed.
        result = _transport_request.
      WHEN substitutionkinds-user.
        IF _user_input IS INITIAL.
          CALL FUNCTION 'TRINT_ORDER_CHOICE'
            EXPORTING
              wi_order_type          = 'K'
              wi_task_type           = 'S'
            IMPORTING
              we_task                = _user_input
            TABLES
              wt_e071                = t_e071
              wt_e071k               = t_e071k
            EXCEPTIONS
              no_correction_selected = 1
              display_mode           = 2
              object_append_error    = 3
              recursive_call         = 4
              wrong_order_type       = 5
              OTHERS                 = 6.
          IF sy-subrc <> 0.
            CLEAR _user_input.
          ELSE.
            result = _user_input.
          ENDIF.
        ENDIF.
        IF NOT _user_input IS INITIAL.
          result = _user_input.
        ELSE.
          CLEAR result.
        ENDIF.
      WHEN substitutionkinds-custom.
      WHEN substitutionkinds-same_as_container.
        READ TABLE _tr_mapping ASSIGNING <s>
             WITH TABLE KEY xml_tr = component->directory-trkorr.
        IF sy-subrc = 0.
          result = <s>-sap_tr.
        ELSEIF NOT component->directory-trkorr IS INITIAL.
        ENDIF.
      WHEN OTHERS.
        RAISE EXCEPTION TYPE zaplink_cx_opt_transport_req
          EXPORTING
            textid    = zaplink_cx_opt_transport_req=>invalid_substitutionkind
            substkind = _substitution.
    ENDCASE.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_OPT_TRANSPORT_REQUEST implementation
CLASS zaplink_tools IMPLEMENTATION.
  METHOD add_comp_to_working_area.
    DATA wa_flag   TYPE rs38l-head.
    DATA o_cx      TYPE REF TO zaplink_cx.
    DATA f_is_wi   TYPE abap_bool.
    DATA _name     TYPE e071-obj_name.
    _name = name.
    IF is_working_areable( type ) = abap_true.
      CALL FUNCTION 'RS_OBJECT_IN_WORKING_AREA'
        EXPORTING
          object              = type
          obj_name            = _name
        IMPORTING
          object_is_work_item = f_is_wi.
      IF f_is_wi = abap_false.   " should be the case
        CALL FUNCTION 'RS_INSERT_INTO_WORKING_AREA'
          EXPORTING
            object            = type
            obj_name          = _name
          IMPORTING
            object_inserted   = wa_flag
          EXCEPTIONS
            wrong_object_name = 1
            OTHERS            = 2.
        IF sy-subrc <> 0.
          o_cx ?= zaplink_cx=>create_from_mf_cx( funcname = 'RS_INSERT_INTO_WORKING_AREA'
                                                    subrc = sy-subrc
                                                classname = 'ZAPLINK_CX' ).
          RAISE EXCEPTION o_cx.
        ENDIF.
      ENDIF.
    ELSE.   " Security Remove old eroneous entries Issue 137
      CALL FUNCTION 'RS_OBJECT_IN_WORKING_AREA'
        EXPORTING
          object              = type
          obj_name            = _name
        IMPORTING
          object_is_work_item = f_is_wi.
      IF f_is_wi = abap_true.   " should only be the case of Issue 137
        remove_comp_from_working_area( type = type
                                       name = name ).
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD calculate_md5_hash.
    DATA _len            TYPE i.
    DATA _md5            TYPE md5_fields-hash.
    _len = strlen( string ).
    CALL FUNCTION 'MD5_CALCULATE_HASH_FOR_CHAR'
      EXPORTING
        data           = string
        length         = _len
      IMPORTING
        hash           = _md5
      EXCEPTIONS
        no_data        = 1
        internal_error = 2
        OTHERS         = 3.
    IF sy-subrc = 0.    result = _md5.    ENDIF.
  ENDMETHOD.
  METHOD check_valid_proglist.
    DATA gc_infoline_on TYPE oax.
    DATA it_gensetc_raw TYPE tt_gensetc.
    DATA t_trdir TYPE HASHED TABLE OF trdir WITH UNIQUE KEY name.
    FIELD-SYMBOLS:
      <dir> LIKE LINE OF t_trdir,
      <obj> LIKE LINE OF it_gensetc_raw.
    it_gensetc_raw = list.
    PERFORM  tadir_2_trdir IN PROGRAM rsparagenlod
             CHANGING it_gensetc_raw.
    DELETE ADJACENT DUPLICATES FROM it_gensetc_raw COMPARING name.
    IF lines( it_gensetc_raw ) > 1000.
      PERFORM trdir_check IN PROGRAM rsparagenlod
        USING    gc_infoline_on
                 it_gensetc_raw
      CHANGING result.
    ELSE.
      SELECT * INTO TABLE t_trdir
        FROM trdir
        FOR ALL ENTRIES IN it_gensetc_raw
        WHERE name = it_gensetc_raw-name
        %_HINTS ORACLE '&max_blocking_factor 50&'.
      LOOP AT it_gensetc_raw ASSIGNING <obj>.
        READ TABLE t_trdir ASSIGNING <dir>
             WITH TABLE KEY name = <obj>-name.
        CHECK sy-subrc = 0.
        CHECK <dir>-subc CA gc_gen_types.
        APPEND <obj> TO result.
      ENDLOOP.
    ENDIF.
    SORT result BY pgmid object objname.   DELETE ADJACENT DUPLICATES FROM result COMPARING pgmid object objname.
  ENDMETHOD.
  METHOD class_constructor.
    DATA s_mandant  TYPE t000.
    SELECT SINGLE *
      INTO s_mandant
      FROM t000.
    ASSERT sy-subrc = 0.
    IF s_mandant-cccategory <> 'P'    " Productive
      AND s_mandant-ccnocliind CO ' 1'.
      import_allowed = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD clean_abap_string.
    CHECK NOT data IS INITIAL.    result = data.
    REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>newline IN result WITH ``.
    REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>cr_lf IN result WITH ``.
    REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>form_feed IN result WITH ``.
  ENDMETHOD.
  METHOD comment_statement.
    DATA d_line       TYPE i.
    DATA d_start      TYPE i.
    DATA d_end        TYPE i.
    DATA d_sdeb       TYPE string.
    DATA d_sfin       TYPE string.
    DATA d_removed    TYPE string.
    DATA f_st_full_l  TYPE abap_bool.     " statement is alone on his lines
    FIELD-SYMBOLS:
      <t_bdeb> LIKE LINE OF tokens,
      <t_afin> LIKE LINE OF tokens,
      <t_deb>  LIKE LINE OF tokens,
      <t_fin>  LIKE LINE OF tokens,
      <l>      LIKE LINE OF code.
    READ TABLE tokens ASSIGNING <t_deb> INDEX statement-from.    ASSERT sy-subrc = 0.
    READ TABLE tokens ASSIGNING <t_fin> INDEX statement-to.      ASSERT sy-subrc = 0.
    f_st_full_l = abap_true.
    d_start = statement-from - 1.     READ TABLE tokens ASSIGNING <t_bdeb> INDEX d_start.
    IF <t_bdeb> IS ASSIGNED.    IF <t_bdeb>-row >= <t_deb>-row.   CLEAR f_st_full_l.    ENDIF.    ENDIF.
    d_end = statement-to + 1.         READ TABLE tokens ASSIGNING <t_afin> INDEX d_end.
    IF <t_afin> IS ASSIGNED.    IF <t_afin>-row <= <t_fin>-row.   CLEAR f_st_full_l.    ENDIF.    ENDIF.
    IF f_st_full_l = abap_true.   " simple case statement is alone
      LOOP AT code ASSIGNING <l> FROM <t_deb>-row TO <t_fin>-row.
        CONCATENATE '*' <l> '"' comment INTO <l>.
      ENDLOOP.
    ELSE.     " Statement share lines with other statements
      d_start = <t_deb>-row + 1.    d_end = <t_fin>-row - 1.
      IF d_start <= d_end.    " lines for this statements only
        LOOP AT code ASSIGNING <l> FROM d_start TO d_end.
          CONCATENATE '*' <l> '"' comment INTO <l>.
        ENDLOOP.
      ENDIF.
      READ TABLE code ASSIGNING <l> INDEX <t_fin>-row.          ASSERT sy-subrc = 0.
      IF <t_deb>-row = <t_fin>-row.     " on the same line
        CLEAR: d_sdeb, d_sfin.
        d_end = <t_fin>-col + strlen( <t_fin>-str ).
        d_removed = <l>+<t_deb>-col(d_end).
        d_sdeb = <l>(<t_deb>-col).    d_sfin = <l>+d_end.
        CONCATENATE d_sdeb d_sfin '"' comment d_removed INTO <l>.
      ELSE.
        CLEAR: d_sdeb, d_sfin.
        d_end = <t_fin>-col + strlen( <t_fin>-str ).
        d_removed = <l>(d_end).
        d_sfin = <l>+d_end.
        CONCATENATE d_sfin '"' comment d_removed INTO <l>.
        READ TABLE code ASSIGNING <l> INDEX <t_deb>-row.         ASSERT sy-subrc = 0.
        CLEAR: d_sdeb, d_sfin.
        d_sdeb = <l>(<t_deb>-col).
        d_removed = <l>+<t_deb>-col.
        <l> = d_sdeb.
        CONCATENATE d_sdeb '"' comment d_removed INTO <l>.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD condense_abap_source.
    FIELD-SYMBOLS <l> TYPE any.
    LOOP AT table ASSIGNING <l>.
      IF <l> IS INITIAL. DELETE table. CONTINUE. ENDIF.  " Condense
      IF <l>(1) = '*'.   DELETE table. CONTINUE. ENDIF.  " Condense
      <l> = conv_abap_line( <l> ).   CONDENSE <l>.
      IF <l> IS INITIAL. CLEAR <l>. CONTINUE. ENDIF.          " Issue 131
      IF <l>(1) = '"'.   DELETE table. CONTINUE. ENDIF.  " commented line like :     " comment
    ENDLOOP.
  ENDMETHOD.
  METHOD conv_abap_line.
    target = source.
    REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>horizontal_tab IN target WITH ` `.
  ENDMETHOD.
  METHOD conv_compkey_2_proglist.
    DATA s_entry      LIKE LINE OF result.
    FIELD-SYMBOLS <k> LIKE LINE OF keys.
    LOOP AT keys ASSIGNING <k>.
      s_entry-pgmid = 'R3TR'.     s_entry-object = <k>-type.      s_entry-objname = <k>-name.   APPEND s_entry TO result.
    ENDLOOP.
    SORT result. DELETE ADJACENT DUPLICATES FROM result.
  ENDMETHOD.
  METHOD conv_limu_2_r3tr.
    DATA _objlist LIKE LINE OF result.
    DATA w_tadir TYPE tadir.
    FIELD-SYMBOLS <limu> LIKE LINE OF e071.
    LOOP AT e071 ASSIGNING <limu>.
      CLEAR: _objlist.
      IF <limu>-pgmid = 'R3TR'.
        _objlist-type = <limu>-object.
        _objlist-name = <limu>-obj_name.
      ELSE.
        CALL FUNCTION 'TR_CHECK_TYPE'
          EXPORTING
            wi_e071  = <limu>
          IMPORTING
            we_tadir = w_tadir.
        _objlist-type = w_tadir-object.
        _objlist-name = w_tadir-obj_name.
      ENDIF.
      IF _objlist IS NOT INITIAL. APPEND _objlist TO result. ENDIF.
    ENDLOOP.
    SORT result BY type name.
    DELETE ADJACENT DUPLICATES FROM result COMPARING type name.
  ENDMETHOD.
  METHOD conv_proglist_2_compkey.
    DATA s_entry      LIKE LINE OF result.
    FIELD-SYMBOLS <k> LIKE LINE OF list.
    LOOP AT list ASSIGNING <k>.
      CHECK NOT <k>-name IS INITIAL.
      s_entry-type = 'PROG'.      s_entry-name = <k>-name.   APPEND s_entry TO result.
    ENDLOOP.
    SORT result. DELETE ADJACENT DUPLICATES FROM result.
  ENDMETHOD.
  METHOD conv_table_2upcase.
    FIELD-SYMBOLS <l> TYPE any.
    LOOP AT table ASSIGNING <l>.    TRANSLATE <l> TO UPPER CASE.  ENDLOOP. "#EC SYNTCHAR
  ENDMETHOD.
  METHOD extend_package.
    DATA r_exclu TYPE tr_packages.
    DATA t_level TYPE tt_pack.
    t_level = result = packages .
    WHILE NOT t_level[] IS INITIAL.
      SORT t_level.
      DELETE ADJACENT DUPLICATES FROM t_level.
      SELECT devclass
          FROM tdevc
          INTO TABLE t_level
             FOR ALL ENTRIES IN t_level
          WHERE parentcl = t_level-table_line.
      APPEND LINES OF t_level TO result.
    ENDWHILE.
    SORT result.
    DELETE ADJACENT DUPLICATES FROM result.
  ENDMETHOD.
  METHOD extend_packages.
    DATA r_exclu TYPE tr_packages.
    DATA t_level TYPE tr_packages.
    DATA s_pack LIKE LINE OF result.
    CHECK NOT packages IS INITIAL.
    r_exclu = packages.   DELETE r_exclu WHERE sign <> 'E'. " Keep only Devcclass to remove
    result = get_sub_packages( packages ).
    IF NOT r_exclu IS INITIAL.
      s_pack-sign = 'I'.   MODIFY r_exclu FROM s_pack TRANSPORTING sign WHERE sign <> s_pack-sign.
      r_exclu = get_sub_packages( r_exclu ).
      DELETE result WHERE low IN r_exclu.
    ENDIF.
    SORT result.    DELETE ADJACENT DUPLICATES FROM result COMPARING low.
    s_pack-sign = 'I'.  s_pack-option = 'EQ'.   MODIFY result FROM s_pack TRANSPORTING sign option WHERE NOT low IS INITIAL.
  ENDMETHOD.
  METHOD get_clas_name.
    DATA o_desc TYPE REF TO cl_abap_objectdescr.
    DATA d_pos TYPE i.
    DATA d_str  TYPE string.
    CHECK object IS BOUND.
    o_desc ?= cl_abap_objectdescr=>describe_by_object_ref( object ).
    d_str = o_desc->absolute_name.
    FIND ALL OCCURRENCES OF '=' IN d_str MATCH OFFSET d_pos.
    IF NOT d_pos IS INITIAL.
      ADD 1 TO d_pos.
      IF strlen( d_str ) > d_pos.
        d_str = d_str+d_pos.
      ENDIF.
    ENDIF.
    result = d_str.
  ENDMETHOD.
  METHOD get_keys_from_package.
    result = get_keys_from_tadir( packages = packages   ext = ext ).
  ENDMETHOD.
  METHOD get_keys_from_tadir.
    TYPES tt_pack TYPE STANDARD TABLE OF tdevc-devclass.
    DATA r_exclu TYPE tr_packages.
    DATA t_devc  TYPE tt_pack.
    DATA t_exclu TYPE tt_pack.
    FIELD-SYMBOLS: <p> LIKE LINE OF t_exclu.
    IF packages IS INITIAL.
      CHECK srcsystem IS NOT INITIAL OR type IS NOT INITIAL OR name IS NOT INITIAL OR author IS NOT INITIAL. " to prevent extracting all tadir
      SELECT object obj_name
        INTO TABLE result
        FROM tadir
        WHERE srcsystem IN srcsystem
          AND object IN type
          AND obj_name IN name
          AND author IN author.
      EXIT.
    ENDIF.
    r_exclu = packages.
    DELETE r_exclu WHERE sign <> 'E'. " Keep only Devcclass to remove
    SELECT devclass
        FROM tdevc
        INTO TABLE t_devc
        WHERE devclass IN packages.
    IF NOT ext IS INITIAL.
      t_devc = extend_package( t_devc ).
    ENDIF.
    IF NOT r_exclu IS INITIAL.
      SELECT devclass
          FROM tdevc
          INTO TABLE t_exclu
          WHERE NOT devclass IN r_exclu.
      t_exclu = extend_package( t_exclu ).
      LOOP AT t_exclu ASSIGNING <p>.
        DELETE TABLE t_devc FROM <p>.
      ENDLOOP.
    ENDIF.
    IF NOT t_devc IS INITIAL.
      SELECT object obj_name
        INTO TABLE result
        FROM tadir
          FOR ALL ENTRIES IN t_devc
        WHERE devclass = t_devc-table_line
          AND srcsystem IN srcsystem
          AND object IN type
          AND obj_name IN name
          AND author IN author.
    ENDIF.
  ENDMETHOD.
  METHOD get_keys_from_tr.
    DATA objlist TYPE tt_e071.
    DATA r_trs   TYPE tr_tr.
    SELECT trkorr trkorr trkorr
        FROM e070
        INTO TABLE r_trs
        WHERE trkorr IN tr.
    SELECT trkorr trkorr trkorr
        FROM e070
        APPENDING TABLE r_trs
        WHERE strkorr IN tr
          AND ( trstatus = 'D'    " Modifiable
             OR trstatus = 'O'    " Release started
             OR trstatus = 'L' ). " Modifiable locked
    SORT r_trs BY low.
    DELETE ADJACENT DUPLICATES FROM r_trs COMPARING low.
    IF NOT r_trs IS INITIAL.
      SELECT *
        FROM  e071
        INTO TABLE objlist
        FOR ALL ENTRIES IN r_trs
        WHERE  trkorr = r_trs-low.
      result = conv_limu_2_r3tr( objlist ).
    ENDIF.
  ENDMETHOD.
  METHOD get_sub_packages.
    DATA t_level TYPE tr_packages.
    DATA s_pack LIKE LINE OF result.
    CHECK NOT packages IS INITIAL.
    SELECT devclass AS low
        FROM tdevc
        INTO CORRESPONDING FIELDS OF TABLE result
        WHERE devclass IN packages.
    t_level = result.
    WHILE NOT t_level[] IS INITIAL.
      SORT t_level.
      DELETE ADJACENT DUPLICATES FROM t_level.
      SELECT devclass AS low
          FROM tdevc
          INTO CORRESPONDING FIELDS OF TABLE t_level
             FOR ALL ENTRIES IN t_level
          WHERE parentcl = t_level-low.
      APPEND LINES OF t_level TO result.
    ENDWHILE.
    SORT result.    DELETE ADJACENT DUPLICATES FROM result COMPARING low.
    s_pack-sign = 'I'.  s_pack-option = 'EQ'.   MODIFY result FROM s_pack TRANSPORTING sign option WHERE NOT low IS INITIAL.
  ENDMETHOD.
  METHOD inverse_table_order.
    DATA x TYPE i.
    FIELD-SYMBOLS <o> TYPE any.
    CHECK NOT my_table IS INITIAL.
    x = lines( my_table ) + 1.
    LOOP AT my_table ASSIGNING <o>.
      IF sy-tabix >= x.   EXIT.   ENDIF.
      INSERT <o> INTO my_table INDEX x.
    ENDLOOP.
    SUBTRACT 1 FROM x.    CHECK x > 0.   DELETE my_table FROM 1 TO x.
  ENDMETHOD.
  METHOD is_working_areable.
    DATA l_item TYPE sewor_working_area.
    result = abap_false.
    CHECK type <> 'CLAS' AND type <> 'PROG' AND type <> 'FUGR'.
    CALL FUNCTION 'RS_OBJ_SUPPORTS_INACTIVE'
      EXPORTING
        obj_type          = space
        sub_type          = type
      IMPORTING
        supports_inactive = result.
  ENDMETHOD.
  METHOD pretty_printer.
    FIELD-SYMBOLS <a>   TYPE any.
    DATA d_remotedata   TYPE string.
    DATA v_extend_mod   TYPE char255.
    DATA v_komprmode(1) TYPE c VALUE '0'.
    DATA v_edit_control TYPE c.
    DATA v_status_flag  TYPE char255.
    DATA v_convert_mode TYPE rseumod.
    DATA v_source_id    TYPE sy-repid.
    DATA v_overflow_area TYPE char255.
    DATA v_content_fill TYPE sy-index.
    DATA v_msg          TYPE char255.
    DATA v_incl         TYPE char255.
    DATA v_row          TYPE char255.
    DATA v_col          TYPE char255.
    DATA v_wrd(30)      TYPE c.
    DATA v_scanned      TYPE char255.
    DATA t_mod_tab      TYPE smodi_mod_tab.
    DATA t_lineindex    TYPE STANDARD TABLE OF edlineindx.
    DATA t_tk           TYPE sedi_tk.
    DATA t_stm          TYPE STANDARD TABLE OF sstmnt.
    DATA t_dummy        TYPE STANDARD TABLE OF string.
    DEFINE mac_assign.
      d_remotedata = &1.
      ASSIGN (d_remotedata) TO <a>.
      IF sy-subrc = 0. <a> = &2. ENDIF.
    END-OF-DEFINITION.
    EXIT.
    CALL FUNCTION 'CONVERT_EDITOR_SOURCE'
      EXPORTING
        convert_mode  = v_convert_mode
        source_id     = v_source_id
        extend_mod    = v_extend_mod
        komprmode     = v_komprmode
        edit_control  = v_edit_control
        status_flag   = v_status_flag
      TABLES
        content       = t_dummy
        tk            = t_tk
        stm           = t_stm
        lineindex     = t_lineindex
        mod_tab       = t_mod_tab
      CHANGING
        overflow_area = v_overflow_area
        content_fill  = v_content_fill
        msg           = v_msg
        incl          = v_incl
        row           = v_row
        col           = v_col
        wrd           = v_wrd
        scanned       = v_scanned.
    IF indent <> abap_true.   v_convert_mode-indent = '0'.    ENDIF.
    mac_assign '(SAPLLOCAL_EDT1)RSEUMOD-STYLE' abap_true.   " Change code to ....
    mac_assign '(SAPLLOCAL_EDT1)RSEUMOD-LOWERCASE' space.   " UPPER CASE
    mac_assign '(SAPLLOCAL_EDT1)EDIT-APP_ABAP' abap_true.   " ABAP Editor
    mac_assign '(SAPLLOCAL_EDT1)EDIT-LINE_SIZE' swbse_c_max_line_width.       " Line Size
    CALL FUNCTION 'CONVERT_EDITOR_SOURCE'
      EXPORTING
        convert_mode  = v_convert_mode
        source_id     = v_source_id
        extend_mod    = v_extend_mod
        komprmode     = v_komprmode
        edit_control  = v_edit_control
        status_flag   = v_status_flag
      TABLES
        content       = table
        tk            = t_tk
        stm           = t_stm
        lineindex     = t_lineindex
        mod_tab       = t_mod_tab
      CHANGING
        overflow_area = v_overflow_area
        content_fill  = v_content_fill
        msg           = v_msg
        incl          = v_incl
        row           = v_row
        col           = v_col
        wrd           = v_wrd
        scanned       = v_scanned.
    DATA t_tokens TYPE STANDARD TABLE OF stokes.
    DATA t_statements TYPE STANDARD TABLE OF sstmnt.
    DATA t_lines   TYPE SORTED TABLE OF sstmnt WITH UNIQUE KEY trow.
    DATA d_tabix   TYPE sy-tabix.
    DATA t_result  TYPE match_result_tab.
    FIELD-SYMBOLS:
      <st> LIKE LINE OF t_lines,
      <r>  LIKE LINE OF t_result.
    SCAN ABAP-SOURCE table TOKENS INTO t_tokens
                       STATEMENTS INTO t_statements.
    SORT t_statements BY trow. DELETE ADJACENT DUPLICATES FROM t_statements COMPARING trow.
    DELETE t_statements WHERE trow = 0.
    t_lines = t_statements.
    LOOP AT table ASSIGNING <a>.
      CHECK <a> CP '*"*' AND NOT <a> CP '*"##EC*'.
      d_tabix = sy-tabix.
      READ TABLE t_lines ASSIGNING <st>
           WITH TABLE KEY trow = d_tabix.
      CHECK sy-subrc = 0.
      FIND ALL OCCURRENCES OF '"' IN <a> RESULTS t_result.
      LOOP AT t_result ASSIGNING <r>.
        CHECK <r>-offset >  <st>-tcol.
        <a> = <a>(<r>-offset).    EXIT.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.
  METHOD remove_comment_on_source.
    FIELD-SYMBOLS <l> TYPE any.
    LOOP AT table ASSIGNING <l>.
      IF <l> IS INITIAL. DELETE table. CONTINUE. ENDIF.  " Condense
      IF <l>(1) = '*'.   DELETE table. CONTINUE. ENDIF.  " Condense
      <l> = conv_abap_line( <l> ).
    ENDLOOP.
  ENDMETHOD.
  METHOD remove_comp_from_working_area.
    DATA _name     TYPE e071-obj_name.
    _name = name.
    IF type ='CLAS'.
      DELETE FROM dwinactiv WHERE object = type
                            AND obj_name = _name.
    ELSE.
      CALL FUNCTION 'RS_DELETE_FROM_WORKING_AREA'
        EXPORTING
          object                 = type
          obj_name               = _name
          immediate              = abap_true
          actualize_working_area = abap_false.
    ENDIF.
  ENDMETHOD.
  METHOD table_2_string.
    DATA s TYPE string.
    CHECK NOT source IS INITIAL.
    LOOP AT source INTO s.
      CONCATENATE result cl_abap_char_utilities=>newline s INTO result.
    ENDLOOP.
    SHIFT result LEFT BY 1 PLACES.
  ENDMETHOD.
  METHOD unzip_string.
    TRY.
        CALL METHOD cl_abap_gzip=>decompress_text
          EXPORTING
            gzip_in    = data
            conversion = 'DEFAULT'
          IMPORTING
            text_out   = result.
      CATCH cx_parameter_invalid_range.
        result = data.
      CATCH cx_sy_buffer_overflow.
        result = data.
      CATCH cx_sy_conversion_codepage.
        result = data.
      CATCH cx_sy_compression_error.
        result = data.
    ENDTRY.
  ENDMETHOD.
  METHOD zip_string.
    TRY.
        CALL METHOD cl_abap_gzip=>compress_text
          EXPORTING
            text_in        = data
            compress_level = 9
            conversion     = 'DEFAULT'
          IMPORTING
            gzip_out       = result.
      CATCH cx_parameter_invalid_range.
        result = data.
      CATCH cx_sy_buffer_overflow.
        result = data.
      CATCH cx_sy_conversion_codepage.
        result = data.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_TOOLS implementation
CLASS zlcx_comp_already_exists IMPLEMENTATION.
  METHOD constructor.
    CALL METHOD super->constructor
      EXPORTING
        previous    = previous
        messages    = messages
        object      = object
        subobject   = subobject
        ext_id      = ext_id
        cx_name     = cx_name
        _cx_list    = _cx_list
        systemstack = systemstack
        name        = name
        type        = type
        connclass   = connclass
        sel_action  = sel_action.
    CLEAR me->textid.
    IF textid IS INITIAL.
      if_t100_message~t100key = zlcx_comp_already_exists .
    ELSE.
      if_t100_message~t100key = textid.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZLCX_COMP_ALREADY_EXISTS implementation
CLASS zaplink_acid_data IMPLEMENTATION.
  METHOD anonymize.
    CLEAR: a0_maindata-create_user,  a0_maindata-create_date.
  ENDMETHOD.
  METHOD from_data.
    DATA s_user     LIKE LINE OF settings_for_users.
    DATA s_server   LIKE LINE OF settings_for_servers.
    DATA s_desc     LIKE LINE OF descriptions.
    FIELD-SYMBOLS:
      <d> LIKE LINE OF fm_data-descriptions,
      <m> LIKE LINE OF fm_data-modes.
    LOOP AT fm_data-descriptions ASSIGNING <d>.
      CLEAR s_desc.   s_desc-lang = <d>-langu.     s_desc-text = <d>-descript.   INSERT s_desc INTO TABLE descriptions.
    ENDLOOP.
    LOOP AT fm_data-modes ASSIGNING <m>.
      IF NOT <m>-username IS INITIAL.
        CLEAR s_user.   s_user-user = <m>-username.   s_user-activation = conv_mode2activation( <m>-actmode ).
        INSERT s_user INTO TABLE settings_for_users.
      ELSEIF NOT <m>-server IS INITIAL.
        CLEAR s_server.   s_server-server = <m>-server.   s_server-activation = conv_mode2activation( <m>-actmode ).
        INSERT s_server INTO TABLE settings_for_servers.
      ELSEIF NOT <m>-actdefault IS INITIAL OR global_settings IS INITIAL.
        global_settings = conv_mode2activation( <m>-actmode ).
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_mode     LIKE LINE OF fm_data-modes.
    DATA s_server   LIKE LINE OF settings_for_servers.
    DATA s_desc     LIKE LINE OF fm_data-descriptions.
    FIELD-SYMBOLS:
      <d> LIKE LINE OF descriptions,
      <s> LIKE LINE OF settings_for_servers,
      <u> LIKE LINE OF settings_for_users.
    LOOP AT descriptions ASSIGNING <d>.
      CLEAR s_desc.   s_desc-langu = <d>-lang.     s_desc-descript = <d>-text.   INSERT s_desc INTO TABLE fm_data-descriptions.
    ENDLOOP.
    s_mode-actmode = conv_activation2mode( global_settings ).     s_mode-actdefault = abap_true.
    INSERT s_mode INTO TABLE fm_data-modes.
    LOOP AT settings_for_users ASSIGNING <u>.
      CLEAR s_mode.     s_mode-username = <u>-user.   s_mode-actmode = conv_activation2mode( <u>-activation ).
      INSERT s_mode INTO TABLE fm_data-modes.
    ENDLOOP.
    LOOP AT settings_for_servers ASSIGNING <s>.
      CLEAR s_mode.     s_mode-server = <s>-server.   s_mode-actmode = conv_activation2mode( <s>-activation ).
      INSERT s_mode INTO TABLE fm_data-modes.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_ACID_DATA implementation
CLASS zaplink_activate IMPLEMENTATION.
  METHOD activate.
    DATA:
      lb_actdone TYPE xflag,
      lc_before  TYPE i,
      lc_after   TYPE i,
      it_items   TYPE tt_items,
      it_progs   TYPE tt_objlist,
      it_mainp   TYPE tt_mainprogs,
      _mp        LIKE LINE OF it_mainp,
      dummy_tab  TYPE tt_items,
      it_objlist TYPE tt_objlist,
      it_ddic    TYPE tt_objlist,
      it_det_obj TYPE tt_det_obj.
    it_obj_list = compkeys_2_objlist( component_list ).
    SORT it_obj_list BY object obj_name.
    DELETE ADJACENT DUPLICATES FROM it_obj_list COMPARING object obj_name.
    CALL METHOD split_list
      EXPORTING
        obj_list  = it_obj_list
      IMPORTING
        ddic      = it_ddic
        prog_list = it_progs.
    activate_ddic( CHANGING it_list = it_ddic ).
    activate_nonddic( CHANGING it_list = it_progs ).
    COMMIT WORK AND WAIT.
    DO.
      CLEAR lb_actdone.
      IF NOT it_ddic IS INITIAL.
        lc_before = lines( it_ddic ).
        activate_ddic( CHANGING it_list = it_ddic ).
        lc_after = lines( it_ddic ).
        IF lc_after < lc_before.
          lb_actdone = abap_true.
          COMMIT WORK AND WAIT.
        ENDIF.
      ENDIF.
      IF NOT it_progs IS INITIAL.
        lc_before = lines( it_progs ).
        activate_nonddic( EXPORTING one_by_one = 'X'
                           CHANGING    it_list = it_progs ).
        lc_after = lines( it_progs ).
        IF lc_after >= lc_before.
          activate_nonddic( CHANGING    it_list = it_progs ).    " Try mass activation
          lc_after = lines( it_progs ).
        ENDIF.
        IF lc_after < lc_before.
          lb_actdone = abap_true.
          COMMIT WORK AND WAIT.
        ENDIF.
      ENDIF.
      IF lb_actdone IS INITIAL. EXIT. ENDIF.
    ENDDO.
    IF force_activation IS NOT INITIAL.
      activate_nonddic( EXPORTING force_activation = force_activation
                                  CHANGING it_list = it_progs ).
    ENDIF.
    APPEND LINES OF it_ddic TO it_objlist.
    APPEND LINES OF it_progs TO it_objlist.
    result = objlist_2_compkeys( it_objlist ).
  ENDMETHOD.
  METHOD activate_ddic.
    DATA:
      it_debug TYPE STANDARD TABLE OF ddmsactrc WITH NON-UNIQUE DEFAULT KEY.
    FIELD-SYMBOLS:
      <wa> LIKE LINE OF it_debug.
    CALL FUNCTION 'SEO_BUFFER_REFRESH'
      EXPORTING
        force = 'X'.
    CALL FUNCTION 'SEO_BUFFER_REFRESH'
      EXPORTING
        version = 1
        force   = 'X'.
    CALL FUNCTION 'RS_DD_WORKLIST_ACTIVATE'
      EXPORTING
        p_generate_active_obj = 'X'
        i_suppress_dialog     = 'X'
      TABLES
        t_worklist            = it_list
        t_act_obj             = it_debug
      EXCEPTIONS
        not_all_activated     = 1
        error_occured         = 2
        locked                = 3
        OTHERS                = 4.
    IF sy-subrc <= 1.
      LOOP AT it_debug ASSIGNING <wa>.
        DELETE it_list
            WHERE pgmid = <wa>-pgmid
              AND object = <wa>-type
              AND obj_name = <wa>-name.
      ENDLOOP.
    ENDIF.
    COMMIT WORK AND WAIT.
  ENDMETHOD.
  METHOD activate_ddic_v2.
    DATA:
      _wb_manager TYPE REF TO  if_wb_manager,               "#EC NEEDED
      it_obj      TYPE tt_det_obj,
      it_det_obj  TYPE tt_det_obj.
    it_det_obj = get_inactive_objects( it_list ).
    CALL FUNCTION 'RS_WORKING_OBJECTS_ACTIVATE'
      EXPORTING
        activate_ddic_objects  = 'X'
      TABLES
        objects                = it_det_obj
      EXCEPTIONS
        excecution_error       = 1
        cancelled              = 2
        insert_into_corr_error = 3
        OTHERS                 = 4.
    IF sy-subrc <> 0.
    ENDIF.
    CALL FUNCTION 'RS_MASS_ACTIVATION'
      EXPORTING
        p_wb_manager = _wb_manager
      TABLES
        objects      = it_det_obj.
    check_inactive_objects( CHANGING obj_list = it_list ).
  ENDMETHOD.
  METHOD activate_nonddic.
    DATA:
      _wb_manager TYPE REF TO  if_wb_manager,               "#EC NEEDED
      it_obj      TYPE tt_det_obj,
      it_det_obj  TYPE tt_det_obj.
    FIELD-SYMBOLS:
      <disable_popup> TYPE data,        " DATA: xcode LIKE rsnewleng-tcode,
      <obj>           LIKE LINE OF it_det_obj.
    ASSIGN ('(SAPLSEWORKINGAREA)xcode') TO <disable_popup>.
    IF sy-subrc = 0.
      <disable_popup> = 'CHEC'. " LSEWORKINGAREAFCK from CHECKLIST_EVALUATE line 2134
    ENDIF.
    IF one_by_one IS INITIAL.
      it_det_obj = conv_list( it_list ).
      CALL FUNCTION 'RS_MASS_ACTIVATION'
        EXPORTING
          p_wb_manager = _wb_manager
        TABLES
          objects      = it_det_obj.
      IF force_activation IS NOT INITIAL.
        PERFORM activate_object IN PROGRAM saplseworkingarea.
      ENDIF.
    ELSE.
      it_det_obj = conv_list( it_list ).
      LOOP AT it_det_obj ASSIGNING <obj>.
        CLEAR it_obj.
        APPEND <obj> TO it_obj.
        CALL FUNCTION 'RS_MASS_ACTIVATION'
          EXPORTING
            p_wb_manager = _wb_manager
          TABLES
            objects      = it_obj.
      ENDLOOP.
    ENDIF.
    check_inactive_objects( CHANGING obj_list = it_list ).
  ENDMETHOD.
  METHOD activate_objects.
    FIELD-SYMBOLS:
      <it> LIKE LINE OF it_items,
      <mp> LIKE LINE OF programs.
    DATA: l_w_area  TYPE tt_items,
          l_w_items TYPE tt_items,
          l_master  TYPE rsnewleng-programm,
          BEGIN OF l_dynp_id,
            prog TYPE progname,
            dnum TYPE dynpronr,
          END OF l_dynp_id,
          message(240)   TYPE c,
          l_page         TYPE seu_objkey,
          l_imp_name     TYPE exit_imp,
          l_navigate     TYPE sy-calld,
          l_subrc        TYPE sy-subrc,
          l_clskey       TYPE seoclskey,
          l_wapd_class   TYPE seoclskey-clsname
                       VALUE 'CL_O2_API_APPLICATION',
          l_sfpf_class   TYPE seoclskey-clsname
                       VALUE 'CL_FP_WB_HELPER',
          l_appl         TYPE o2applname,
          l_obj_name     TYPE e071-obj_name,
          l_exception    TYPE REF TO cx_root,
          l_message_text TYPE string.
    LOOP AT programs ASSIGNING <mp>.
      IF <mp>-master <> l_master.
        l_master = <mp>-master.
        CHECK <mp>-error IS INITIAL.
        CHECK <mp>-include(1) <> '<' AND
              <mp>-include(1) <> '>'.
        CASE <mp>-object.
          WHEN 'REPS'.
            CALL FUNCTION 'REPS_OBJECT_GENERATE'
              EXPORTING
                i_program        = l_master
              IMPORTING
                o_gen_message    = message
                o_gen_subrc      = l_subrc
                o_navigate       = l_navigate
              EXCEPTIONS
                syntax_error     = 1
                generation_error = 2
                OTHERS           = 3.
            IF l_subrc <> 0 OR sy-subrc <> 0.
            ENDIF.
          WHEN 'CREP' OR 'CPUB' OR 'CPRI' OR 'CPRO' OR 'METH'
               OR 'CINC' OR 'CLAS'.
            l_clskey = l_master.
            CALL FUNCTION 'SEO_CLASS_GENERATE_LOAD'
              EXPORTING
                clskey             = l_clskey
              EXCEPTIONS
                syntax_error       = 1
                generation_failure = 2
                OTHERS             = 3.
            IF sy-subrc <> 0.
            ENDIF.
          WHEN 'INTF'.
            l_clskey = l_master.
            CALL FUNCTION 'SEO_INTERFACE_GENERATE_LOAD'
              EXPORTING
                intkey             = l_clskey
              EXCEPTIONS
                syntax_error       = 1
                generation_failure = 2
                OTHERS             = 3.
            IF sy-subrc <> 0.
            ENDIF.
          WHEN 'WAPD' OR 'WAPA'.
            l_appl = <it>-obj_name.
            CALL METHOD (l_wapd_class)=>generate_application
              EXPORTING
                p_application = l_appl
              EXCEPTIONS
                OTHERS        = 1.
            IF sy-subrc <> 0.
            ENDIF.
          WHEN 'WDYN' OR 'WDYD' OR 'WDYV' OR 'WDYC'.
            l_obj_name = l_master.
            CALL FUNCTION 'WDY_WB_GENERATE'
              EXPORTING
                p_object_name        = l_obj_name
                p_suppress_index_upd = ' '
              EXCEPTIONS
                not_existing         = 1
                error_occured        = 2
                syntax_error         = 3
                OTHERS               = 4.
            IF sy-subrc <> 0.
            ENDIF.
          WHEN 'ENHO' OR 'ENHC' OR 'ENHS' OR'ENSC'.
            l_obj_name = l_master.
            CALL FUNCTION 'ENH_WB_GENERATE'
              EXPORTING
                p_object_name        = l_obj_name
                p_obj_type           = <mp>-object
                p_suppress_index_upd = ' '
              EXCEPTIONS
                not_existing         = 1
                error_occured        = 2
                syntax_error         = 3
                OTHERS               = 4.
            IF sy-subrc <> 0.
            ENDIF.
          WHEN 'SFBF' OR 'SFSW' OR 'SFBS' OR 'SF01'.
            l_obj_name = l_master.
            CALL FUNCTION 'SFW_WB_GENERATE'
              EXPORTING
                p_object_name        = l_obj_name
                p_obj_type           = <mp>-object
                p_suppress_index_upd = ' '
              EXCEPTIONS
                not_existing         = 1
                error_occured        = 2
                syntax_error         = 3
                OTHERS               = 4.
            IF sy-subrc <> 0.
            ENDIF.
          WHEN 'SFPI'.
            l_obj_name = <it>-obj_name.
            TRY.
                CALL METHOD (l_sfpf_class)=>interface_generate
                  EXPORTING
                    i_name = l_obj_name.
              CATCH cx_fp_api_usage
                    cx_fp_api_repository
                    cx_fp_api_internal INTO l_exception.
                CLEAR l_message_text.
                l_message_text = l_exception->get_text( ).
            ENDTRY.
          WHEN 'SFPF'.
            l_obj_name = <it>-obj_name.
            TRY.
                CALL METHOD (l_sfpf_class)=>form_generate
                  EXPORTING
                    i_name = l_obj_name.
              CATCH cx_fp_api_usage
                    cx_fp_api_repository
                    cx_fp_api_internal INTO l_exception.
                CLEAR l_message_text.
                l_message_text = l_exception->get_text( ).
            ENDTRY.
        ENDCASE.
      ENDIF.
    ENDLOOP.
    LOOP AT items ASSIGNING <it>.
      CASE <it>-object.
        WHEN 'DYNP'.
          l_dynp_id = <it>-obj_name.
          CALL FUNCTION 'RS_SCRP_SERVICE'
            EXPORTING
              dynnr           = l_dynp_id-dnum
              function        = swbm_c_op_activate
              progname        = l_dynp_id-prog
              suppress_checks = ' '
            IMPORTING
              error_subrc     = l_subrc
            EXCEPTIONS
              illegal_value   = 1
              not_exists      = 2
              cancelled       = 3
              OTHERS          = 4.
          IF sy-subrc <> 0 OR l_subrc <> 0 .
          ENDIF.
        WHEN 'CUAD'.
          l_obj_name = <it>-obj_name.
          CALL FUNCTION 'CUAD_OBJECT_GENERATE'
            EXPORTING
              object_name       = l_obj_name
            EXCEPTIONS
              generation_failed = 1
              OTHERS            = 2.
          IF sy-subrc <> 0.
          ENDIF.
        WHEN 'WAPP'.
          l_page = <it>-obj_name.
          CALL FUNCTION 'O2_GENERATE_PAGE'
            EXPORTING
              p_composite_name = l_page
            EXCEPTIONS
              not_found        = 1
              error_occured    = 2
              OTHERS           = 3.
          IF sy-subrc <> 0.
          ENDIF.
        WHEN 'SXCI'.
          l_imp_name =  <it>-obj_name.
          CALL FUNCTION 'SXO_IMPL_ACTIVE'
            EXPORTING
              imp_name                  = l_imp_name
            EXCEPTIONS
              badi_not_existing         = 1
              imp_not_existing          = 2
              already_active            = 3
              data_inconsistency        = 4
              activation_not_admissable = 5
              action_canceled           = 6
              access_failure            = 7
              OTHERS                    = 8.
          IF sy-subrc <> 0.
          ENDIF.
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.
  METHOD add_from_tadir.
    DATA t_keys      TYPE tt_compkeys.
    t_keys = zaplink_tools=>get_keys_from_tadir( srcsystem = srcsystem
                                                     type  = type
                                                      name = name
                                                  packages = packages
                                                       ext = ext
                                                    author = author ).
    CHECK NOT t_keys IS INITIAL.
    add_keys( t_keys ).
  ENDMETHOD.
  METHOD add_keys.
    DATA t_obj_list TYPE tt_objlist.
    DATA local_list TYPE tt_compkeys.
    DATA flag       TYPE abap_bool.
    FIELD-SYMBOLS <wa> LIKE LINE OF local_list.
    local_list = obj_list.
    SORT local_list.
    LOOP AT local_list ASSIGNING <wa>.
      AT NEW type.
        CALL FUNCTION 'RS_OBJ_SUPPORTS_INACTIVE'
          EXPORTING
            obj_type          = space
            sub_type          = <wa>-type
          IMPORTING
            supports_inactive = flag.
        IF flag IS INITIAL.   " If Not activable => Remove
          DELETE local_list WHERE type = <wa>-type.
        ENDIF.
      ENDAT.
    ENDLOOP.
    APPEND LINES OF local_list TO component_list.
    SORT component_list BY type name.   DELETE ADJACENT DUPLICATES FROM component_list COMPARING type name.
    t_obj_list = compkeys_2_objlist( obj_list ).
    APPEND LINES OF t_obj_list TO it_obj_list.
    SORT it_obj_list BY object obj_name.    DELETE ADJACENT DUPLICATES FROM it_obj_list COMPARING object obj_name.
    object_count = lines( it_obj_list ).
  ENDMETHOD.
  METHOD add_list.
    DATA t_comps      TYPE tt_compkeys.
    CHECK o_list IS BOUND.
    t_comps = o_list->get_keys( ).
    add_keys( t_comps ).
  ENDMETHOD.
  METHOD add_obj_to_wa.
    FIELD-SYMBOLS <wa>   LIKE LINE OF it_obj_list.
    DATA name TYPE td_compname.
    LOOP AT it_obj_list ASSIGNING <wa>.
      name = <wa>-obj_name.
      zaplink_tools=>add_comp_to_working_area( type = <wa>-object
                                               name = name ).
    ENDLOOP.
  ENDMETHOD.
  METHOD ask_for_activation.
    DATA d_count    TYPE i.
    DATA d_answer   TYPE c.
    DATA d_msg      TYPE string.
    DATA o_cx       TYPE REF TO zaplink_cx.
    CLEAR activation_requested.
    d_count = lines( it_obj_list ).   d_msg = d_count.  CONDENSE d_msg.
    CONCATENATE 'Would you like to activate the objects ('(t01) d_msg ') that have been installed ?'(t02) INTO d_msg. "#EC NOTEXT
    CALL FUNCTION 'POPUP_TO_CONFIRM'
      EXPORTING
        titlebar              = 'Activate imported objects'(ptb)
        text_question         = d_msg
        text_button_1         = 'Yes'(yes)
        icon_button_1         = 'ICON_ACTIVATE'               "#EC NOTEXT
        text_button_2         = 'No'(no_)
        icon_button_2         = 'ICON_SKIP'                   "#EC NOTEXT
        default_button        = '1'                           "#EC NOTEXT
        display_cancel_button = abap_false
        iv_quickinfo_button_1 = 'All object will be activate as far as possible'(qi1) "#EC NOTEXT
        iv_quickinfo_button_2 = 'No object activation at all'(qi2) "#EC NOTEXT
      IMPORTING
        answer                = d_answer
      EXCEPTIONS
        text_not_found        = 1
        OTHERS                = 2.
    IF sy-subrc <> 0.
      o_cx = zaplink_cx=>create_from_mf_cx( funcname = 'POPUP_TO_CONFIRM'
                                               subrc = sy-subrc ) .
      RAISE EXCEPTION o_cx.
    ENDIF.
    IF d_answer CO 'YJ1'.
      activation_requested = abap_true.
      result = activate( ).
    ELSE.
      result = objlist_2_compkeys( it_obj_list ).
    ENDIF.
  ENDMETHOD.
  METHOD check_inactive_objects.
    DATA my_obj LIKE obj_list.
    DATA inact TYPE tt_items.
    FIELD-SYMBOLS <obj> LIKE LINE OF obj_list.
    LOOP AT obj_list ASSIGNING <obj>.
      REFRESH: my_obj, inact.   APPEND <obj> TO my_obj.
      CALL FUNCTION 'RS_INACTIVE_OBJECTS_WARNING'
        EXPORTING
          suppress_protocol = 'X'
        TABLES
          p_e071            = my_obj
          p_dwinactiv       = inact.
      IF inact IS INITIAL.    DELETE obj_list.    ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD compkeys_2_genset.
    DATA          s_obj LIKE LINE OF result.
    FIELD-SYMBOLS <k>   LIKE LINE OF keys.
    LOOP AT keys ASSIGNING <k>.
      CLEAR s_obj.
      s_obj-object = <k>-type.
      s_obj-objname = <k>-name.
      s_obj-pgmid = zaplink_connectors=>get_typekind( <k>-type ).
      APPEND s_obj TO result.
    ENDLOOP.
    SORT result BY object objname.
    PERFORM tadir_2_trdir IN PROGRAM rsparagenlod
            CHANGING result.
  ENDMETHOD.
  METHOD compkeys_2_objlist.
    DATA          s_obj LIKE LINE OF result.
    FIELD-SYMBOLS <k>   LIKE LINE OF keys.
    LOOP AT keys ASSIGNING <k>.   CLEAR s_obj.  s_obj-object = <k>-type.    s_obj-obj_name = <k>-name.  APPEND s_obj TO result.   ENDLOOP.
  ENDMETHOD.
  METHOD conv_list.
    DATA _item LIKE LINE OF item_list.
    FIELD-SYMBOLS <obj>   LIKE LINE OF obj_list.
    LOOP AT obj_list ASSIGNING <obj>.   MOVE-CORRESPONDING <obj> TO _item.    APPEND _item TO item_list.    ENDLOOP.
  ENDMETHOD.
  METHOD generate.
    CONSTANTS gc_gen_types(8) TYPE c VALUE '1CFJKMST'.
    DATA t_genset   TYPE tt_genset.
    DATA t_trdir    TYPE HASHED TABLE OF trdir WITH UNIQUE KEY name.
    FIELD-SYMBOLS:
      <dir> LIKE LINE OF t_trdir,
      <obj> LIKE LINE OF t_genset.
    t_genset = compkeys_2_genset( component_list ).
    SORT t_genset BY name.
    DELETE ADJACENT DUPLICATES FROM t_genset COMPARING name.
    DELETE t_genset WHERE name IS INITIAL
                      OR NOT ( object = 'PROG' OR
                               object = 'FUGR' OR
                               object = 'FUGS' OR
                               object = 'CLAS' OR
                               object = 'INTF' OR
                               object = 'TYPE' OR
                               object = 'LDBA' )
                     OR NOT pgmid = 'R3TR'.
    SELECT * INTO TABLE t_trdir
      FROM trdir
      FOR ALL ENTRIES IN t_genset
      WHERE name = t_genset-name
      %_HINTS ORACLE '&max_blocking_factor 250&'.
    LOOP AT t_genset ASSIGNING <obj>.
      READ TABLE t_trdir ASSIGNING <dir>
           WITH TABLE KEY name = <obj>-name.
      CHECK sy-subrc = 0.
      IF NOT <dir>-subc CA gc_gen_types.    CLEAR <obj>-name.     ENDIF.
    ENDLOOP.
    DELETE t_genset WHERE name IS INITIAL.
    CALL FUNCTION 'SUBST_GENER8_ABAP_LOADS'
      EXPORTING
        countmax   = 100    " commit every 100 obejcts
      TABLES
        it_gensetc = t_genset.
    DELETE t_genset WHERE NOT genstatus = 'E' AND NOT genstatus = 'S'.
    result = genset_2_compkeys( t_genset ).
  ENDMETHOD.
  METHOD genset_2_compkeys.
    DATA          s_obj LIKE LINE OF result.
    FIELD-SYMBOLS <k>   LIKE LINE OF keys.
    LOOP AT keys ASSIGNING <k>.   CLEAR s_obj.  s_obj-type = <k>-object.    s_obj-name = <k>-objname.    APPEND s_obj TO result.   ENDLOOP.
  ENDMETHOD.
  METHOD get_inactive_objects.
    CALL FUNCTION 'RS_INACTIVE_OBJECTS_WARNING'
      EXPORTING
        suppress_protocol = 'X'
      TABLES
        p_e071            = obj_list
        p_dwinactiv       = inact.
  ENDMETHOD.
  METHOD objlist_2_compkeys.
    DATA          s_obj LIKE LINE OF result.
    FIELD-SYMBOLS <k>   LIKE LINE OF keys.
    LOOP AT keys ASSIGNING <k>.   CLEAR s_obj.  s_obj-type = <k>-object.    s_obj-name = <k>-obj_name.    APPEND s_obj TO result.   ENDLOOP.
  ENDMETHOD.
  METHOD reset.
    CLEAR: it_items, it_obj_list, component_list, activation_requested, object_count, force_activation.
  ENDMETHOD.
  METHOD split_list.
    FIELD-SYMBOLS <obj>   LIKE LINE OF obj_list.
    LOOP AT obj_list ASSIGNING <obj>.
      IF <obj>-object = 'DTEL' OR
         <obj>-object = 'VIEW' OR
         <obj>-object = 'DOMA' OR
         <obj>-object = 'TTYP' OR
         <obj>-object = 'INDX' OR
         <obj>-object = 'XINX' OR
         <obj>-object = 'SHLP' OR
         <obj>-object = 'ENQU' OR
         <obj>-object = 'MCOB' OR
         <obj>-object = 'TABL' OR
         <obj>-object = 'SQLT' OR
         <obj>-object = 'STRU'.
        APPEND <obj> TO ddic.
      ELSE.
        APPEND <obj> TO prog_list.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_ACTIVATE implementation
CLASS zaplink_avar_data IMPLEMENTATION.
  METHOD anonymize.
    CLEAR: a0_maindata-create_user,  a0_maindata-create_date.
  ENDMETHOD.
  METHOD from_data.
    DATA s_def      LIKE LINE OF definitions.
    DATA s_desc     LIKE LINE OF descriptions.
    FIELD-SYMBOLS:
      <d> LIKE LINE OF fm_data-descriptions,
      <m> LIKE LINE OF fm_data-modes.
    LOOP AT fm_data-descriptions ASSIGNING <d>.
      CLEAR s_desc.   s_desc-lang = <d>-langu.     s_desc-text = <d>-descript.   INSERT s_desc INTO TABLE descriptions.
    ENDLOOP.
    LOOP AT fm_data-modes ASSIGNING <m>.
      CLEAR s_def.    s_def-type = <m>-object.    s_def-name = <m>-name.    s_def-activation = conv_mode2activation( <m>-actmode ).    INSERT s_def INTO TABLE definitions.
    ENDLOOP.
  ENDMETHOD.
  METHOD key_2_name.
    IF data-user IS INITIAL.
      result = data-name.
    ELSE.
      CONCATENATE data-name separator data-user INTO result.
    ENDIF.
  ENDMETHOD.
  METHOD name_2_key.
    SPLIT data AT separator INTO result-name result-user.
  ENDMETHOD.
  METHOD to_data.
    DATA s_mode     LIKE LINE OF fm_data-modes.
    DATA s_desc     LIKE LINE OF fm_data-descriptions.
    FIELD-SYMBOLS:
      <d> LIKE LINE OF descriptions,
      <s> LIKE LINE OF definitions.
    LOOP AT descriptions ASSIGNING <d>.
      CLEAR s_desc.   s_desc-langu = <d>-lang.     s_desc-descript = <d>-text.   INSERT s_desc INTO TABLE fm_data-descriptions.
    ENDLOOP.
    LOOP AT definitions ASSIGNING <s>.
      CLEAR s_mode.     s_mode-object = <s>-type.   s_mode-name = <s>-name.   s_mode-actmode = conv_activation2mode( <s>-activation ).    INSERT s_mode INTO TABLE fm_data-modes.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_AVAR_DATA implementation
CLASS zaplink_component IMPLEMENTATION.
  METHOD class_constructor.
  ENDMETHOD.
  METHOD clone.
    CREATE OBJECT result.
    result->copy_from( me ).
  ENDMETHOD.
  METHOD connector.
    result = _connector-o_conn.
  ENDMETHOD.
  METHOD connector_exists.
    result = _connector-exists.
  ENDMETHOD.
  METHOD constructor.
    DATA o_obj TYPE REF TO cl_abap_objectdescr.
    IF my_attribs IS INITIAL.         " can't be in class constructor because me not yet exists
      o_obj ?= cl_abap_typedescr=>describe_by_object_ref( me ).
      my_attribs = o_obj->attributes.
      DELETE my_attribs WHERE is_class = abap_true    " remove class attributes
                        OR is_constant = abap_true.   " remove constants.
    ENDIF.
    set_with_subcomp( default_sub_component_level ).
  ENDMETHOD.
  METHOD copy_from.
    FIELD-SYMBOLS:
      <s> TYPE any,
      <t> TYPE any,
      <a> LIKE LINE OF my_attribs.
    me->type = component->type.
    me->name = component->name.
    LOOP AT my_attribs ASSIGNING <a>.
      ASSIGN me->(<a>-name) TO <t>.   CHECK sy-subrc = 0.
      ASSIGN component->(<a>-name) TO <s>.   CHECK sy-subrc = 0.
      <t> = <s>.
    ENDLOOP.
  ENDMETHOD.
  METHOD create_new.
    DATA _cx TYPE REF TO zaplink_cx_component.
    CREATE OBJECT result.
    result->_set_key( key ).
  ENDMETHOD.
  METHOD do_exists.
    result = _exists.
  ENDMETHOD.
  METHOD get_action.
    result = _action.
  ENDMETHOD.
  METHOD get_add_data.
    result = _data.
  ENDMETHOD.
  METHOD get_add_object.
    result = _object.
  ENDMETHOD.
  METHOD get_checksum.
    result = _checksum.
  ENDMETHOD.
  METHOD get_code_signature.
    result = _code_signature.
  ENDMETHOD.
  METHOD get_connuuid.
    result = _connector-uuid.
  ENDMETHOD.
  METHOD get_devclass.
    result = _devclass.
  ENDMETHOD.
  METHOD get_exception.
    result = _exception.
  ENDMETHOD.
  METHOD get_key.
    IF type IS INITIAL OR name IS INITIAL.
      RAISE EXCEPTION TYPE zaplink_cx_component
        EXPORTING
          textid = zaplink_cx_component=>system_error.
    ENDIF.
    result-type = type.
    result-name = name.
  ENDMETHOD.
  METHOD get_msg_coll.
    result = _msg_coll.
  ENDMETHOD.
  METHOD get_name.
    result = name.
  ENDMETHOD.
  METHOD get_src_sys.
    result = _srcsystem.
  ENDMETHOD.
  METHOD get_subcomponents.
    result = _subcomponents.
  ENDMETHOD.
  METHOD get_type.
    result = type.
  ENDMETHOD.
  METHOD get_typekind.
    result = _kind.
  ENDMETHOD.
  METHOD get_with_subcomp.
    result = with_subcomp.
  ENDMETHOD.
  METHOD on_change_clear.
    CLEAR: _exists, _connector-uuid, _code_signature, _checksum.
  ENDMETHOD.
  METHOD on_change_update.
    DATA o_cx_cnx TYPE REF TO zaplink_cx_connector.
    IF _connector-o_conn IS BOUND AND NOT name IS INITIAL.
      _exists = _connector-o_conn->do_exists( me ).
      _connector-uuid = _connector-o_conn->uuid.
      CHECK NOT type IS INITIAL.
      _kind = zaplink_connectors=>get_typekind( type ).
      SELECT SINGLE devclass srcsystem INTO (_devclass, _srcsystem)
        FROM tadir
        WHERE pgmid = _kind
         AND object = type
         AND obj_name = name.
    ENDIF.
  ENDMETHOD.
  METHOD refresh.
    TRY.
        on_change_update( ).                                  " Issue 31
      CATCH zaplink_cx.   "_COMPONENT INTO o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD set_action.
    _action = data.
  ENDMETHOD.
  METHOD set_add_data.
    _data = data.
  ENDMETHOD.
  METHOD set_add_object.
    _object = data.
  ENDMETHOD.
  METHOD set_checksum.
    _checksum = data.
  ENDMETHOD.
  METHOD set_code_signature.
    _code_signature = data.
  ENDMETHOD.
  METHOD set_connuuid.
    DATA _cx    TYPE REF TO zaplink_cx.
    DATA o_conn TYPE to_connector.
    CHECK data <> _connector-uuid.
    o_conn = zaplink_connectors=>create_connector( type = type
                                               connuuid = data ).
    _connector-o_conn = o_conn.
    on_change_clear( ).
    _connector-uuid = data.
    IF o_conn IS BOUND.
      _connector-exists = connexists-exists.
    ELSE.
      _connector-exists = connexists-not_exists.
    ENDIF.
    on_change_update( ).
  ENDMETHOD.
  METHOD set_devclass.
    CHECK data <> _devclass.
    _devclass = data.
  ENDMETHOD.
  METHOD set_exception.
    DATA cx TYPE REF TO cx_root.
    DATA _cx TYPE REF TO zaplink_cx_component.
    DATA _desc TYPE REF TO cl_abap_typedescr.
    IF data IS BOUND.
      TRY.
          _exception ?= data.
        CATCH cx_root INTO cx.
          _desc = cl_abap_typedescr=>describe_by_object_ref( data ).
          CREATE OBJECT _cx
            EXPORTING
              textid   = zaplink_cx_component=>invalid_exception
              objtype  = _desc->absolute_name
              previous = cx.
          _cx->update( ).
          RAISE EXCEPTION _cx.
      ENDTRY.
    ELSE.
      CLEAR _exception.
    ENDIF.
  ENDMETHOD.
  METHOD set_msg_coll.
    DATA cx TYPE REF TO cx_root.
    DATA _cx TYPE REF TO zaplink_cx_component.
    DATA _desc TYPE REF TO cl_abap_typedescr.
    IF data IS BOUND.
      TRY.
          _msg_coll ?= data.
        CATCH cx_root INTO cx.
          _desc = cl_abap_typedescr=>describe_by_object_ref( data ).
          CREATE OBJECT _cx
            EXPORTING
              textid   = zaplink_cx_component=>invalid_msg_coll
              objtype  = _desc->absolute_name
              previous = cx.
          _cx->update( ).
          RAISE EXCEPTION _cx.
      ENDTRY.
    ELSE.
      CLEAR _msg_coll.
    ENDIF.
  ENDMETHOD.
  METHOD set_name.
    CHECK data <> name.
    name = data.
    on_change_clear( ).
    on_change_update( ).
  ENDMETHOD.
  METHOD set_src_sys.
    _srcsystem = data.
  ENDMETHOD.
  METHOD set_subcomponents.
    DATA cx TYPE REF TO cx_root.
    DATA _cx TYPE REF TO zaplink_cx_component.
    DATA _desc TYPE REF TO cl_abap_typedescr.
    IF data IS BOUND.
      TRY.
          _subcomponents ?= data.
        CATCH cx_root INTO cx.
          _desc = cl_abap_typedescr=>describe_by_object_ref( data ).
          CREATE OBJECT _cx
            EXPORTING
              textid   = zaplink_cx_component=>invalid_subcomponents
              objtype  = _desc->absolute_name
              previous = cx.
          _cx->update( ).
          RAISE EXCEPTION _cx.
      ENDTRY.
    ELSE.
      CLEAR _msg_coll.
    ENDIF.
  ENDMETHOD.
  METHOD set_type.
    DATA o_conn   TYPE to_connector.
    DATA o_cx_cnx TYPE REF TO zaplink_cx_connector.
    CHECK data <> type.
    TRY.
        o_conn = zaplink_connectors=>create_connector( type = data ).
      CATCH zaplink_cx_connector INTO o_cx_cnx.
        IF o_cx_cnx->is_exception_text( zaplink_cx_connector=>invalid_type ) IS INITIAL.    RAISE EXCEPTION o_cx_cnx.   ENDIF.
    ENDTRY.
    type = data.    CLEAR _connector.
    on_change_clear( ).
    _connector-o_conn = o_conn.
    IF o_conn IS BOUND.   _connector-exists = connexists-exists.    ELSE.     _connector-exists = connexists-not_exists.    ENDIF.
    on_change_update( ).
  ENDMETHOD.
  METHOD set_with_subcomp.
    CHECK data <> with_subcomp.
    with_subcomp = data.
  ENDMETHOD.
  METHOD _get_key.
    result-type = type.
    result-name = name.
  ENDMETHOD.
  METHOD _set_key.
    DATA _cx TYPE REF TO zaplink_cx_component.
    set_type( data-type ).
    set_name( data-name ).
  ENDMETHOD.
ENDCLASS. "ZAPLINK_COMPONENT implementation
CLASS zaplink_connectors IMPLEMENTATION.
  METHOD add_local_connector.
    _add_connector( class = local_class
                 devclass = local_devclass ).
    _update_def_class( ).
  ENDMETHOD.
  METHOD class_constructor.
    DATA t_types    TYPE STANDARD TABLE OF ko100 WITH DEFAULT KEY.
    DATA s_saptypes LIKE LINE OF saptypes.
    DATA t_saptypes TYPE STANDARD TABLE OF ts_saptypes.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF t_types.
    xmlengine = cl_ixml=>create( ).
    CALL FUNCTION 'TR_OBJECT_TABLE'
      TABLES
        wt_object_text = t_types.
    SORT t_types BY object.
    DELETE ADJACENT DUPLICATES FROM t_types COMPARING object.
    LOOP AT t_types ASSIGNING <t>.
      CLEAR s_saptypes. s_saptypes-hdr = <t>.
      s_saptypes-order = max_order.
      APPEND s_saptypes TO t_saptypes.
    ENDLOOP.
    saptypes = t_saptypes.
    c_class-type = 'CLAS'.    c_class-kind = zaplink_connectors=>get_typekind( c_class-type ).
    s_saptypes-order = 50.  MODIFY saptypes FROM s_saptypes TRANSPORTING order WHERE object = 'DEVC'.
    s_saptypes-order = 100. MODIFY saptypes FROM s_saptypes TRANSPORTING order WHERE object = 'INTF'.
    s_saptypes-order = 150. MODIFY saptypes FROM s_saptypes TRANSPORTING order WHERE object = c_class-type.
    TRY.
        reset_connectors( ).
      CATCH zaplink_cx INTO o_cx.
        IF o_cx->is_exception_text( zaplink_cx_connector=>twice_uuid ) = abap_true OR
           o_cx->is_exception_text( zaplink_cx_connector=>twice_class ) = abap_true.
          RAISE EXCEPTION o_cx. " Major failure that will cause Short Dump
        ENDIF.
    ENDTRY.
  ENDMETHOD.
  METHOD clear_connectors.
    CLEAR type_list.
  ENDMETHOD.
  METHOD create_connector.
    DATA _cx        TYPE REF TO cx_root.
    DATA _conn      LIKE LINE OF type_list.
    DATA _classname TYPE td_connclass.
    FIELD-SYMBOLS:
      <cl> LIKE LINE OF _classes,
      <c>  LIKE LINE OF _conn-classes.
    IF NOT connuuid IS INITIAL.
      READ TABLE _classes ASSIGNING <cl>
                 WITH TABLE KEY uuid = connuuid.
      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE zaplink_cx_connector
          EXPORTING
            textid   = zaplink_cx_connector=>invalid_uuid
            type     = type
            connuuid = connuuid.
      ELSE.
        IF NOT type IS INITIAL.
          READ TABLE <cl>-types TRANSPORTING NO FIELDS
               WITH TABLE KEY type = type.
          IF sy-subrc <> 0.
            RAISE EXCEPTION TYPE zaplink_cx_connector
              EXPORTING
                textid    = zaplink_cx_connector=>type_not_supported
                type      = type
                connclass = <cl>-classname
                connuuid  = connuuid.
          ENDIF.
        ENDIF.
      ENDIF.
      _classname = <cl>-classname.
    ELSEIF NOT type IS INITIAL.
      _conn = _search_connector( type ).
      IF NOT _conn-classes IS INITIAL AND _conn-default_class IS INITIAL.
        READ TABLE _conn-classes ASSIGNING <c> INDEX 1.
        IF sy-subrc = 0.
          _conn-default_class = <c>-classname.
        ENDIF.
      ENDIF.
      _classname = _conn-default_class.
    ELSE.
      EXIT.
    ENDIF.
    IF NOT _classname IS INITIAL.
      TRY.
          CREATE OBJECT result TYPE (_classname).
        CATCH cx_root INTO _cx.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid   = zaplink_cx=>system_error
              previous = _cx.
      ENDTRY.
    ENDIF.
  ENDMETHOD.
  METHOD do_exists.
    DATA _conn LIKE LINE OF type_list.
    result = exists-not_exists.
    _conn = _search_connector( type ).
    IF NOT _conn-classes IS INITIAL.
      result = exists-exists.
    ENDIF.
  ENDMETHOD.
  METHOD get_classname.
    DATA o_typedesc TYPE REF TO cl_abap_objectdescr.
    CHECK o_conn IS BOUND.
    o_typedesc ?= cl_abap_objectdescr=>describe_by_object_ref( o_conn ).
    result = o_typedesc->get_relative_name( ).
  ENDMETHOD.
  METHOD get_connectorlist.
    DATA o_comp TYPE to_component.
    FIELD-SYMBOLS:
      <c> LIKE LINE OF _classes.
    CREATE OBJECT result.
    LOOP AT _classes ASSIGNING <c>
         WHERE NOT types IS INITIAL
           AND NOT uuid IS INITIAL.
      CREATE OBJECT o_comp.
      o_comp->set_type( c_class-type ).
      o_comp->set_name( <c>-classname ).
      result->add( o_comp ).
    ENDLOOP.
  ENDMETHOD.
  METHOD get_typekind.
    FIELD-SYMBOLS <t> LIKE LINE OF saptypes.
    READ TABLE saptypes ASSIGNING <t>
         WITH TABLE KEY object = data.
    IF sy-subrc = 0.    result = <t>-pgmid.   ENDIF.
  ENDMETHOD.
  METHOD get_typeorder.
    FIELD-SYMBOLS <t> LIKE LINE OF saptypes.
    READ TABLE saptypes ASSIGNING <t>
         WITH TABLE KEY object = data.
    IF sy-subrc = 0.
      result = <t>-order.
    ELSE.
      result = max_order.
    ENDIF.
  ENDMETHOD.
  METHOD get_values.
    DATA lt_return TYPE STANDARD TABLE OF ddshretval.
    DATA d_value   TYPE help_info-fldvalue.
    d_value = type.
    CALL FUNCTION 'F4IF_INT_TABLE_VALUE_REQUEST'
      EXPORTING
        retfield        = 'OBJECT'
        window_title    = 'Installed connectors'(sh1)
        value           = d_value
        value_org       = 'S'
      TABLES
        value_tab       = value_table
        return_tab      = lt_return
      EXCEPTIONS
        parameter_error = 1
        no_values_found = 2
        OTHERS          = 3.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'F4IF_INT_TABLE_VALUE_REQUEST'
                                                  subrc = sy-subrc
                                              classname = 'ZAPLINK_CX_CONNECTOR' ).
      o_mycx->update( ).
      RAISE EXCEPTION o_mycx.
    ELSE.
      type = d_value.
    ENDIF.
  ENDMETHOD.
  METHOD node_2_raw.
    DATA ez_xml    TYPE REF TO zaplink_easyxml.
    DATA _xml_comp TYPE REF TO if_ixml_document.
    DATA _clone    TYPE REF TO if_ixml_node.
    DATA _cx       TYPE REF TO zaplink_cx.
    _xml_comp = xmlengine->create_document( ).
    _clone = node->clone( ).
    _xml_comp->if_ixml_node~append_child( _clone ).
    CREATE OBJECT result.
    CREATE OBJECT ez_xml.
    TRY.
        CALL METHOD ez_xml->xml2any
          EXPORTING
            xmldoc = _xml_comp
          CHANGING
            any    = result.
      CATCH zaplink_cx INTO _cx.
        CREATE OBJECT o_mycx
          EXPORTING
            textid   = zaplink_cx=>system_error
            previous = _cx.
        o_mycx->update( ).
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD raw_2_string.
    DATA o_xml  TYPE to_xml.
    CHECK data IS BOUND.
    o_xml = raw_2_xml( data ).
    result = xml_2_string( o_xml ).
  ENDMETHOD.
  METHOD raw_2_xml.
    DATA ez_xml    TYPE REF TO zaplink_easyxml.
    CHECK data IS BOUND.
    CREATE OBJECT ez_xml.
    result = ez_xml->any2xml( any       = data
                              type      = comp_nodename ).
  ENDMETHOD.
  METHOD reset_connectors.
    DATA o_conn      TYPE REF TO zaplink_connector.
    DATA _connectors TYPE REF TO cl_oo_if_relations.
    DATA o_desc      TYPE REF TO cl_abap_typedescr.
    FIELD-SYMBOLS:
      <im_cl> LIKE LINE OF _connectors->implementing_classes,
      <s_cl>  LIKE LINE OF _connectors->subclasses.
    CLEAR type_list.
    o_desc = cl_abap_structdescr=>describe_by_name( 'ZAPLINK_CONNECTOR' ).
    IF o_desc->absolute_name CP '\INTERFACE=*'.
      CREATE OBJECT _connectors
        EXPORTING
          clsname      = 'ZAPLINK_CONNECTOR'
        EXCEPTIONS
          not_existing = 0    " For installer ignore not existing class
          is_class     = 2
          OTHERS       = 3.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = 'cl_oo_if_relations'
                                                         method = 'constructor'
                                                          subrc = sy-subrc
                                                   cx_classname = 'ZAPLINK_CX_CONNECTOR').
        RAISE EXCEPTION o_mycx.
      ENDIF.
      IF _connectors IS BOUND.
        LOOP AT _connectors->implementing_classes ASSIGNING <im_cl>
                WHERE exposure <> '0'   " Private
                  AND version = '1'     " Active
                  AND state <> '0'.     " Only modeled
          TRY.
              _add_connector( class = <im_cl>-clsname ).
            CATCH zaplink_cx INTO o_cx.
              IF o_cx->is_exception_text( zaplink_cx_connector=>twice_uuid ) = abap_true OR
                 o_cx->is_exception_text( zaplink_cx_connector=>twice_class ) = abap_true.
                RAISE EXCEPTION o_cx.
              ENDIF.
          ENDTRY.
        ENDLOOP.
        LOOP AT _connectors->subclasses ASSIGNING <s_cl>
                WHERE state <> '0'      " Only modeled
                  AND version = '1'.    " Active
          TRY.
              _add_connector( class = <s_cl>-clsname ).
            CATCH zaplink_cx INTO o_cx.
              IF o_cx->is_exception_text( zaplink_cx_connector=>twice_uuid ) = abap_true OR
                 o_cx->is_exception_text( zaplink_cx_connector=>twice_class ) = abap_true.
                RAISE EXCEPTION o_cx.
              ENDIF.
          ENDTRY.
        ENDLOOP.
        _update_def_class( ).
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD string_2_xml.
    DATA o_streamfactory  TYPE REF TO if_ixml_stream_factory.
    DATA o_stream         TYPE REF TO if_ixml_istream.
    DATA o_parser         TYPE REF TO if_ixml_parser.
    DATA _tempstring      TYPE string.
    DATA _rc              TYPE sysubrc.
    DATA o_doc            TYPE to_xml.
    CHECK NOT data IS INITIAL.
    TRY.
        o_streamfactory = xmlengine->create_stream_factory( ).
        o_doc = xmlengine->create_document( ).
        o_stream = o_streamfactory->create_istream_string( data ).
        o_parser = xmlengine->create_parser(  stream_factory = o_streamfactory
                                              istream        = o_stream
                                              document       = o_doc ).
        o_parser->parse( ).
      CATCH cx_root.
    ENDTRY.
    IF o_doc IS BOUND.  result = o_doc.   ENDIF.
  ENDMETHOD.
  METHOD type2text.
    FIELD-SYMBOLS <t> LIKE LINE OF saptypes.
    READ TABLE saptypes ASSIGNING <t>
         WITH TABLE KEY object = data.
    IF sy-subrc = 0.
      result = <t>-text.
    ENDIF.
  ENDMETHOD.
  METHOD xml_2_string.
    DATA o_xmlengine    TYPE REF TO if_ixml.
    DATA _streamfactory TYPE REF TO if_ixml_stream_factory.
    DATA _outputstream TYPE REF TO if_ixml_ostream.
    DATA _renderer TYPE REF TO if_ixml_renderer.
    DATA _tempstring TYPE string.
    DATA _printxmldoc TYPE REF TO cl_xml_document.
    DATA _rc      TYPE sysubrc.
    CHECK xml IS BOUND.
    o_xmlengine = cl_ixml=>create( ).
    _streamfactory = o_xmlengine->create_stream_factory( ).
    _outputstream = _streamfactory->create_ostream_cstring( _tempstring ).
    _renderer = xmlengine->create_renderer( document = xml
                                             ostream = _outputstream ).
    _renderer->set_normalizing( ).
    _rc = _renderer->render( ).
    CREATE OBJECT _printxmldoc.
    _rc = _printxmldoc->parse_string( _tempstring ).
    WHILE _tempstring(1) <> '<'.    SHIFT _tempstring LEFT BY 1 PLACES.   ENDWHILE.
    result = _tempstring.
  ENDMETHOD.
  METHOD _add_connector.
    DATA connector TYPE REF TO zaplink_connector.
    DATA o_cx_root TYPE REF TO cx_root.
    DATA o_cx_create TYPE REF TO cx_sy_create_object_error.
    DATA cx_comp   TYPE REF TO zaplink_cx_component.
    DATA tabletypeline TYPE ko105.
    DATA _conn     LIKE LINE OF type_list.
    DATA _class    LIKE LINE OF _conn-classes.
    DATA the_class LIKE LINE OF _classes.
    DATA _value    LIKE LINE OF value_table.
    FIELD-SYMBOLS:
      <cl> LIKE LINE OF _classes,
      <c>  LIKE LINE OF type_list,
      <st> LIKE LINE OF saptypes,
      <t>  LIKE LINE OF connector->supported_types.
    TRY.
        CREATE OBJECT connector TYPE (class).
      CATCH cx_sy_create_object_error INTO o_cx_create.
        CASE o_cx_create->textid.
          WHEN cx_sy_create_object_error=>abstract_class
            OR cx_sy_create_object_error=>private_constructor
            OR cx_sy_create_object_error=>protected_constructor.
          WHEN OTHERS.
            mac_cascade_raise o_mycx o_cx_create.
        ENDCASE.
      CATCH cx_root INTO o_cx_root.
        mac_cascade_raise o_mycx o_cx_root.
    ENDTRY.
    CHECK connector IS BOUND.
    IF NOT connector->uuid IS INITIAL               AND
       NOT connector->supported_types IS INITIAL.
      the_class-uuid = connector->uuid.
      READ TABLE _classes ASSIGNING <cl>
                 WITH TABLE KEY uuid = the_class-uuid.
      IF sy-subrc = 0.
        IF <cl>-classname <> class.                           " Issue 25
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid     = zaplink_cx_connector=>twice_uuid
              connclass  = class
              otherclass = <cl>-classname
              connuuid   = <cl>-uuid.
        ELSEIF NOT ( <cl>-devclass <> local_devclass AND devclass = local_devclass ).
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid    = zaplink_cx_connector=>twice_class
              connclass = class.
        ELSE.
          LOOP AT <cl>-types ASSIGNING <t>.
            READ TABLE type_list ASSIGNING <c>
                 WITH TABLE KEY object = <t>-type.
            IF sy-subrc <> 0.
              RAISE EXCEPTION TYPE zaplink_cx_connector
                EXPORTING
                  textid  = zaplink_cx_connector=>system_error
                  cx_name = 'TYPE NOT FOUND'.
            ELSE.
              DELETE <c>-classes WHERE classname = class.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDIF.
      the_class-classname = class.
      IF NOT devclass IS INITIAL.
        the_class-devclass = devclass.
      ELSE.
        SELECT SINGLE devclass INTO the_class-devclass
          FROM tadir
          WHERE pgmid = c_class-kind
            AND object = c_class-type
            AND obj_name = the_class-classname.
      ENDIF.
      the_class-types = connector->supported_types.
      INSERT the_class INTO TABLE _classes.
      LOOP AT connector->supported_types ASSIGNING <t>.
        READ TABLE type_list ASSIGNING <c>
             WITH TABLE KEY object = <t>-type.
        IF sy-subrc <> 0.
          _conn-object = <t>-type.
          READ TABLE saptypes ASSIGNING <st>
                     WITH TABLE KEY object = _conn-object.
          IF sy-subrc = 0.
            _conn-text = <st>-text.
          ENDIF.
          INSERT _conn INTO TABLE type_list.
          READ TABLE type_list ASSIGNING <c>
               WITH TABLE KEY object = <t>-type.
        ENDIF.
        CLEAR _class.
        MOVE-CORRESPONDING the_class TO _class.
        INSERT _class INTO TABLE <c>-classes.
      ENDLOOP.
    ENDIF.
    CLEAR value_table.
    LOOP AT type_list ASSIGNING <c>.
      _value-object = <c>-object.
      _value-text = <c>-text.
      APPEND _value TO value_table.
    ENDLOOP.
  ENDMETHOD.
  METHOD _search_connector.
    READ TABLE type_list INTO result
               WITH TABLE KEY object = type.
    IF sy-subrc <> 0.
      READ TABLE saptypes TRANSPORTING NO FIELDS
                 WITH TABLE KEY object = type.
      IF sy-subrc <> 0.
        RAISE EXCEPTION TYPE zaplink_cx_connector
          EXPORTING
            textid = zaplink_cx_connector=>invalid_type
            type   = type.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD _update_def_class.
    TYPES:
      BEGIN OF t_classlist,
        class TYPE seoclsname,
      END OF t_classlist.
    DATA classlist TYPE STANDARD TABLE OF t_classlist WITH DEFAULT KEY.
    DATA tabletypeline TYPE ko105.
    DATA _conn LIKE LINE OF type_list.
    DATA _class LIKE LINE OF _conn-classes.
    DATA _types TYPE STANDARD TABLE OF ko100 WITH DEFAULT KEY.
    DATA s_type LIKE LINE OF supported_types.
    FIELD-SYMBOLS:
      <c> LIKE LINE OF type_list.
    REFRESH supported_types.
    LOOP AT type_list ASSIGNING <c>.
      CLEAR: s_type.    s_type-type = <c>-object.   INSERT s_type INTO TABLE supported_types.
      CHECK NOT <c>-classes IS INITIAL.
      LOOP AT <c>-classes INTO _class   WHERE devclass = local_devclass.
        EXIT.
      ENDLOOP.
      LOOP AT <c>-classes INTO _class   WHERE devclass = 'ZAPLINK-CONNECTORS-MAIN'.
        EXIT.
      ENDLOOP.
      IF sy-subrc <> 0 OR _class-classname IS INITIAL.
        LOOP AT <c>-classes INTO _class WHERE devclass CP 'ZAPLINK-CONNECTORS*'.
          EXIT.
        ENDLOOP.
      ENDIF.
      IF sy-subrc <> 0 OR _class-classname IS INITIAL.
        LOOP AT <c>-classes INTO _class WHERE devclass CP 'ZAPLINK*'.
          EXIT.
        ENDLOOP.
      ENDIF.
      IF sy-subrc <> 0 OR _class-classname IS INITIAL.
        READ TABLE <c>-classes INTO _class INDEX 1.
      ENDIF.
      <c>-default_class = _class-classname.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CONNECTORS implementation
CLASS zaplink_easyxml IMPLEMENTATION.
  METHOD add_any.
    DATA _desc     TYPE REF TO cl_abap_typedescr.
    DATA svalue    TYPE string.
    FIELD-SYMBOLS: <any> TYPE any.
    CHECK any IS NOT INITIAL.         " prevent from do anything for an empty field
    IF typedesc IS BOUND.
      _desc = typedesc.
    ELSE.
      _desc = cl_abap_typedescr=>describe_by_data( p_data = any ).
    ENDIF.
    _desc = get_ref_type( _desc ).
    stack_descr( _desc ).
    CASE _desc->kind.
      WHEN cl_abap_datadescr=>kind_ref.
        IF _desc->type_kind = cl_abap_refdescr=>typekind_dref.   " Data Ref
          ASSIGN any->* TO <any>.
          IF sy-subrc = 0.        " Ignore dref {A:INITIAL}
            _desc = cl_abap_typedescr=>describe_by_data( p_data = <any> ).
            add_any(   xmldoc = xmldoc
                     xml_node = xml_node
                         name = name
                          any = <any>
                     typedesc = _desc ).
          ENDIF.
        ELSE.
          mac_syserr_log -1 'cl_abap_datadescr=>kind_ref' 'ZAPLINK_EASYXML->ADD_ANY'.
        ENDIF.
      WHEN cl_abap_datadescr=>kind_elem.
        svalue = elem_2_string( any = any
                          type_desc = _desc ).
        IF NOT svalue IS INITIAL.
          IF name IS INITIAL.
            rc = xml_node->set_value( svalue ).
            mac_syserr_log rc 'set_value' 'ZAPLINK_EASYXML->ADD_ANY'.
          ELSE.
            rc = xml_node->set_attribute( name = name
                                         value = svalue ).
            mac_syserr_log rc 'set_attribute' 'ZAPLINK_EASYXML->ADD_ANY'. "#EC NOTEXT
          ENDIF.
        ENDIF.
      WHEN cl_abap_datadescr=>kind_struct.
        add_structure(   xmldoc = xmldoc
                       xml_node = xml_node
                           name = name
                      structure = any ).
      WHEN cl_abap_datadescr=>kind_table.
        add_table(   xmldoc = xmldoc
                   xml_node = xml_node
                       name = name
                      table = any ).
      WHEN cl_abap_datadescr=>kind_class.
        add_object(   xmldoc = xmldoc
                    xml_node = xml_node
                        name = name
                      object = any
                    typedesc = _desc ).
      WHEN cl_abap_datadescr=>kind_intf.
        svalue = _desc->get_relative_name( ).
        SET EXTENDED CHECK OFF.
        IF 1 = 2. MESSAGE ID msgid TYPE 'E' NUMBER 001 WITH name svalue. ENDIF.
        SET EXTENDED CHECK ON.
        CALL METHOD application_log->add_warning
          EXPORTING
            id_msgno = '001'
            id_msgv1 = name
            id_msgv2 = svalue.
    ENDCASE.
    unstack( ).
  ENDMETHOD.
  METHOD add_object.
    DATA node      TYPE REF TO if_ixml_element.
    DATA o_obj     TYPE REF TO cl_abap_classdescr.
    DATA typedescr TYPE REF TO cl_abap_typedescr.
    DATA svalue    TYPE string.
    DATA sname     TYPE string.
    DATA attr_name TYPE string.
    DATA self_done TYPE flag.
    FIELD-SYMBOLS:
      <d>   TYPE any,
      <any> TYPE any,
      <a>   LIKE LINE OF o_obj->attributes.
    IF NOT object IS BOUND. EXIT. ENDIF.
    o_obj ?= cl_abap_classdescr=>describe_by_object_ref( p_object_ref = object ).
    unstack( ).
    attr_name = o_obj->absolute_name.
    stack( attr_name ).
    IF name IS INITIAL.
      node = xml_node.
    ELSE.
      node = xmldoc->create_element( name ).
    ENDIF.
    READ TABLE o_obj->attributes TRANSPORTING NO FIELDS
         WITH KEY name = self_fieldname.
    IF sy-subrc = 0.
      ASSIGN object->(self_fieldname) TO <d>.
      IF sy-subrc <> 0.
        mac_syserr_log sy-subrc 'ASSIGN COMPONENT <c>-name OF STRUCTURE structure' 'ZAPLINK_EASYXML->ADD_OBJECT'. "#EC NOTEXT
      ELSE.
        add_self( xml_node = node
                      name = name
                      any = <d> ).
        self_done = abap_true.
      ENDIF.
    ENDIF.
    LOOP AT o_obj->attributes ASSIGNING <a>
      WHERE ( visibility = cl_abap_classdescr=>public OR
              visibility = cl_abap_classdescr=>protected )  " May be friend of the class
        AND is_constant IS INITIAL  " Do not handle constants
        AND is_class    IS INITIAL  " Do not handle class attribute
        AND alias_for   IS INITIAL
        AND is_virtual  IS INITIAL.
      ASSIGN object->(<a>-name) TO <d>.
      IF sy-subrc <> 0.
        mac_syserr_log sy-subrc 'ASSIGN object->(<a>-name)' 'ZAPLINK_EASYXML->ADD_OBJECT'. "#EC NOTEXT
        CONTINUE.
      ENDIF.
      IF <a>-name = self_fieldname AND self_done = abap_true.     CONTINUE.   ENDIF.
      attr_name = <a>-name.
      stack( attr_name ).
      add_any(   xmldoc = xmldoc
               xml_node = node
                   name = attr_name
                    any = <d> ).
      unstack( ).
    ENDLOOP.
    IF node IS BOUND AND NOT name IS INITIAL.
      rc = xml_node->append_child( node ).
      mac_syserr_log rc 'append_child' 'ZAPLINK_EASYXML->ADD_OBJECT'. "#EC NOTEXT
    ENDIF.
  ENDMETHOD.
  METHOD add_self.
    DATA svalue    TYPE string.
    DATA typedescr TYPE REF TO cl_abap_typedescr.
    FIELD-SYMBOLS: <any> TYPE any.
    typedescr = cl_abap_typedescr=>describe_by_data( any ).
    typedescr = get_ref_type( typedescr ).
    IF typedescr->kind = cl_abap_datadescr=>kind_ref.
      ASSIGN any->* TO <any>.
      typedescr = cl_abap_typedescr=>describe_by_data( p_data = <any> ).
    ENDIF.
    CASE typedescr->kind.
      WHEN cl_abap_datadescr=>kind_elem.
        svalue = elem_2_string( any = any
                          type_desc = typedescr ).
        IF svalue IS NOT INITIAL.
          svalue = protect_string( svalue ).                  " Issue 61
          rc = xml_node->set_value( svalue ).
          mac_syserr_log rc 'set_value' 'ZAPLINK_EASYXML->ADD_SELF'. "#EC NOTEXT
        ENDIF.
      WHEN OTHERS.
        svalue = typedescr->get_relative_name( ).
        IF NOT application_log IS BOUND. MESSAGE e004 WITH self_fieldname name svalue typedescr->kind. ENDIF.
        CALL METHOD application_log->add_warning
          EXPORTING
            id_msgno = 004
            id_msgv1 = self_fieldname
            id_msgv2 = name
            id_msgv3 = svalue
            id_msgv4 = typedescr->kind.
    ENDCASE.
  ENDMETHOD.
  METHOD add_structure.
    DATA node         TYPE REF TO if_ixml_element.
    DATA sname        TYPE string.
    DATA svalue       TYPE string.
    DATA structdescr  TYPE REF TO cl_abap_structdescr.
    DATA typedescr    TYPE REF TO cl_abap_typedescr.
    DATA self_done    TYPE flag.
    FIELD-SYMBOLS:
      <fieldvalue> TYPE any,
      <fld>        TYPE any,
      <any>        TYPE any,
      <c>          LIKE LINE OF structdescr->components.
    IF structure IS INITIAL. EXIT. ENDIF.
    IF name IS INITIAL.
      node = xml_node.
    ELSE.
      node = xmldoc->create_element( name ).
    ENDIF.
    structdescr ?= cl_abap_structdescr=>describe_by_data( structure ).
    READ TABLE structdescr->components TRANSPORTING NO FIELDS
         WITH KEY name = self_fieldname.
    IF sy-subrc = 0.
      ASSIGN COMPONENT self_fieldname OF STRUCTURE structure TO <fieldvalue>.
      IF sy-subrc <> 0.
        mac_syserr_log sy-subrc 'ASSIGN COMPONENT <c>-name OF STRUCTURE structure' 'ZAPLINK_EASYXML->ADD_STRUCTURE'. "#EC NOTEXT
      ELSE.
        add_self( xml_node = node
                      name = name
                       any = <fieldvalue> ).
        self_done = abap_true.
      ENDIF.
    ENDIF.
    LOOP AT structdescr->components ASSIGNING <c>.
      ASSIGN COMPONENT <c>-name OF STRUCTURE structure TO <fieldvalue>.
      IF sy-subrc <> 0.
        mac_syserr_log sy-subrc 'ASSIGN COMPONENT <c>-name OF STRUCTURE structure' 'ZAPLINK_EASYXML->ADD_STRUCTURE'. "#EC NOTEXT
        CONTINUE.
      ENDIF.
      IF <c>-name = self_fieldname AND self_done = abap_true.     CONTINUE.   ENDIF.
      typedescr = cl_abap_typedescr=>describe_by_data( <fieldvalue> ).
      typedescr = get_ref_type( typedescr ).
      sname = <c>-name.
      IF sname(1) CO '0123456789' AND typedescr->kind = cl_abap_datadescr=>kind_elem.
        CONCATENATE issue46_prefix sname INTO sname. UNASSIGN <fld>. ASSIGN COMPONENT sname OF STRUCTURE structure TO <fld>.
        WHILE <fld> IS ASSIGNED. CONCATENATE issue46_prefix sname INTO sname. UNASSIGN <fld>. ASSIGN COMPONENT sname OF STRUCTURE structure TO <fld>. ENDWHILE.
      ENDIF.
      stack( sname ).
      add_any( xmldoc = xmldoc
             xml_node = node
                 name = sname
                  any = <fieldvalue>
             typedesc = typedescr ).
      unstack( ).
    ENDLOOP.
    IF node IS BOUND AND NOT name IS INITIAL.
      rc = xml_node->append_child( node ).
      mac_syserr_log rc 'append_child' 'ZAPLINK_EASYXML->ADD_STRUCTURE'. "#EC NOTEXT
    ENDIF.
  ENDMETHOD.
  METHOD add_table.
    DATA t_node        TYPE REF TO if_ixml_element.
    DATA i_node        TYPE REF TO if_ixml_element.
    FIELD-SYMBOLS:
      <l> TYPE any.
    IF table IS INITIAL. EXIT. ENDIF.
    IF name IS INITIAL.
      t_node = xml_node.
    ELSE.
      t_node = xmldoc->create_element( name ).
    ENDIF.
    ASSERT t_node IS BOUND.
    LOOP AT table ASSIGNING <l>.
      i_node = xmldoc->create_element( en_line ).
      add_any(   xmldoc = xmldoc
               xml_node = i_node
                    any = <l> ).
      t_node->append_child( i_node ).
    ENDLOOP.
    IF NOT name IS INITIAL.
      rc = xml_node->append_child( t_node ).
      mac_syserr_log rc 'append_child' 'ZAPLINK_EASYXML->ADD_TABLE'.
    ENDIF.
  ENDMETHOD.
  METHOD any2xml.
    DATA xml_node  TYPE REF TO if_ixml_element.
    DATA _desc     TYPE REF TO cl_abap_typedescr.
    DATA string    TYPE string.
    xmldoc = ixml->create_document( ).
    xml_node = xmldoc->create_element( type ). stack( type ).
    IF attributs IS SUPPLIED.
      _desc = cl_abap_typedescr=>describe_by_data( p_data = attributs ).
      _desc = get_ref_type( _desc ).
      stack_descr( _desc ).
      CASE _desc->kind.
        WHEN cl_abap_datadescr=>kind_ref.
          mac_syserr_log -1 'cl_abap_datadescr=>kind_ref' 'ZAPLINK_EASYXML->ANY2XML'.
        WHEN cl_abap_datadescr=>kind_struct.
          add_structure(   xmldoc = xmldoc
                         xml_node = xml_node
                        structure = attributs ).
          " cl_abap_datadescr=>kind_elem.
          " cl_abap_datadescr=>kind_table.
          " cl_abap_datadescr=>kind_class.
        WHEN OTHERS. " cl_abap_datadescr=>kind_intf.
          string = _desc->get_relative_name( ).
          MESSAGE ID msgid TYPE 'X' NUMBER 001 WITH string 'ATTRIBUTES'.
      ENDCASE.
      unstack( ).
    ENDIF.
    add_any( xmldoc = xmldoc
           xml_node = xml_node
                any = any ).
    rc = xmldoc->append_child( xml_node ).
    mac_syserr_log rc 'append_child' 'ZAPLINK_EASYXML->ANY2XML'.
    IF application_log->has_messages_of_msgt( id_msgty     = 'E' ) IS INITIAL.
      IF NOT application_log IS BOUND. MESSAGE ID msgid TYPE 'S' NUMBER 006. ENDIF.
      CALL METHOD application_log->add_success
        EXPORTING
          id_msgno = '006'.
    ENDIF.
    unstack( ).
  ENDMETHOD.
  METHOD class_constructor.
    DATA s_char LIKE LINE OF char_to_protect.
    s_char-sign = 'I'.    s_char-option = 'EQ'.
    s_char-low = space.                                 APPEND s_char TO char_to_protect.
    s_char-low = cl_abap_char_utilities=>newline.       APPEND s_char TO char_to_protect.
    s_char-low = cl_abap_char_utilities=>cr_lf.         APPEND s_char TO char_to_protect.
    s_char-low = cl_abap_char_utilities=>form_feed.     APPEND s_char TO char_to_protect.
    CONCATENATE '^[' issue46_prefix ']*' INTO issue46_regex.
  ENDMETHOD.
  METHOD constructor.
    ixml = cl_ixml=>create( ).
    reset( ).
  ENDMETHOD.
  METHOD elem_2_string.
    DATA _desc     TYPE REF TO cl_abap_typedescr.
    DATA exception TYPE REF TO cx_root.
    DATA l_convin  TYPE REF TO cl_abap_conv_in_ce.
    IF any IS INITIAL.
      EXIT.
    ENDIF.
    IF type_desc IS BOUND.
      _desc = type_desc.
    ELSE.
      _desc = cl_abap_typedescr=>describe_by_data( p_data = any ).
    ENDIF.
    IF _desc->kind <> cl_abap_datadescr=>kind_elem. EXIT. ENDIF.
    CASE _desc->type_kind.
      WHEN cl_abap_typedescr=>typekind_xstring
        OR cl_abap_typedescr=>typekind_xsequence.
        TRY.
            l_convin = cl_abap_conv_in_ce=>create( encoding = 'UTF-8'
                                                      input = any ).
            CALL METHOD l_convin->read
              IMPORTING
                data = string.
          CATCH cx_root INTO exception.
            application_log->add_exception( exception = exception ).
        ENDTRY.
      WHEN cl_abap_typedescr=>typekind_char
        OR cl_abap_typedescr=>typekind_clike
        OR cl_abap_typedescr=>typekind_date
        OR cl_abap_typedescr=>typekind_time
        OR cl_abap_typedescr=>typekind_string
        OR cl_abap_typedescr=>typekind_csequence
        OR cl_abap_typedescr=>typekind_num
        OR cl_abap_typedescr=>typekind_numeric
        OR cl_abap_typedescr=>typekind_int
        OR cl_abap_typedescr=>typekind_int1
        OR cl_abap_typedescr=>typekind_int2
        OR cl_abap_typedescr=>typekind_float
        OR cl_abap_typedescr=>typekind_packed
        OR cl_abap_typedescr=>typekind_simple
        OR cl_abap_typedescr=>typekind_hex        " Convert Hex to String works
          .
        TRY.
            string = any.
          CATCH cx_root INTO exception.
            application_log->add_exception( exception ).
        ENDTRY.
      WHEN OTHERS.
        mac_syserr_log -1 'WHEN OTHERS' 'ZAPLINK_EASYXML->ELEM_2_STRING'.
    ENDCASE.
  ENDMETHOD.
  METHOD get_attributs.
    DATA root_node   TYPE REF TO if_ixml_element.
    DATA _desc     TYPE REF TO cl_abap_typedescr.
    DATA string    TYPE string.
    root_node = xmldoc->get_root_element( ).
    IF root_node IS BOUND.
      _desc = cl_abap_typedescr=>describe_by_data( p_data = attributs ).
      _desc = get_ref_type( _desc ).
      stack_descr( _desc ).
      CASE _desc->kind.
        WHEN cl_abap_datadescr=>kind_ref.
          mac_syserr_log -1 'cl_abap_datadescr=>kind_ref' 'ZAPLINK_EASYXML->ANY2XML'.
        WHEN cl_abap_datadescr=>kind_struct.
          read_structure( EXPORTING
                           xml_node = root_node
                           CHANGING
                          structure = attributs ).
          " cl_abap_datadescr=>kind_elem.
          " cl_abap_datadescr=>kind_table.
          " cl_abap_datadescr=>kind_class.
        WHEN OTHERS. " cl_abap_datadescr=>kind_intf.
          string = _desc->get_relative_name( ).
          MESSAGE ID msgid TYPE 'X' NUMBER 001 WITH string 'ATTRIBUTES'.
      ENDCASE.
      unstack( ).
    ENDIF.
  ENDMETHOD.
  METHOD get_node_text.
    DATA o_filter   TYPE REF TO if_ixml_node_filter.
    DATA o_iterator TYPE REF TO if_ixml_node_iterator.
    DATA o_text     TYPE REF TO if_ixml_node.
    CHECK xml_node->contains( if_ixml_node=>co_node_text ) = abap_true.    " value returned by get_value is the right one.
    o_filter = xml_node->create_filter_node_type( if_ixml_node=>co_node_text ).
    o_iterator = xml_node->create_iterator_filtered( depth = 1
                                                    filter = o_filter ).
    o_text = o_iterator->get_next( ).   result = o_text->get_value( ).
    IF result = '#'. CLEAR result. ENDIF.
  ENDMETHOD.
  METHOD get_ref_type.
    DATA o_ref      TYPE REF TO cl_abap_refdescr.
    FIELD-SYMBOLS <a> TYPE any.
    ref_type = typedesc.
    IF typedesc->kind = cl_abap_datadescr=>kind_ref.
      o_ref ?= typedesc.
      IF o_ref->type_kind = cl_abap_refdescr=>typekind_oref.    " Object
        ref_type = o_ref->get_referenced_type( ).
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD is_simple_type_kind.
    result = '?'.  " unknow
    CASE type_kind.
      WHEN cl_abap_typedescr=>typekind_char
        OR cl_abap_typedescr=>typekind_clike
        OR cl_abap_typedescr=>typekind_date
        OR cl_abap_typedescr=>typekind_time
        OR cl_abap_typedescr=>typekind_string
        OR cl_abap_typedescr=>typekind_xstring
        OR cl_abap_typedescr=>typekind_num
        OR cl_abap_typedescr=>typekind_numeric
        OR cl_abap_typedescr=>typekind_int
        OR cl_abap_typedescr=>typekind_int1
        OR cl_abap_typedescr=>typekind_int2
        OR cl_abap_typedescr=>typekind_float
        OR cl_abap_typedescr=>typekind_packed
        OR cl_abap_typedescr=>typekind_simple
          .
        result = abap_true.
      WHEN cl_abap_typedescr=>typekind_class
        OR cl_abap_typedescr=>typekind_struct1
        OR cl_abap_typedescr=>typekind_struct2
        OR cl_abap_typedescr=>typekind_table
        .
        result = abap_false.
      WHEN cl_abap_typedescr=>typekind_any.
      WHEN cl_abap_typedescr=>typekind_csequence.
      WHEN cl_abap_typedescr=>typekind_data.
      WHEN cl_abap_typedescr=>typekind_dref.
      WHEN cl_abap_typedescr=>typekind_hex.
      WHEN cl_abap_typedescr=>typekind_intf.
      WHEN cl_abap_typedescr=>typekind_iref.
      WHEN cl_abap_typedescr=>typekind_oref.
      WHEN cl_abap_typedescr=>typekind_w.
      WHEN cl_abap_typedescr=>typekind_xsequence.
    ENDCASE.
  ENDMETHOD.
  METHOD node2string.
    DATA _ixml TYPE REF TO if_ixml.
    DATA _streamfactory TYPE REF TO if_ixml_stream_factory.
    DATA _outputstream TYPE REF TO if_ixml_ostream.
    DATA _printxmldoc TYPE REF TO cl_xml_document.
    _ixml = cl_ixml=>create( ).
    _streamfactory = _ixml->create_stream_factory( ).
    _outputstream = _streamfactory->create_ostream_cstring( string ).
    CALL METHOD xml_node->render
      EXPORTING
        ostream = _outputstream.
    CREATE OBJECT _printxmldoc.
    _printxmldoc->parse_string( string ).
  ENDMETHOD.
  METHOD node_is_not_type.
    DATA d_mask(8)  TYPE x.
    DATA d_txt_m(8) TYPE x.
    CHECK node IS BOUND.
    d_mask = node->get_type( ).   d_txt_m = type.
    d_mask = d_mask BIT-AND d_txt_m.
    IF d_mask = 00000000.   result = abap_true.   ENDIF.
  ENDMETHOD.
  METHOD node_is_type.
    DATA d_mask(8)  TYPE x.
    DATA d_txt_m(8) TYPE x.
    CHECK node IS BOUND.
    d_mask = node->get_type( ).   d_txt_m = type.
    d_mask = d_mask BIT-AND d_txt_m.
    IF d_mask = d_txt_m.    result = abap_true.   ENDIF.
  ENDMETHOD.
  METHOD protect_string.
    DATA d_last TYPE i.
    CHECK NOT string IS INITIAL.
    d_last = strlen( string ) - 1.
    IF NOT string(1) IN char_to_protect.
      result = string.
    ELSE.
      CONCATENATE protection_char string INTO result.
    ENDIF.
    IF string+d_last(1) IN char_to_protect.   CONCATENATE result protection_char INTO result.   ENDIF.    " Issue 61 & 68
  ENDMETHOD.
  METHOD read_any.
    DATA _desc     TYPE REF TO cl_abap_typedescr.
    DATA string    TYPE string.
    DATA name      TYPE string.
    DATA object    TYPE REF TO object.
    FIELD-SYMBOLS: <any> TYPE any.
    IF typedesc IS BOUND.
      _desc = typedesc.
    ELSE.
      _desc = cl_abap_typedescr=>describe_by_data( p_data = any ).
    ENDIF.
    _desc = get_ref_type( _desc ).
    stack_descr( _desc ).
    CASE _desc->kind.
      WHEN cl_abap_datadescr=>kind_ref.
        IF _desc->type_kind = cl_abap_refdescr=>typekind_dref.   " Data Ref
          ASSIGN any->* TO <any>.
          IF sy-subrc = 0.        " already assigned
            mac_syserr_log -1 'cl_abap_datadescr=>kind_ref' 'ZAPLINK_EASYXML->READ_ANY'.
          ELSE.
            CREATE DATA any TYPE REF TO if_ixml_element.
            ASSIGN any->* TO <any>.
            ASSERT sy-subrc = 0.
            <any> = xml_node.
          ENDIF.
        ELSE.
          mac_syserr_log -1 'cl_abap_datadescr=>kind_ref' 'ZAPLINK_EASYXML->READ_ANY'.
        ENDIF.
      WHEN cl_abap_datadescr=>kind_elem.
        string = xml_node->get_value( ).
        string_2_elem( EXPORTING
                          string = string
                      type_desc = _desc
                       CHANGING
                            any = any ).
      WHEN cl_abap_datadescr=>kind_struct.
        read_structure( EXPORTING
                         xml_node = xml_node
                         CHANGING
                        structure = any ).
      WHEN cl_abap_datadescr=>kind_table.
        read_table( EXPORTING
                     xml_node = xml_node
                     CHANGING
                        table = any ).
      WHEN cl_abap_datadescr=>kind_class.
        object = any.
        read_object( EXPORTING
                      xml_node = xml_node
                      typedesc = _desc
                      CHANGING
                        object = object ).
        IF any <> object.   any ?= object.    ENDIF.
      WHEN cl_abap_datadescr=>kind_intf.
        string = _desc->get_relative_name( ).
        name = xml_node->get_name( ).
        IF NOT application_log IS BOUND. MESSAGE ID msgid TYPE 'E' NUMBER 001 WITH space space. ENDIF.
        CALL METHOD application_log->add_warning
          EXPORTING
            id_msgno = '001'
            id_msgv1 = name
            id_msgv2 = string.
    ENDCASE.
    unstack( ).
  ENDMETHOD.
  METHOD read_object.
    DATA elem       TYPE REF TO if_ixml_element.
    DATA next_node  TYPE REF TO if_ixml_node.
    DATA node       TYPE REF TO if_ixml_node.
    DATA o_obj      TYPE REF TO cl_abap_classdescr.
    DATA iterator   TYPE REF TO if_ixml_node_iterator.
    DATA childs     TYPE REF TO if_ixml_node_list.
    DATA attrs      TYPE REF TO if_ixml_named_node_map.
    DATA data_type  TYPE string.
    DATA attr_name  TYPE string.
    DATA name       TYPE string.
    DATA svalue     TYPE string.
    DATA typedescr  TYPE REF TO cl_abap_typedescr.
    DATA _cx        TYPE REF TO cx_root.
    FIELD-SYMBOLS <d> TYPE any.
    IF NOT object IS BOUND AND NOT typedesc IS BOUND. EXIT. ENDIF.
    IF NOT object IS BOUND.
      data_type = typedesc->get_relative_name( ).
      TRY.
          CREATE OBJECT object TYPE (data_type).
        CATCH cx_root INTO _cx.
          CALL METHOD application_log->add_exception
            EXPORTING
              exception = _cx.
          EXIT.
      ENDTRY.
    ENDIF.
    o_obj ?= cl_abap_classdescr=>describe_by_object_ref( p_object_ref = object ).
    unstack( ).
    attr_name = o_obj->absolute_name.
    stack( attr_name ).
    svalue = get_node_text( xml_node ).                       " Issue 38
    IF NOT svalue IS INITIAL.
      svalue = unprotect_string( svalue ).                    " Issue 61
      ASSIGN object->(self_fieldname) TO <d>.
      IF sy-subrc <> 0.
        mac_syserr_log sy-subrc 'ASSIGN object->(self_fieldname) TO <d>' 'ZAPLINK_EASYXML->READ_OBJECT'. "#EC NOTEXT
      ELSE.
        typedescr = cl_abap_typedescr=>describe_by_data( <d> ).
        typedescr = get_ref_type( typedescr ).
        CASE typedescr->kind.
          WHEN cl_abap_datadescr=>kind_ref.
            mac_syserr_log -1 'cl_abap_datadescr=>kind_ref (Value)' 'ZAPLINK_EASYXML->READ_OBJECT'. "#EC NOTEXT
          WHEN cl_abap_datadescr=>kind_elem.
            string_2_elem( EXPORTING
                              string = svalue
                          type_desc = typedescr
                           CHANGING
                                any = <d> ).
          WHEN OTHERS.
            mac_syserr_log -1 'NOT cl_abap_datadescr=>kind_elem (Value)' 'ZAPLINK_EASYXML->READ_OBJECT'. "#EC NOTEXT
        ENDCASE.
      ENDIF.
    ENDIF.
    attrs = xml_node->get_attributes( ).
    iterator = attrs->create_iterator( ).
    next_node = iterator->get_next( ).
    WHILE next_node IS BOUND.
      node = next_node.    next_node ?= iterator->get_next( ).
      attr_name = node->get_name( ).
      READ TABLE o_obj->attributes TRANSPORTING NO FIELDS WITH KEY name = attr_name.
      IF sy-subrc <> 0.
        data_type = o_obj->get_relative_name( ).
        name = xml_node->get_name( ).
        IF NOT application_log IS BOUND. MESSAGE ID msgid TYPE 'E' NUMBER 003 WITH abap_true abap_true abap_true. ENDIF.
        CALL METHOD application_log->add_warning
          EXPORTING
            id_msgno = '003'
            id_msgv1 = attr_name
            id_msgv2 = name
            id_msgv3 = data_type.
      ELSE.
        ASSIGN object->(attr_name) TO <d>.
        IF sy-subrc <> 0.
          mac_syserr_log sy-subrc 'ASSIGN object->(attr_name) TO <d> (Attrs)' 'ZAPLINK_EASYXML->READ_STRUCTURE'. "#EC NOTEXT
        ELSE.
          typedescr = cl_abap_typedescr=>describe_by_data( <d> ).
          typedescr = get_ref_type( typedescr ).
          CASE typedescr->kind.
            WHEN cl_abap_datadescr=>kind_ref.
              mac_syserr_log -1 'cl_abap_datadescr=>kind_ref (Attrs)' 'ZAPLINK_EASYXML->READ_STRUCTURE'. "#EC NOTEXT
            WHEN cl_abap_datadescr=>kind_elem.
              svalue = node->get_value( ).
              string_2_elem( EXPORTING
                                string = svalue
                            type_desc = typedescr
                             CHANGING
                                  any = <d> ).
            WHEN OTHERS.
              TRY.
                  elem ?= node.
                  stack( attr_name ).
                  read_any( EXPORTING
                             xml_node = elem
                             typedesc = typedescr
                             CHANGING
                                  any = <d> ).
                  unstack( ).
                CATCH cx_root INTO _cx.
                  application_log->add_exception( exception = _cx ).
              ENDTRY.
          ENDCASE.
        ENDIF.
      ENDIF.
    ENDWHILE.
    childs = xml_node->get_children( ).
    iterator = childs->create_iterator( ).
    next_node = iterator->get_next( ).
    WHILE next_node IS BOUND.
      node = next_node.    next_node ?= iterator->get_next( ).
      attr_name = node->get_name( ).
      CHECK node_is_not_type( node = node type = if_ixml_node=>co_node_text ) = abap_true. " not text node
      READ TABLE o_obj->attributes TRANSPORTING NO FIELDS WITH KEY name = attr_name.
      IF sy-subrc <> 0.
        data_type = o_obj->get_relative_name( ).
        name = xml_node->get_name( ).
        IF NOT application_log IS BOUND. MESSAGE ID msgid TYPE 'E' NUMBER 003 WITH abap_true abap_true abap_true. ENDIF.
        CALL METHOD application_log->add_warning
          EXPORTING
            id_msgno = '003'
            id_msgv1 = attr_name
            id_msgv2 = name
            id_msgv3 = data_type.
      ELSE.
        ASSIGN object->(attr_name) TO <d>.
        IF sy-subrc <> 0.
          mac_syserr_log sy-subrc 'ASSIGN object->(attr_name)' 'ZAPLINK_EASYXML->READ_OBJECT'. "#EC NOTEXT
        ELSE.
          typedescr = cl_abap_typedescr=>describe_by_data( <d> ).
          typedescr = get_ref_type( typedescr ).
          CASE typedescr->kind.
            WHEN cl_abap_datadescr=>kind_elem.
              svalue = node->get_value( ).
              string_2_elem( EXPORTING
                                string = svalue
                            type_desc = typedescr
                             CHANGING
                                  any = <d> ).
            WHEN OTHERS.
              TRY.
                  elem ?= node.
                  stack( attr_name ).
                  read_any( EXPORTING
                             xml_node = elem
                             typedesc = typedescr
                             CHANGING
                                  any = <d> ).
                  unstack( ).
                CATCH cx_root INTO _cx.
                  application_log->add_exception( exception = _cx ).
              ENDTRY.
          ENDCASE.
        ENDIF.
      ENDIF.
    ENDWHILE.
  ENDMETHOD.
  METHOD read_structure.
    DATA elem        TYPE REF TO if_ixml_element.
    DATA node        TYPE REF TO if_ixml_node.
    DATA next_node   TYPE REF TO if_ixml_node.
    DATA structdescr TYPE REF TO cl_abap_structdescr.
    DATA typedescr   TYPE REF TO cl_abap_typedescr.
    DATA svalue      TYPE string.
    FIELD-SYMBOLS:
      <d> TYPE any,
      <c> LIKE LINE OF structdescr->components.
    DATA attrs      TYPE REF TO if_ixml_named_node_map.
    DATA iterator   TYPE REF TO if_ixml_node_iterator.
    DATA childs     TYPE REF TO if_ixml_node_list.
    DATA attr_name  TYPE string.
    DATA name       TYPE string.
    DATA data_type  TYPE string.
    DATA exception  TYPE REF TO cx_root.
    svalue = get_node_text( xml_node ).                       " Issue 38
    IF NOT svalue IS INITIAL.
      svalue = unprotect_string( svalue ).                    " Issue 61
      ASSIGN COMPONENT self_fieldname OF STRUCTURE structure TO <d>.
      IF sy-subrc <> 0.
        mac_syserr_log sy-subrc 'ASSIGN COMPONENT self_fieldname OF STRUCTURE structure (Value)' 'ZAPLINK_EASYXML->READ_STRUCTURE'. "#EC NOTEXT
      ELSE.
        typedescr = cl_abap_typedescr=>describe_by_data( <d> ).
        typedescr = get_ref_type( typedescr ).
        CASE typedescr->kind.
          WHEN cl_abap_datadescr=>kind_ref.
            mac_syserr_log -1 'cl_abap_datadescr=>kind_ref (Value)' 'ZAPLINK_EASYXML->READ_STRUCTURE'. "#EC NOTEXT
          WHEN cl_abap_datadescr=>kind_elem.
            string_2_elem( EXPORTING
                              string = svalue
                          type_desc = typedescr
                           CHANGING
                                any = <d> ).
          WHEN OTHERS.
            mac_syserr_log -1 'NOT cl_abap_datadescr=>kind_elem (Value)' 'ZAPLINK_EASYXML->READ_STRUCTURE'. "#EC NOTEXT
        ENDCASE.
      ENDIF.
    ENDIF.
    structdescr ?= cl_abap_structdescr=>describe_by_data( structure ).
    attrs = xml_node->get_attributes( ).
    iterator = attrs->create_iterator( ).
    node = iterator->get_next( ).
    WHILE node IS BOUND.
      attr_name = node->get_name( ).    UNASSIGN <c>.
      READ TABLE structdescr->components ASSIGNING <c> WITH KEY name = attr_name.
      IF sy-subrc <> 0.
        REPLACE FIRST OCCURRENCE OF REGEX issue46_regex IN attr_name WITH ``.
        IF sy-subrc = 0 AND strlen( attr_name ) > 0.
          IF attr_name(1) CO '0123456789'.    " Issue 46 : Field names strating with numbre in attributes
            READ TABLE structdescr->components ASSIGNING <c> WITH KEY name = attr_name.
          ENDIF.
        ENDIF.
        IF NOT <c> IS ASSIGNED.   attr_name = node->get_name( ).    ENDIF.
      ENDIF.
      IF NOT <c> IS ASSIGNED.
        data_type = structdescr->get_relative_name( ).
        name = xml_node->get_name( ).
        IF NOT application_log IS BOUND. MESSAGE ID msgid TYPE 'E' NUMBER 003 WITH abap_true abap_true abap_true. ENDIF.
        CALL METHOD application_log->add_warning
          EXPORTING
            id_msgno = '003'
            id_msgv1 = attr_name
            id_msgv2 = name
            id_msgv3 = data_type.
      ELSE.
        ASSIGN COMPONENT attr_name OF STRUCTURE structure TO <d>.
        IF sy-subrc <> 0.
          mac_syserr_log sy-subrc 'ASSIGN COMPONENT attr_name OF STRUCTURE structure (Attrs)' 'ZAPLINK_EASYXML->READ_STRUCTURE'. "#EC NOTEXT
        ELSE.
          typedescr = cl_abap_typedescr=>describe_by_data( <d> ).
          typedescr = get_ref_type( typedescr ).
          CASE typedescr->kind.
            WHEN cl_abap_datadescr=>kind_ref.
              mac_syserr_log -1 'cl_abap_datadescr=>kind_ref (Attrs)' 'ZAPLINK_EASYXML->READ_STRUCTURE'. "#EC NOTEXT
            WHEN cl_abap_datadescr=>kind_elem.
              svalue = node->get_value( ).
              string_2_elem( EXPORTING
                                string = svalue
                            type_desc = typedescr
                             CHANGING
                                  any = <d> ).
            WHEN OTHERS.
              TRY.
                  elem ?= node.
                  stack( attr_name ).
                  read_any( EXPORTING
                             xml_node = elem
                             typedesc = typedescr
                             CHANGING
                                  any = <d> ).
                  unstack( ).
                CATCH cx_root INTO exception.
                  application_log->add_exception( exception = exception ).
              ENDTRY.
          ENDCASE.
        ENDIF.
      ENDIF.
      node ?= iterator->get_next( ).
    ENDWHILE.
    childs = xml_node->get_children( ).
    iterator = childs->create_iterator( ).
    next_node ?= iterator->get_next( ).
    WHILE next_node IS BOUND.
      node = next_node.    next_node ?= iterator->get_next( ).
      attr_name = node->get_name( ).
      CHECK node_is_not_type( node = node type = if_ixml_node=>co_node_text ) = abap_true. " not text node
      READ TABLE structdescr->components ASSIGNING <c> WITH KEY name = attr_name.
      IF sy-subrc <> 0.
        data_type = structdescr->get_relative_name( ).
        name = xml_node->get_name( ).
        IF NOT application_log IS BOUND. MESSAGE ID msgid TYPE 'E' NUMBER 003 WITH abap_true abap_true abap_true. ENDIF.
        CALL METHOD application_log->add_warning
          EXPORTING
            id_msgno = '003'
            id_msgv1 = attr_name
            id_msgv2 = name
            id_msgv3 = data_type.
      ELSE.
        ASSIGN COMPONENT attr_name OF STRUCTURE structure TO <d>.
        IF sy-subrc <> 0.
          mac_syserr_log sy-subrc 'ASSIGN COMPONENT attr_name OF STRUCTURE structure (Childs)' 'ZAPLINK_EASYXML->READ_STRUCTURE'. "#EC NOTEXT
        ELSE.
          typedescr = cl_abap_typedescr=>describe_by_data( <d> ).
          typedescr = get_ref_type( typedescr ).
          CASE typedescr->kind.
            WHEN cl_abap_datadescr=>kind_ref.
              mac_syserr_log -1 'cl_abap_datadescr=>kind_ref (Childs)' 'ZAPLINK_EASYXML->READ_STRUCTURE'. "#EC NOTEXT
            WHEN cl_abap_datadescr=>kind_elem.
              svalue = node->get_value( ).
              string_2_elem( EXPORTING
                                string = svalue
                            type_desc = typedescr
                             CHANGING
                                  any = <d> ).
            WHEN OTHERS.
              elem ?= node.
              stack( attr_name ).
              read_any( EXPORTING
                         xml_node = elem
                         typedesc = typedescr
                         CHANGING
                              any = <d> ).
              unstack( ).
          ENDCASE.
        ENDIF.
      ENDIF.
    ENDWHILE.
  ENDMETHOD.
  METHOD read_table.
    DATA o_n_elem   TYPE REF TO if_ixml_element.
    DATA o_elem     TYPE REF TO if_ixml_element.
    DATA o_iterator TYPE REF TO if_ixml_node_iterator.
    DATA o_childs   TYPE REF TO if_ixml_node_list.
    DATA o_filter   TYPE REF TO if_ixml_node_filter.
    DATA dref       TYPE REF TO data.
    DATA d_name     TYPE string.
    DATA d_context  LIKE LINE OF context.
    DATA _cx        TYPE REF TO cx_root.
    DATA _count     TYPE string.
    FIELD-SYMBOLS:
      <d> TYPE any.
    o_childs = xml_node->get_children( ).
    o_filter = xml_node->create_filter_node_type( if_ixml_node=>co_node_element ).
    o_iterator = o_childs->create_iterator_filtered( filter = o_filter ).
    o_n_elem ?= o_iterator->get_next( ).
    WHILE o_n_elem IS BOUND.
      ADD 1 TO _count.    stack( _count ).
      o_elem = o_n_elem.    o_n_elem ?= o_iterator->get_next( ).
      d_name = o_elem->get_name( ).
      IF en_line <> d_name.
        IF NOT context IS INITIAL. READ TABLE context INTO d_context INDEX 1. ENDIF.
        CALL METHOD application_log->add_error
          EXPORTING
            id_msgno = '007'
            id_msgv1 = en_line
            id_msgv2 = d_name
            id_msgv3 = d_context.
      ELSE.
        TRY.
            CREATE DATA dref LIKE LINE OF table.
          CATCH cx_root INTO _cx.
            application_log->add_exception( exception = _cx ).
            CONTINUE.
        ENDTRY.
        ASSIGN dref->* TO <d>.
        IF sy-subrc <> 0.
          mac_syserr_log sy-subrc 'ASSIGN dref->*' 'ZAPLINK_EASYXML->READ_TABLE'. "#EC NOTEXT
        ELSE.
          read_any( EXPORTING
                     xml_node = o_elem
                     CHANGING
                          any = <d> ).
          INSERT <d> INTO TABLE table.
          mac_syserr_log sy-subrc 'INSERT <d> INTO TABLE table.' 'ZAPLINK_EASYXML->READ_TABLE'. "#EC NOTEXT
        ENDIF.
      ENDIF.
      unstack( ).
    ENDWHILE.
  ENDMETHOD.
  METHOD reset.
    DATA object TYPE balobj_d.
    DATA subobject  TYPE balsubobj.
    DATA ext_id TYPE balnrext.
    IF application_log IS BOUND.
      application_log->clear( ).
      application_log->free( ).
    ELSE.
      CREATE OBJECT application_log.
      application_log->msgid = msgid.
      object = 'ZAPLINK'.
      subobject = 'EASYXML'.
      CALL METHOD application_log->init
        EXPORTING
          id_object      = object
          id_subobject   = subobject
          id_extnumber   = ext_id
          auto_upd_custo = abap_true
          id_activity    = zaplink_message_collector=>actions-create
        EXCEPTIONS
          error          = 1
          OTHERS         = 2.
      IF sy-subrc <> 0.
      ELSE.
        bal_level = 1.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD stack.
    IF NOT item IS INITIAL.
      INSERT item INTO context INDEX 1.
    ENDIF.
  ENDMETHOD.
  METHOD stack_descr.
    DATA name TYPE string.
    name = desc->absolute_name.
    stack( name ).
  ENDMETHOD.
  METHOD string_2_elem.
    DATA _desc     TYPE REF TO cl_abap_typedescr.
    DATA exception TYPE REF TO cx_root.
    IF string IS INITIAL. EXIT. ENDIF.
    IF type_desc IS BOUND.
      _desc = type_desc.
    ELSE.
      _desc = cl_abap_typedescr=>describe_by_data( p_data = any ).
    ENDIF.
    IF _desc->kind <> cl_abap_datadescr=>kind_elem. EXIT. ENDIF.
    CASE _desc->type_kind.
      WHEN cl_abap_typedescr=>typekind_xstring
        OR cl_abap_typedescr=>typekind_xsequence.
        TRY.
            CALL FUNCTION 'ECATT_CONV_STRING_TO_XSTRING'
              EXPORTING
                im_string  = string
              IMPORTING
                ex_xstring = any.
          CATCH cx_root INTO exception.
            application_log->add_exception( exception = exception ).
        ENDTRY.
      WHEN cl_abap_typedescr=>typekind_char
        OR cl_abap_typedescr=>typekind_clike
        OR cl_abap_typedescr=>typekind_date
        OR cl_abap_typedescr=>typekind_time
        OR cl_abap_typedescr=>typekind_string
        OR cl_abap_typedescr=>typekind_csequence
        OR cl_abap_typedescr=>typekind_num
        OR cl_abap_typedescr=>typekind_numeric
        OR cl_abap_typedescr=>typekind_int
        OR cl_abap_typedescr=>typekind_int1
        OR cl_abap_typedescr=>typekind_int2
        OR cl_abap_typedescr=>typekind_float
        OR cl_abap_typedescr=>typekind_packed
        OR cl_abap_typedescr=>typekind_simple
        OR cl_abap_typedescr=>typekind_hex        " Convert Hex to String works
          .
        TRY.
            any = string.
          CATCH cx_root INTO exception.
            application_log->add_exception( exception = exception ).
        ENDTRY.
      WHEN OTHERS.
        mac_syserr_log -1 'WHEN OTHERS' 'ZAPLINK_EASYXML->STRING_2_ELEM'.
    ENDCASE.
  ENDMETHOD.
  METHOD unprotect_string.
    DATA d_last TYPE i.
    CHECK NOT string IS INITIAL.
    d_last = strlen( string ) - 1.    result = string.
    IF string(1) = protection_char AND d_last >= 1.
      IF string+1(1) IN char_to_protect.
        SHIFT result BY 1 PLACES LEFT.
      ENDIF.
    ENDIF.
    IF string+d_last(1) = protection_char AND d_last >= 2.      " Issue 61 & 68
      SUBTRACT 1 FROM d_last.
      IF string+d_last(1) IN char_to_protect.
        SHIFT result BY 1 PLACES RIGHT CIRCULAR.    SHIFT result BY 1 PLACES LEFT.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD unstack.
    IF NOT context IS INITIAL.
      DELETE context INDEX 1.
    ENDIF.
  ENDMETHOD.
  METHOD xml2any.
    DATA root_node   TYPE REF TO if_ixml_element.
    root_node = xmldoc->get_root_element( ).
    IF root_node IS BOUND.
      IF attributs IS SUPPLIED.
        CALL METHOD me->get_attributs
          EXPORTING
            xmldoc    = xmldoc
          CHANGING
            attributs = attributs.
      ENDIF.
      read_any( EXPORTING
                 xml_node = root_node
                 CHANGING
                      any = any ).
      IF application_log->has_messages_of_msgt( id_msgty     = 'E' ) IS INITIAL.
        IF NOT application_log IS BOUND. MESSAGE ID msgid TYPE 'S' NUMBER 005. ENDIF.
        CALL METHOD application_log->add_success
          EXPORTING
            id_msgno = '005'.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD _xml2any.
    DATA root_node   TYPE REF TO if_ixml_element.
    DATA _doc        TYPE REF TO if_ixml_document.
    TRY.
        _doc ?= xml.
        root_node = _doc->get_root_element( ).
      CATCH cx_sy_move_cast_error.
        root_node ?= xml.
    ENDTRY.
    IF root_node IS BOUND.
      read_any( EXPORTING
                 xml_node = root_node
                 CHANGING
                      any = any ).
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_EASYXML implementation
CLASS zaplink_enhancement_data IMPLEMENTATION.
  METHOD sotr_2_texts.
    TYPES:
      BEGIN OF ts_lang,
        lang TYPE sotr_text-langu,
      END OF ts_lang.
    DATA tt_lang    TYPE STANDARD TABLE OF ts_lang WITH DEFAULT KEY.
    DATA key        TYPE sotr_key.
    DATA s_text     LIKE LINE OF results.
    DATA sotr_text  TYPE sotr_text.
    DATA btfr_str   TYPE btfr_string.
    FIELD-SYMBOLS <l> LIKE LINE OF tt_lang.
    SELECT langu INTO TABLE tt_lang
      FROM sotr_text
      WHERE concept = data-short
        AND object = space.
    SELECT langu APPENDING TABLE tt_lang
      FROM sotr_textu
      WHERE concept = data-long
        AND object = space.
    SORT tt_lang.     DELETE ADJACENT DUPLICATES FROM tt_lang.
    LOOP AT tt_lang ASSIGNING <l>.
      CLEAR s_text.
      IF data-short IS NOT INITIAL.
        CLEAR: key, sotr_text.
        key-concept = data-short.
        CALL FUNCTION 'SOTR_READ_TEXT_WITH_KEY'
          EXPORTING
            langu            = <l>-lang
            sotr_key         = key
          IMPORTING
            entry            = sotr_text
          EXCEPTIONS
            no_entry_found   = 1
            language_missing = 0        " Could exist only for long for this language
            OTHERS           = 3.
        IF sy-subrc <> 0.
          mac_raise_mf 'SOTR_READ_TEXT_WITH_KEY' sy-subrc.
        ELSE.
          s_text-text = sotr_text-text.
        ENDIF.
      ENDIF.
      IF data-long IS NOT INITIAL.
        CLEAR: btfr_str.
        CALL FUNCTION 'BTFR_SELECT_SINGLE'
          EXPORTING
            concept             = data-long
            langu               = <l>-lang
            flag_string         = abap_true
            flag_system_context = abap_false
          IMPORTING
            string_wa           = btfr_str
          EXCEPTIONS
            concept_not_found   = 1
            text_not_found      = 0     " Could exist only for long for this language
            OTHERS              = 3.
        IF sy-subrc <> 0.
          mac_raise_mf 'BTFR_SELECT_SINGLE' sy-subrc.
        ELSE.
          s_text-_ = btfr_str-text.
        ENDIF.
      ENDIF.
      IF s_text IS NOT INITIAL.
        s_text-lang = <l>.
        INSERT s_text INTO TABLE results.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD texts_2_sotr.
    DATA _txt     TYPE string.
    FIELD-SYMBOLS: <t> LIKE LINE OF texts.
    LOOP AT texts ASSIGNING <t>.
      IF <t>-text IS NOT INITIAL.
        _txt = <t>-text.
        CALL FUNCTION 'BTFR_MAINTAIN_SINGLE_TEXT'
          EXPORTING
            langu                 = <t>-lang
            concept               = sotr-short
            flag_no_screen        = abap_true
            default_text          = _txt
            flag_correction_entry = abap_false
          EXCEPTIONS
            parameter_error       = 1
            text_not_found        = 2
            invalid_object_type   = 3
            invalid_package       = 4
            header_diff_interface = 5
            invalid_tadir_entry   = 6
            invalid_transl_type   = 7
            invalid_concept       = 8
            OTHERS                = 9.
        IF sy-subrc <> 0.
          mac_raise_mf 'BTFR_MAINTAIN_SINGLE_TEXT' sy-subrc.
        ENDIF.
      ENDIF.
      IF <t>-_ IS NOT INITIAL.
        _txt = <t>-_.
        CALL FUNCTION 'BTFR_MAINTAIN_SINGLE_TEXT'
          EXPORTING
            langu                 = <t>-lang
            concept               = sotr-long
            flag_no_screen        = abap_true
            default_text          = _txt
            flag_correction_entry = abap_false
          EXCEPTIONS
            parameter_error       = 1
            text_not_found        = 2
            invalid_object_type   = 3
            invalid_package       = 4
            header_diff_interface = 5
            invalid_tadir_entry   = 6
            invalid_transl_type   = 7
            invalid_concept       = 8
            OTHERS                = 9.
        IF sy-subrc <> 0.
          mac_raise_mf 'BTFR_MAINTAIN_SINGLE_TEXT' sy-subrc.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_ENHANCEMENT_DATA implementation
CLASS zaplink_extractor IMPLEMENTATION.
  METHOD analyse.
    DATA filename    TYPE td_filename.
    DATA t_keys      TYPE tt_compkeys.
    DATA o_tmp_list  TYPE to_list.
    DATA o_comp      TYPE to_component.
    DATA o_comp_n    TYPE to_component.
    DATA o_conn      TYPE to_connector.
    DATA o_cnx_clean TYPE to_connector_cleaner.
    DATA _comp       TYPE ts_component.
    DATA o_raw       TYPE REF TO zaplink_raw.
    DATA d_checksum  TYPE td_checksum.
    DATA d_code_sign TYPE td_checksum.
    DATA s_my_file   TYPE ts_my_file.
    DATA _cx_list    TYPE REF TO zaplink_cx_list.
    DATA _cx_cnx     TYPE REF TO zaplink_cx_connector.
    DATA _cx_comp    TYPE REF TO zaplink_cx_component.
    DATA o_data      TYPE REF TO lcl_data.
    t_keys = zaplink_tools=>get_keys_from_tadir( srcsystem = srcsystem
                                                     type  = type
                                                      name = name
                                                  packages = packages
                                                       ext = ext
                                                    author = author ).
    CHECK NOT t_keys IS INITIAL.
    TRY.
        working_list->clear( ).                               " Issue 115
        working_list->add_keys( t_keys ).
        zaplink_gui=>update_subobj( o_list = working_list     " Update Sub Component level
                                     f_sub = f_sub ).
        working_list->select_default( zaplink_list=>sel_actions-export ).
        working_list->reverse_selection( ).
        o_tmp_list = working_list->selection_as_list( ).
        working_list->remove_list( o_tmp_list ).
        working_list->order_kind = zaplink_list=>order_kinds-no_order.
        working_list->init_iter( ).
        working_list->display_progress = abap_true.
        o_comp_n = working_list->get_next( ).
        WHILE o_comp_n IS BOUND.
          o_comp = o_comp_n.    o_comp_n = working_list->get_next( ).
          TRY.
              _comp = o_comp->get_key( ).   o_conn = o_comp->connector( ).
              o_raw = o_conn->read_from_sap( o_comp ).
              TRY.
                  CLEAR o_cnx_clean.
                  o_cnx_clean ?= o_conn.
                  o_cnx_clean->anonymize( o_raw ).
                CATCH cx_root.
              ENDTRY.
              filename = create_fullpath( directory = target_dir
                                          hierarchy = hierarchy
                                               comp = o_comp ).
              s_my_file = load_file( filename ).
              s_my_file-o_raw = o_raw.
              lmac_create_data o_data s_my_file.
              o_comp->set_add_object( o_data ).
              d_checksum =  o_raw->get_checksum( ).           o_comp->set_checksum( d_checksum ).
              d_code_sign =  o_raw->get_code_signature( ).    o_comp->set_code_signature( d_code_sign ).
              IF d_checksum = s_my_file-checksum.   o_comp->set_action( zaplink_list=>sel_actions-none ).    ENDIF.
            CATCH zaplink_cx_connector INTO _cx_cnx.
              o_comp->set_exception( _cx_cnx ).
              TRY.
                  o_comp->set_msg_coll( o_conn->application_log ).
                CATCH cx_root.
              ENDTRY.
            CATCH zaplink_cx_component INTO _cx_comp.
              CREATE OBJECT _cx_cnx
                EXPORTING
                  textid   = zaplink_cx_container=>add_failed
                  previous = _cx_comp.
              _cx_cnx->update( ).
              o_comp->set_exception( _cx_cnx ).
              RAISE EXCEPTION TYPE zaplink_cx_container
                EXPORTING
                  textid = zaplink_cx_container=>add_comp_failed
                  type   = _comp-type
                  name   = _comp-name.
          ENDTRY.
        ENDWHILE.
      CATCH zaplink_cx_list INTO _cx_list.
        CREATE OBJECT o_mycx
          EXPORTING
            textid   = zaplink_cx_component=>invalid_exception
            previous = _cx_list.
        o_mycx->update( ).
        RAISE EXCEPTION o_mycx.
    ENDTRY.
    working_list->select_by_action( ).
  ENDMETHOD.
  METHOD class_constructor.
    xmlengine = cl_ixml=>create( ).
    CALL METHOD cl_gui_frontend_services=>get_file_separator
      CHANGING
        file_separator       = file_sep
      EXCEPTIONS
        cntl_error           = 1
        error_no_gui         = 2
        not_supported_by_gui = 3
        OTHERS               = 4.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                 WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDMETHOD.
  METHOD concatenate_path.
    DATA len TYPE i.
    IF directory IS INITIAL.    result = filename.    RETURN.   ENDIF.
    len = strlen( directory ) - 1.
    IF directory+len(1) <> file_sep.
      CONCATENATE directory file_sep filename INTO result.
    ELSE.
      CONCATENATE directory filename INTO result.
    ENDIF.
  ENDMETHOD.
  METHOD constructor.
    mac_create_log application_log ballog_subobject space.
    CREATE OBJECT working_list. " Issue 115
  ENDMETHOD.
  METHOD create_filename.
    CONCATENATE type ext_sep name ext_sep file_ext INTO result.
  ENDMETHOD.
  METHOD create_fullpath.
    CASE hierarchy.
      WHEN dirhierachies-type.
        result = create_fullpath_by_type( directory = directory
                                          comp      = comp ).
      WHEN dirhierachies-devc.
        result = create_fullpath_by_devc( directory = directory
                                          comp      = comp ).
      WHEN dirhierachies-dcty.
        result = create_fullpath_by_devc( directory = directory
                                          with_type = abap_true
                                          comp      = comp ).
    ENDCASE.
  ENDMETHOD.
  METHOD create_fullpath_by_devc.
    DATA filename    TYPE td_filename.
    DATA _comp       TYPE ts_component.
    DATA d_devc      TYPE td_devclass.
    DATA _directory  TYPE td_directoryname.
    DATA rc          TYPE sy-subrc.
    DATA len TYPE i.
    DATA type        TYPE td_directoryname.
    CHECK comp IS BOUND.
    d_devc = comp->get_devclass( ).
    _comp = comp->get_key( ).
    filename = create_filename( type = _comp-type
                                name = _comp-name ).
    _directory = get_devc_path( directory = directory
                                 devclass = d_devc ).
    IF NOT with_type IS INITIAL.
      type = _comp-type.
      _directory = concatenate_path( directory = _directory
                                      filename = type ).
    ENDIF.
    _directory = concatenate_path( directory = directory
                                    filename = _directory ).
    CALL METHOD cl_gui_frontend_services=>directory_create
      EXPORTING
        directory                = _directory
      CHANGING
        rc                       = rc
      EXCEPTIONS
        cntl_error               = 1
        directory_access_denied  = 2
        directory_already_exists = 0
        directory_create_failed  = 4
        error_no_gui             = 5
        not_supported_by_gui     = 6
        path_not_found           = 7
        unknown_error            = 8
        wrong_parameter          = 9
        OTHERS                   = 10.
    IF sy-subrc <> 0.
      mac_raise_obj_meth_by_name 'cl_gui_frontend_services' 'directory_create' sy-subrc.
    ENDIF.
    result = concatenate_path( directory = _directory
                                filename = filename ).
  ENDMETHOD.
  METHOD create_fullpath_by_type.
    DATA _comp       TYPE ts_component.
    DATA filename    TYPE td_filename.
    DATA _directory  TYPE td_directoryname.
    DATA rc          TYPE sy-subrc.
    CHECK comp IS BOUND.
    _comp = comp->get_key( ).
    filename = _comp-type.
    _directory = concatenate_path( directory = directory
                                    filename = filename ).
    CALL METHOD cl_gui_frontend_services=>directory_create
      EXPORTING
        directory                = _directory
      CHANGING
        rc                       = rc
      EXCEPTIONS
        cntl_error               = 1
        directory_access_denied  = 2
        directory_already_exists = 0
        directory_create_failed  = 4
        error_no_gui             = 5
        not_supported_by_gui     = 6
        path_not_found           = 7
        unknown_error            = 8
        wrong_parameter          = 9
        OTHERS                   = 10.
    IF sy-subrc <> 0.
      DATA(lv_subrc) = sy-subrc.
      mac_raise_obj_meth_by_name 'cl_gui_frontend_services' 'directory_create' lv_subrc.
    ENDIF.
    filename = create_filename( type = _comp-type
                                name = _comp-name ).
    result = concatenate_path( directory = _directory
                                filename = filename ).
  ENDMETHOD.
  METHOD extract.
    DATA directory   TYPE string.
    DATA filename    TYPE td_filename.
    DATA t_keys      TYPE tt_compkeys.
    DATA rc          TYPE sy-subrc.
    DATA o_list      TYPE to_list.
    DATA o_comp      TYPE to_component.
    DATA o_comp_n    TYPE to_component.
    DATA o_conn      TYPE to_connector.
    DATA o_cnx_clean TYPE to_connector_cleaner.
    DATA o_raw       TYPE REF TO zaplink_raw.
    DATA _comp       TYPE zaplink_component=>ts_component.
    DATA _cx_cnx     TYPE REF TO zaplink_cx_connector.
    DATA _cx_comp    TYPE REF TO zaplink_cx_component.
    DATA _cx_list    TYPE REF TO zaplink_cx_list.
    DATA o_data      TYPE REF TO lcl_data.
    analyse( target_dir = target_dir
             srcsystem  = srcsystem
             type       = type
             name       = name
             packages   = packages
             ext        = ext
             hierarchy  = hierarchy
             author     = author
                  f_sub = f_sub ).
    CHECK working_list IS BOUND.
    working_list->change_selection( ).
    TRY.
        working_list->order_kind = zaplink_list=>order_kinds-no_order.
        working_list->init_sel_iter( ).
        working_list->display_progress = abap_true.
        o_comp_n = working_list->get_next( ).
        WHILE o_comp_n IS BOUND.
          o_comp = o_comp_n.    o_comp_n = working_list->get_next( ).
          TRY.
              o_conn = o_comp->connector( ).
              CASE o_comp->get_action( ).
                WHEN actions-export.
                  o_data ?= o_comp->get_add_object(  ).
                  CHECK o_data IS BOUND.
                  ASSERT o_data->o_raw IS BOUND.
                  save_file( o_raw = o_data->o_raw
                          filename = o_data->filename ).
                WHEN actions-import.
                WHEN actions-uninstall.
                WHEN actions-unreplicable.
                WHEN OTHERS.
              ENDCASE.
            CATCH zaplink_cx_connector INTO _cx_cnx.
              o_comp->set_exception( _cx_cnx ).
              TRY.
                  o_comp->set_msg_coll( o_conn->application_log ).
                CATCH cx_root.
              ENDTRY.
            CATCH zaplink_cx_component INTO _cx_comp.
              CREATE OBJECT _cx_cnx
                EXPORTING
                  textid   = zaplink_cx_container=>add_failed
                  previous = _cx_comp.
              _cx_cnx->update( ).
              o_comp->set_exception( _cx_cnx ).
              RAISE EXCEPTION TYPE zaplink_cx_container
                EXPORTING
                  textid = zaplink_cx_container=>add_comp_failed
                  type   = _comp-type
                  name   = _comp-name.
          ENDTRY.
        ENDWHILE.
      CATCH zaplink_cx_list INTO _cx_list.
        CREATE OBJECT o_mycx
          EXPORTING
            textid   = zaplink_cx_component=>invalid_exception
            previous = _cx_list.
        o_mycx->update( ).
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD extract_connectors.
    DATA o_generator TYPE REF TO zaplink_standalone_generator.
    DATA _cx         TYPE REF TO cx_root.
    DATA directory   TYPE string.
    DATA filename    TYPE td_filename.
    DATA packages    TYPE scompaklis.
    DATA t_keys      TYPE tt_compkeys.
    DATA rc          TYPE sy-subrc.
    DATA o_list      TYPE to_list.
    DATA o_file      TYPE to_file.
    DATA o_cnxlist   TYPE to_list.
    DATA o_contlist  TYPE to_list.
    DATA o_oriclist  TYPE to_list.
    DATA o_cont      TYPE to_container.
    DATA o_comp      TYPE to_component.
    DATA o_cnx       TYPE to_component.
    DATA o_cnxcomp   TYPE to_component.
    DATA o_conn      TYPE to_connector.
    DATA o_cnx_clean TYPE to_connector_cleaner.
    DATA d_classname TYPE zaplink_standalone_generator=>td_name.
    DATA _comp       TYPE zaplink_component=>ts_component.
    DATA _cx_cnx  TYPE REF TO zaplink_cx_connector.
    DATA _cx_comp TYPE REF TO zaplink_cx_component.
    DATA _cx_list TYPE REF TO zaplink_cx_list.
    DATA s_cnxdata   TYPE ts_contdata.
    DATA d_msg       TYPE string.
    DATA d_change    TYPE abap_bool.
    FIELD-SYMBOLS:
      <m> LIKE LINE OF o_generator->messages,
      <i> LIKE LINE OF o_generator->includes,
      <c> LIKE LINE OF o_generator->classes.
    TRY.
        o_list ?= zaplink_connectors_4extractor=>get_connectorlist( ).
        o_list->select_default( zaplink_list=>sel_actions-export ).
        TRY.
            o_list->order_kind = zaplink_list=>order_kinds-no_order.
            o_list->init_sel_iter( ).
            o_list->display_progress = abap_true.
            o_cnx = o_list->get_next( ).
          CATCH zaplink_cx_list INTO _cx_list.
            CREATE OBJECT o_mycx
              EXPORTING
                textid   = zaplink_cx_component=>invalid_exception
                previous = _cx_list.
            o_mycx->update( ).
            RAISE EXCEPTION o_mycx.
        ENDTRY.
        WHILE o_cnx IS BOUND.
          CREATE OBJECT o_generator.
          o_generator->packages = package.
          CREATE OBJECT o_cnxlist.
          CREATE OBJECT o_file.
          TRY.
              _comp = o_cnx->get_key( ).
              TRY.
                  CREATE OBJECT o_conn TYPE (_comp-name).
                CATCH cx_root INTO _cx.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid   = zaplink_cx=>system_error
                      previous = _cx.
              ENDTRY.
              filename = o_conn->uuid.
              CONCATENATE filename ext_sep o_conn->version ext_sep file_ext INTO filename.
              filename = concatenate_path( directory = target_dir
                                            filename = filename ).
              o_file->set_filename( filename ).
              o_file->set_filetype( zaplink_file=>c_ft_local ).
              CLEAR o_cont.
              IF o_file->file_exists( ) = abap_true.
                TRY.
                    CREATE OBJECT o_cont
                      EXPORTING
                        o_file = o_file.
                    o_cont->load_from_file( ).
                    o_oriclist = o_cont->get_content( ).
                  CATCH zaplink_cx_container.
                    CLEAR o_cont.
                ENDTRY.
              ENDIF.
              d_classname = _comp-name.
              o_generator->add_object( d_classname ).
              LOOP AT o_generator->classes ASSIGNING <c>.
                CREATE OBJECT o_cnxcomp.
                o_cnxcomp->set_type( 'CLAS' ).    _comp-name = <c>-name.    o_cnxcomp->set_name( _comp-name ).
                TRY.
                    o_cnxlist->add( o_cnxcomp ).
                  CATCH zlcx_comp_already_exists.
                ENDTRY.
              ENDLOOP.
              LOOP AT o_generator->includes ASSIGNING <i>.
                CREATE OBJECT o_cnxcomp.
                o_cnxcomp->set_type( 'PROG' ).    _comp-name = <i>.   o_cnxcomp->set_name( _comp-name ).
                TRY.
                    o_cnxlist->add( o_cnxcomp ).
                  CATCH zlcx_comp_already_exists.
                ENDTRY.
              ENDLOOP.
              LOOP AT o_generator->messages ASSIGNING <m>.
                CREATE OBJECT o_cnxcomp.
                o_cnxcomp->set_type( 'MSAG' ).      _comp-name = <m>-name.      o_cnxcomp->set_name( _comp-name ).
                TRY.
                    o_cnxlist->add( o_cnxcomp ).
                  CATCH zlcx_comp_already_exists.
                ENDTRY.
              ENDLOOP.
              o_cnxlist->select_default( zaplink_list=>sel_actions-export ).
              IF NOT o_cont IS BOUND.
                _comp = o_cnx->get_key( ).
                s_cnxdata-name = _comp-name.
                o_cont = zaplink_container=>create_new( o_file = o_file
                                                          data = s_cnxdata ).
              ENDIF.
              o_cont->add_components( o_cnxlist ).
              o_contlist ?= o_cont->get_content( ).
              CLEAR d_change.
              IF NOT o_oriclist IS BOUND.
                CREATE OBJECT o_oriclist.
              ENDIF.
              o_contlist->init_iter( ).
              o_comp = o_contlist->get_next( ).
              WHILE o_comp IS BOUND.
                o_cnxcomp = o_oriclist->search( o_comp ).
                IF NOT o_cnxcomp IS BOUND.    d_change = abap_true.   EXIT.   ENDIF.
                IF o_comp->get_checksum( ) <> o_cnxcomp->get_checksum( ).    d_change = abap_true.   EXIT.   ENDIF.
                o_comp = o_contlist->get_next( ).
              ENDWHILE.
              _comp = o_cnx->get_key( ).
              IF d_change IS INITIAL.
                MESSAGE w015 WITH _comp-name o_conn->uuid filename INTO d_msg.
                WRITE:/ icon_light_out AS ICON, d_msg.
              ELSE.
                MESSAGE w002 WITH _comp-name o_conn->uuid filename INTO d_msg.
                WRITE:/ icon_green_light AS ICON, d_msg.
                o_cont->save_to_file( ).
                o_contlist->init_iter( ).
                o_cnxcomp = o_contlist->get_next( ).
                WHILE o_cnxcomp IS BOUND.
                  _comp = o_cnxcomp->get_key( ).    o_comp = o_oriclist->search( o_cnxcomp ).    CLEAR d_change.
                  IF NOT o_comp IS BOUND.
                    d_change = abap_true.
                  ELSE.
                    IF o_comp->get_checksum( ) <> o_cnxcomp->get_checksum( ).   d_change = abap_true.   ENDIF.
                  ENDIF.
                  IF d_change = abap_true.
                    MESSAGE w004 WITH _comp-type _comp-name INTO d_msg.
                    WRITE:/ space, space, icon_green_light AS ICON, d_msg.
                  ELSE.
                    MESSAGE i003 WITH _comp-type _comp-name INTO d_msg.
                    WRITE:/ space, space, icon_light_out AS ICON, d_msg.
                  ENDIF.
                  o_cnxcomp = o_contlist->get_next( ).
                ENDWHILE.
                WRITE:/ .
              ENDIF.
            CATCH zaplink_cx_component INTO _cx_comp.
              CREATE OBJECT _cx_cnx
                EXPORTING
                  textid   = zaplink_cx_container=>add_failed
                  previous = _cx_comp.
              _cx_cnx->update( ).   o_cnx->set_exception( _cx_cnx ).    _comp = o_cnx->get_key( ).
              RAISE EXCEPTION TYPE zaplink_cx_container
                EXPORTING
                  textid = zaplink_cx_container=>add_comp_failed
                  type   = _comp-type
                  name   = _comp-name.
          ENDTRY.
          TRY.
              o_cnx = o_list->get_next( ).
            CATCH zaplink_cx_list INTO _cx_list.
              EXIT.
          ENDTRY.
        ENDWHILE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD get_devc_path.
    TYPES: BEGIN OF ts_devc,
             devc TYPE td_devclass,
             path TYPE td_filename,
           END OF ts_devc.
    STATICS: t_devc TYPE SORTED TABLE OF ts_devc WITH UNIQUE KEY devc.
    DATA s_devc     LIKE LINE OF t_devc.
    DATA o_pack     TYPE REF TO if_package.
    DATA d_dir      TYPE td_directoryname.
    DATA rc          TYPE sy-subrc.
    s_devc-devc = devclass.
    READ TABLE t_devc INTO s_devc
         WITH TABLE KEY devc = s_devc-devc.
    IF sy-subrc <> 0.
      CALL METHOD cl_package=>if_package~load_package
        EXPORTING
          i_package_name             = devclass
          i_force_reload             = 'X'
        IMPORTING
          e_package                  = o_pack
        EXCEPTIONS
          object_not_existing        = 1
          unexpected_error           = 2
          intern_err                 = 3
          object_locked_and_modified = 4
          OTHERS                     = 5.
      IF sy-subrc <> 0.
      ENDIF.
      IF o_pack->super_package_name IS INITIAL.
        s_devc-path = devclass.
      ELSE.
        s_devc-path = get_devc_path( directory = directory
                                      devclass = o_pack->super_package_name ).
        d_dir = devclass.
        s_devc-path = concatenate_path( directory = s_devc-path
                                         filename = d_dir ).
      ENDIF.
      INSERT s_devc INTO TABLE t_devc.
      d_dir = concatenate_path( directory = directory
                                 filename = s_devc-path ).
      CALL METHOD cl_gui_frontend_services=>directory_create
        EXPORTING
          directory                = d_dir
        CHANGING
          rc                       = rc
        EXCEPTIONS
          directory_create_failed  = 1
          cntl_error               = 2
          error_no_gui             = 3
          directory_access_denied  = 4
          directory_already_exists = 0
          path_not_found           = 6
          unknown_error            = 7
          not_supported_by_gui     = 8
          wrong_parameter          = 9
          OTHERS                   = 10.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                   WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
    ENDIF.
    result = s_devc-path.
  ENDMETHOD.
  METHOD load_file.
    DATA _tempstring     TYPE string.
    DATA root_node       TYPE REF TO if_ixml_node.
    result-filename = filename.
    CREATE OBJECT result-o_file.
    result-o_file->set_filename( filename ).
    result-o_file->set_filetype( zaplink_file=>filetypes-local ).
    TRY.
        result-o_file->load( ).
        _tempstring = result-o_file->get_filecontent( ).
      CATCH zaplink_cx_file.
        CLEAR _tempstring.
    ENDTRY.
    CHECK NOT _tempstring IS INITIAL. " file exists
    result-o_xml = zaplink_connectors=>string_2_xml( _tempstring ).
    CHECK result-o_xml IS BOUND.
    root_node = result-o_xml->get_root_element( ).
    TRY.
        result-o_raw_base = zaplink_connectors=>node_2_raw( root_node ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
    result-checksum = result-o_raw_base->get_checksum( ).
  ENDMETHOD.
  METHOD save_file.
    DATA _tempstring     TYPE string.
    DATA s_my_file       TYPE ts_my_file.
    DATA d_name          TYPE td_compname.
    DATA d_type          TYPE td_comptype.
    DATA d_msg           TYPE string.
    CHECK o_raw IS BOUND.
    s_my_file = load_file( filename ).
    d_name = o_raw->get_name( ).                              " Issue 32
    d_type = o_raw->get_type( ).                              " Issue 32
    IF NOT s_my_file-checksum IS INITIAL.  " file allready exists => check checksum
      o_raw->set_checksum( ).
      IF o_raw->get_checksum( ) = s_my_file-checksum. " no change => skip file
        MESSAGE w000 WITH d_type d_name filename INTO d_msg.
        WRITE:/ zaplink_list_4extractor=>lights-export AS ICON, icon_yellow_light AS ICON, d_msg.
        EXIT.
      ELSE.
        s_my_file-o_xml = zaplink_connectors=>raw_2_xml( o_raw ).
      ENDIF.
    ENDIF.
    IF NOT s_my_file-o_xml IS BOUND.    " if not allready done
      o_raw->set_checksum( ).
      s_my_file-o_xml = zaplink_connectors=>raw_2_xml( o_raw ).
    ENDIF.
    CHECK s_my_file-o_xml IS BOUND.
    _tempstring = zaplink_connectors=>xml_2_string( s_my_file-o_xml ).
    TRY.
        s_my_file-o_file->set_filecontent( _tempstring ).
        s_my_file-o_file->save( ).
        MESSAGE s001 WITH d_type d_name filename INTO d_msg.
        WRITE:/ zaplink_list_4extractor=>lights-export AS ICON, icon_green_light AS ICON, d_msg.
      CATCH zaplink_cx_file.
        MESSAGE e005 WITH d_type d_name filename INTO d_msg.
        WRITE:/ zaplink_list_4extractor=>lights-export AS ICON, icon_red_light AS ICON, d_msg.
        RETURN.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_EXTRACTOR implementation
CLASS zaplink_fugr_data IMPLEMENTATION.
  METHOD anonymize.
    IF menupainter IS BOUND.    menupainter->anonymize( ).    ENDIF.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids-group.
    _id-sign = 'I'.
    _id-option = 'EQ'.
    _id-low = doc_ids-group.      APPEND _id TO r_doc_ids-group.
    _id-low = doc_ids-function.   APPEND _id TO r_doc_ids-function.
  ENDMETHOD.
  METHOD conv_function.
    DATA s_func LIKE LINE OF result.
    FIELD-SYMBOLS <f> LIKE LINE OF fm_data-functions.
    LOOP AT fm_data-functions ASSIGNING <f>.
      CLEAR s_func.   MOVE-CORRESPONDING <f> TO s_func. " header, import_p, changing_p, export_p, tables, exceptions, source.
      s_func-docs = fm_data-docs.
      APPEND s_func TO result.
    ENDLOOP.
    SORT result BY header-name.
  ENDMETHOD.
  METHOD from_data.
    DATA s_func    LIKE LINE OF functions.
    DATA s_txt     LIKE LINE OF a0_maindata-texts.
    DATA d_suffix  TYPE rs38l-suffix.
    DATA d_group   TYPE rs38l-area.
    DATA s_inc     LIKE LINE OF includes.
    DATA t_abapsrc TYPE tt_abaprawsource.
    DATA d_search  TYPE string.
    DATA d_replace TYPE string.
    DATA d_lcount  TYPE i.
    DATA d_doc     TYPE doku_obj.
    DATA d_doc_p   TYPE ts_doc_param.
    DATA t_docs    TYPE tt_docs.
    DATA t_funcs TYPE tt_fm_data.
    FIELD-SYMBOLS:
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <t>  LIKE LINE OF fm_data-texts,
      <f>  LIKE LINE OF fm_data-functions,        " Issue 100
      <i>  LIKE LINE OF fm_data-includes,
      <s>  LIKE LINE OF <i>-source,
      <im> LIKE LINE OF <f>-import_p,
      <ch> LIKE LINE OF <f>-changing_p,
      <ex> LIKE LINE OF <f>-export_p,
      <cx> LIKE LINE OF <f>-exceptions,
      <ta> LIKE LINE OF <f>-tables.
    a0_maindata-hdr = fm_data-header.
    textspool = fm_data-textspool.
    dynpros = fm_data-dynpros.
    menupainter = fm_data-menupainter.
    d_doc = zaplink_function_group=>get_mainprogram( fm_data-header-area ).
    t_docs = fm_data-docs.
    READ TABLE t_docs ASSIGNING <d>
         WITH KEY id = doc_ids-group
              object = d_doc.
    LOOP AT fm_data-texts ASSIGNING <t>.
      CLEAR s_txt.    s_txt-langu = <t>-spras.   s_txt-short_txt = <t>-areat.
      IF <d> IS ASSIGNED.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_txt-langu.
        IF sy-subrc = 0.    s_txt-long_txt = <dt>.   CLEAR s_txt-long_txt-tdspras.    DELETE TABLE <d>-texts FROM <dt>.    ENDIF.
      ENDIF.
      INSERT s_txt INTO TABLE a0_maindata-texts.
    ENDLOOP.
    IF <d> IS ASSIGNED.
      LOOP AT <d>-texts ASSIGNING <dt>.
        CLEAR s_txt.    s_txt-langu = <dt>-tdspras.   s_txt-long_txt = <dt>.   CLEAR s_txt-long_txt-tdspras.    INSERT s_txt INTO TABLE a0_maindata-texts.
      ENDLOOP.
    ENDIF.
    LOOP AT fm_data-includes ASSIGNING <i>.
      CLEAR s_inc.    s_inc-name = <i>-name.            t_abapsrc = <i>-source.
      CALL FUNCTION 'FUNCTION_INCLUDE_SPLIT'
        IMPORTING
          group                        = d_group
          suffix                       = d_suffix
        CHANGING
          include                      = s_inc-name
        EXCEPTIONS
          include_not_exists           = 1
          group_not_exists             = 2
          no_selections                = 3
          no_function_include          = 4
          no_function_pool             = 5
          delimiter_wrong_position     = 6
          no_customer_function_group   = 7
          no_customer_function_include = 8
          reserved_name_customer       = 9
          namespace_too_long           = 10
          area_length_error            = 11
          OTHERS                       = 12.
      IF sy-subrc = 0 AND d_group = a0_maindata-area.
        s_inc-name = d_suffix.
        IF s_inc-name = suffixes-top AND NOT <i>-source IS INITIAL.
          READ TABLE t_abapsrc ASSIGNING <s> INDEX 1.
          TRANSLATE <s> TO UPPER CASE.                    "#EC SYNTCHAR
          IF <s> CP 'FUNCTION-POOL *'.
            CONCATENATE space a0_maindata-area space INTO d_search.   TRANSLATE d_search TO UPPER CASE.
            CONCATENATE space markups-area space INTO d_replace.
            REPLACE FIRST OCCURRENCE OF d_search IN <s> WITH d_replace.
          ENDIF.
        ENDIF.
      ENDIF.
      s_inc-source-_ = zaplink_function_group=>conv_abap_raw2source( t_abapsrc ).
      INSERT s_inc INTO TABLE includes.
    ENDLOOP.
    LOOP AT fm_data-functions ASSIGNING <f>.      " Issue 100
      CLEAR s_func.
      CREATE OBJECT s_func-zl_object EXPORTING fm_data = <f>.
      APPEND s_func TO functions.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_func    LIKE LINE OF fm_data-functions.
    DATA s_line    LIKE LINE OF s_func-source.
    DATA s_txt     LIKE LINE OF fm_data-texts.
    DATA s_p_im    LIKE LINE OF s_func-import_p.
    DATA s_p_ch    LIKE LINE OF s_func-changing_p.
    DATA s_p_ex    LIKE LINE OF s_func-export_p.
    DATA s_p_ta    LIKE LINE OF s_func-tables.
    DATA s_excep   LIKE LINE OF s_func-exceptions.
    DATA d_suffix  TYPE rs38l-suffix.
    DATA d_group   TYPE rs38l-area.
    DATA s_inc     LIKE LINE OF fm_data-includes.
    DATA d_search  TYPE string.
    DATA d_replace TYPE string.
    DATA d_lcount  TYPE i.
    DATA s_doc     LIKE LINE OF fm_data-docs.
    DATA s_doc_txt LIKE LINE OF s_doc-texts.
    DATA d_doc_p   TYPE ts_doc_param.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF a0_maindata-texts,
      <i> LIKE LINE OF includes,
      <f> LIKE LINE OF functions,
      <s> LIKE LINE OF s_inc-source.
    fm_data-header = a0_maindata-hdr.
    fm_data-textspool = textspool.
    fm_data-dynpros = dynpros.
    fm_data-menupainter = menupainter.
    s_doc-application = 'DOKU'.   s_doc-id = doc_ids-group.   s_doc-object = zaplink_function_group=>get_mainprogram( fm_data-header-area ).
    s_doc-masterlang = abap_true.   s_doc-typ = 'E'.    s_doc-dokform = 'S_DOCU_SHOW'.    s_doc-dokstyle = 'S_DOCUS1'.
    LOOP AT a0_maindata-texts ASSIGNING <t>.
      IF NOT <t>-short_txt IS INITIAL.    CLEAR s_txt.    s_txt-spras = <t>-langu.   s_txt-areat = <t>-short_txt.   INSERT s_txt INTO TABLE fm_data-texts.    ENDIF.
      IF NOT <t>-long_txt IS INITIAL.
        CLEAR s_doc_txt.    s_doc_txt = <t>-long_txt.   s_doc_txt-tdspras = <t>-langu.    INSERT s_doc_txt INTO TABLE s_doc-texts.
        IF s_doc-langu IS INITIAL.    s_doc-langu = s_doc_txt-tdspras.    ENDIF.
      ENDIF.
    ENDLOOP.
    IF NOT s_doc-texts IS INITIAL.    INSERT s_doc INTO TABLE fm_data-docs.   ENDIF.
    LOOP AT includes ASSIGNING <i>.
      CLEAR s_inc.   d_suffix = s_inc-name = s_inc-short = <i>-name.
      s_inc-source = zaplink_function_group=>conv_abap_source2raw( <i>-source-_ ).
      IF d_suffix = s_inc-name.   " include has been truncated
        CONCATENATE 'L' a0_maindata-area d_suffix INTO s_inc-name.
        CALL FUNCTION 'FUNCTION_INCLUDE_SPLIT'
          IMPORTING
            group                        = d_group
            suffix                       = d_suffix
          CHANGING
            include                      = s_inc-name
          EXCEPTIONS
            include_not_exists           = 1
            group_not_exists             = 2
            no_selections                = 3
            no_function_include          = 4
            no_function_pool             = 5
            delimiter_wrong_position     = 6
            no_customer_function_group   = 7
            no_customer_function_include = 8
            reserved_name_customer       = 9
            namespace_too_long           = 10
            area_length_error            = 11
            OTHERS                       = 12.
        IF sy-subrc <> 0.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
        IF d_group <> a0_maindata-area.   CONTINUE.   ENDIF.    " Internal error
        IF d_suffix = suffixes-top AND NOT s_inc-source IS INITIAL.
          READ TABLE s_inc-source ASSIGNING <s> INDEX 1.
          TRANSLATE <s> TO UPPER CASE.                    "#EC SYNTCHAR
          IF <s> CP 'FUNCTION-POOL *'.
            CONCATENATE space markups-area space INTO d_search.   TRANSLATE d_search TO UPPER CASE.
            CONCATENATE space a0_maindata-area space INTO d_replace.
            REPLACE FIRST OCCURRENCE OF d_search IN <s> WITH d_replace.
          ENDIF.
        ENDIF.
      ENDIF.
      INSERT s_inc INTO TABLE fm_data-includes.
    ENDLOOP.
    LOOP AT functions ASSIGNING <f>.      " previously missing => No function imported :-(
      s_func = <f>-zl_object->to_data( ).
      s_func-header-str_area = fm_data-header-area.
      INSERT s_func INTO TABLE fm_data-functions.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_FUGR_DATA implementation
CLASS zaplink_list IMPLEMENTATION.
  METHOD add.
    DATA _idx  LIKE LINE OF _index.
    DATA _comp LIKE LINE OF _allcomp.
    CHECK comp IS BOUND.
    _idx = search_index( comp ).
    IF _idx-o_comp IS BOUND.
      RAISE EXCEPTION TYPE zlcx_comp_already_exists
        EXPORTING
          type = _idx-key-type
          name = _idx-key-name.
    ENDIF.
    _idx-o_comp = comp.
    INSERT _idx INTO TABLE _index.
    MOVE-CORRESPONDING _idx TO _comp. INSERT _comp INTO TABLE _allcomp.
    _add_subcomp( comp ).
  ENDMETHOD.
  METHOD add_keys.
    DATA o_comp   TYPE to_component.
    DATA o_cx_comp TYPE REF TO zaplink_cx_component.
    DATA _list    TYPE tt_compkeys.
    FIELD-SYMBOLS:
      <k> LIKE LINE OF _list.
    TRY.
        _list = data.
        SORT _list.
        DELETE ADJACENT DUPLICATES FROM _list.
        DELETE _list WHERE table_line IS INITIAL.
        LOOP AT _list ASSIGNING <k>.
          TRY.
              o_comp = zaplink_component=>create_new( <k> ).
            CATCH zaplink_cx_component INTO o_cx_comp.
              CREATE OBJECT o_mycx
                EXPORTING
                  textid   = zaplink_cx_list=>zaplink_cx_list
                  previous = o_cx_comp.
              o_mycx->update( ).
              RAISE EXCEPTION o_mycx.
          ENDTRY.
          add( o_comp ).
        ENDLOOP.
      CATCH zaplink_cx_list INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD add_list.
    DATA t_allcomp   TYPE tt_allcomplist.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF _index.
    LOOP AT data->_index ASSIGNING <i>.
      READ TABLE _index TRANSPORTING NO FIELDS
                 WITH TABLE KEY key = <i>-key.
      IF sy-subrc = 0.
        CONTINUE.
      ENDIF.
      t_allcomp = data->_allcomp.
      DELETE t_allcomp WHERE o_comp <> <i>-o_comp.
      INSERT <i> INTO TABLE _index.
      INSERT LINES OF t_allcomp INTO TABLE _allcomp.
    ENDLOOP.
  ENDMETHOD.
  METHOD change_selection.
    DATA alv TYPE td_alv.
    CHECK sy-batch IS INITIAL.
    alv = conv_to_alv( ).
    PERFORM set_list  USING me.
    CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
      EXPORTING
        i_callback_program       = callback_program
        i_callback_pf_status_set = pf_status
        i_callback_user_command  = user_command
        i_grid_title             = 'Select objects'(lst)
        it_fieldcat              = alv_conf-simple-fields
        is_layout                = alv_conf-simple-layout
      TABLES
        t_outtab                 = alv-headers
      EXCEPTIONS
        OTHERS                   = 0.
    PERFORM clear_list .
    IF is_confirmed IS INITIAL.
      unselect_all( ).
    ELSE.
      update_from_alv( alv ).
    ENDIF.
  ENDMETHOD.
  METHOD class_constructor.
    DATA field_s   LIKE LINE OF alv_conf-simple-fields.
    DATA field_h   LIKE LINE OF alv_conf-hierar-fields.
    DATA i_pos     TYPE i VALUE 0. " position d'affichage des champs
    DATA t_desc    TYPE REF TO cl_abap_typedescr.
    DATA st_desc   TYPE REF TO cl_abap_structdescr.
    DATA o_elem    TYPE REF TO cl_abap_elemdescr.
    DATA list      TYPE tt_alv.
    DATA line      LIKE LINE OF list.
    DATA text_name TYPE string.
    DATA i_len     TYPE i.
    DATA d_hex     TYPE x.                                    " Issue 76
    DATA d_char(2) TYPE c.
    CONSTANTS fn_sel TYPE string VALUE 'SELECT'.
    FIELD-SYMBOLS:
      <t> TYPE any,
      <c> LIKE LINE OF st_desc->components.
    DEFINE m_fieldcat_s.
      CLEAR field_s.
      field_s-fieldname = &1.
      field_s-seltext_m = field_s-seltext_l = &2.
      APPEND field_s TO alv_conf-simple-fields.
    END-OF-DEFINITION.
    DEFINE m_fieldcat_h.
      CLEAR field_h.
      field_h-row_pos   = 1.
      field_h-tabname   = &1.
      field_h-col_pos   = i_pos.
      field_h-fieldname = &2.
      field_h-seltext_m = field_h-seltext_l = &3.
      field_h-intlen  = field_h-outputlen = field_h-ddic_outputlen = &4.
      field_h-datatype = 'CHAR'.
      CASE field_h-fieldname.
        WHEN 'NAME'.
          field_h-key = abap_true.
        WHEN 'TYPE'.
          field_h-key = abap_true.
        WHEN 'SELECT'.
          field_h-input = abap_true.
          field_h-checkbox = abap_true.
        WHEN 'MSG'.
          field_h-row_pos   = 2.
          field_h-col_pos   = 1.
      ENDCASE.
      APPEND field_h TO alv_conf-hierar-fields.
    END-OF-DEFINITION.
    t_desc = cl_abap_structdescr=>describe_by_data( line ).
    CHECK t_desc->kind = cl_abap_structdescr=>kind_struct.
    st_desc ?= t_desc.
    LOOP AT st_desc->components ASSIGNING <c>.
      i_pos = sy-tabix.
      d_hex = i_pos.
      WRITE d_hex TO d_char.
      text_name = d_char+1.
      CONCATENATE 'TEXT-NF' text_name INTO text_name.
      ASSIGN (text_name) TO <t>.
      IF sy-subrc = 0.
        text_name = <t>.
      ELSE.
        text_name = <c>-name.
      ENDIF.
      CLEAR i_len.
      ASSIGN COMPONENT <c>-name OF STRUCTURE line TO <t>.
      IF sy-subrc = 0.
        t_desc = cl_abap_structdescr=>describe_by_data( <t> ).
        IF t_desc->kind = cl_abap_structdescr=>kind_elem.
          o_elem ?= t_desc.
          IF o_elem->output_length = 0.
            CASE <c>-name.
              WHEN 'NAME'.
                i_len = 30.
              WHEN 'MSG'.
                i_len = 80.
              WHEN OTHERS.
                i_len = 50.
            ENDCASE.
          ELSE.
            i_len = o_elem->output_length.
          ENDIF.
        ENDIF.
      ENDIF.
      IF i_len IS INITIAL. i_len = <c>-length. ENDIF.
      m_fieldcat_s <c>-name text_name.
      m_fieldcat_h alv_h_tables-header <c>-name text_name i_len.
      m_fieldcat_h alv_h_tables-item <c>-name text_name i_len.
    ENDLOOP.
    alv_conf-simple-layout-box_fieldname     = fn_sel.
    alv_conf-simple-layout-f2code            = 'MYPICK' .
    alv_conf-simple-layout-colwidth_optimize = 'X'.
    DELETE alv_conf-simple-fields WHERE fieldname = alv_conf-simple-layout-box_fieldname
                                     OR fieldname = 'ID'
                                     OR fieldname = 'EXPAND'.
    alv_conf-hierar-layout-expand_fieldname = 'EXPAND'.
    alv_conf-hierar-layout-box_fieldname     = fn_sel.
    alv_conf-hierar-layout-allow_switch_to_list = abap_true.
    DELETE alv_conf-hierar-fields WHERE fieldname = 'ID'
                                     OR ( fieldname = fn_sel AND tabname = alv_h_tables-item )
                                     OR fieldname = alv_conf-hierar-layout-expand_fieldname.
  ENDMETHOD.
  METHOD clear.
    CLEAR:
        display_progress,
        _allcomp,
        _index,
        o_exception,
        t_cursors,
        _iterator_count,
        _iterator_tabix,
        _iterator_type.
  ENDMETHOD.
  METHOD clone.
    DATA o_comp TYPE to_component.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF _index.
    TRY.
        CREATE OBJECT result.
        LOOP AT _index ASSIGNING <i>.
          o_comp = <i>-o_comp->clone( ).
          result->add( o_comp ).
          IF <i>-selected = abap_true.    result->select( o_comp ).    ENDIF.
        ENDLOOP.
      CATCH zaplink_cx.
        CLEAR result.
    ENDTRY.
  ENDMETHOD.
  METHOD comp_to_alv.
    DATA _key     TYPE ts_compkey.
    DATA d_action TYPE td_sel_action.
    DATA o_cx     TYPE REF TO cx_root.
    _key = o_comp->_get_key( ).
    result-type = _key-type.
    result-name = _key-name.
    d_action = o_comp->get_action( ).
    CASE d_action.
      WHEN sel_actions-delete_file.
        result-action = lights-delete_file.
      WHEN sel_actions-import.
        result-action = lights-import.
      WHEN sel_actions-export.
        result-action = lights-export.
      WHEN sel_actions-uninstall.
        result-action = lights-uninst.
      WHEN sel_actions-activated.
        result-action = lights-active.
      WHEN sel_actions-not_active.
        result-action = lights-inactive.
      WHEN sel_actions-unreplicable.
        result-action = lights-rep_error.
    ENDCASE.
    result-typ_txt = zaplink_connectors=>type2text( result-type ).
    IF o_comp->_connector-exists = zaplink_component=>connexists-not_exists.
      result-connector = lights-red.
      result-status = lights-no.
      MESSAGE e050 WITH result-type INTO result-msg.
    ELSE.
      result-connector = lights-green.
      result-checksum = o_comp->get_checksum( ).
      result-code_signature = o_comp->get_code_signature( ).
      result-devclass = o_comp->get_devclass( ).
      result-srcsystem = o_comp->get_src_sys( ).
      o_cx = o_comp->get_exception( ).
      result-status = lights-green.
      CASE d_action.
        WHEN sel_actions-import.
          IF o_comp->_exists = zaplink_connector=>exists. " AND selected = abap_true.
            result-status = lights-yellow.
            CLEAR result-select.
            MESSAGE e051 WITH result-type result-name INTO result-msg.
          ELSEIF o_cx IS BOUND.
            result-status = lights-yellow.
            result-msg = o_cx->get_text( ).
          ENDIF.
        WHEN sel_actions-export.
          IF o_comp->_exists <> zaplink_connector=>exists. " AND selected = abap_true.
            CLEAR result-select.
            result-status = lights-red.
            MESSAGE e052 WITH result-type result-name INTO result-msg.
          ELSEIF o_cx IS BOUND.
            result-status = lights-yellow.
            result-msg = o_cx->get_text( ).
          ENDIF.
        WHEN sel_actions-uninstall.
          IF o_comp->_exists <> zaplink_connector=>exists. " AND selected = abap_true.
            CLEAR result-select.
            result-status = lights-red.
            MESSAGE e052 WITH result-type result-name INTO result-msg.
          ELSEIF o_cx IS BOUND.
            result-status = lights-yellow.
            result-msg = o_cx->get_text( ).
          ENDIF.
        WHEN sel_actions-unreplicable.
          result-status = lights-red.
          MESSAGE e053 WITH result-type result-name INTO result-msg.
        WHEN OTHERS.
      ENDCASE.
    ENDIF.
  ENDMETHOD.
  METHOD conv_to_alv.
    FIELD-SYMBOLS <i> LIKE LINE OF _index.
    DATA _line  LIKE LINE OF result-headers.
    DATA s_item LIKE LINE OF result-items.
    DATA o_list TYPE to_me.
    DATA o_comp TYPE to_component.
    TRY.
        LOOP AT _index ASSIGNING <i>.
          _line = comp_to_alv( o_comp = <i>-o_comp
                             selected = <i>-selected ).
          CALL FUNCTION 'GUID_CREATE'
            IMPORTING
              ev_guid_16 = _line-id.
          _line-select = <i>-selected.
          IF NOT w_item IS INITIAL.
            o_list = <i>-o_comp->get_subcomponents( ).
            IF o_list IS BOUND.
              _line-expand = abap_true.
            ENDIF.
          ENDIF.
          APPEND _line TO result-headers.
          IF NOT w_item IS INITIAL.
            CHECK o_list IS BOUND.
            o_list->display_progress = abap_false.
            o_list->init_iter( ).
            o_comp = o_list->get_next( ).
            WHILE o_comp IS BOUND.
              s_item = comp_to_alv( o_comp = o_comp
                                  selected = <i>-selected ).
              o_comp = o_list->get_next( ).
              s_item-id = _line-id.
              s_item-select = _line-expand.
              APPEND s_item TO result-items.
            ENDWHILE.
          ENDIF.
        ENDLOOP.
        mac_def_catch zaplink_cx_list.
    ENDTRY.
  ENDMETHOD.
  METHOD display.
    DATA alv        TYPE td_alv.
    DATA s_keyinfo  TYPE slis_keyinfo_alv.
    s_keyinfo-header01 = s_keyinfo-item01 = 'ID'.
    alv = conv_to_alv( abap_true ).
    CALL FUNCTION 'REUSE_ALV_HIERSEQ_LIST_DISPLAY'
      EXPORTING
        i_callback_program       = callback_program
        i_callback_pf_status_set = pf_status_no_actions
        i_callback_user_command  = user_command
        is_layout                = alv_conf-hierar-layout
        it_fieldcat              = alv_conf-hierar-fields
        i_tabname_header         = alv_h_tables-header
        i_tabname_item           = alv_h_tables-item
        is_keyinfo               = s_keyinfo
      TABLES
        t_outtab_header          = alv-headers
        t_outtab_item            = alv-items
      EXCEPTIONS
        program_error            = 1
        OTHERS                   = 2.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
  ENDMETHOD.
  METHOD get_count.
    IF is_selected IS INITIAL.
      result = lines( _index ).
    ELSE.
      LOOP AT _index TRANSPORTING NO FIELDS WHERE selected = abap_true. ADD 1 TO result. ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD get_keys.
    FIELD-SYMBOLS:
      <k> LIKE LINE OF _index.
    LOOP AT _index ASSIGNING <k>.
      APPEND <k>-key TO result.
    ENDLOOP.
    SORT result.    DELETE ADJACENT DUPLICATES FROM result.
  ENDMETHOD.
  METHOD get_next.
    DATA component TYPE ts_compkey.
    DATA msg       TYPE string.
    DATA _pos      TYPE i.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF t_cursors.
    CHECK _iterator_tabix < _iterator_count.
    CASE _iterator_type.
      WHEN iterator_types-selected.
      WHEN iterator_types-all.
      WHEN OTHERS.
        RAISE EXCEPTION TYPE zaplink_cx_list
          EXPORTING
            textid = zaplink_cx_list=>iterator_not_initialize.
    ENDCASE.
    ADD 1 TO _iterator_tabix.
    READ TABLE t_cursors INDEX _iterator_tabix ASSIGNING <i>.
    ASSERT sy-subrc = 0.
    result = <i>-o_comp.
    IF display_progress = abap_true.
      component = result->_get_key( ).
      IF sy-batch = abap_true.
        MESSAGE i000 WITH component-type component-name.
      ELSE.
        MESSAGE i000 WITH component-type component-name INTO msg.
        IF _iterator_count > 0.
          _pos = 100 * _iterator_tabix / _iterator_count.
        ELSE.
          _pos = _iterator_tabix.
        ENDIF.
        CALL FUNCTION 'SAPGUI_PROGRESS_INDICATOR'
          EXPORTING
            percentage = _pos
            text       = msg.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD has_any.
    DATA t_allcomp TYPE tt_allcomplist.
    FIELD-SYMBOLS:
      <c> LIKE LINE OF _allcomp.
    t_allcomp = list->_allcomp.
    DELETE ADJACENT DUPLICATES FROM t_allcomp COMPARING key.
    result = abap_false.
    LOOP AT t_allcomp ASSIGNING <c>.
      READ TABLE _allcomp TRANSPORTING NO FIELDS
           WITH TABLE KEY key = <c>-key.
      IF sy-subrc = 0.
        result = abap_true.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD init_iter.
    DATA s_cursor LIKE LINE OF t_cursors.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF _index.
    CLEAR: _iterator_tabix, _iterator_count, t_cursors.    " Issue 30
    _iterator_type = iterator_types-all.
    LOOP AT _index ASSIGNING <i>.
      MOVE-CORRESPONDING <i> TO s_cursor.
      IF order_kind <> order_kinds-no_order.
        s_cursor-order = zaplink_connectors=>get_typeorder( <i>-key-type ).
      ENDIF.
      APPEND s_cursor TO t_cursors.
    ENDLOOP.
    CASE order_kind.
      WHEN order_kinds-install.
        SORT t_cursors BY order key.
      WHEN order_kinds-uninstall.
        SORT t_cursors BY order DESCENDING key.
      WHEN OTHERS.
        SORT t_cursors BY key.
    ENDCASE.
    DESCRIBE TABLE t_cursors LINES _iterator_count.
  ENDMETHOD.
  METHOD init_sel_iter.
    DATA s_cursor LIKE LINE OF t_cursors.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF _index.
    CLEAR: _iterator_tabix, _iterator_count, t_cursors.    " Issue 30
    _iterator_type = iterator_types-selected.
    LOOP AT _index ASSIGNING <i>
         WHERE selected = abap_true.
      MOVE-CORRESPONDING <i> TO s_cursor.
      IF order_kind <> order_kinds-no_order.
        s_cursor-order = zaplink_connectors=>get_typeorder( <i>-key-type ).
      ENDIF.
      APPEND s_cursor TO t_cursors.
    ENDLOOP.
    CASE order_kind.
      WHEN order_kinds-install.
        SORT t_cursors BY order key.
      WHEN order_kinds-uninstall.
        SORT t_cursors BY order DESCENDING key.
      WHEN OTHERS.
        SORT t_cursors BY key.
    ENDCASE.
    DESCRIBE TABLE t_cursors LINES _iterator_count.
  ENDMETHOD.
  METHOD is_empty.
    IF _index IS INITIAL.   result = abap_true.   ENDIF.
  ENDMETHOD.
  METHOD is_included.
    DATA t_allcomp TYPE tt_allcomplist.
    FIELD-SYMBOLS:
      <c> LIKE LINE OF _allcomp.
    t_allcomp = list->_allcomp.
    DELETE ADJACENT DUPLICATES FROM t_allcomp COMPARING key.
    result = abap_true.
    LOOP AT t_allcomp ASSIGNING <c>.
      READ TABLE _allcomp TRANSPORTING NO FIELDS
           WITH TABLE KEY key = <c>-key.
      IF sy-subrc <> 0.
        result = abap_false.
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD is_selected.
    DATA _idx LIKE LINE OF _index.
    _idx = search_index( comp ).
    IF _idx-selected IS NOT INITIAL.
      result = abap_true.
    ELSE.
      result = abap_false.
    ENDIF.
  ENDMETHOD.
  METHOD keep_commun_list.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF _index.
    LOOP AT _index ASSIGNING <i>.
      READ TABLE data->_index TRANSPORTING NO FIELDS
                 WITH TABLE KEY key = <i>-key.
      IF sy-subrc <> 0.
        DELETE _index.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD refresh.
    DATA t_list TYPE tt_complist.
    FIELD-SYMBOLS <i> LIKE LINE OF t_list.
    t_list = _index.
    clear( ).
    LOOP AT t_list ASSIGNING <i>.
      add( <i>-o_comp ).
      IF <i>-selected = abap_true.    select( <i>-o_comp ).    ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD remove.
    DATA _idx LIKE LINE OF _index.
    TRY.
        _idx = search_index( comp ).
      CATCH zaplink_cx_list INTO o_exception.
        RAISE EXCEPTION o_exception.
    ENDTRY.
    DELETE _allcomp WHERE o_comp = _idx-o_comp.
    DELETE TABLE _index FROM _idx.
  ENDMETHOD.
  METHOD remove_list.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF _index.
    LOOP AT data->_index ASSIGNING <i>.
      TRY.
          remove( <i>-o_comp ).
        CATCH zaplink_cx_list INTO o_exception.
      ENDTRY.
    ENDLOOP.
  ENDMETHOD.
  METHOD reverse_selection.
    FIELD-SYMBOLS <i> LIKE LINE OF _index.
    LOOP AT _index ASSIGNING <i>. IF <i>-selected IS INITIAL.   <i>-selected = abap_true.   ELSE.   CLEAR <i>-selected.   ENDIF.  ENDLOOP.
  ENDMETHOD.
  METHOD search.
    DATA _idx LIKE LINE OF _index.
    _idx = search_index( comp ).
    IF NOT _idx-o_comp IS BOUND.
      EXIT.
    ENDIF.
    result = _idx-o_comp.
  ENDMETHOD.
  METHOD search_index.
    DATA _key TYPE ts_compkey.
    CHECK comp IS BOUND.
    _key = comp->_get_key( ).
    READ TABLE _index INTO result
               WITH TABLE KEY key = _key.
    IF sy-subrc <> 0.
      result-key = _key.
    ENDIF.
  ENDMETHOD.
  METHOD select.
    TRY.
        _select( comp = comp
                value = abap_true ).
      CATCH zaplink_cx_list INTO o_exception.
        RAISE EXCEPTION o_exception.
    ENDTRY.
  ENDMETHOD.
  METHOD selection_as_list.
    DATA o_comp TYPE to_component.
    FIELD-SYMBOLS <i> LIKE LINE OF _index.
    TRY.
        CREATE OBJECT result.
        LOOP AT _index ASSIGNING <i> WHERE selected = abap_true.
          o_comp = <i>-o_comp->clone( ).
          result->add( o_comp ).
        ENDLOOP.
      CATCH zaplink_cx.
        CLEAR result.
    ENDTRY.
  ENDMETHOD.
  METHOD select_all.
    DATA s_idx LIKE LINE OF _index.
    s_idx-selected = abap_true.   MODIFY _index FROM s_idx TRANSPORTING selected WHERE selected <> s_idx-selected.
  ENDMETHOD.
  METHOD select_by_action.
    DATA action TYPE td_sel_action.
    FIELD-SYMBOLS <i> LIKE LINE OF _index.
    LOOP AT _index ASSIGNING <i>.
      CLEAR <i>-selected.
      action = <i>-o_comp->get_action( ).
      CASE action.
        WHEN sel_actions-export OR sel_actions-import OR sel_actions-uninstall OR sel_actions-delete_file.
          <i>-selected = abap_true.
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.
  METHOD select_default.
    TRY.
        CASE sel_action.
          WHEN sel_actions-export.
            select_export( ).
          WHEN sel_actions-import.
            select_import( ).
          WHEN sel_actions-uninstall.
            select_uninstall( ).
          WHEN OTHERS.
            RAISE EXCEPTION TYPE zaplink_cx_list
              EXPORTING
                textid     = zaplink_cx_list=>invalid_action
                sel_action = sel_action.
        ENDCASE.
      CATCH zaplink_cx_list INTO o_exception.
        RAISE EXCEPTION o_exception.
    ENDTRY.
  ENDMETHOD.
  METHOD select_export.
    FIELD-SYMBOLS <i> LIKE LINE OF _index.
    LOOP AT _index ASSIGNING <i>.
      CLEAR <i>-selected.
      IF <i>-o_comp->_connector-exists = zaplink_component=>connexists-exists.
        <i>-o_comp->set_action( sel_actions-export ).
        IF <i>-o_comp->_exists = zaplink_connector=>exists.    <i>-selected = abap_true.   ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD select_import.
    FIELD-SYMBOLS <i> LIKE LINE OF _index.
    LOOP AT _index ASSIGNING <i>.
      CLEAR <i>-selected.
      IF <i>-o_comp->_connector-exists = zaplink_component=>connexists-exists.
        <i>-o_comp->set_action( sel_actions-import ).
        IF <i>-o_comp->_exists = zaplink_connector=>exists-not_exists.    <i>-selected = abap_true.   ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD select_uninstall.
    FIELD-SYMBOLS <i> LIKE LINE OF _index.
    LOOP AT _index ASSIGNING <i>.
      CLEAR <i>-selected.
      IF <i>-o_comp->_connector-exists = zaplink_component=>connexists-exists.
        <i>-o_comp->set_action( sel_actions-uninstall ).
        IF <i>-o_comp->_exists = zaplink_connector=>exists.     <i>-selected = abap_true.     ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD unselect.
    TRY.
        _select( comp = comp
                value = abap_false ).
      CATCH zaplink_cx_list INTO o_exception.
        RAISE EXCEPTION o_exception.
    ENDTRY.
  ENDMETHOD.
  METHOD unselect_all.
    DATA s_idx LIKE LINE OF _index.
    s_idx-selected = abap_false.   MODIFY _index FROM s_idx TRANSPORTING selected WHERE selected <> s_idx-selected.
  ENDMETHOD.
  METHOD update_from_alv.
    FIELD-SYMBOLS:
      <a> LIKE LINE OF data-headers,
      <i> LIKE LINE OF _index.
    DATA _key TYPE ts_compkey.
    LOOP AT data-headers ASSIGNING <a>.
      _key-type = <a>-type.
      _key-name = <a>-name.
      READ TABLE _index ASSIGNING <i>
           WITH KEY key = _key.
      IF sy-subrc = 0.
        IF NOT <a>-select IS INITIAL.
          <i>-selected = abap_true.
        ELSE.
          <i>-selected = abap_false.
        ENDIF.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD _add_subcomp.
    DATA o_list TYPE to_me.
    DATA o_sub  TYPE to_me.
    DATA _comp LIKE LINE OF _allcomp.
    CHECK data IS BOUND.
    TRY.
        o_list = data->get_subcomponents( ).
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
    CHECK o_list IS BOUND.
    LOOP AT o_list->_allcomp INTO _comp.
      _comp-as_sub = abap_true.
      _comp-o_comp = data.
      INSERT _comp INTO TABLE _allcomp.
    ENDLOOP.
    LOOP AT o_list->_allcomp INTO _comp.    " Issue 102
      _add_subcomp( _comp-o_comp ).
    ENDLOOP.
  ENDMETHOD.
  METHOD _select.
    DATA _idx LIKE LINE OF _index.
    _idx = search_index( comp ).
    IF NOT _idx-o_comp IS BOUND.
      RAISE EXCEPTION TYPE zaplink_cx_list
        EXPORTING
          textid = zaplink_cx_list=>not_found
          type   = _idx-key-type
          name   = _idx-key-name.
    ENDIF.
    _idx-selected = value.
    MODIFY TABLE _index FROM _idx TRANSPORTING selected.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE zaplink_cx_list
        EXPORTING
          textid = zaplink_cx_list=>system_error
          type   = _idx-key-type
          name   = _idx-key-name.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_LIST implementation
CLASS zaplink_object_data IMPLEMENTATION.
  METHOD anonymize.
    DATA s_al  LIKE LINE OF aliases.
    DATA s_at LIKE LINE OF attributs.
    FIELD-SYMBOLS <ev>    LIKE LINE OF events.
    FIELD-SYMBOLS <in>    LIKE LINE OF interfaces.
    DATA s_co  LIKE LINE OF <in>-components.
    DATA s_ty  LIKE LINE OF types.
    DATA s_tg  LIKE LINE OF typegroups.
    FIELD-SYMBOLS <me>    LIKE LINE OF methods.
    DATA s_pa  LIKE LINE OF <me>-parameters.
    DATA s_ex  LIKE LINE OF <me>-exceptions.
    DATA s_dc  LIKE LINE OF deferred-classes.
    DATA s_di  LIKE LINE OF deferred-interfaces.
    MODIFY aliases FROM s_al TRANSPORTING version              " Issue 75
           WHERE NOT cmpname IS INITIAL OR cmpname IS INITIAL.
    MODIFY attributs FROM s_at TRANSPORTING author createdon changedby changedon r3release version editorder " Issue 75 / Issue 108
           WHERE NOT cmpname IS INITIAL OR cmpname IS INITIAL.
    LOOP AT events ASSIGNING <ev>.
      CLEAR: <ev>-author, <ev>-createdon, <ev>-changedby, <ev>-changedon, <ev>-r3release, <ev>-version, <ev>-editorder. " Issue 75 / Issue 108
      MODIFY <ev>-parameters FROM s_pa TRANSPORTING author createdon changedby changedon  version editorder             " Issue 75 / Issue 108
             WHERE NOT cmpname IS INITIAL OR cmpname IS INITIAL.
    ENDLOOP.
    LOOP AT interfaces ASSIGNING <in>.
      CLEAR: <in>-author, <in>-createdon, <in>-changedby, <in>-changedon, <in>-version. " Issue 75
      MODIFY <in>-components FROM s_co TRANSPORTING version   " Issue 75
             WHERE NOT clsname IS INITIAL OR clsname IS INITIAL.
    ENDLOOP.
    LOOP AT methods ASSIGNING <me>.
      CLEAR: <me>-author, <me>-createdon, <me>-changedby, <me>-changedon, <me>-r3release, <me>-version, <me>-editorder. " Issue 75 / Issue 108
      MODIFY <me>-parameters FROM s_pa TRANSPORTING author createdon changedby changedon version editorder              " Issue 75 / Issue 108
             WHERE NOT sconame IS INITIAL OR sconame IS INITIAL. " Issue 22
      MODIFY <me>-exceptions FROM s_ex TRANSPORTING author createdon changedby changedon version editorder              " Issue 75 / Issue 108
             WHERE NOT sconame IS INITIAL OR sconame IS INITIAL. " Issue 22
    ENDLOOP.
    MODIFY typegroups FROM s_tg TRANSPORTING version             " Issue 75
           WHERE NOT clsname IS INITIAL OR clsname IS INITIAL.
    MODIFY types FROM s_ty TRANSPORTING author createdon changedby changedon r3release version " editorder Issue 117 (preserve edit order) " Issue 75 / Issue 108
           WHERE NOT cmpname IS INITIAL OR cmpname IS INITIAL.
    MODIFY deferred-classes FROM s_dc TRANSPORTING version    " Issue 75
           WHERE NOT clsname IS INITIAL OR clsname IS INITIAL.
    MODIFY deferred-interfaces FROM s_di TRANSPORTING version " Issue 75
           WHERE NOT clsname IS INITIAL OR clsname IS INITIAL.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids-class.
    _id-sign = 'I'.
    _id-option = 'EQ'.
    _id-low = doc_ids-class-header.     APPEND _id TO r_doc_ids-class.
    _id-low = doc_ids-class-attribute.  APPEND _id TO r_doc_ids-class.
    _id-low = doc_ids-class-method.     APPEND _id TO r_doc_ids-class.
    _id-low = doc_ids-class-event.      APPEND _id TO r_doc_ids-class.
    _id-low = doc_ids-class-type.       APPEND _id TO r_doc_ids-class.
    _id-low = doc_ids-interface-header.     APPEND _id TO r_doc_ids-interface.    " Issue 33 : Wrong Doc IDs
    _id-low = doc_ids-interface-attribute.  APPEND _id TO r_doc_ids-interface.    " Issue 33 : Wrong Doc IDs
    _id-low = doc_ids-interface-method.     APPEND _id TO r_doc_ids-interface.    " Issue 33 : Wrong Doc IDs
    _id-low = doc_ids-interface-event.      APPEND _id TO r_doc_ids-interface.    " Issue 33 : Wrong Doc IDs
    _id-low = doc_ids-interface-type.       APPEND _id TO r_doc_ids-interface.    " Issue 33 : Wrong Doc IDs
  ENDMETHOD.
  METHOD clear_tags.
    CLEAR: obj_name, obj_version, obj_langu, obj_type.
  ENDMETHOD.
  METHOD complete_data.
    DATA s_impl_detail LIKE LINE OF fm_data-impl_details.
    FIELD-SYMBOLS:
      <m> LIKE LINE OF fm_data-includes-methods.
    CHECK NOT obj_name IS INITIAL.                            " Issue 23
    SELECT * INTO TABLE fm_data-class_desc
      FROM seoclasstx
      WHERE clsname = obj_name.                               " Issue 23
    SELECT * INTO TABLE fm_data-component_desc
      FROM seocompotx
      WHERE clsname = obj_name.                               " Issue 23
    SELECT * INTO TABLE fm_data-subcomponent_desc
      FROM seosubcotx
      WHERE clsname = obj_name.                               " Issue 23
    DELETE fm_data-class_desc WHERE descript IS INITIAL.
    DELETE fm_data-component_desc WHERE descript IS INITIAL.
    DELETE fm_data-subcomponent_desc WHERE descript IS INITIAL.
    LOOP AT fm_data-includes-methods ASSIGNING <m>
            WHERE cpdkey-clsname = obj_name.                  " Issue 23
      READ TABLE fm_data-methods TRANSPORTING NO FIELDS
           WITH KEY clsname = <m>-cpdkey-clsname
                    cmpname = <m>-cpdkey-cpdname.
      IF sy-subrc = 0.
        CONTINUE.
      ENDIF.
      READ TABLE fm_data-redefinitions TRANSPORTING NO FIELDS
           WITH KEY clsname = <m>-cpdkey-clsname
                 refclsname = fm_data-inheritance-refclsname
                    mtdname = <m>-cpdkey-cpdname.
      IF sy-subrc = 0.
        CONTINUE.
      ENDIF.
      CLEAR s_impl_detail.
      s_impl_detail-clsname = <m>-cpdkey-clsname.
      SPLIT <m>-cpdkey-cpdname AT method_separator INTO s_impl_detail-refclsname s_impl_detail-mtdname.
      IF s_impl_detail-mtdname IS INITIAL. " no ~ in name
        MESSAGE a000(zaplink_object) WITH <m>-cpdkey-cpdname <m>-cpdkey-clsname.
      ENDIF.
      READ TABLE fm_data-impl_details TRANSPORTING NO FIELDS
           WITH KEY clsname = s_impl_detail-clsname
                 refclsname = s_impl_detail-refclsname
                    mtdname = s_impl_detail-mtdname.
      IF sy-subrc = 0.
        CONTINUE.
      ENDIF.
      s_impl_detail-version = '1'. APPEND s_impl_detail TO fm_data-impl_details.
    ENDLOOP.
  ENDMETHOD.
  METHOD fd_comp_desc.
    DATA _t     LIKE LINE OF texts.
    DATA s_key  TYPE ts_doc_key.
    FIELD-SYMBOLS:
      <d>    LIKE LINE OF documentation,
      <dt>   LIKE LINE OF <d>-texts,
      <desc> LIKE LINE OF descriptions.
    LOOP AT descriptions ASSIGNING <desc>
         WHERE clsname = obj_name
           AND cmpname = component.
      _t-lang = <desc>-langu.      _t-text = <desc>-descript.
      s_key-name = obj_name.
      s_key-other = component.
      READ TABLE documentation ASSIGNING <d>
           WITH KEY object = s_key           " Component name should be unique so no realy need to check ID
                        id = id.
      IF sy-subrc = 0.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = _t-lang.
        IF sy-subrc = 0.   _t-_ = <dt>-_.   ENDIF.
      ENDIF.
      INSERT _t INTO TABLE texts.
    ENDLOOP.
  ENDMETHOD.
  METHOD fd_exceptions.
    DATA: _ex  LIKE LINE OF exceptions.
    FIELD-SYMBOLS:
      <ex>  LIKE LINE OF fm_data-exceps.
    LOOP AT fm_data-exceps ASSIGNING <ex>
         WHERE clsname = obj_name
           AND cmpname = component.
      CLEAR: _ex.
      _ex-hdr = <ex>.
      _ex-texts = fd_subc_desc( descriptions = fm_data-subcomponent_desc
                                   component = <ex>-cmpname
                               sub_component = <ex>-sconame ).
      CLEAR: _ex-clsname, _ex-cmpname, _ex-descript. " VERSION
      INSERT _ex INTO TABLE exceptions.
    ENDLOOP.
  ENDMETHOD.
  METHOD fd_parameters.
    DATA: _pa  LIKE LINE OF parameters.
    FIELD-SYMBOLS:
      <pa>  LIKE LINE OF fm_data-parameters.
    LOOP AT fm_data-parameters ASSIGNING <pa>
         WHERE clsname = obj_name
           AND cmpname = component.
      CLEAR: _pa.
      _pa-hdr = <pa>.
      _pa-texts = fd_subc_desc( descriptions = fm_data-subcomponent_desc
                                   component = <pa>-cmpname
                               sub_component = <pa>-sconame ).
      CLEAR: _pa-clsname, _pa-cmpname, _pa-langu, _pa-descript. " VERSION
      INSERT _pa INTO TABLE parameters.
    ENDLOOP.
  ENDMETHOD.
  METHOD fd_subc_desc.
    DATA: _t   LIKE LINE OF texts.
    FIELD-SYMBOLS:
      <desc> LIKE LINE OF descriptions.
    LOOP AT descriptions ASSIGNING <desc>
         WHERE clsname = obj_name
           AND cmpname = component
           AND sconame = sub_component.
      _t-lang = <desc>-langu.      _t-text = <desc>-descript.
      INSERT _t INTO TABLE texts.
    ENDLOOP.
  ENDMETHOD.
  METHOD fd_text.
    DATA _t     LIKE LINE OF texts.
    DATA s_key  TYPE ts_doc_key.
    DATA s_txt  LIKE LINE OF texts.
    FIELD-SYMBOLS:
      <doc>  LIKE LINE OF documentation,
      <dt>   LIKE LINE OF <doc>-texts,
      <desc> LIKE LINE OF descriptions.
    LOOP AT descriptions ASSIGNING <desc>
         WHERE clsname = classname.
      s_txt-lang = <desc>-langu.      s_txt-text = <desc>-descript.
      s_key-name = obj_name.
      READ TABLE documentation ASSIGNING <doc>
           WITH KEY object = s_key.           " Component name should be unique so no need to check ID
      IF sy-subrc = 0.
        READ TABLE <doc>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_txt-lang.
        IF sy-subrc = 0.    s_txt-_ = <dt>-_.     ENDIF.
      ENDIF.
      INSERT s_txt INTO TABLE texts.
    ENDLOOP.
  ENDMETHOD.
  METHOD fix_included_type_pool.
    DATA d_tabix TYPE sy-tabix.
    DATA t_tokens TYPE STANDARD TABLE OF stokes.
    DATA t_statments TYPE STANDARD TABLE OF sstmnt.
    DATA s_tp     LIKE LINE OF new_typepools.
    DATA d_flag TYPE abap_bool.
    FIELD-SYMBOLS:
      <s> LIKE LINE OF new_sourcecode,
      <t> LIKE LINE OF t_tokens,
      <n> LIKE LINE OF t_tokens.
    CHECK NOT sourcecode IS INITIAL.
    new_sourcecode = sourcecode.
    SCAN ABAP-SOURCE sourcecode
                     TOKENS INTO t_tokens
                     STATEMENTS INTO t_statments.
    LOOP AT t_tokens ASSIGNING <t>
      WHERE str CP 'TYPE-POOLS'.
      d_tabix = sy-tabix + 1.
      READ TABLE t_tokens ASSIGNING <n> INDEX d_tabix.
      CHECK sy-subrc = 0.
      CHECK <n>-row = <t>-row.    " TYPE-POOLS ABAP.
      READ TABLE typepools TRANSPORTING NO FIELDS
           WITH KEY typegroup = <n>-str
                     explicit = abap_true.
      CHECK sy-subrc <> 0 OR public IS INITIAL.
      IF sy-subrc <> 0.
        CLEAR s_tp.
        s_tp-typegroup = <n>-str.
        s_tp-tputype = 0.     " Type group use                (TYPE-POOLS tp)
        s_tp-explicit = abap_true.
        s_tp-implicit = abap_false.
        APPEND s_tp TO new_typepools.
      ENDIF.
      READ TABLE new_sourcecode ASSIGNING <s> INDEX <n>-row.
      CONCATENATE '*' <s> '"Auto commented by ZAPLINK_OBJECT connector and added as Explicit type group'(cmt) INTO <s>.
      d_flag = abap_true.
    ENDLOOP.
    IF d_flag IS INITIAL. CLEAR new_sourcecode. ENDIF.
  ENDMETHOD.
  METHOD from_data.
    DATA _at  LIKE LINE OF attributs.
    DATA _ty  LIKE LINE OF types.
    DATA _tg  LIKE LINE OF typegroups.
    DATA _me  LIKE LINE OF methods.
    DATA _al  LIKE LINE OF aliases.
    DATA _ev  LIKE LINE OF events.
    DATA _mk  TYPE seocpdkey.
    DATA _dc  LIKE LINE OF deferred-classes.
    DATA _di  LIKE LINE OF deferred-interfaces.
    DATA id   TYPE doku_id.
    FIELD-SYMBOLS:
      <at> LIKE LINE OF fm_data-attributes,
      <al> LIKE LINE OF fm_data-aliases,
      <me> LIKE LINE OF fm_data-methods,
      <ev> LIKE LINE OF fm_data-events,
      <cd> LIKE LINE OF fm_data-clsdeferrds,
      <id> LIKE LINE OF fm_data-intdeferrds,
      <ty> LIKE LINE OF fm_data-types,
      <tu> LIKE LINE OF fm_data-typeusages.
    LOOP AT fm_data-typeusages ASSIGNING <tu>
            WHERE clsname = obj_name.
      CLEAR _tg.
      _tg-hdr = <tu>.
      READ TABLE fm_data-clsdeferrds ASSIGNING <cd>
           WITH TABLE KEY clsname = <tu>-clsname
                        typegroup = <tu>-typegroup
                          version = <tu>-version.
      IF sy-subrc = 0.
        _tg-defered = <cd>.
      ENDIF.
      READ TABLE fm_data-intdeferrds ASSIGNING <id>
           WITH TABLE KEY clsname = <tu>-clsname
                        typegroup = <tu>-typegroup
                          version = <tu>-version.
      IF sy-subrc = 0.
        _tg-itf_def = <id>.
      ENDIF.
      CLEAR: _tg-clsname, _tg-defered-clsname, _tg-itf_def-clsname. " VERSION
      INSERT _tg INTO TABLE typegroups.
    ENDLOOP.
    LOOP AT fm_data-clsdeferrds ASSIGNING <cd>.
      _dc = <cd>.
      CLEAR: _dc-clsname.
      INSERT _dc INTO TABLE deferred-classes.
    ENDLOOP.
    LOOP AT fm_data-intdeferrds ASSIGNING <id>.
      _di = <id>.
      CLEAR: _di-clsname.
      INSERT _di INTO TABLE deferred-interfaces.
    ENDLOOP.
    IF obj_type = object_types-class. id = doc_ids-class-attribute. ELSE. id = doc_ids-interface-attribute. ENDIF.
    LOOP AT fm_data-attributes ASSIGNING <at>
      WHERE clsname = obj_name.
      CLEAR _at.
      _at-hdr = <at>.
      _at-_ = _at-typesrc. CLEAR _at-typesrc.                 " Issue 68
      REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>cr_lf IN _at-_ WITH cl_abap_char_utilities=>newline. " Issue 68
      _at-texts = fd_comp_desc( descriptions = fm_data-component_desc
                                          id = id
                               documentation = fm_data-documentation
                                   component = <at>-cmpname ).
      CLEAR: _at-clsname, _at-langu, _at-descript. " VERSION ?
      CLEAR: _at-srcrow1, _at-srccolumn1, _at-srcrow2, _at-srccolumn2, _at-typesrc_leng. " Issue 68
      INSERT _at INTO TABLE attributs.
    ENDLOOP.
    IF obj_type = object_types-class. id = doc_ids-class-method. ELSE. id = doc_ids-interface-method. ENDIF.
    LOOP AT fm_data-methods ASSIGNING <me>
            WHERE clsname = obj_name.
      CLEAR _me.
      _me-hdr = <me>.
      _me-texts = fd_comp_desc( descriptions = fm_data-component_desc
                                          id = id
                               documentation = fm_data-documentation
                                   component = <me>-cmpname ).
      _me-exceptions = fd_exceptions( fm_data = fm_data
                                    component = <me>-cmpname ).
      _me-parameters = fd_parameters( fm_data = fm_data
                                    component = <me>-cmpname ).
      CLEAR: _me-clsname, _me-langu, _me-descript. " VERSION
      INSERT _me INTO TABLE methods.
    ENDLOOP.
    IF obj_type = object_types-class. id = doc_ids-class-event. ELSE. id = doc_ids-interface-event. ENDIF.
    LOOP AT fm_data-events ASSIGNING <ev>
            WHERE clsname = obj_name.
      CLEAR _ev.
      _ev-hdr = <ev>.
      _ev-texts = fd_comp_desc( descriptions = fm_data-component_desc
                                          id = id
                               documentation = fm_data-documentation
                                   component = <ev>-cmpname ).
      _ev-parameters = fd_parameters( fm_data = fm_data
                                    component = <ev>-cmpname ).
      CLEAR: _ev-clsname, _ev-langu, _ev-descript. " VERSION
      INSERT _ev INTO TABLE events.
    ENDLOOP.
    IF obj_type = object_types-class. id = doc_ids-class-type. ELSE. id = doc_ids-interface-type. ENDIF.
    LOOP AT fm_data-types ASSIGNING <ty>
            WHERE clsname = obj_name.
      CLEAR _ty.
      _ty-hdr = <ty>.
      _ty-_ = _ty-typesrc. CLEAR _ty-typesrc.                 " Issue 68
      REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>cr_lf IN _ty-_ WITH cl_abap_char_utilities=>newline. " Issue 68
      _ty-texts = fd_comp_desc( descriptions = fm_data-component_desc
                                          id = id
                               documentation = fm_data-documentation
                                   component = <ty>-cmpname ).
      CLEAR: _ty-clsname, _ty-langu, _ty-descript. " VERSION
      CLEAR: _ty-srcrow1, _ty-srccolumn1, _ty-srcrow2, _ty-srccolumn2, _ty-typesrc_leng. " Issue 68
      INSERT _ty INTO TABLE types.
    ENDLOOP.
    LOOP AT fm_data-aliases ASSIGNING <al>
            WHERE clsname = obj_name.
      CLEAR _al.    _al-hdr = <al>.   CLEAR: _al-clsname. " VERSION
      INSERT _al INTO TABLE aliases.
    ENDLOOP.
  ENDMETHOD.
  METHOD td_comp_desc.
    DATA _t     LIKE LINE OF descriptions.
    DATA _d     LIKE LINE OF documentation.
    DATA _dt    LIKE LINE OF _d-texts.
    DATA s_key  TYPE ts_doc_key.
    FIELD-SYMBOLS:
      <t>   LIKE LINE OF texts.
    _d-application = 'DOKU'.
    _d-id = id.
    s_key-name = obj_name. s_key-other = component.
    _d-object = s_key.
    _d-langu = sy-langu.
    _d-masterlang = abap_true.
    _d-typ = 'E'.
    _d-dokform = 'S_DOCU_SHOW'.
    _d-dokstyle = 'S_DOCUS1'.
    LOOP AT texts ASSIGNING <t>.
      CLEAR _t.    _t-langu = <t>-lang.   _t-descript = <t>-text.    _t-clsname = obj_name.    _t-cmpname = component.
      INSERT _t INTO TABLE descriptions.
      CHECK NOT <t>-_ IS INITIAL.
      _dt-_ = <t>-_.    _dt-tdspras = <t>-lang.
      INSERT _dt INTO TABLE _d-texts.
    ENDLOOP.
    IF NOT _d-texts IS INITIAL. INSERT _d INTO TABLE documentation. ENDIF.
  ENDMETHOD.
  METHOD td_exceptions.
    DATA _ex  LIKE LINE OF fm_data-exceps.
    FIELD-SYMBOLS:
      <ex> LIKE LINE OF exception,
      <t>  LIKE LINE OF <ex>-texts.
    LOOP AT exception ASSIGNING <ex>.
      CLEAR: _ex.
      _ex = <ex>-hdr.
      CALL METHOD td_subc_desc
        EXPORTING
          sub_component = <ex>-sconame
          component     = component
          texts         = <ex>-texts
        CHANGING
          descriptions  = fm_data-subcomponent_desc.
      CLEAR: _ex-clsname, _ex-cmpname. " VERSION
      _ex-clsname = obj_name.   _ex-cmpname = component.    _ex-langu = obj_langu.
      READ TABLE <ex>-texts ASSIGNING <t>
           WITH TABLE KEY lang = _ex-langu.
      IF sy-subrc = 0.    _ex-descript = <t>-text.   ENDIF.
      INSERT _ex INTO TABLE fm_data-exceps.
    ENDLOOP.
  ENDMETHOD.
  METHOD td_parameters.
    DATA: _pa  LIKE LINE OF fm_data-parameters.
    FIELD-SYMBOLS:
      <pa> LIKE LINE OF parameters,
      <t>  LIKE LINE OF <pa>-texts.
    LOOP AT parameters ASSIGNING <pa>.
      CLEAR: _pa.
      _pa = <pa>-hdr.
      CALL METHOD td_subc_desc
        EXPORTING
          sub_component = <pa>-sconame
          component     = component
          texts         = <pa>-texts
        CHANGING
          descriptions  = fm_data-subcomponent_desc.
      _pa-clsname = obj_name.
      _pa-cmpname = component.
      _pa-langu = obj_langu.
      READ TABLE <pa>-texts ASSIGNING <t>
           WITH TABLE KEY lang = _pa-langu.
      IF sy-subrc = 0.    _pa-descript = <t>-text.   ENDIF.
      INSERT _pa INTO TABLE fm_data-parameters.
    ENDLOOP.
  ENDMETHOD.
  METHOD td_subc_desc.
    DATA _d   LIKE LINE OF descriptions.
    FIELD-SYMBOLS <t> LIKE LINE OF texts.
    LOOP AT texts ASSIGNING <t>.
      _d-clsname = obj_name.    _d-cmpname = component.   _d-sconame = sub_component.
      _d-langu = <t>-lang.     _d-descript = <t>-text.
      INSERT _d INTO TABLE descriptions.
    ENDLOOP.
  ENDMETHOD.
  METHOD td_text.
    DATA _d   LIKE LINE OF documentation.
    DATA _dt  LIKE LINE OF _d-texts.
    DATA _ct  LIKE LINE OF descriptions.
    FIELD-SYMBOLS:
      <t>   LIKE LINE OF texts.
    _d-application = 'DOKU'.
    _d-id = id.
    _d-object = classname.
    _d-langu = sy-langu.
    _d-masterlang = abap_true.
    _d-typ = 'E'.
    _d-dokform = 'S_DOCU_SHOW'.
    _d-dokstyle = 'S_DOCUS1'.
    LOOP AT texts ASSIGNING <t>.
      CLEAR _ct.    _ct-langu = <t>-lang.   _ct-descript = <t>-text.    _ct-clsname = classname.
      INSERT _ct INTO TABLE descriptions.
      CHECK NOT <t>-_ IS INITIAL.
      _dt-_ = <t>-_.    _dt-tdspras = <t>-lang.
      INSERT _dt INTO TABLE _d-texts.
    ENDLOOP.
    IF NOT _d-texts IS INITIAL. INSERT _d INTO TABLE documentation. ENDIF.
  ENDMETHOD.
  METHOD to_data.
    DATA _id  LIKE LINE OF fm_data-impl_details.
    DATA _at  LIKE LINE OF fm_data-attributes.
    DATA _ty  LIKE LINE OF fm_data-types.
    DATA _tg  LIKE LINE OF fm_data-typeusages.
    DATA _me  LIKE LINE OF fm_data-methods.
    DATA _al  LIKE LINE OF fm_data-aliases.
    DATA _ev  LIKE LINE OF fm_data-events.
    DATA _ms  LIKE LINE OF fm_data-method_sources.
    DATA _dc  LIKE LINE OF fm_data-clsdeferrds.
    DATA _di  LIKE LINE OF deferred-interfaces.
    DATA tmp_me LIKE LINE OF methods.
    DATA id   TYPE doku_id.
    FIELD-SYMBOLS:
      <at> LIKE LINE OF attributs,
      <al> LIKE LINE OF aliases,
      <me> LIKE LINE OF methods,
      <ev> LIKE LINE OF events,
      <ct> LIKE LINE OF <at>-texts,
      <dc> LIKE LINE OF deferred-classes,
      <di> LIKE LINE OF deferred-interfaces,
      <ty> LIKE LINE OF types,
      <tu> LIKE LINE OF typegroups.
    APPEND LINES OF documentation TO fm_data-documentation.
    LOOP AT typegroups ASSIGNING <tu>.
      CLEAR _tg.
      _tg = <tu>-hdr.
      IF NOT <tu>-defered IS INITIAL.
        <tu>-defered-clsname = <tu>-clsname.
        <tu>-defered-typegroup = <tu>-typegroup.
        <tu>-defered-version = <tu>-version.
        APPEND <tu>-defered TO fm_data-clsdeferrds.
      ENDIF.
      IF NOT <tu>-itf_def IS INITIAL.
        <tu>-itf_def-clsname = <tu>-clsname.
        <tu>-itf_def-typegroup = <tu>-typegroup.
        <tu>-itf_def-version = <tu>-version.
        APPEND <tu>-itf_def TO fm_data-intdeferrds.
      ENDIF.
      _tg-clsname = obj_name.
      INSERT _tg INTO TABLE fm_data-typeusages.
    ENDLOOP.
    LOOP AT deferred-classes ASSIGNING <dc>.
      CLEAR _dc. _dc = <dc>.
      _dc-clsname = obj_name..
      INSERT _dc INTO TABLE fm_data-clsdeferrds.
    ENDLOOP.
    LOOP AT deferred-interfaces ASSIGNING <di>.
      CLEAR _di. _di = <di>.
      _di-clsname = obj_name.
      INSERT _di INTO TABLE fm_data-intdeferrds.
    ENDLOOP.
    IF obj_type = object_types-class. id = doc_ids-class-attribute. ELSE. id = doc_ids-interface-attribute. ENDIF.
    LOOP AT attributs ASSIGNING <at>.
      CLEAR _at.
      _at = <at>-hdr.
      _at-typesrc = <at>-_.                                   " Issue 68
      REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>newline IN _at-typesrc WITH cl_abap_char_utilities=>cr_lf.
      CALL METHOD td_comp_desc
        EXPORTING
          component     = <at>-cmpname
          texts         = <at>-texts
          id            = id
        CHANGING
          documentation = fm_data-documentation
          descriptions  = fm_data-component_desc.
      _at-clsname = obj_name.
      _at-langu = obj_langu.
      READ TABLE <at>-texts ASSIGNING <ct>
           WITH TABLE KEY lang = _at-langu.
      IF sy-subrc = 0.    _at-descript = <ct>-text.      ENDIF.
      INSERT _at INTO TABLE fm_data-attributes.
    ENDLOOP.
    IF obj_type = object_types-class. id = doc_ids-class-method. ELSE. id = doc_ids-interface-method. ENDIF.
    LOOP AT methods ASSIGNING <me>.
      CLEAR: _me, _ms.
      _me = <me>-hdr.
      CALL METHOD td_comp_desc
        EXPORTING
          component     = <me>-cmpname
          texts         = <me>-texts
          id            = id
        CHANGING
          documentation = fm_data-documentation
          descriptions  = fm_data-component_desc.
      CALL METHOD td_parameters
        EXPORTING
          component  = <me>-cmpname
          parameters = <me>-parameters
        CHANGING
          fm_data    = fm_data.
      CALL METHOD td_exceptions
        EXPORTING
          component = <me>-cmpname
          exception = <me>-exceptions
        CHANGING
          fm_data   = fm_data.
      tmp_me = <me>.
      CLEAR: tmp_me-cmpname, tmp_me-source.
      IF tmp_me IS INITIAL.
        CONTINUE.  " Interface implementation
      ENDIF.
      _ms-cpdname = <me>-cmpname.
      _ms-source = zaplink_object=>conv_abap_source2raw( <me>-source-_ ).
      APPEND _ms TO fm_data-method_sources.
      _me-clsname = obj_name.
      _me-langu = obj_langu.
      READ TABLE <me>-texts ASSIGNING <ct>
           WITH TABLE KEY lang = _me-langu.
      IF sy-subrc = 0.    _me-descript = <ct>-text.      ENDIF.
      INSERT _me INTO TABLE fm_data-methods.
    ENDLOOP.
    IF obj_type = object_types-class. id = doc_ids-class-event. ELSE. id = doc_ids-interface-event. ENDIF.
    LOOP AT events ASSIGNING <ev>.
      CLEAR _ev.
      _ev = <ev>-hdr.
      CALL METHOD td_comp_desc
        EXPORTING
          component     = <ev>-cmpname
          texts         = <ev>-texts
          id            = id
        CHANGING
          documentation = fm_data-documentation
          descriptions  = fm_data-component_desc.
      CALL METHOD td_parameters
        EXPORTING
          component  = <ev>-cmpname
          parameters = <ev>-parameters
        CHANGING
          fm_data    = fm_data.
      _ev-clsname = obj_name.
      _ev-langu = obj_langu.
      READ TABLE <ev>-texts ASSIGNING <ct>
           WITH TABLE KEY lang = _ev-langu.
      IF sy-subrc = 0.    _ev-descript = <ct>-text.      ENDIF.
      INSERT _ev INTO TABLE fm_data-events.
    ENDLOOP.
    IF obj_type = object_types-class. id = doc_ids-class-type. ELSE. id = doc_ids-interface-type. ENDIF.
    LOOP AT types ASSIGNING <ty>.
      CLEAR _ty.
      _ty = <ty>-hdr.
      _ty-typesrc = <ty>-_.                                   " Issue 68
      REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>newline IN _ty-typesrc WITH cl_abap_char_utilities=>cr_lf.
      CALL METHOD me->td_comp_desc
        EXPORTING
          component     = <ty>-cmpname
          texts         = <ty>-texts
          id            = id
        CHANGING
          documentation = fm_data-documentation
          descriptions  = fm_data-component_desc.
      _ty-clsname = obj_name.
      _ty-langu = obj_langu.
      READ TABLE <ty>-texts ASSIGNING <ct>
           WITH TABLE KEY lang = _ty-langu.
      IF sy-subrc = 0.    _ty-descript = <ct>-text.      ENDIF.
      INSERT _ty INTO TABLE fm_data-types.
    ENDLOOP.
    LOOP AT aliases ASSIGNING <al>.
      CLEAR _al.
      _al = <al>-hdr.
      _al-clsname = obj_name.
      INSERT _al INTO TABLE fm_data-aliases.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_OBJECT_DATA implementation
CLASS zaplink_options IMPLEMENTATION.
  METHOD constructor.
    CREATE OBJECT directory.
    CREATE OBJECT devclass.
  ENDMETHOD.
  METHOD get_directory.
    result = directory.
  ENDMETHOD.
  METHOD set_directory.
    CHECK data <> directory.
    directory = data.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_OPTIONS implementation
CLASS zaplink_opt_directory IMPLEMENTATION.
  METHOD constructor.
    CREATE OBJECT _devclass.
    CREATE OBJECT _tr.
    mac_create_log application_log ballog_subobject space.
  ENDMETHOD.
  METHOD get_devclass.
    result = _devclass.
  ENDMETHOD.
  METHOD get_transport_request.
    result = _tr.
  ENDMETHOD.
  METHOD set_devclass.
    CHECK data <> _devclass.
    _devclass = data.
  ENDMETHOD.
  METHOD set_directory.
    DATA _name        TYPE trobj_name.    " tadir-obj_name.
    DATA d_tdname     TYPE tadir-obj_name.
    DATA _type        TYPE tadir-object.
    DATA _pgmid       TYPE tadir-pgmid.
    DATA _act_devc    TYPE tadir-devclass.
    DATA _exists      TYPE saus_dpara-tadirexist.
    DATA f_global     TYPE abap_bool.                         " Issue 87
    DATA s_e071       TYPE e071.
    DATA s_parent_key TYPE tadir.
    DATA f_hide_dia   TYPE abap_bool.
    CHECK component IS BOUND.
    result = component->directory.
    TRY.
        _type = component->get_type( ).
        d_tdname = _name = component->get_name( ).
        _pgmid = component->get_typekind( ).                    " Issue 87
        IF _pgmid = 'R3TR'.   f_global = abap_true.   ELSEIF _pgmid = 'LIMU'.   f_global = abap_false.    ELSE.   EXIT.   ENDIF.    " Form DETERMINE_LOCK_KEY(LSEUQF01) 125
        IF me->_devclass IS BOUND.
          TRY.
              result-devclass = me->_devclass->substitute( component ).
            CATCH zaplink_cx_options INTO o_mycx.
              RAISE EXCEPTION o_mycx.
          ENDTRY.
        ENDIF.
        IF me->_tr IS BOUND.
          TRY.
              result-trkorr = _tr->substitute( component ).
            CATCH zaplink_cx_options INTO o_mycx.
              RAISE EXCEPTION o_mycx.
          ENDTRY.
        ENDIF.
        IF _pgmid = 'LIMU'.
          s_e071-pgmid = _pgmid.
          s_e071-object = _type.
          s_e071-obj_name = _name.
          CALL FUNCTION 'TR_CHECK_TYPE'
            EXPORTING
              wi_e071  = s_e071
            IMPORTING
              we_tadir = s_parent_key.
          IF s_parent_key-pgmid = 'R3TR'.     " Check parent's devclass
            CALL FUNCTION 'TRINT_TADIR_QUERY'
              EXPORTING
                iv_pgmid    = s_parent_key-pgmid
                iv_object   = s_parent_key-object
                iv_obj_name = s_parent_key-obj_name
              IMPORTING
                ev_devclass = _act_devc
                ev_exist    = _exists.
            IF NOT _exists IS INITIAL.
              result-devclass = _act_devc.    " Never change devclass of parent because of child devclass
            ENDIF.
          ENDIF.
        ELSE.
          s_parent_key-pgmid = _pgmid.
          s_parent_key-object = _type.
          s_parent_key-obj_name = d_tdname.
          CALL FUNCTION 'TRINT_TADIR_QUERY'
            EXPORTING
              iv_pgmid    = s_parent_key-pgmid
              iv_object   = s_parent_key-object
              iv_obj_name = s_parent_key-obj_name
            IMPORTING
              ev_devclass = _act_devc
              ev_exist    = _exists.
          IF _exists IS INITIAL.
            CALL FUNCTION 'TRINT_TADIR_INSERT'
              EXPORTING
                devclass             = result-devclass
                object               = _type
                obj_name             = d_tdname
                pgmid                = _pgmid
              EXCEPTIONS
                object_exists_global = 1
                object_exists_local  = 2
                OTHERS               = 3.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise_class 'ZAPLINK_CX_OPT_DEVCLASS' 'TRINT_TADIR_INSERT' sy-subrc.
            ENDIF.
          ELSEIF _act_devc <> result-devclass.
            CALL FUNCTION 'TRINT_TADIR_MODIFY'
              EXPORTING
                devclass             = result-devclass
                object               = _type
                obj_name             = d_tdname
                pgmid                = _pgmid
              EXCEPTIONS
                object_exists_global = 1
                object_exists_local  = 2
                object_has_no_tadir  = 3
                OTHERS               = 4.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise_class 'ZAPLINK_CX_OPT_DEVCLASS' 'TRINT_TADIR_MODIFY' sy-subrc.
            ENDIF.
          ENDIF.
        ENDIF.
        IF NOT result-trkorr IS INITIAL.    f_hide_dia = abap_true.   ENDIF.
        CALL FUNCTION 'RS_CORR_INSERT'
          EXPORTING
            object              = _name
            object_class        = _type
            mode                = 'I'        " Insert
            global_lock         = f_global   " R3TR or LIMU
            devclass            = result-devclass
            korrnum             = result-trkorr
            suppress_dialog     = f_hide_dia
          IMPORTING
            korrnum             = result-trkorr
          EXCEPTIONS
            cancelled           = 1
            permission_failure  = 2
            unknown_objectclass = 3
            OTHERS              = 4.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise_class 'ZAPLINK_CX_OPT_DEVCLASS' 'RS_CORR_INSERT' sy-subrc.
        ENDIF.
        mac_def_catch zaplink_cx_options.
    ENDTRY.
  ENDMETHOD.
  METHOD set_transport_request.
    CHECK data <> _tr.
    _tr = data.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_OPT_DIRECTORY implementation
CLASS zaplink_prog_data IMPLEMENTATION.
  METHOD anonymize.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF texts,
      <v> LIKE LINE OF variants.
    CLEAR: a0_maindata-cnam, a0_maindata-cdat, a0_maindata-unam, a0_maindata-udat, a0_maindata-sdate, a0_maindata-stime, a0_maindata-idate,
           a0_maindata-itime, a0_maindata-vern, a0_maindata-state. " Issue 68.
    LOOP AT variants ASSIGNING <v>.
      <v>-zl_object->anonymize( ).
    ENDLOOP.
    LOOP AT texts ASSIGNING <t>.
      CLEAR: <t>-long_txt-tdlreles, <t>-long_txt-tdfreles.
    ENDLOOP.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids-prog.
    _id-sign = 'I'.   _id-option = 'EQ'.
    _id-low = doc_ids-prog.      APPEND _id TO r_doc_ids-prog.
  ENDMETHOD.
  METHOD from_data.
    DATA s_txt     LIKE LINE OF texts.
    DATA t_docs    TYPE tt_docs.
    DATA s_variant LIKE LINE OF variants.
    FIELD-SYMBOLS:
      <v>  LIKE LINE OF fm_data-variants,
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <t>  LIKE LINE OF fm_data-texts.
    a0_maindata = fm_data-header.
    textspool = fm_data-textspool.
    source-_ = fm_data-source.
    dynpros = fm_data-dynpros.
    menupainter = fm_data-menupainter.
    t_docs = fm_data-docs.
    READ TABLE t_docs ASSIGNING <d>
         WITH KEY id = doc_ids-prog
              object = a0_maindata-name.
    LOOP AT fm_data-texts ASSIGNING <t>.
      CLEAR s_txt.    s_txt-langu = <t>-sprsl.   s_txt-short_txt = <t>-text.
      IF <d> IS ASSIGNED.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_txt-langu.
        IF sy-subrc = 0.    s_txt-long_txt = <dt>.   CLEAR s_txt-long_txt-tdspras.    DELETE TABLE <d>-texts FROM <dt>.    ENDIF.
      ENDIF.
      INSERT s_txt INTO TABLE texts.
    ENDLOOP.
    IF <d> IS ASSIGNED.
      LOOP AT <d>-texts ASSIGNING <dt>.
        CLEAR s_txt.    s_txt-langu = <dt>-tdspras.   s_txt-long_txt = <dt>.   CLEAR s_txt-long_txt-tdspras.    INSERT s_txt INTO TABLE texts.
      ENDLOOP.
    ENDIF.
    LOOP AT fm_data-variants ASSIGNING <v>.
      CREATE OBJECT s_variant-zl_object EXPORTING fm_data = <v>.
      APPEND s_variant TO variants.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_txt     LIKE LINE OF fm_data-texts.
    DATA s_doc     LIKE LINE OF fm_data-docs.
    DATA s_doc_txt LIKE LINE OF s_doc-texts.
    DATA s_variant LIKE LINE OF fm_data-variants.
    DATA d_variant TYPE zaplink_vari_data=>ts_variant_key.
    FIELD-SYMBOLS:
      <v> LIKE LINE OF variants,
      <t> LIKE LINE OF texts.
    fm_data-header = a0_maindata.
    fm_data-textspool = textspool.
    fm_data-source = source-_.
    fm_data-dynpros = dynpros.
    fm_data-menupainter = menupainter.
    s_doc-application = 'DOKU'.   s_doc-id = doc_ids-prog.   s_doc-object = a0_maindata-name.
    s_doc-masterlang = abap_true.   s_doc-typ = 'E'.    s_doc-dokform = 'S_DOCU_SHOW'.    s_doc-dokstyle = 'S_DOCUS1'.
    LOOP AT texts ASSIGNING <t>.
      IF NOT <t>-short_txt IS INITIAL.    CLEAR s_txt.    s_txt-sprsl = <t>-langu.   s_txt-text = <t>-short_txt.   INSERT s_txt INTO TABLE fm_data-texts.    ENDIF.
      IF NOT <t>-long_txt IS INITIAL.
        CLEAR s_doc_txt.    s_doc_txt = <t>-long_txt.   s_doc_txt-tdspras = <t>-langu.    INSERT s_doc_txt INTO TABLE s_doc-texts.
        IF s_doc-langu IS INITIAL.    s_doc-langu = s_doc_txt-tdspras.    ENDIF.
      ENDIF.
    ENDLOOP.
    IF NOT s_doc-texts IS INITIAL.    INSERT s_doc INTO TABLE fm_data-docs.   ENDIF.
    LOOP AT variants ASSIGNING <v>.
      d_variant = zaplink_vari_data=>name_2_key( <v>-zl_object->name ).
      d_variant-program = fm_data-header-name.
      <v>-zl_object->name = zaplink_vari_data=>key_2_name( d_variant ).
      s_variant = <v>-zl_object->to_data( ).
      APPEND s_variant TO fm_data-variants.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
    FIELD-SYMBOLS <v> LIKE LINE OF variants.
    a0_maindata-cnam = sy-uname.
    LOOP AT variants ASSIGNING <v>.
      <v>-zl_object->unanonymize( ).
    ENDLOOP.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_PROG_DATA implementation
CLASS zaplink_raw_base IMPLEMENTATION.
  METHOD anonymize.
    CLEAR:
      me->directory-korrnum,
      me->directory-srcsystem,
      me->directory-author,
      me->directory-trkorr.
    set_checksum( ).
  ENDMETHOD.
  METHOD class_constructor.
    xmlengine = cl_ixml=>create( ).
  ENDMETHOD.
  METHOD constructor.
    TRY.
        IF o_comp IS BOUND.
          set_component( o_comp ).
        ENDIF.
      CATCH zaplink_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD conv_to_xml.
    DATA ez_xml          TYPE to_ez_xml.
    DATA o_xml           TYPE to_xml.
    CREATE OBJECT ez_xml.
    CLEAR checksum.  " Issue 21 : clear previous checksum
    o_xml = ez_xml->any2xml( any       = me
                             type      = comp_nodename ).
    result = o_xml.
  ENDMETHOD.
  METHOD get_checksum.
    result = checksum.
  ENDMETHOD.
  METHOD get_code_signature.
    result = code_signature.
  ENDMETHOD.
  METHOD get_component.
    TRY.
        CREATE OBJECT o_comp.
        o_comp->set_type( type ).
        o_comp->set_name( name ).
        o_comp->set_devclass( directory-devclass ).
        o_comp->set_checksum( checksum ).
        o_comp->set_code_signature( code_signature ).
        TRY.
            o_comp->set_connuuid( connector ).
          CATCH zaplink_cx INTO o_cx.
            IF o_cx->is_exception_text( zaplink_cx_connector=>invalid_uuid ) IS INITIAL.     RAISE EXCEPTION o_cx.    ENDIF.
        ENDTRY.
      CATCH zaplink_cx INTO o_cx.
        IF without_cx IS INITIAL.  RAISE EXCEPTION o_cx.    ENDIF.
    ENDTRY.
  ENDMETHOD.
  METHOD get_name.
    result = name.
  ENDMETHOD.
  METHOD get_type.
    result = type.
  ENDMETHOD.
  METHOD get_typekind.
    CHECK NOT type IS INITIAL.
    result = zaplink_connectors=>get_typekind( type ).      " Issue 87
  ENDMETHOD.
  METHOD refresh_directory.
    DATA d_kind  TYPE td_transport_kind.
    d_kind = zaplink_connectors=>get_typekind( type ).
    SELECT SINGLE *
      INTO CORRESPONDING FIELDS OF directory
      FROM tadir
      WHERE pgmid = d_kind
        AND object = type
        AND obj_name = name.
    IF type = 'DEVC'. CLEAR directory-devclass. ENDIF.
  ENDMETHOD.
  METHOD set_checksum.
    DATA o_xml           TYPE to_xml.
    DATA _tempstring     TYPE string.
    DATA _len            TYPE i.
    DATA _key            TYPE string.
    o_xml = conv_to_xml( ).
    ASSERT o_xml IS BOUND.
    _tempstring = xml_2_string( o_xml ).
    REPLACE FIRST OCCURRENCE OF REGEX '<\?.*\?>' IN _tempstring WITH ``.
    checksum = zaplink_tools=>calculate_md5_hash( _tempstring ).
    CONCATENATE type '/' name INTO _key.
  ENDMETHOD.
  METHOD set_component.
    CHECK o_comp IS BOUND.
    TRY.
        type = o_comp->get_type( ).
        name = o_comp->get_name( ).
        connector = o_comp->get_connuuid( ).
        refresh_directory( ).
        mac_def_catch zaplink_cx_container.
    ENDTRY.
  ENDMETHOD.
  METHOD unanonymize.
    IF me->directory-srcsystem IS INITIAL. me->directory-srcsystem = sy-sysid. ENDIF.
    IF me->directory-author IS INITIAL. me->directory-author = sy-uname. ENDIF.
  ENDMETHOD.
  METHOD update_connector_data.
    me->connector = o_connector->uuid.
    me->version = o_connector->version.
  ENDMETHOD.
  METHOD xml_2_string.
    DATA _streamfactory  TYPE REF TO if_ixml_stream_factory.
    DATA _outputstream   TYPE REF TO if_ixml_ostream.
    DATA _renderer       TYPE REF TO if_ixml_renderer.
    DATA _tempstring     TYPE string.
    DATA _printxmldoc    TYPE REF TO cl_xml_document.
    DATA _rc             TYPE sysubrc.
    CHECK o_xml IS BOUND.
    _streamfactory = xmlengine->create_stream_factory( ).
    _outputstream = _streamfactory->create_ostream_cstring( _tempstring ).
    _renderer = xmlengine->create_renderer( document = o_xml
                                             ostream = _outputstream ).
    _renderer->set_normalizing( ).
    _rc = _renderer->render( ).
    CREATE OBJECT _printxmldoc.
    _rc = _printxmldoc->parse_string( _tempstring ).
    WHILE _tempstring(1) <> '<'.
      SHIFT _tempstring LEFT BY 1 PLACES.
    ENDWHILE.
    result = _tempstring.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_RAW_BASE implementation
CLASS zaplink_tabu_data IMPLEMENTATION.
  METHOD from_data.
    DATA d_name     TYPE ddobjname.
    DATA t_fields   TYPE STANDARD TABLE OF dd03p.
    DATA s_line     TYPE REF TO data.
    FIELD-SYMBOLS:
      <f> LIKE LINE OF t_fields,
      <s> TYPE any,
      <m> TYPE any,
      <t> TYPE STANDARD TABLE.
    CREATE DATA content TYPE STANDARD TABLE OF (table).
    ASSERT sy-subrc = 0.
    ASSIGN content->* TO <t>.
    ASSERT sy-subrc = 0.
    SELECT *
      INTO TABLE <t>
      FROM (table).
    ASSERT sy-subrc = 0.
    CHECK <t> IS NOT INITIAL.
    d_name = table.
    CALL FUNCTION 'DDIF_TABL_GET'
      EXPORTING
        name          = d_name
        state         = 'M'
      TABLES
        dd03p_tab     = t_fields
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    CREATE DATA s_line TYPE (table).
    ASSERT sy-subrc = 0.
    ASSIGN s_line->* TO <s>.
    ASSERT sy-subrc = 0.
    LOOP AT t_fields ASSIGNING <f>
            WHERE datatype = 'CLNT'
              AND keyflag = abap_true.
      LOOP AT <t> ASSIGNING <s>.
        ASSIGN COMPONENT <f>-fieldname OF STRUCTURE <s> TO <m>.
        ASSERT sy-subrc = 0.
        CLEAR <m>.
      ENDLOOP.
      EXIT.   " expect only one : Second one might be application value
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_TABU_DATA implementation
CLASS zaplink_xinx_data IMPLEMENTATION.
  METHOD anonymize.
    CLEAR: a0_maindata-as4user, a0_maindata-as4date, a0_maindata-as4time.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = doc_ids-header. APPEND _id TO r_doc_ids.
  ENDMETHOD.
  METHOD from_data.
    DATA s_text  LIKE LINE OF texts.
    DATA s_field LIKE LINE OF fields.
    DATA d_str   TYPE string.
    DATA s_key   TYPE ts_idx_key.
    FIELD-SYMBOLS:
      <f>  LIKE LINE OF fm_data-fields,
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <t>  LIKE LINE OF fm_data-texts.
    a0_maindata = fm_data-header.
    s_key-table = a0_maindata-sqltab.   s_key-index = a0_maindata-indexname.
    CLEAR: a0_maindata-sqltab, a0_maindata-indexname.
    LOOP AT fm_data-texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-langu = <t>-ddlanguage.
      s_text-short_txt = <t>-ddtext.
      READ TABLE fm_data-docs ASSIGNING <d>
           WITH KEY id = doc_ids-header
                object = s_key.
      IF sy-subrc = 0.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_text-langu.
        IF sy-subrc = 0.
          s_text-long_txt = <dt>.
          CLEAR s_text-long_txt-tdspras.
        ENDIF.
      ENDIF.
      INSERT s_text INTO TABLE texts.
    ENDLOOP.
    LOOP AT fm_data-fields ASSIGNING <f>
            WHERE sqltab = s_key-table
           AND indexname = s_key-index.
      CLEAR s_field.    s_field = <f>.       CLEAR: s_field-sqltab, s_field-indexname.
      INSERT s_field INTO TABLE fields.
    ENDLOOP.
  ENDMETHOD.
  METHOD key_2_name.
    DATA d_obj_name TYPE  e071-obj_name.
    CALL FUNCTION 'DD_DD_TO_E071'
      EXPORTING
        type          = zaplink_dictionary=>supportedtypes-ext_index
        name          = data-table
        id            = data-index
      IMPORTING
        obj_name      = d_obj_name
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc <> 0.
      mac_raise_mf 'DD_DD_TO_E071' sy-subrc.
    ELSE.
      result = d_obj_name.
    ENDIF.
  ENDMETHOD.
  METHOD name_2_key.
    DATA d_obj_name TYPE  e071-obj_name.
    d_obj_name = data.
    CALL FUNCTION 'DD_E071_TO_DD'
      EXPORTING
        object        = zaplink_dictionary=>supportedtypes-ext_index
        obj_name      = d_obj_name
      IMPORTING
        name          = result-table
        id            = result-index
      EXCEPTIONS
        illegal_input = 1
        OTHERS        = 2.
    IF sy-subrc <> 0.
      mac_raise_mf 'DD_DD_TO_E071' sy-subrc.
    ENDIF.
  ENDMETHOD.
  METHOD to_data.
    DATA s_text  LIKE LINE OF fm_data-texts.
    DATA s_field LIKE LINE OF fm_data-fields.
    DATA s_doc   LIKE LINE OF fm_data-docs.
    DATA s_key   TYPE ts_idx_key.
    FIELD-SYMBOLS:
      <f> LIKE LINE OF fields,
      <d> LIKE LINE OF fm_data-docs,
      <t> LIKE LINE OF texts.
    DATA s_dtxt LIKE LINE OF <d>-texts.
    fm_data-header = a0_maindata.
    s_key-table = a0_maindata-sqltab.   s_key-index = a0_maindata-indexname.
    LOOP AT texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-sqltab = fm_data-header-sqltab.
      s_text-indexname = fm_data-header-indexname.
      s_text-ddlanguage = <t>-langu.
      s_text-as4local = 'A'. " Active
      s_text-as4vers = '0000'. " Active
      s_text-ddtext = <t>-short_txt.
      INSERT s_text INTO TABLE fm_data-texts.
      IF NOT <t>-long_txt IS INITIAL.
        IF fm_data-docs IS INITIAL.
          s_doc-application = 'DOKU'.
          s_doc-id = doc_ids-header.
          s_doc-object = s_key.
          s_doc-langu = <t>-langu.
          s_doc-masterlang = abap_true.
          s_doc-typ = 'E'.
          s_doc-dokform = 'S_DOCU_SHOW'.
          s_doc-dokstyle = 'S_DOCUS1'.
          INSERT s_doc INTO TABLE fm_data-docs.
        ENDIF.
        READ TABLE fm_data-docs ASSIGNING <d> INDEX 1.
        s_dtxt = <t>-long_txt.
        s_dtxt-tdspras = <t>-langu.
        INSERT s_dtxt INTO TABLE <d>-texts.
      ENDIF.
    ENDLOOP.
    LOOP AT fields ASSIGNING <f>.
      CLEAR s_field.      s_field = <f>.      s_field-sqltab = s_key-table.   s_field-indexname = s_key-index.
      INSERT s_field INTO TABLE fm_data-fields.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_XINX_DATA implementation
CLASS zaplink_connector_ IMPLEMENTATION.
  METHOD active_component.
    DATA d_is_work_i    TYPE abap_bool.
    DATA d_is_inactiv   TYPE abap_bool.
    DATA d_obj_name     TYPE e071-obj_name.
    DATA d_type         TYPE e071-object.
    DATA t_comps      TYPE zaplink_list=>tt_compkeys.
    DATA s_comp       LIKE LINE OF t_comps.
    result = abap_false.
    s_comp-name = d_obj_name = name.
    s_comp-type = d_type = type.
    CALL FUNCTION 'RS_OBJECT_IN_WORKING_AREA'
      EXPORTING
        object                  = d_type
        obj_name                = d_obj_name
      IMPORTING
        object_is_work_item     = d_is_work_i     " My inactive object
        object_inactive_version = d_is_inactiv.
    IF NOT d_is_work_i IS INITIAL OR NOT d_is_inactiv IS INITIAL.
      IF NOT o_activate IS BOUND.
        CREATE OBJECT o_activate.
      ELSE.
        o_activate->reset( ).
      ENDIF.
      APPEND s_comp TO t_comps.
      o_activate->add_keys( t_comps ).
      t_comps = o_activate->activate( ).
      result = abap_true.
      IF NOT t_comps IS INITIAL.      CLEAR result.     ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD check_component_list.
    DATA o_comp         TYPE to_component.
    o_comp = object->get_component( abap_true ).
    IF NOT components IS BOUND.   CREATE OBJECT components.   ENDIF.
    TRY.
        components->add( o_comp ).
      CATCH zaplink_cx_list.
    ENDTRY.
  ENDMETHOD.
  METHOD class_constructor.
    DATA s_type LIKE LINE OF r_text_fields.
    s_type-sign = 'I'. s_type-option = 'EQ'.
    s_type-low = rpyty_dynp_ftype-text.       APPEND s_type TO r_text_fields.
    s_type-low = rpyty_dynp_ftype-frame.      APPEND s_type TO r_text_fields.
    s_type-low = rpyty_dynp_ftype-push.       APPEND s_type TO r_text_fields.
  ENDMETHOD.
  METHOD constructor.
    class_name = zaplink_tools=>get_clas_name( me ).
  ENDMETHOD.
  METHOD conv_abapsource2flowlogic.
    SPLIT source AT line_separator INTO TABLE result.
    IF NOT result IS INITIAL.       " remove first line separator
      IF source(1) = line_separator.
        DELETE result INDEX 1.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD conv_abap_raw2source.
    FIELD-SYMBOLS <c> LIKE LINE OF raw.
    LOOP AT raw ASSIGNING <c>.
      CONCATENATE result <c> INTO result SEPARATED BY line_separator. " will start with line_sep better for XML display and required because get_value remove spaces
    ENDLOOP.
  ENDMETHOD.
  METHOD conv_abap_source2raw.
    SPLIT source AT line_separator INTO TABLE result.
    IF NOT result IS INITIAL.       " remove first line separator
      IF source(1) = line_separator.
        DELETE result INDEX 1.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD conv_flowlogic2abapsource.
    FIELD-SYMBOLS:
      <c> LIKE LINE OF raw.
    LOOP AT raw ASSIGNING <c>.
      CONCATENATE result <c> INTO result SEPARATED BY line_separator. " will start with line_sep better for XML display and required because get_value remove spaces
    ENDLOOP.
  ENDMETHOD.
  METHOD fusion_textpool.
    FIELD-SYMBOLS:
      <c>  LIKE LINE OF completion,
      <ct> LIKE LINE OF <c>-texts,
      <t>  LIKE LINE OF source.
    result = source.
    LOOP AT result ASSIGNING <t>.
      READ TABLE completion ASSIGNING <c>
           WITH TABLE KEY id = <t>-id
                         key = <t>-key.
      CHECK sy-subrc = 0.
      LOOP AT <c>-texts ASSIGNING <ct>.
        READ TABLE <t>-texts TRANSPORTING NO FIELDS
             WITH TABLE KEY langu = <ct>-langu.
        CHECK sy-subrc <> 0.
        INSERT <ct> INTO TABLE <t>-texts.
      ENDLOOP.
    ENDLOOP.
    LOOP AT completion ASSIGNING <c>.
      READ TABLE result ASSIGNING <t>
           WITH TABLE KEY id = <c>-id
                         key = <c>-key.
      CHECK sy-subrc <> 0.
      INSERT <c> INTO TABLE result.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_dynpros.
    SET EXTENDED CHECK OFF.
    INCLUDE mseusbit. " for c_type_dynp_select_norm, c_type_dynp_select_mod, c_type_dynp_select_incl
    SET EXTENDED CHECK ON.
    TYPES:
      BEGIN OF t_dynpro,
        prog TYPE d020s-prog,
        dnum TYPE d020s-dnum,
      END OF t_dynpro.
    DATA t_dynpros TYPE SORTED TABLE OF t_dynpro WITH UNIQUE KEY dnum.
    DATA header TYPE d020s.
    DATA t_d021t TYPE SORTED TABLE OF d021t WITH UNIQUE KEY dynr fldn lang.
    DATA t_container TYPE dycatt_tab.
    DATA t_fields    TYPE dyfatc_tab.
    DATA t_flowlogic TYPE tt_flow_logic.
    DATA s_result LIKE LINE OF result.
    DATA s_cont   LIKE LINE OF s_result-containers.
    FIELD-SYMBOLS:
      <c> LIKE LINE OF t_container,
      <f> LIKE LINE OF t_fields,
      <t> LIKE LINE OF t_d021t,
      <r> LIKE LINE OF t_dynpros.
    DATA s_field  LIKE LINE OF s_cont-fields.
    DATA s_text   LIKE LINE OF s_field-texts.
    DATA f_clear  TYPE abap_bool.
    SELECT prog dnum INTO TABLE t_dynpros
      FROM d020s
      WHERE prog = program
        AND type NOT IN (c_type_dynp_select_norm, c_type_dynp_select_mod, c_type_dynp_select_incl).
    SELECT *
      INTO TABLE t_d021t
      FROM d021t
      WHERE prog = program
        AND dtxt <> space.
    LOOP AT t_dynpros ASSIGNING <r>.
      CLEAR s_result.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE i500 WITH space space. ENDIF.
      SET EXTENDED CHECK ON.
      application_log->add_info( id_msgid = 'ZAPLINK'
                                 id_msgno = '500'
                                 id_msgv1 = <r>-prog
                                 id_msgv2 = <r>-dnum ).
      SELECT lang dtxt
        INTO CORRESPONDING FIELDS OF TABLE s_result-texts
        FROM d020t
        WHERE prog = <r>-prog
          AND dynr = <r>-dnum
          AND dtxt <> space.
      CALL FUNCTION 'RPY_DYNPRO_READ'
        EXPORTING
          progname             = <r>-prog
          dynnr                = <r>-dnum
        IMPORTING
          header               = s_result-hdr
        TABLES
          containers           = t_container
          fields_to_containers = t_fields
          flow_logic           = t_flowlogic
          params               = s_result-matchcodes
        EXCEPTIONS
          cancelled            = 1
          not_found            = 2
          permission_error     = 3
          OTHERS               = 4.
      IF sy-subrc <> 0.
      ENDIF.
      LOOP AT t_container ASSIGNING <c>.
        CLEAR s_cont.
        IF <c>-type <> 'SCREEN'.
          IF <c>-c_resize_v IS INITIAL.   CLEAR <c>-c_line_min.   ENDIF.
          IF <c>-c_resize_h IS INITIAL.   CLEAR <c>-c_coln_min.   ENDIF.
        ENDIF.
        s_cont-hdr = <c>.
        LOOP AT t_fields ASSIGNING <f>
             WHERE cont_type = <c>-type
               AND cont_name = <c>-name.
          CLEAR: s_field, f_clear.
          s_field-hdr = <f>.
          CLEAR: s_field-cont_type, s_field-cont_name.
          IF <f>-type IN r_text_fields.       " field may have texts
            LOOP AT t_d021t ASSIGNING <t>
                 WHERE dynr = <r>-dnum
                   AND fldn = <f>-name.
              CLEAR s_text.
              s_text-langu = <t>-lang.
              s_text-short_txt = <t>-dtxt.
              INSERT s_text INTO TABLE s_field-texts.
              IF <t>-dtxt = s_field-text. f_clear = abap_true. ENDIF.
            ENDLOOP.
            IF NOT s_field-texts IS INITIAL AND NOT s_field-text CO '_' AND f_clear = abap_true. CLEAR s_field-text. ENDIF.
          ENDIF.
          INSERT s_field INTO TABLE s_cont-fields.
        ENDLOOP.
        INSERT s_cont INTO TABLE s_result-containers.
      ENDLOOP.
      s_result-flow_logic-_ = conv_flowlogic2abapsource( t_flowlogic ).
      CLEAR s_result-program.
      INSERT s_result INTO TABLE result.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_menus.
    DATA s_fm_data TYPE zaplink_menupainter_data=>ts_fm_data.
    DATA d_state   TYPE progdir-state.
    DATA rcode(5)  TYPE c.
    d_state = 'I'.      " Inactive
    PERFORM version_check IN PROGRAM saplsmpi USING program d_state CHANGING rcode.
    IF sy-subrc <> 0 OR NOT rcode IS INITIAL.   d_state = 'A'.    ENDIF.
    CALL FUNCTION 'RS_CUA_INTERNAL_FETCH'
      EXPORTING
        program         = program
        state           = d_state
      IMPORTING
        adm             = s_fm_data-header
      TABLES
        sta             = s_fm_data-status
        fun             = s_fm_data-functions
        men             = s_fm_data-menus_det
        mtx             = s_fm_data-menus
        act             = s_fm_data-bars_det
        but             = s_fm_data-buttons_det
        pfk             = s_fm_data-keyboards
        set             = s_fm_data-stat_funcs
        doc             = s_fm_data-attributes
        tit             = s_fm_data-titles
        biv             = s_fm_data-ffuncs
      EXCEPTIONS
        not_found       = 1
        unknown_version = 2
        OTHERS          = 3.
    IF sy-subrc <> 0.
      mac_add_mf_and_raise 'RS_CUA_INTERNAL_FETCH' sy-subrc.
    ELSEIF s_fm_data IS INITIAL.
      EXIT.     " No Menu
    ENDIF.
    SELECT *
      INTO TABLE s_fm_data-texts
      FROM rsmptexts
      WHERE progname = program.
    CREATE OBJECT result.
    result->from_data( s_fm_data ).
  ENDMETHOD.
  METHOD get_prog_rawsource.
    DATA d_obj_name   TYPE e071-obj_name.
    DATA d_is_work_i  TYPE abap_bool.
    DATA d_is_inactiv TYPE abap_bool.
    d_obj_name = program.
    CALL FUNCTION 'RS_OBJECT_IN_WORKING_AREA'
      EXPORTING
        object                  = 'REPS'
        obj_name                = d_obj_name
      IMPORTING
        object_is_work_item     = d_is_work_i     " My inactive object
        object_inactive_version = d_is_inactiv.
    IF NOT d_is_work_i IS INITIAL OR NOT d_is_inactiv IS INITIAL.
      READ REPORT program INTO result STATE 'I'.
    ELSE.
      sy-subrc = 4.
    ENDIF.
    IF sy-subrc <> 0.
      READ REPORT program INTO result STATE 'A'.
    ENDIF.
  ENDMETHOD.
  METHOD get_prog_source.
    DATA code TYPE tt_abaprawsource.
    code = get_prog_rawsource( program ).
    result = conv_abap_raw2source( code ).
  ENDMETHOD.
  METHOD get_prog_textpool.
    DATA t_textpool TYPE STANDARD TABLE OF textpool.
    DATA t_langlist TYPE instlang.
    TYPES:
      BEGIN OF ts_text,
        id     TYPE  textpoolid,
        key    TYPE  textpoolky,
        langu  TYPE spras,
        entry  TYPE textpooltx,
        length TYPE textpoolln,
      END OF ts_text.
    DATA: t_texts TYPE STANDARD TABLE OF ts_text.
    DATA _text LIKE LINE OF t_texts.
    DATA _textpool LIKE LINE OF result.
    DATA _tpool LIKE LINE OF _textpool-texts.
    FIELD-SYMBOLS:
      <l> LIKE LINE OF t_langlist,
      <t> LIKE LINE OF t_textpool.
    CALL FUNCTION 'RS_TEXTLOG_GET_PARAMETERS'
      CHANGING
        installed_languages = t_langlist.
    LOOP AT t_langlist ASSIGNING <l>.
      READ TEXTPOOL program INTO t_textpool LANGUAGE <l>.
      CHECK sy-subrc = 0.
      _text-langu = <l>.
      LOOP AT t_textpool ASSIGNING <t>.
        _text-id = <t>-id.
        _text-key = <t>-key.
        _text-entry = <t>-entry.
        _text-length = <t>-length.
        APPEND _text TO t_texts.
      ENDLOOP.
    ENDLOOP.
    SORT t_texts BY id key langu.
    DELETE ADJACENT DUPLICATES FROM t_texts COMPARING id key langu.
    LOOP AT t_texts INTO _text.
      AT NEW key. " ID
        CLEAR _textpool.
        _textpool-id = _text-id.
        _textpool-key = _text-key.
      ENDAT.
      AT NEW langu.
        CLEAR _tpool.
        _tpool-langu = _text-langu.
      ENDAT.
      _tpool-entry = _text-entry.
      _tpool-length = _text-length.
      AT END OF langu.
        APPEND _tpool TO _textpool-texts.
      ENDAT.
      AT END OF key.
        APPEND _textpool TO result.
      ENDAT.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_type_from_xml.
    DATA root_node TYPE REF TO if_ixml_node.
    DATA o_raw     TYPE to_raw_base.
    DATA _name     TYPE string.
    CHECK object IS BOUND.
    root_node = object->get_root_element( ).
    IF NOT root_node IS BOUND.
      _name = '$NONE$'(001).
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          textid    = zaplink_cx_connector=>invalid_xml
          node_name = _name.
    ENDIF.
    _name = root_node->get_name( ).
    IF _name <> comp_nodename.
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          textid    = zaplink_cx_connector=>invalid_xml
          node_name = _name.
    ENDIF.
    o_raw = zaplink_connectors=>node_2_raw( root_node ).
    result = o_raw->type.
  ENDMETHOD.
  METHOD set_base_attributs.
    DATA o_desc    TYPE REF TO cl_abap_typedescr.
    DATA string    TYPE string.
    DATA _name     TYPE tadir-obj_name.
    DATA _type     TYPE tadir-object.
    DATA _kind     TYPE tadir-pgmid.
    o_desc = cl_abap_typedescr=>describe_by_object_ref( p_object_ref = me ).
    string = o_desc->get_relative_name( ).
    _name = attributs-name = component->get_name( ).
    _type = component->get_type( ).
    attributs-class = string.
    attributs-version = me->version.
    _kind = zaplink_connectors=>get_typekind( _type ).
    CALL FUNCTION 'TRINT_TADIR_QUERY'
      EXPORTING
        iv_pgmid    = _kind
        iv_object   = _type
        iv_obj_name = _name
      IMPORTING
        ev_devclass = attributs-devclass.
  ENDMETHOD.
  METHOD set_dynpros.
    INCLUDE mseusbit. " for c_type_dynp_select_norm, c_type_dynp_select_mod, c_type_dynp_select_incl
    DATA:
      BEGIN OF dynp_id,
        prog TYPE d020s-prog,
        dnum TYPE d020s-dnum,
      END OF dynp_id.
    DATA header   TYPE rpy_dyhead.
    DATA t_flowlogic TYPE tt_flow_logic.
    DATA t_containers TYPE dycatt_tab.
    DATA s_cont  LIKE LINE OF t_containers.
    DATA t_fields TYPE dyfatc_tab.
    DATA s_field LIKE LINE OF t_fields.
    DATA t_descs TYPE SORTED TABLE OF d020t WITH UNIQUE KEY prog dynr.
    DATA s_desc LIKE LINE OF t_descs.
    DATA t_texts TYPE SORTED TABLE OF d021t WITH UNIQUE KEY prog dynr fldn lang.
    DATA s_text LIKE LINE OF t_texts.
    DATA f_fill TYPE abap_bool.
    FIELD-SYMBOLS:
      <r> LIKE LINE OF dynpros,
      <l> LIKE LINE OF <r>-texts,
      <c> LIKE LINE OF <r>-containers,
      <f> LIKE LINE OF <c>-fields,
      <t> LIKE LINE OF <f>-texts.
    CLEAR o_mycx.
    LOOP AT dynpros ASSIGNING <r>.
      CLEAR: header, t_containers, t_fields, t_texts, t_descs.
      header = <r>-hdr.
      header-program = program.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE i500 WITH space space. ENDIF.
      SET EXTENDED CHECK ON.
      application_log->add_info( id_msgid = 'ZAPLINK'
                                 id_msgno = '500'
                                 id_msgv1 = header-program
                                 id_msgv2 = header-screen ).
      LOOP AT <r>-texts ASSIGNING <l>.
        CLEAR s_desc.
        MOVE-CORRESPONDING <l> TO s_desc.
        INSERT s_desc INTO TABLE t_descs.
      ENDLOOP.
      t_flowlogic = conv_abapsource2flowlogic( <r>-flow_logic-_ ).
      LOOP AT <r>-containers ASSIGNING <c>.
        CLEAR s_cont.
        s_cont = <c>-hdr.
        LOOP AT <c>-fields ASSIGNING <f>.
          s_field = <f>-hdr.
          s_field-cont_type = <c>-type.
          s_field-cont_name = <c>-name.
          IF s_field-text IS INITIAL. f_fill = abap_true. ELSE. f_fill = abap_false. ENDIF.    " protect data
          LOOP AT <f>-texts ASSIGNING <t>.
            IF f_fill = abap_true AND ( sy-tabix = 1 OR <t>-langu = sy-langu ). s_field-text = <t>-short_txt. ENDIF.
            CLEAR s_text.
            s_text-prog = header-program.
            s_text-dynr = header-screen.
            s_text-fldn = <f>-name.
            s_text-lang = <t>-langu.
            s_text-dtxt = <t>-short_txt.
            INSERT s_text INTO TABLE t_texts.
          ENDLOOP.
          INSERT s_field INTO TABLE t_fields.
        ENDLOOP.
        INSERT s_cont INTO TABLE t_containers.
      ENDLOOP.
      SORT t_containers BY element_of name.
      CALL FUNCTION 'RPY_DYNPRO_INSERT'
        EXPORTING
          suppress_exist_checks  = abap_true
          header                 = header
        TABLES
          containers             = t_containers
          fields_to_containers   = t_fields
          flow_logic             = t_flowlogic
          params                 = <r>-matchcodes
        EXCEPTIONS
          cancelled              = 1
          already_exists         = 2
          program_not_exists     = 3
          not_executed           = 4
          missing_required_field = 5
          illegal_field_value    = 6
          field_not_allowed      = 7
          not_generated          = 8
          illegal_field_position = 9
          OTHERS                 = 10.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'RPY_DYNPRO_INSERT'
                                                    subrc = sy-subrc
                                                classname = 'ZAPLINK_CX_CONNECTOR' ).
        application_log->add_symsg( ).
        application_log->add_exception( o_mycx ).
        CONTINUE.
      ENDIF.
      MODIFY d020t FROM TABLE t_descs.
      MODIFY d021t FROM TABLE t_texts.
    ENDLOOP.
    IF o_mycx IS BOUND.   RAISE EXCEPTION o_mycx.   ENDIF.
  ENDMETHOD.
  METHOD set_menus.
    DATA s_fm_data TYPE zaplink_menupainter_data=>ts_fm_data.
    DATA d_trkey   TYPE trkey.
    DATA d_lang    TYPE sy-langu.
    CHECK menus IS BOUND.
    s_fm_data = menus->to_data( program ).
    d_trkey-obj_type = 'PROG'.
    d_trkey-sub_name = d_trkey-obj_name = program.
    d_trkey-sub_type = 'CUAD'.
    d_lang = s_fm_data-header-mod_langu.
    IF d_lang IS INITIAL.   d_lang = sy-langu.    ENDIF.
    CALL FUNCTION 'RS_CUA_INTERNAL_WRITE'
      EXPORTING
        program   = program
        language  = d_lang
        tr_key    = d_trkey
        adm       = s_fm_data-header
        state     = 'I'
      TABLES
        sta       = s_fm_data-status
        fun       = s_fm_data-functions
        men       = s_fm_data-menus_det
        mtx       = s_fm_data-menus
        act       = s_fm_data-bars_det
        but       = s_fm_data-buttons_det
        pfk       = s_fm_data-keyboards
        set       = s_fm_data-stat_funcs
        doc       = s_fm_data-attributes
        tit       = s_fm_data-titles
        biv       = s_fm_data-ffuncs
      EXCEPTIONS
        not_found = 1
        OTHERS    = 2.
    IF sy-subrc <> 0.
      mac_add_mf_and_raise 'RS_CUA_INTERNAL_WRITE' sy-subrc.
    ENDIF.
    DELETE FROM rsmptexts WHERE progname = program.
    MODIFY rsmptexts FROM TABLE s_fm_data-texts.
  ENDMETHOD.
  METHOD set_prog_rawsource.
    INSERT REPORT program FROM raw STATE 'I'.
    IF sy-subrc = 0.
      INSERT REPORT program FROM raw STATE 'A'.
    ENDIF.
  ENDMETHOD.
  METHOD set_prog_source.
    DATA _raw TYPE tt_abaprawsource.
    _raw = conv_abap_source2raw( source ).
    set_prog_rawsource( program = program
                            raw = _raw ).
  ENDMETHOD.
  METHOD set_prog_textpool.
    TYPES:
      BEGIN OF ts_text,
        langu  TYPE spras,
        id     TYPE  textpoolid,
        key    TYPE  textpoolky,
        entry  TYPE textpooltx,
        length TYPE textpoolln,
      END OF ts_text.
    DATA t_textpool TYPE STANDARD TABLE OF textpool.
    DATA: t_texts TYPE STANDARD TABLE OF ts_text.
    DATA _text LIKE LINE OF t_texts.
    DATA _textpool LIKE LINE OF t_textpool.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF textpool,
      <l> LIKE LINE OF <t>-texts.
    LOOP AT textpool ASSIGNING <t>.
      _text-id = <t>-id.
      _text-key = <t>-key.
      LOOP AT <t>-texts ASSIGNING <l>.
        _text-langu = <l>-langu.
        _text-entry = <l>-entry.
        _text-length = <l>-length.
        APPEND _text TO t_texts.
      ENDLOOP.
    ENDLOOP.
    SORT t_texts BY langu id key.
    DELETE ADJACENT DUPLICATES FROM t_texts COMPARING langu id key.
    LOOP AT t_texts INTO _text.
      AT NEW langu. " ID
        CLEAR: t_textpool, _textpool.
      ENDAT.
      _textpool-id = _text-id.
      _textpool-key = _text-key.
      _textpool-entry = _text-entry.
      _textpool-length = _text-length.
      APPEND _textpool TO t_textpool.
      AT END OF langu.
        INSERT TEXTPOOL program FROM t_textpool LANGUAGE _text-langu STATE 'I'.   " Issue 68
        INSERT TEXTPOOL program FROM t_textpool LANGUAGE _text-langu STATE 'A'.   " Issue 68
      ENDAT.
    ENDLOOP.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~anonymize.
    DATA o_intf TYPE ti_cleanning_4data.
    CHECK object IS BOUND.
    TRY.
        TRY.
            o_intf ?= object.
          CATCH cx_sy_move_cast_error.    " Auto anonymize can't be done
        ENDTRY.
        IF o_intf IS BOUND.     o_intf->anonymize( ).     ENDIF.
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
    TRY.
        object->anonymize( ).
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~unanonymize.
    DATA o_intf TYPE ti_cleanning_4data.
    CHECK object IS BOUND.
    TRY.
        TRY.
            o_intf ?= object.
          CATCH cx_sy_move_cast_error.    " Auto anonymize can't be done
        ENDTRY.
        IF o_intf IS BOUND.       o_intf->unanonymize( ).     ENDIF.
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
    TRY.
        object->unanonymize( ).
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_code_signature~get_signature.
  ENDMETHOD.
  METHOD zaplink_connector~export_from_sap.
    DATA ez_xml          TYPE to_ez_xml.
    DATA o_data          TYPE to_raw.
    o_data = read_from_sap( component ).
    IF o_data IS BOUND.
      o_data->update_connector_data( me ).
      CREATE OBJECT ez_xml.
      TRY.
          object = ez_xml->any2xml( any       = o_data
                                    type      = comp_nodename ).
        CATCH zaplink_cx INTO o_cx.
          mac_cascade_raise o_mycx o_cx.
      ENDTRY.
    ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~get_values.
    DATA _obj_type TYPE  euobj-id.
    DATA _name TYPE td_compname.
    _obj_type = type.
    CALL FUNCTION 'REPOSITORY_INFO_SYSTEM_F4'
      EXPORTING
        object_type           = _obj_type
        object_name           = name
        suppress_selection    = abap_true
        use_alv_grid          = abap_false
        without_personal_list = abap_false
      IMPORTING
        object_name_selected  = _name
      EXCEPTIONS
        cancel                = 1.
    IF sy-subrc = 0.
      name = _name.
    ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~import_to_sap.
    DATA root_node TYPE REF TO if_ixml_node.
    DATA o_raw_b   TYPE to_raw_base.
    DATA o_raw     TYPE to_raw.
    DATA _name     TYPE string.
    DATA wa_flag   TYPE rs38l-head.
    DATA ez_xml    TYPE to_ez_xml.
    DATA o_cx      TYPE REF TO cx_root.
    DATA t_bapiret TYPE bapirettab.
    DATA f_is_wi TYPE abap_bool.
    CHECK object IS BOUND.
    TRY.
        root_node = object->get_root_element( ).
        IF NOT root_node IS BOUND.
          _name = '$NONE$'(001).
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid    = zaplink_cx_connector=>invalid_xml
              node_name = _name.
        ENDIF.
        _name = root_node->get_name( ).
        IF _name <> comp_nodename.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid    = zaplink_cx_connector=>invalid_xml
              node_name = _name.
        ENDIF.
        TRY.
            o_raw_b = zaplink_connectors=>node_2_raw( root_node ).
          CATCH zaplink_cx_connector INTO o_mycx.
            RAISE EXCEPTION o_mycx.
        ENDTRY.
        IF is_supported_version( o_raw_b->version ) = abap_false.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid   = zaplink_cx_connector=>unsuported_version
              conn_ver = o_raw_b->version.
        ENDIF.
        o_raw = create_new_raw( o_raw_b->type ).
        CREATE OBJECT ez_xml.
        CALL METHOD ez_xml->xml2any
          EXPORTING
            xmldoc = object
          CHANGING
            any    = o_raw.
        IF ez_xml->application_log->has_messages_of_msgt( id_msgty = 'W') = abap_true.
          application_log->add_from_instance( io_msglist = ez_xml->application_log
                                       if_add_as_subnode = abap_true ).
          DATA t_handle TYPE bal_t_logh.
          DATA s_profil TYPE bal_s_prof.
          DATA s_choice TYPE bal_s_excm.
          APPEND application_log->md_handle TO t_handle.
          CALL FUNCTION 'BAL_DSP_PROFILE_SINGLE_LOG_GET'
            IMPORTING
              e_s_display_profile = s_profil
            EXCEPTIONS
              OTHERS              = 0.
          s_profil-langu = sy-langu.
          MESSAGE i010(zaplink_easyxml) WITH o_raw_b->type o_raw_b->name INTO s_profil-title.
          s_profil-use_grid = s_profil-no_toolbar = s_profil-show_all = s_profil-cwidth_opt = abap_true.
          MESSAGE i009(zaplink_easyxml) WITH o_raw_b->type o_raw_b->name INTO s_profil-grid_title-gridtitle.
          s_profil-start_col = s_profil-start_row = 5.
          s_profil-end_col = 120.
          s_profil-end_row = 40.
          s_profil-head_size = 10.
          CALL FUNCTION 'BAL_DSP_LOG_DISPLAY'
            EXPORTING
              i_s_display_profile  = s_profil
              i_t_log_handle       = t_handle
              i_amodal             = abap_false
            IMPORTING
              e_s_exit_command     = s_choice
            EXCEPTIONS
              profile_inconsistent = 1
              internal_error       = 2
              no_data_available    = 3
              no_authority         = 4
              OTHERS               = 5.
          IF sy-subrc <> 0 OR s_choice-continue IS INITIAL.
            CREATE OBJECT o_mycx
              EXPORTING
                textid = zaplink_cx_connector=>xml_error
                type   = o_raw_b->type
                name   = o_raw_b->name.
            o_mycx->update( ).
            RAISE EXCEPTION o_mycx.
          ENDIF.
        ENDIF.
        zaplink_tools=>add_comp_to_working_area( type = o_raw->type
                                                 name = o_raw->name ).
        components = write_to_sap( o_raw ).
        IF components IS NOT BOUND.   CREATE OBJECT components.   ENDIF.
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
      CATCH cx_root INTO o_cx.
        CREATE OBJECT o_mycx
          EXPORTING
            textid   = zaplink_cx=>system_error
            previous = o_cx.
        o_mycx->update( ).
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CONNECTOR_ implementation
CLASS zaplink_documentation IMPLEMENTATION.
  METHOD class_constructor.
    mac_create_log log ballog_subobject space.
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    super->constructor( ).
    mac_create_log application_log ballog_subobject space.
    type-type = supportedtypes-general. INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-indep.   INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD docu_get.
    DATA _text  TYPE tt_rawtext.
    TRY.
        head-id = docu-id.
        head-object = docu-object.
        head-masterlang = docu-masterlang.
        head-langu = docu-langu.
        head-typ = docu-typ.
        head-selfdef = docu-selfdef.
        IF docu-selfdef = space.
          CALL FUNCTION 'DOCU_GET'
            EXPORTING
              id                     = docu-id
              langu                  = docu-langu
              object                 = docu-object
              typ                    = docu-typ
              version                = docu-version
              version_active_or_last = 'A'
            IMPORTING
              dokstate               = lang-state
              head                   = lang-head
            TABLES
              line                   = _text
            EXCEPTIONS
              no_docu_on_screen      = 1
              no_docu_self_def       = 2
              no_docu_temp           = 3
              ret_code               = 4
              OTHERS                 = 5.
          IF sy-subrc <> 0.
            lmac_add_mf_and_raise 'DOCU_GET' sy-subrc.
          ENDIF.
          lang-_ = raw2string( _text ).
          head-application = lang-tdobject.
          head-dokform = lang-tdform.
          head-dokstyle = lang-tdstyle.
          CLEAR:
            lang-tdobject,
            lang-tdname,
            lang-tdid,
            lang-tdform,
            lang-tdstyle.
        ENDIF.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD get.
    DATA _obj   TYPE RANGE OF doku_obj.
    DATA my_obj LIKE LINE OF _obj.
    DATA docs   TYPE STANDARD TABLE OF dokil WITH DEFAULT KEY.
    DATA doc    LIKE LINE OF t_docs.
    DATA _lang  LIKE LINE OF doc-texts.
    FIELD-SYMBOLS:
      <d> LIKE LINE OF docs.
    IF ids IS INITIAL.
      EXIT.
    ENDIF.
    my_obj-sign = 'I'. my_obj-option = 'CP'.
    my_obj-low = object. APPEND my_obj TO _obj.
    SELECT * INTO TABLE docs
      FROM dokil
      WHERE id IN ids
        AND object IN _obj.
    IF docs IS INITIAL.
      EXIT.
    ENDIF.
    reset( ).
    SORT docs BY id object masterlang DESCENDING langu.
    LOOP AT docs ASSIGNING <d>.
      AT NEW object. " ID + OBJECT
        CLEAR doc.
        CALL METHOD docu_get
          EXPORTING
            docu = <d>
          IMPORTING
            head = doc-hdr
            lang = _lang.
      ENDAT.
      IF _lang IS INITIAL.
        CALL METHOD docu_get
          EXPORTING
            docu = <d>
          IMPORTING
            lang = _lang.
      ENDIF.
      IF NOT _lang IS INITIAL.
        CLEAR: _lang-tdversion, _lang-tdfuser, _lang-tdfdate, _lang-tdftime, _lang-tdluser, _lang-tdldate, _lang-tdltime.   " Issue 68 : Remove useless data
        INSERT _lang INTO TABLE doc-texts.
        CLEAR _lang.
      ENDIF.
      AT END OF object. " ID + OBJECT
        APPEND doc TO t_docs.
      ENDAT.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_single.
    DATA r_ids  TYPE tr_docid.
    DATA my_id  LIKE LINE OF r_ids.
    DATA t_docs TYPE tt_docs.
    my_id-sign = 'I'. my_id-option = 'EQ'.    my_id-low = ids. APPEND my_id TO r_ids.
    t_docs = get( ids = r_ids
               object = object ).
    IF NOT t_docs IS INITIAL.   READ TABLE t_docs INTO result INDEX 1.    ENDIF.
  ENDMETHOD.
  METHOD name_2_mask.
    CASE type.
      WHEN supportedtypes-general. result-id = 'TX'.    result-object = name.
      WHEN supportedtypes-indep.   result = name.
    ENDCASE.
  ENDMETHOD.
  METHOD raw2string.
    FIELD-SYMBOLS <l> LIKE LINE OF raw.
    DATA str TYPE string.
    LOOP AT raw ASSIGNING <l>.
      str = <l>.
      IF string IS INITIAL.
        string = str.
      ELSE.
        CONCATENATE string line_separator str INTO string.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD reset.
    DATA object TYPE balobj_d.
    DATA subobject  TYPE balsubobj.
    DATA ext_id TYPE balnrext.
    IF NOT log IS BOUND.    EXIT.   ENDIF.
    object = zaplink_connector=>ballog_object.
    subobject = 'DOCT'.
    CALL METHOD log->init
      EXPORTING
        id_object      = object
        id_subobject   = subobject
        id_extnumber   = ext_id
        auto_upd_custo = abap_true
        id_activity    = zaplink_message_collector=>actions-create
      EXCEPTIONS
        error          = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
    ENDIF.
  ENDMETHOD.
  METHOD set.
    DATA _text  TYPE tt_rawtext.
    DATA _dokil TYPE dokil.
    DATA _head  TYPE thead.
    FIELD-SYMBOLS:
      <o> LIKE LINE OF t_docs,
      <t> LIKE LINE OF <o>-texts.
    IF t_docs IS INITIAL.
      EXIT. "nothing to do
    ENDIF.
    LOOP AT t_docs ASSIGNING <o>.
      _dokil-id = <o>-id.
      _dokil-object = <o>-object.
      _dokil-selfdef = <o>-selfdef.
      CALL FUNCTION 'DOCU_SELFDEF_WRITE'
        EXPORTING
          object_id   = _dokil-id
          object_name = _dokil-object
          selfdef     = _dokil-selfdef
        EXCEPTIONS
          not_deleted = 1
          OTHERS      = 2.
      IF sy-subrc <> 0.
        lmac_add_mf_and_raise 'DOCU_SELFDEF_WRITE' sy-subrc.
      ENDIF.
      LOOP AT <o>-texts ASSIGNING <t>.
        _text = string2raw( <t>-_  ).
        _head = <t>-head.
        _head-tdobject = <o>-application.
        _head-tdname = <o>-object.
        _head-tdid = <o>-id.
        _head-tdform = <o>-dokform.
        _head-tdstyle = <o>-dokstyle.
        IF <o>-selfdef IS INITIAL.
          CALL FUNCTION 'DOCU_UPDATE'
            EXPORTING
              head    = _head
              state   = <t>-state
              typ     = <o>-typ
              version = 0
            TABLES
              line    = _text.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
  ENDMETHOD.
  METHOD set_single.
    DATA t_docs TYPE tt_docs.
    APPEND data TO t_docs.
    set( t_docs ).
  ENDMETHOD.
  METHOD string2raw.
    SPLIT string AT line_separator
            INTO TABLE raw.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_doc TYPE to_doc.
    CREATE OBJECT object.
    CASE type.
      WHEN supportedtypes-general OR supportedtypes-indep.
        CREATE OBJECT o_doc.
        object->raw = o_doc.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA pool     TYPE rs38l-area.
    DATA type     TYPE td_comptype.
    DATA name     TYPE td_compname.
    DATA s_mask   TYPE ts_name_mask.
    DATA d_ori_modified TYPE c.
    DATA d_doc_type TYPE doku_typ.
    DATA s_dokil  TYPE dokil.
    DATA s_head   TYPE thead.
    TRY.
        type = component->get_type( ).
        name = component->get_name( ).
        CASE type.
          WHEN supportedtypes-general OR supportedtypes-indep.
            CASE type.
              WHEN supportedtypes-general. s_mask-id = 'TX'.    s_mask-object = name. " Issue 60
              WHEN supportedtypes-indep.   s_mask = name.
            ENDCASE.
            CALL FUNCTION 'EXT_MODIFY_ORIGINAL_CHECK'
              EXPORTING
                p_id                = s_mask-id
                p_object            = s_mask-object
              IMPORTING
                p_original_modified = d_ori_modified
              EXCEPTIONS
                OTHERS              = 1.
            IF d_ori_modified = abap_true."Modi. vorh.
              d_doc_type = 'M'.
            ELSEIF s_mask-id = 'FU' OR s_mask-id = 'FX'.
              d_doc_type = 'T'.
            ELSE.
              d_doc_type = 'E'.
            ENDIF.
            SELECT SINGLE * INTO s_dokil
              FROM dokil
              WHERE id = s_mask-id
                AND object = s_mask-object
                AND typ = d_doc_type
                AND masterlang = abap_true.
            IF sy-subrc <> 0.
              SELECT SINGLE * INTO s_dokil
                FROM dokil
                WHERE id = s_mask-id
                  AND object = s_mask-object
                  AND typ = d_doc_type.
            ENDIF.
            s_head-tdid     = s_mask-id.
            s_head-tdname   = s_mask-object.
            s_head-tdspras  = s_dokil-langu.
            CALL FUNCTION 'ENQUEUE_ESDOC'
              EXPORTING
                id             = s_dokil-id
                object         = s_dokil-object
                langu          = s_dokil-langu
                typ            = s_dokil-typ
              EXCEPTIONS
                foreign_lock   = 1
                system_failure = 2
                OTHERS         = 3.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise 'ENQUEUE_ESDOC' sy-subrc.
            ENDIF.
            CALL FUNCTION 'DOCU_DELETE'
              EXPORTING
                head    = s_head
                typ     = d_doc_type
                version = s_dokil-version.
            CALL FUNCTION 'DEQUEUE_ESDOC'
              EXPORTING
                id     = s_dokil-id
                object = s_dokil-object
                langu  = s_dokil-langu
                typ    = s_dokil-typ.
            SELECT SINGLE * INTO s_dokil
              FROM dokil
              WHERE id = s_mask-id
                AND object = s_mask-object
                AND typ = d_doc_type.
            IF sy-subrc <> 0.   result = abap_true.   ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    zaplink_tools=>remove_comp_from_working_area( type = type
                                                  name = name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA type     TYPE td_comptype.
    DATA s_mask   TYPE ts_name_mask.
    DATA d_name   TYPE td_compname.
    exists = me->exists-not_exists.
    TRY.
        type = component->get_type( ).
        CASE type.
          WHEN supportedtypes-general OR supportedtypes-indep..
            d_name = component->get_name( ).
            s_mask = name_2_mask( type = type    name = d_name ).
            SELECT SINGLE id INTO s_mask-id
              FROM dokil
              WHERE     id = s_mask-id
                AND object = s_mask-object.
            IF sy-subrc = 0.    exists = me->exists-exists.   ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.    result = abap_true.   ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    DATA o_data   TYPE to_doc.
    DATA d_name   TYPE td_compname.
    DATA type     TYPE td_comptype.
    DATA s_mask   TYPE ts_name_mask.
    DATA s_doc    TYPE ts_doc.
    TRY.
        type = component->get_type( ).
        CREATE OBJECT object.
        object->set_component( component ).
        CASE type.
          WHEN supportedtypes-general OR supportedtypes-indep.
            d_name = component->get_name( ).
            s_mask = name_2_mask( type = type    name = d_name ).
            s_doc = get_single( ids = s_mask-id
                             object = s_mask-object ).
            CREATE OBJECT o_data.
            o_data->from_data( s_doc ).
            CLEAR: o_data->a0_maindata-id, o_data->a0_maindata-object.
            object->raw = o_data.
          WHEN OTHERS.
            CLEAR object.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        object->update_connector_data( me ).                    " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    DATA o_data   TYPE to_doc.
    DATA o_comp   TYPE to_component.
    DATA s_mask   TYPE ts_name_mask.
    DATA s_doc    TYPE ts_doc.
    TRY.
        CASE object->type.
          WHEN supportedtypes-general OR supportedtypes-indep.
            o_data ?= object->raw.
            CASE object->type.
              WHEN supportedtypes-general. s_mask-id = 'TX'.    s_mask-object = object->name.
              WHEN supportedtypes-indep.   s_mask = object->name.
            ENDCASE.
            o_data->a0_maindata-id = s_mask-id.   o_data->a0_maindata-object = s_mask-object.
            s_doc = o_data->to_data( ).
            set_single( s_doc ).
            CREATE OBJECT o_comp.
            o_comp->set_type( object->type ).   o_comp->set_name( object->name ).
            CREATE OBJECT components.
            components->add( o_comp ).
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name object->type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ). " Issue 92
      CATCH zaplink_cx_connector INTO o_mycx.
        ROLLBACK WORK.
        RAISE EXCEPTION o_mycx.
      CATCH zaplink_cx INTO o_cx.
        ROLLBACK WORK.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_DOCUMENTATION implementation
CLASS zaplink_list_4extractor IMPLEMENTATION.
ENDCLASS. "ZAPLINK_LIST_4EXTRACTOR implementation
CLASS zaplink_message IMPLEMENTATION.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_id.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = c_msg_id. APPEND _id TO r_doc_id.
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.
    type-type = st_msgclass. INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~anonymize.
    DATA o_msag TYPE to_data.
    CHECK object IS BOUND.
    o_msag ?= object->raw.
    o_msag->anonymize( ).
    TRY.
        super->zaplink_cnx_ext_cleaner~anonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~unanonymize.
    DATA o_msag TYPE to_data.
    TRY.
        super->zaplink_cnx_ext_cleaner~unanonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
    o_msag ?= object->raw.
    o_msag->unanonymize( ).
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_data TYPE to_data.
    CREATE OBJECT object.
    CASE type.
      WHEN st_msgclass.
        CREATE OBJECT o_data.
        object->raw = o_data.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA _name TYPE t100a-arbgb.
    DATA type  TYPE td_comptype.
    DATA name  TYPE td_compname.
    TRY.
        type = component->get_type( ).
        CASE type.
          WHEN st_msgclass.
            _name = name = component->get_name( ).
            CALL FUNCTION 'RS_DELETE_MESSAGE_ID'
              EXPORTING
                nachrichtenklasse = _name
              EXCEPTIONS
                not_executed      = 1
                not_found         = 2
                no_permission     = 3
                OTHERS            = 4.
            IF sy-subrc <> 0. " SAP NameSpace
              CASE sy-subrc.
                WHEN 2.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>not_found.
                WHEN OTHERS.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>system_error.
              ENDCASE.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    result = abap_true.
    zaplink_tools=>remove_comp_from_working_area( type = type
                                                  name = name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA _name TYPE t100a-arbgb.
    DATA type  TYPE td_comptype.
    exists = me->exists-not_exists.
    TRY.
        type = component->get_type( ).
        CASE type.
          WHEN st_msgclass.
            _name = component->get_name( ).
            SELECT SINGLE arbgb INTO _name
              FROM t100a
              WHERE arbgb = _name.
            IF sy-subrc = 0.
              exists = me->exists-exists.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.
      result = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    DATA _data  TYPE to_data.
    DATA _obj   TYPE doku_obj.
    DATA t_t100 TYPE SORTED TABLE OF t100 WITH UNIQUE KEY msgnr sprsl.
    DATA _name  TYPE arbgb.
    DATA t_docs TYPE zaplink_documentation=>tt_docs.
    FIELD-SYMBOLS:
      <l>  LIKE LINE OF t_docs,
      <lt> LIKE LINE OF <l>-texts,
      <t>  LIKE LINE OF t_t100,
      <m>  LIKE LINE OF _data->messages,
      <mt> LIKE LINE OF <m>-texts.
    DATA _text LIKE LINE OF <m>-texts.
    DATA _htxt LIKE LINE OF _data->texts.
    DATA _key  TYPE doku_obj.
    DATA d_type TYPE td_comptype.
    TRY.
        CREATE OBJECT object.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN st_msgclass.
            _name = component->get_name( ).
            CONCATENATE _name '+++' INTO _obj.  " +++ stand for message number
            t_docs = zaplink_documentation=>get( ids = r_doc_id
                                              object = _obj ).
            DELETE t_docs WHERE texts IS INITIAL.
            CREATE OBJECT _data.
            SELECT SINGLE *
              INTO CORRESPONDING FIELDS OF _data->a0_maindata
              FROM t100a
              WHERE arbgb = _name.
            SELECT sprsl stext
              INTO TABLE _data->texts
              FROM t100t
              WHERE arbgb = _name
                AND stext <> space.        " ignore null
            READ TABLE _data->texts TRANSPORTING NO FIELDS
                 WITH TABLE KEY langu = _data->a0_maindata-masterlang.
            IF sy-subrc <> 0.
              _htxt-langu = _data->a0_maindata-masterlang.
              _htxt-short_txt = _data->a0_maindata-stext.
              INSERT _htxt INTO TABLE _data->texts.
            ENDIF.
            CLEAR _data->a0_maindata-stext.
            SELECT *
              INTO CORRESPONDING FIELDS OF TABLE _data->messages
              FROM t100u
              WHERE arbgb = _name.
            SELECT * INTO TABLE t_t100
              FROM t100
              WHERE arbgb = _name
                AND text <> space.          " ignore null
            LOOP AT _data->messages ASSIGNING <m>.
              LOOP AT t_t100 ASSIGNING <t>
                      WHERE msgnr = <m>-msgnr.
                CLEAR _text.
                _text-langu = <t>-sprsl.
                _text-short_txt = <t>-text.
                INSERT _text INTO TABLE <m>-texts.
              ENDLOOP.
              CONCATENATE _name <m>-msgnr INTO _key.
              LOOP AT t_docs ASSIGNING <l>
                      WHERE object = _key.
                IF <m>-application IS INITIAL.
                  <m>-application = <l>-application.
                ELSE.
                  ASSERT <m>-application = <l>-application.
                ENDIF.
                IF <m>-typ IS INITIAL.
                  <m>-typ = <l>-typ.
                ELSE.
                  ASSERT <m>-typ = <l>-typ.
                ENDIF.
                IF <m>-dokform IS INITIAL.
                  <m>-dokform = <l>-dokform.
                ELSE.
                  ASSERT <m>-dokform = <l>-dokform.
                ENDIF.
                IF <m>-dokstyle IS INITIAL.
                  <m>-dokstyle = <l>-dokstyle.
                ELSE.
                  ASSERT <m>-dokstyle = <l>-dokstyle.
                ENDIF.
                LOOP AT <l>-texts ASSIGNING <lt>.
                  READ TABLE <m>-texts ASSIGNING <mt>
                       WITH TABLE KEY langu = <lt>-tdspras.
                  IF sy-subrc = 0.
                    <mt>-long_txt = <lt>.
                    CLEAR <mt>-long_txt-tdspras.
                  ELSE.
                    CLEAR _text.
                    _text-long_txt = <lt>.
                    CLEAR _text-long_txt-tdspras.
                    INSERT _text INTO TABLE <m>-texts.
                  ENDIF.
                ENDLOOP.
              ENDLOOP.
              IF <m>-texts IS INITIAL.    DELETE _data->messages.     ENDIF.
            ENDLOOP.
            object->set_component( component ).
            CLEAR _data->a0_maindata-arbgb.
            object->raw = _data.
          WHEN OTHERS.
            CLEAR object.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        object->update_connector_data( me ).                    " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    DATA _data      TYPE to_data.
    DATA o_comp     TYPE to_component.
    DATA _name      TYPE td_compname.
    DATA t_docs     TYPE zaplink_documentation=>tt_docs.
    DATA ls_doc     LIKE LINE OF t_docs.
    DATA: lt_t100  TYPE STANDARD TABLE OF t100,
          ls_t100  LIKE LINE OF lt_t100,
          lt_t100t TYPE STANDARD TABLE OF t100t,
          ls_t100t LIKE LINE OF lt_t100t,
          lt_t100u TYPE STANDARD TABLE OF t100u,
          ls_t100u LIKE LINE OF lt_t100u,
          ls_t100a TYPE t100a.
    FIELD-SYMBOLS:
      <m> LIKE LINE OF _data->messages,
      <l> LIKE LINE OF <m>-texts,
      <t> LIKE LINE OF _data->texts.
    TRY.
        CREATE OBJECT components. " Issue 92
        CASE object->type.
          WHEN st_msgclass.
            _data ?= object->raw.
            _data->a0_maindata-arbgb = object->name.
            MOVE-CORRESPONDING _data->a0_maindata TO ls_t100a.
            LOOP AT _data->texts ASSIGNING <t>.
              CLEAR ls_t100t.
              ls_t100t-arbgb = _data->a0_maindata-arbgb.
              ls_t100t-sprsl = <t>-langu.
              ls_t100t-stext = <t>-short_txt.
              APPEND ls_t100t TO lt_t100t.
              IF <t>-langu = _data->a0_maindata-masterlang.
                ls_t100a-stext = <t>-short_txt.
              ENDIF.
            ENDLOOP.
            LOOP AT _data->messages ASSIGNING <m>.
              CLEAR ls_t100u.
              MOVE-CORRESPONDING <m> TO ls_t100u.
              ls_t100u-arbgb = _data->a0_maindata-arbgb.
              APPEND ls_t100u TO lt_t100u.
              CLEAR ls_doc.
              ls_doc-application = <m>-application.
              ls_doc-id = c_msg_id.
              CONCATENATE _data->a0_maindata-arbgb <m>-msgnr INTO ls_doc-object.
              ls_doc-typ = <m>-typ.
              ls_doc-dokform = <m>-dokform.
              ls_doc-dokstyle = <m>-dokstyle.
              ls_doc-selfdef = <m>-selfdef.
              CLEAR ls_t100.
              MOVE-CORRESPONDING <m> TO ls_t100.
              MOVE-CORRESPONDING ls_t100u TO ls_t100.
              LOOP AT <m>-texts ASSIGNING <l>.
                IF NOT <l>-short_txt IS INITIAL.
                  ls_t100-sprsl = <l>-langu.
                  ls_t100-text = <l>-short_txt.
                  MOVE-CORRESPONDING <l> TO ls_t100.
                  APPEND ls_t100 TO lt_t100.
                ENDIF.
                IF NOT <l>-long_txt IS INITIAL.
                  <l>-long_txt-tdspras = <l>-langu.
                  INSERT <l>-long_txt INTO TABLE ls_doc-texts .
                ENDIF.
              ENDLOOP.
              IF NOT ls_doc-texts IS INITIAL.
                INSERT ls_doc INTO TABLE t_docs.
              ENDIF.
            ENDLOOP.
            CALL FUNCTION 'RS_ACCESS_PERMISSION'
              EXPORTING
                mode         = 'FREE'
                object       = ls_t100a-arbgb
                object_class = 'T100'.
            CALL FUNCTION 'RS_ACCESS_PERMISSION'
              EXPORTING
                authority_check          = 'X'
                global_lock              = 'X'
                mode                     = 'INSERT'
                language_upd_exit        = 'UPDATE_MASTER'
                master_language          = ls_t100a-masterlang
                object                   = ls_t100a-arbgb
                object_class             = 'T100'
                suppress_language_check  = ' '
              EXCEPTIONS
                canceled_in_corr         = 01
                enqueued_by_user         = 02
                enqueue_system_failure   = 03
                illegal_parameter_values = 04
                locked_by_author         = 05
                no_modify_permission     = 06
                no_show_permission       = 07
                permission_failure       = 08.
            CASE sy-subrc.
              WHEN 0.
              WHEN 2 OR 5.
                RAISE EXCEPTION TYPE zaplink_cx_connector
                  EXPORTING
                    name   = _name
                    type   = object->type
                    textid = zaplink_cx_connector=>object_locked.
              WHEN 6 OR 7 OR 8 OR 9.
                RAISE EXCEPTION TYPE zaplink_cx_connector
                  EXPORTING
                    name   = _name
                    type   = object->type
                    textid = zaplink_cx_connector=>not_authorized.
              WHEN OTHERS.
                RAISE EXCEPTION TYPE zaplink_cx_connector
                  EXPORTING
                    name   = _name
                    type   = object->type
                    textid = zaplink_cx_connector=>system_error.
            ENDCASE.
            MODIFY t100a FROM ls_t100a.
            MODIFY t100t FROM TABLE lt_t100t.
            MODIFY t100u FROM TABLE lt_t100u.
            MODIFY t100 FROM TABLE lt_t100.
            CALL METHOD zaplink_documentation=>set
              EXPORTING
                t_docs = t_docs.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name object->type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ). " Issue 92
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_MESSAGE implementation
CLASS zaplink_os_command IMPLEMENTATION.
  METHOD calc_signature.
    DATA d_string TYPE string.
    CLEAR: data-name, data-opsystem, data-addpar, data-sapcommand, data-permission, data-traceon.
    d_string = data.
    CONDENSE d_string.
    result = zaplink_tools=>calculate_md5_hash( d_string ).
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_id.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = c_msg_id. APPEND _id TO r_doc_id.
  ENDMETHOD.
  METHOD comp_to_key.
    SPLIT data AT field_separator INTO result-name result-opsystem.
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.
    type-type = st_os_cmd. INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD key_to_comp.
    CONCATENATE data-name field_separator data-opsystem INTO result.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_code_signature~get_signature.
    DATA d_name TYPE td_compname.
    DATA d_type TYPE td_comptype.
    DATA s_name TYPE ts_os_cmd_key.
    DATA s_data TYPE sxpgcolist.
    TRY.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN st_os_cmd.
            d_name = component->get_name( ).
            s_name = comp_to_key( d_name ).
            CALL FUNCTION 'SXPG_COMMAND_GET'
              EXPORTING
                commandname       = s_name-name
                operatingsystem   = s_name-opsystem
              IMPORTING
                command           = s_data
              EXCEPTIONS
                command_not_found = 1
                OTHERS            = 2.
            IF sy-subrc <> 0.
              RAISE EXCEPTION TYPE zaplink_cx_connector
                EXPORTING
                  textid = zaplink_cx_connector=>not_found
                  name   = d_name
                  type   = st_os_cmd.
            ENDIF.
            result = calc_signature( s_data ).
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_data TYPE to_data.
    CREATE OBJECT object.
    CASE type.
      WHEN st_os_cmd.
        CREATE OBJECT o_data.
        object->raw ?= o_data.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA d_name TYPE td_compname.
    DATA s_name TYPE ts_os_cmd_key.
    DATA d_dialog TYPE c.
    TYPES: BEGIN OF s_ext_cmd.
        INCLUDE TYPE sxpgcostab.
    TYPES: sapcommand TYPE sxpgcolist-sapcommand,
           type(8)    TYPE c,
           END OF s_ext_cmd.
    DATA: external_command TYPE s_ext_cmd.
    TYPES retcode TYPE i.
    DATA d_rc     TYPE retcode.
    CONSTANTS:
      rc_command_not_found TYPE retcode VALUE 801,
      rc_last_error        TYPE retcode VALUE 9999.         "#EC NEEDED
    DATA d_type TYPE td_comptype.
    TRY.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN st_os_cmd.
            d_name = component->get_name( ).
            s_name = comp_to_key( d_name ).
            external_command-name = s_name-name.
            external_command-opsystem = s_name-opsystem.
            PERFORM command_delete IN PROGRAM saplsxpt
                    USING d_dialog
                 CHANGING external_command
                          d_rc.
            IF d_rc <> 0.
              CASE d_rc.
                WHEN rc_command_not_found.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>not_found.
                WHEN OTHERS.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>system_error.
              ENDCASE.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    result = abap_true.
    zaplink_tools=>remove_comp_from_working_area( type = d_type
                                                  name = d_name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA d_name TYPE td_compname.
    DATA d_type TYPE td_comptype.
    DATA s_name TYPE ts_os_cmd_key.
    TRY.
        exists = me->exists-not_exists.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN st_os_cmd.
            d_name = component->get_name( ).
            s_name = comp_to_key( d_name ).
            CALL FUNCTION 'SXPG_COMMAND_GET'
              EXPORTING
                commandname       = s_name-name
                operatingsystem   = s_name-opsystem
              EXCEPTIONS
                command_not_found = 1
                OTHERS            = 2.
            IF sy-subrc = 0.
              exists = me->exists-exists.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.
      result = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    DATA d_name TYPE td_compname.
    DATA d_type TYPE td_comptype.
    DATA s_name TYPE ts_os_cmd_key.
    DATA o_data  TYPE to_data.
    TRY.
        CREATE OBJECT object.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN st_os_cmd.
            d_name = component->get_name( ).
            s_name = comp_to_key( d_name ).
            CREATE OBJECT o_data.
            CALL FUNCTION 'SXPG_COMMAND_GET'
              EXPORTING
                commandname       = s_name-name
                operatingsystem   = s_name-opsystem
              IMPORTING
                command           = o_data->a0_maindata
              EXCEPTIONS
                command_not_found = 1
                OTHERS            = 2.
            IF sy-subrc <> 0.
              RAISE EXCEPTION TYPE zaplink_cx_connector
                EXPORTING
                  textid = zaplink_cx_connector=>not_found
                  name   = d_name
                  type   = st_os_cmd.
            ENDIF.
            object->set_component( component ).
            CLEAR: o_data->a0_maindata-name,
                   o_data->a0_maindata-opsystem.
            object->raw ?= o_data.
            object->code_signature = calc_signature( o_data->a0_maindata ).
          WHEN OTHERS.
            CLEAR object.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        object->update_connector_data( me ).                    " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    DATA d_name TYPE td_compname.
    DATA d_type TYPE td_comptype.
    DATA s_name TYPE ts_os_cmd_key.
    DATA o_data  TYPE to_data.
    DATA o_comp  TYPE to_component.
    TRY.
        CREATE OBJECT components. " Issue 92
        d_type = object->type.
        CASE d_type.
          WHEN st_os_cmd.
            o_data ?= object->raw.
            d_name = object->get_name( ).
            s_name = comp_to_key( d_name ).
            o_data->a0_maindata-name = s_name-name.
            o_data->a0_maindata-opsystem = s_name-opsystem.
            CALL FUNCTION 'SXPG_COMMAND_INSERT'
              EXPORTING
                command                = o_data->a0_maindata
              EXCEPTIONS
                command_already_exists = 1
                no_permission          = 2
                parameters_wrong       = 3
                foreign_lock           = 4
                system_failure         = 5
                OTHERS                 = 6.
            IF sy-subrc <> 0.
              IF sy-subrc <> 1.
                o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname  = 'SXPG_COMMAND_INSERT'
                                                         subrc     = sy-subrc
                                                         classname = 'ZAPLINK_CX_CONNECTOR'
                                                       ).
                RAISE EXCEPTION o_mycx.
              ENDIF.
              CALL FUNCTION 'SXPG_COMMAND_MODIFY'
                EXPORTING
                  command          = o_data->a0_maindata
                EXCEPTIONS
                  no_permission    = 1
                  parameters_wrong = 2
                  system_failure   = 3
                  foreign_lock     = 4
                  OTHERS           = 5.
              IF sy-subrc <> 0.
                o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname  = 'SXPG_COMMAND_MODIFY'
                                                         subrc     = sy-subrc
                                                         classname = 'ZAPLINK_CX_CONNECTOR'
                                                       ).
                RAISE EXCEPTION o_mycx.
              ENDIF.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ). " Issue 92
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_OS_COMMAND implementation
CLASS zaplink_badi IMPLEMENTATION.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_id_definition.
    _id-sign = 'I'.
    _id-option = 'EQ'.
    _id-low = 'HY'. APPEND _id TO r_doc_id_definition.
    _id-low = 'BI'. APPEND _id TO r_doc_id_implementation.
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.
    type-type = st_badi_def. INSERT type INTO TABLE supported_types.
    type-type = st_badi_impl. INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD create_doc_key.
    doc_key-simg = 'SIMG'.
  ENDMETHOD.
  METHOD do_exists_impl.
    _exists = zaplink_badi=>exists-not_exists.
    CALL FUNCTION 'SXV_IMP_EXISTS'
      EXPORTING
        imp_name           = name
      EXCEPTIONS
        not_existing       = 1
        data_inconsistency = 2
        OTHERS             = 3.
    IF sy-subrc = 0.
      _exists =  zaplink_badi=>exists-exists.
    ENDIF.
  ENDMETHOD.
  METHOD export_from_sap_def.
    DATA obj_mask    TYPE doku_obj.
    DATA docu_key    TYPE ts_doc_key.
    DATA _d          TYPE zaplink_sxsd_data=>t_fm_data.
    DATA exit_name   TYPE rsexscrn-exit_name.
    DATA o_conn      TYPE to_connector.
    DATA _list       TYPE to_list.
    DATA _comp       TYPE to_component.
    DATA _name       TYPE td_compname.
    DATA f_subcomp  TYPE td_with_subcomp.
    TRY.
        CHECK component->get_type( ) = st_badi_def.
        f_subcomp = component->get_with_subcomp( ).
        exit_name = component->get_name( ).
        CALL FUNCTION 'SXO_BADI_READ'
          EXPORTING
            exit_name          = exit_name
          IMPORTING
            badi               = _d-definition
            mast_langu         = _d-mast_langu
            ext_clname         = _d-ext_clname
            filter_obj         = _d-filter_obj
          TABLES
            fcodes             = _d-fcodes
            cocos              = _d-cocos
            intas              = _d-intas
            scrns              = _d-scrns
            methods            = _d-methods
            inactive_tabstrips = _d-inactive_tabstrips
          EXCEPTIONS
            read_failure       = 1
            OTHERS             = 2.
        IF sy-subrc <> 0.
        ENDIF.
        docu_key = create_doc_key( ).
        docu_key-name = component->get_name( ).
        obj_mask = docu_key.
        CREATE OBJECT o_data.
        o_data->from_data( _d ).
        IF NOT o_data->a0_maindata-inter_name IS INITIAL AND f_subcomp >= sub_component-with_required.
          o_conn = zaplink_connectors=>create_connector( type = t_badi_itf ).
          IF o_conn IS BOUND.
            CREATE OBJECT _comp.
            _comp->set_type( t_badi_itf ).
            _name = o_data->a0_maindata-inter_name.
            _comp->set_name( _name ).
            o_data->interface = o_conn->read_from_sap( _comp ).
            IF o_data->interface IS BOUND.
              CLEAR o_data->a0_maindata-inter_name.
              CREATE OBJECT _list.
              _list->add( _comp ).
              component->set_subcomponents( _list ).
            ENDIF.
          ENDIF.
        ENDIF.
        o_data->documentation = zaplink_documentation=>get( ids = r_doc_id_definition
                                                         object = obj_mask ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_from_sap_impl.
    DATA obj_mask    TYPE doku_obj.
    DATA _d          TYPE zaplink_badi_data=>t_fm_data.
    DATA imp_name    TYPE rsexscrn-imp_name.
    DATA exit_name   TYPE rsexscrn-exit_name.
    DATA inter_name  TYPE rsexscrn-inter_name.
    DATA filters     TYPE seex_filter_table.
    DATA o_conn      TYPE to_connector.
    DATA _comp       TYPE to_component.
    DATA badi_info   TYPE badi_data.
    DATA filter_obj  TYPE REF TO cl_badi_flt_struct.
    DATA t_fcodes    TYPE seex_fcode_table.
    DATA t_cocos     TYPE seex_coco_table.
    DATA t_intas     TYPE seex_table_table.
    DATA t_scrns     TYPE seex_screen_table.
    DATA methods     TYPE seex_mtd_table.
    DATA _name       TYPE td_compname.
    DATA f_subcomp  TYPE td_with_subcomp.
    TRY.
        CHECK component->get_type( ) = st_badi_impl.
        f_subcomp = component->get_with_subcomp( ).
        imp_name = component->get_name( ).
        IF do_exists_impl( imp_name ) <> exists.
          EXIT.
        ENDIF.
        CALL FUNCTION 'SXV_EXIT_FOR_IMP'
          EXPORTING
            imp_name           = imp_name
          IMPORTING
            exit_name          = exit_name
          TABLES
            filters            = filters
          EXCEPTIONS
            data_inconsistency = 1
            OTHERS             = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'SXV_EXIT_FOR_IMP' sy-subrc.
        ENDIF.
        CALL FUNCTION 'SXO_BADI_READ'
          EXPORTING
            exit_name    = exit_name
          IMPORTING
            badi         = badi_info
            filter_obj   = filter_obj
          TABLES
            fcodes       = t_fcodes
            cocos        = t_cocos
            intas        = t_intas
            scrns        = t_scrns
            methods      = methods
          EXCEPTIONS
            read_failure = 1
            OTHERS       = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'SXO_BADI_READ' sy-subrc.
        ENDIF.
        inter_name = badi_info-inter_name.
        IF filter_obj IS BOUND.
          _d-impl_w_filter = badi_info-flt_ext.
          _d-filter_datatype = filter_obj->flt_type.
        ENDIF.
        CALL FUNCTION 'SXO_IMPL_FOR_BADI_READ'
          EXPORTING
            imp_name     = imp_name
            exit_name    = exit_name
            inter_name   = inter_name
            filter_obj   = filter_obj
          IMPORTING
            impl         = _d-implementation
            mast_langu   = _d-mast_langu
          TABLES
            fcodes       = _d-fcodes
            cocos        = _d-cocos
            intas        = _d-intas
            scrns        = _d-scrns
          CHANGING
            methods      = methods
          EXCEPTIONS
            read_failure = 1
            OTHERS       = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'SXO_IMPL_FOR_BADI_READ' sy-subrc.
        ENDIF.
        CALL FUNCTION 'SXV_EXIT_FOR_IMP'
          EXPORTING
            imp_name           = imp_name
          TABLES
            filters            = _d-filter_values
          EXCEPTIONS
            data_inconsistency = 1
            OTHERS             = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'SXV_EXIT_FOR_IMP' sy-subrc.
        ENDIF.
        CREATE OBJECT o_data.
        o_data->from_data( _d ).
        IF NOT o_data->a0_maindata-imp_class IS INITIAL AND f_subcomp >= sub_component-with_required.
          o_conn = zaplink_connectors=>create_connector( type = t_badi_impl ).
          IF o_conn IS BOUND.
            CREATE OBJECT _comp.
            _comp->set_type( t_badi_impl ).
            _name = o_data->a0_maindata-imp_class.
            _comp->set_name( _name ).
            o_data->implementation = o_conn->read_from_sap( _comp ).
            IF o_data->implementation IS BOUND.
              CLEAR o_data->a0_maindata-imp_class.
            ENDIF.
          ENDIF.
        ENDIF.
        CONCATENATE _name '*' INTO obj_mask.
        o_data->documentation = zaplink_documentation=>get( ids = r_doc_id_implementation
                                                         object = obj_mask ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_to_sap_def.
    DATA _d               TYPE zaplink_sxsd_data=>t_fm_data.
    DATA i_korrnr         TYPE trkorr.
    DATA i_devclass       TYPE devclass.
    DATA _component       TYPE to_component.
    DATA mast_langu       TYPE sy-langu.
    DATA o_conn           TYPE to_connector.
    DATA transport_key    TYPE trkey.
    TRY.
        IF o_data->interface IS BOUND.
          o_conn = zaplink_connectors=>create_connector( type = t_badi_itf ).
          IF o_conn IS BOUND.
            o_data->interface->type = t_badi_itf.
            components = o_conn->write_to_sap( o_data->interface ).
            IF components IS BOUND.
              components->init_iter( ).
              _component = components->get_next( ).
              WHILE _component IS BOUND.
                IF _component->get_type( ) = t_badi_itf.
                  o_data->a0_maindata-inter_name = _component->get_name( ).
                  EXIT.
                ENDIF.
                _component = components->get_next( ).
              ENDWHILE.
            ENDIF.
          ENDIF.
        ENDIF.
        _d = o_data->to_data( ).
        CALL FUNCTION 'SXO_BADI_SAVE'
          EXPORTING
            badi             = _d-definition
          IMPORTING
            mast_langu       = mast_langu
          TABLES
            fcodes_to_insert = _d-fcodes
            cocos_to_insert  = _d-cocos
            intas_to_insert  = _d-intas
            sscrs_to_insert  = _d-scrns
          CHANGING
            korrnum          = i_korrnr
            devclass         = i_devclass
          EXCEPTIONS
            save_failure     = 1
            action_canceled  = 2
            OTHERS           = 3.
        CASE sy-subrc.
          WHEN '0'.
          WHEN OTHERS.
            RAISE EXCEPTION TYPE zaplink_cx_connector
              EXPORTING
                textid = zaplink_cx_connector=>system_error.
        ENDCASE.
        IF mast_langu <> o_data->a0_maindata-mast_langu.
          transport_key-obj_name = o_data->a0_maindata-exit_name.
          CALL FUNCTION 'SXO_BADI_MAST_LANG_UPDATE'
            EXPORTING
              new_master_language = o_data->a0_maindata-mast_langu
              old_master_language = mast_langu
              transport_key       = transport_key
            EXCEPTIONS
              object_not_found    = 1
              OTHERS              = 2.
          IF sy-subrc <> 0.
          ENDIF.
        ENDIF.
        zaplink_documentation=>set( o_data->documentation ).
        CREATE OBJECT _component.
        _component->set_type( st_badi_def ).
        _component->set_name( o_data->a0_maindata-exit_name ).
        IF NOT components IS BOUND. CREATE OBJECT components. ENDIF.
        components->add( _component ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_to_sap_impl.
    DATA _d               TYPE zaplink_badi_data=>t_fm_data.
    DATA i_korrnr         TYPE trkorr.
    DATA i_devclass       TYPE devclass.
    DATA _component       TYPE to_component.
    DATA mast_langu       TYPE sy-langu.
    DATA o_conn           TYPE to_connector.
    DATA transport_key    TYPE trkey.
    DATA o_filter         TYPE REF TO cl_badi_flt_struct.
    DATA o_filter_val     TYPE REF TO cl_badi_flt_values_alv.
    DATA badi_data        TYPE badi_data.
    TRY.
        IF o_data->implementation IS BOUND.
          o_conn = zaplink_connectors=>create_connector( type = t_badi_impl ).
          IF o_conn IS BOUND.
            o_data->implementation->type = t_badi_impl.
            components = o_conn->write_to_sap( o_data->implementation ).
            IF components IS BOUND.
              components->init_iter( ).
              _component = components->get_next( ).
              WHILE _component IS BOUND.
                IF _component->get_type( ) = t_badi_impl.
                  o_data->a0_maindata-imp_class = _component->get_name( ).
                  EXIT.
                ENDIF.
                _component = components->get_next( ).
              ENDWHILE.
            ENDIF.
          ENDIF.
        ENDIF.
        _d = o_data->to_data( ).
        CALL FUNCTION 'SXO_BADI_READ'
          EXPORTING
            exit_name    = _d-implementation-exit_name
          IMPORTING
            badi         = badi_data
          EXCEPTIONS
            read_failure = 1
            OTHERS       = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'SXO_BADI_READ' sy-subrc.
        ENDIF.
        CREATE OBJECT o_filter
          EXPORTING
            filter_structure               = _d-filter_datatype
            extend                         = badi_data-flt_ext
          EXCEPTIONS
            ddic_object_not_active         = 1
            no_data_element                = 2
            domain_not_of_char             = 3
            domain_too_long                = 4
            filtertype_inadmissible        = 5
            shlp_inadmissible              = 6
            invalid_key_comb_of_val_table  = 7
            invalid_key_comb_of_text_table = 8
            wrong_table_class              = 9
            invalid_text_table             = 10
            no_value_table                 = 11
            no_text_table                  = 12
            checktable_existing            = 13
            no_domain                      = 14
            OTHERS                         = 15.
        IF sy-subrc <> 0.
        ENDIF.
        CREATE OBJECT o_filter_val
          EXPORTING
            filter_object = o_filter
            filter_values = _d-filter_values.
        CALL FUNCTION 'SXO_IMPL_SAVE'
          EXPORTING
            impl             = _d-implementation
            flt_ext          = _d-impl_w_filter
            flt_type         = _d-filter_datatype
            maint_langu      = _d-mast_langu
            filter_val_obj   = o_filter_val
          IMPORTING
            mast_langu       = mast_langu
          TABLES
            fcodes_to_insert = _d-fcodes
            cocos_to_insert  = _d-cocos
            intas_to_insert  = _d-intas
            sscrs_to_insert  = _d-scrns
          CHANGING
            korrnum          = i_korrnr
            devclass         = i_devclass
          EXCEPTIONS
            save_failure     = 1
            action_canceled  = 2
            OTHERS           = 3.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'SXO_IMPL_SAVE' sy-subrc.
        ENDIF.
        IF mast_langu <> o_data->a0_maindata-mast_langu.
          transport_key-obj_name = o_data->a0_maindata-exit_name.
          CALL FUNCTION 'SXO_IMPL_MAST_LANG_UPDATE'
            EXPORTING
              new_master_language = o_data->a0_maindata-mast_langu
              old_master_language = mast_langu
              transport_key       = transport_key
            EXCEPTIONS
              object_not_found    = 1
              OTHERS              = 2.
          IF sy-subrc <> 0.
            mac_add_mf_and_raise 'SXO_IMPL_MAST_LANG_UPDATE' sy-subrc.
          ENDIF.
        ENDIF.
        zaplink_documentation=>set( o_data->documentation ).
        IF NOT _d-implementation-active IS INITIAL.
          CALL FUNCTION 'SXO_IMPL_ACTIVE'
            EXPORTING
              imp_name                  = _d-implementation-imp_name
              no_dialog                 = seex_true
            EXCEPTIONS
              badi_not_existing         = 1
              imp_not_existing          = 2
              already_active            = 3
              data_inconsistency        = 4
              activation_not_admissable = 5
              action_canceled           = 6
              access_failure            = 7
              OTHERS                    = 8.
          IF sy-subrc <> 0.
            mac_add_mf_and_raise 'SXO_IMPL_ACTIVE' sy-subrc.
          ENDIF.
        ENDIF.
        CREATE OBJECT _component.
        _component->set_type( st_badi_impl ).
        _component->set_name( o_data->a0_maindata-exit_name ).
        IF NOT components IS BOUND. CREATE OBJECT components. ENDIF.
        components->add( _component ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~anonymize.
    DATA o_bdef TYPE to_badi_def.
    DATA o_impl TYPE to_badi_impl.
    CHECK object IS BOUND.
    CASE object->type.
      WHEN st_badi_def.
        o_bdef ?= object->raw.
        o_bdef->anonymize( ).
      WHEN st_badi_impl.
        o_impl ?= object->raw.
        o_impl->anonymize( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name object->type.
    ENDCASE.
    TRY.
        super->zaplink_cnx_ext_cleaner~anonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_conn   TYPE to_connector.
    DATA o_sxsd   TYPE to_badi_def.
    DATA o_sxci   TYPE to_badi_impl.
    DATA _type    TYPE td_comptype.
    CREATE OBJECT object.
    CASE type.
      WHEN st_badi_def.
        CREATE OBJECT o_sxsd.
        o_conn = zaplink_connectors=>create_connector( type = t_badi_itf ).
        IF o_conn IS BOUND.
          _type = t_badi_itf.
          o_sxsd->interface = o_conn->create_new_raw( _type ).
        ENDIF.
        object->raw = o_sxsd.
      WHEN st_badi_impl.
        CREATE OBJECT o_sxci.
        o_conn = zaplink_connectors=>create_connector( type = t_badi_impl ).
        IF o_conn IS BOUND.
          _type = t_badi_impl.
          o_sxci->implementation = o_conn->create_new_raw( _type ).
        ENDIF.
        object->raw = o_sxci.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA exit_name  TYPE rsexscrn-exit_name.
    DATA d_type     TYPE td_comptype.
    DATA d_name     TYPE td_compname.
    TRY.
        d_type = component->get_type( ).
        d_name = component->get_name( ).
        CASE d_type.
          WHEN st_badi_def.
            exit_name = d_name.
            CALL FUNCTION 'SXO_BADI_DELETE'
              EXPORTING
                exit_name          = exit_name
                no_dialog          = seex_true
              EXCEPTIONS
                badi_not_existing  = 1
                action_canceled    = 2
                access_failure     = 3
                data_inconsistency = 4
                OTHERS             = 5.
            IF sy-subrc <> 0.
              CASE sy-subrc.
                WHEN OTHERS.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>system_error.
              ENDCASE.
            ENDIF.
          WHEN st_badi_impl.
            exit_name = d_name.
            CALL FUNCTION 'SXO_IMPL_DELETE'
              EXPORTING
                imp_name           = exit_name
              EXCEPTIONS
                imp_not_existing   = 1
                action_canceled    = 2
                access_failure     = 3
                data_inconsistency = 4
                OTHERS             = 5.
            IF sy-subrc <> 0.
              CASE sy-subrc.
                WHEN OTHERS.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>system_error.
              ENDCASE.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    result = abap_true.
    zaplink_tools=>remove_comp_from_working_area( type = d_type
                                                  name = d_name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA exit_name  TYPE rsexscrn-exit_name.
    DATA imp_name   TYPE rsexscrn-imp_name.
    DATA d_type     TYPE td_comptype.
    TRY.
        exists = me->exists-not_exists.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN st_badi_def.
            exit_name = component->get_name( ).
            CALL FUNCTION 'SXV_EXIT_EXISTS'
              EXPORTING
                exit_name                   = exit_name
              EXCEPTIONS
                not_existing                = 1
                exit_interface_not_existing = 2
                category_conflict           = 3
                no_sxs_inter_entry          = 4
                OTHERS                      = 5.
            IF sy-subrc = 0.
              exists = me->exists-exists.
            ENDIF.
          WHEN st_badi_impl.
            imp_name = component->get_name( ).
            exists = do_exists_impl( imp_name ).
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.    result = abap_true.   ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    DATA o_bdef TYPE to_badi_def.
    DATA o_impl TYPE to_badi_impl.
    DATA d_type TYPE td_comptype.
    TRY.
        CREATE OBJECT object.
        object->set_component( component ).
        d_type = component->get_type( ).
        CASE d_type.
          WHEN st_badi_def.
            o_bdef = export_from_sap_def( component ).
            object->raw = o_bdef.
          WHEN st_badi_impl.
            o_impl = export_from_sap_impl( component ).
            object->raw = o_impl.
          WHEN OTHERS.
            CLEAR object.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        object->update_connector_data( me ).                    " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    DATA _o_def         TYPE to_badi_def.
    DATA _o_impl        TYPE to_badi_impl.
    DATA d_type         TYPE td_comptype.
    DATA o_comp         TYPE to_component.              " Issue 92
    TRY.
        d_type = object->type.
        CASE d_type.
          WHEN st_badi_def.
            _o_def ?= object->raw.
            _o_def->a0_maindata-exit_name = object->name.
            components = import_to_sap_def( _o_def ).
          WHEN st_badi_impl.
            _o_impl ?= object->raw.
            _o_impl->a0_maindata-imp_name = object->name.
            components = import_to_sap_impl( _o_impl ).
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ).    " Issue 92
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_BADI implementation
CLASS zaplink_badi_data IMPLEMENTATION.
  METHOD anonymize.
  ENDMETHOD.
  METHOD from_data.
    DATA _fc    LIKE LINE OF functions_codes.
    DATA _cc    LIKE LINE OF controls_composites.
    DATA _scr   LIKE LINE OF subscreens.
    DATA _t     LIKE LINE OF tables.
    FIELD-SYMBOLS:
      <fc>  LIKE LINE OF fm_data-fcodes,
      <cc>  LIKE LINE OF fm_data-cocos,
      <in>  LIKE LINE OF fm_data-intas,
      <scr> LIKE LINE OF fm_data-scrns,
      <it>  LIKE LINE OF fm_data-inactive_tabstrips.
    LOOP AT fm_data-fcodes ASSIGNING <fc>
      WHERE exit_name = def_name.
      CLEAR _fc.
      _fc = <fc>.
      CLEAR: _fc-exit_name. " VERSION
      INSERT _fc INTO TABLE functions_codes.
    ENDLOOP.
    LOOP AT fm_data-cocos ASSIGNING <cc>
      WHERE exit_name = def_name.
      CLEAR _cc.
      _cc = <cc>.
      CLEAR: _cc-exit_name. " VERSION
      INSERT _cc INTO TABLE controls_composites.
    ENDLOOP.
    LOOP AT fm_data-intas ASSIGNING <in>
      WHERE exit_name = def_name.
      CLEAR _t.
      _t = <in>.
      CLEAR: _t-exit_name. " VERSION
      INSERT _t INTO TABLE tables.
    ENDLOOP.
    LOOP AT fm_data-scrns ASSIGNING <scr>
      WHERE exit_name = def_name.
      CLEAR _scr.
      _scr = <scr>.
      CLEAR: _scr-exit_name. " VERSION
      INSERT _scr INTO TABLE subscreens.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA _in  LIKE LINE OF fm_data-intas.
    DATA _cc  LIKE LINE OF fm_data-cocos.
    DATA _fc  LIKE LINE OF fm_data-fcodes.
    DATA _scr LIKE LINE OF fm_data-scrns.
    FIELD-SYMBOLS:
      <t>   LIKE LINE OF tables,
      <scr> LIKE LINE OF subscreens,
      <fc>  LIKE LINE OF functions_codes,
      <cc>  LIKE LINE OF controls_composites.
    LOOP AT functions_codes ASSIGNING <fc>.
      CLEAR _fc.
      _fc = <fc>.
      _fc-exit_name = def_name.
      INSERT _fc INTO TABLE fm_data-fcodes.
    ENDLOOP.
    LOOP AT controls_composites ASSIGNING <cc>.
      CLEAR _cc.
      _cc = <cc>.
      _cc-exit_name = def_name.
      INSERT _cc INTO TABLE fm_data-cocos.
    ENDLOOP.
    LOOP AT tables ASSIGNING <t>.
      CLEAR _in.
      _in = <t>.
      _in-exit_name = def_name.
      INSERT _in INTO TABLE fm_data-intas.
    ENDLOOP.
    LOOP AT subscreens ASSIGNING <scr>.
      CLEAR _scr.
      _scr = <scr>.
      _scr-exit_name = def_name.
      INSERT _scr INTO TABLE fm_data-scrns.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_BADI_DATA implementation
CLASS zaplink_checkpoints IMPLEMENTATION.
  METHOD class_constructor.
    supportedkinds-checkpoint =  zaplink_connectors=>get_typekind( supportedtypes-checkpoint ).
    supportedkinds-variant =  zaplink_connectors=>get_typekind( supportedtypes-variant ).
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.
    type-type = supportedtypes-checkpoint.    INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-variant.       INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~anonymize.
    DATA o_checkpoint    TYPE to_checkpoint.
    CHECK object IS BOUND.
    CASE object->type.
      WHEN supportedtypes-checkpoint.
        o_checkpoint ?= object->raw.
        o_checkpoint->anonymize( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name object->type.
    ENDCASE.
    TRY.
        super->zaplink_cnx_ext_cleaner~anonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~unanonymize.
    DATA o_checkpoint    TYPE to_checkpoint.
    CHECK object IS BOUND.
    CASE object->type.
      WHEN supportedtypes-checkpoint.
        o_checkpoint ?= object->raw.
        o_checkpoint->unanonymize( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name object->type.
    ENDCASE.
    TRY.
        super->zaplink_cnx_ext_cleaner~unanonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_code_signature~get_signature.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_checkpoint   TYPE to_checkpoint.
    DATA o_variant      TYPE to_variant.
    CASE type.
      WHEN supportedtypes-checkpoint.
        CREATE OBJECT object.
        CREATE OBJECT o_checkpoint.
        object->raw = o_checkpoint.
      WHEN supportedtypes-variant.
        CREATE OBJECT object.
        CREATE OBJECT o_variant.
        object->raw = o_variant.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA o_checkpoint   TYPE REF TO cl_aab_id.
    DATA d_checkpoint   TYPE td_checkpoint.
    DATA state          TYPE flag.
    DATA o_variant      TYPE REF TO cl_aab_variant.
    DATA type           TYPE td_comptype.
    DATA name           TYPE td_compname.
    DATA s_variant      TYPE zaplink_avar_data=>ts_name.
    TRY.
        type = component->get_type( ).
        CASE type.
          WHEN supportedtypes-checkpoint.
            d_checkpoint = name = component->get_name( ).
            CREATE OBJECT o_checkpoint
              EXPORTING
                im_name          = d_checkpoint
              EXCEPTIONS
                name_not_allowed = 1
                OTHERS           = 2.
            IF sy-subrc <> 0.
              RAISE EXCEPTION TYPE zaplink_cx_connector
                EXPORTING
                  textid = zaplink_cx_connector=>not_found
                  type   = type
                  name   = name.
            ENDIF.
            CALL METHOD o_checkpoint->enqueue
              EXCEPTIONS
                cts_error    = 1
                foreign_lock = 2
                system_error = 3
                OTHERS       = 4.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_checkpoint 'ENQUEUE' sy-subrc.
            ENDIF.
            CALL METHOD o_checkpoint->delete
              EXCEPTIONS
                act_error        = 1
                cts_devclass     = 2
                cts_error        = 3
                id_not_found     = 4
                id_still_used    = 5
                no_authorization = 6
                propt_error      = 7
                prop_error       = 8
                where_used_error = 9
                OTHERS           = 10.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_checkpoint 'DELETE' sy-subrc.
            ENDIF.
          WHEN supportedtypes-variant.
            name = component->get_name( ).
            s_variant = zaplink_avar_data=>name_2_key( name ).
            CREATE OBJECT o_variant
              EXPORTING
                im_name          = s_variant-name
                im_local         = s_variant-user
              EXCEPTIONS
                name_not_allowed = 1
                no_authorization = 2
                user_not_valid   = 3
                OTHERS           = 4.
            IF sy-subrc <> 0.
              mac_add_name_meth_and_raise 'cl_aab_variant' 'CONSTRUCTOR' sy-subrc 'ZAPLINK_CX_CONNECTOR'.
            ENDIF.
            CALL METHOD o_variant->delete
              EXCEPTIONS
                cts_devclass     = 1
                cts_error        = 2
                no_authorization = 3
                prop_error       = 4
                propt_error      = 5
                var_id_error     = 6
                var_not_found    = 7
                OTHERS           = 8.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_variant 'DELETE' sy-subrc.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    result = abap_true.
    zaplink_tools=>remove_comp_from_working_area( type = type
                                                  name = name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA o_checkpoint   TYPE REF TO cl_aab_id.
    DATA d_checkpoint   TYPE td_checkpoint.
    DATA state          TYPE flag.
    DATA o_variant      TYPE REF TO cl_aab_variant.
    DATA type           TYPE td_comptype.
    DATA name           TYPE td_compname.
    DATA s_variant      TYPE zaplink_avar_data=>ts_name.
    exists = me->exists-not_exists.
    TRY.
        type = component->get_type( ).
        CASE type.
          WHEN supportedtypes-checkpoint.
            d_checkpoint = component->get_name( ).
            CREATE OBJECT o_checkpoint
              EXPORTING
                im_name          = d_checkpoint
              EXCEPTIONS
                name_not_allowed = 1
                OTHERS           = 2.
            IF sy-subrc <> 0.
              mac_add_name_meth_and_raise 'cl_aab_variant' 'CONSTRUCTOR' sy-subrc 'ZAPLINK_CX_CONNECTOR'.
            ELSE.
              o_checkpoint->get_state( IMPORTING ex_state = state ).
              IF NOT state IS INITIAL.     exists = me->exists-exists.     ENDIF.
            ENDIF.
          WHEN supportedtypes-variant.
            name = component->get_name( ).
            s_variant = zaplink_avar_data=>name_2_key( name ).
            CREATE OBJECT o_variant
              EXPORTING
                im_name          = s_variant-name
                im_local         = s_variant-user
              EXCEPTIONS
                name_not_allowed = 1
                no_authorization = 2
                user_not_valid   = 3
                OTHERS           = 4.
            IF sy-subrc <> 0.
              mac_add_name_meth_and_raise 'cl_aab_variant' 'CONSTRUCTOR' sy-subrc 'ZAPLINK_CX_CONNECTOR'.
            ELSE.
              o_variant->get_state( IMPORTING ex_state = state ).
              IF NOT state IS INITIAL.     exists = me->exists-exists.     ENDIF.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.
      result = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    DATA o_aab_id         TYPE REF TO cl_aab_id.
    DATA o_checkpoint     TYPE to_checkpoint.
    DATA s_fmd_acid       TYPE ts_fmd_acid.
    DATA type             TYPE td_comptype.
    DATA name             TYPE td_compname.
    DATA l_mode           TYPE aab_id_mode.
    DATA l_tstamp         TYPE aab_id_act-act_tstamp.
    DATA o_aab_variant    TYPE REF TO cl_aab_variant.
    DATA o_variant        TYPE to_variant.
    DATA s_variant        TYPE zaplink_avar_data=>ts_name.
    DATA s_fmd_avar       TYPE ts_fmd_avar.
    TRY.
        type = component->get_type( ).
        CREATE OBJECT object.
        object->set_component( component ).
        CASE type.
          WHEN supportedtypes-checkpoint.
            s_fmd_acid-header-name = name = component->get_name( ).
            CREATE OBJECT o_aab_id
              EXPORTING
                im_name          = s_fmd_acid-header-name
              EXCEPTIONS
                name_not_allowed = 1
                OTHERS           = 2.
            IF sy-subrc <> 0.
              RAISE EXCEPTION TYPE zaplink_cx_connector
                EXPORTING
                  textid = zaplink_cx_connector=>not_found
                  type   = type
                  name   = name.
            ENDIF.
            SELECT * INTO TABLE s_fmd_acid-descriptions
              FROM aab_id_propt
              WHERE name = s_fmd_acid-header-name.
            CALL METHOD o_aab_id->get_all_modes
              IMPORTING
                ex_modes_tab  = s_fmd_acid-modes
              EXCEPTIONS
                no_mode_found = 1
                system_error  = 2
                OTHERS        = 3.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_aab_id 'GET_ALL_MODES' sy-subrc.
            ENDIF.
            CREATE OBJECT o_checkpoint.
            o_checkpoint->from_data( s_fmd_acid ).
            CLEAR s_fmd_acid-header-name.
            object->raw = o_checkpoint.
          WHEN supportedtypes-variant.
            name = component->get_name( ).
            s_variant = zaplink_avar_data=>name_2_key( name ).
            s_fmd_avar-header-name = s_variant-name.
            s_fmd_avar-header-local = s_variant-user.
            CREATE OBJECT o_aab_variant
              EXPORTING
                im_name          = s_fmd_avar-header-name
                im_local         = s_fmd_avar-header-local
              EXCEPTIONS
                name_not_allowed = 1
                no_authorization = 2
                user_not_valid   = 3
                OTHERS           = 4.
            IF sy-subrc <> 0.
              mac_add_name_meth_and_raise 'cl_aab_variant' 'CONSTRUCTOR' sy-subrc 'ZAPLINK_CX_CONNECTOR'.
            ENDIF.
            SELECT * INTO TABLE s_fmd_avar-descriptions
              FROM aab_var_propt
              WHERE name = s_fmd_avar-header-name
               AND local = s_fmd_avar-header-local.
            CALL METHOD o_aab_variant->get_ids
              IMPORTING
                ex_ids       = s_fmd_avar-modes
              EXCEPTIONS
                id_not_valid = 1
                OTHERS       = 2.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_aab_variant 'GET_IDS' sy-subrc.
            ENDIF.
            CREATE OBJECT o_variant.
            o_variant->from_data( s_fmd_avar ).
            CLEAR: s_fmd_avar-header-name, s_fmd_avar-header-local.
            object->raw = o_variant.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        object->update_connector_data( me ).                    " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    DATA o_aab_id         TYPE REF TO cl_aab_id.
    DATA o_checkpoint     TYPE to_checkpoint.
    DATA s_fmd_acid       TYPE ts_fmd_acid.
    DATA o_variant        TYPE to_variant.
    DATA s_fmd_avar       TYPE ts_fmd_avar.
    DATA _comp            TYPE to_component.
    DATA s_desc           LIKE LINE OF s_fmd_acid-descriptions.
    DATA d_nb_err         TYPE i.
    DATA lt_modes         TYPE aab_id_act_tab.
    DATA o_aab_variant    TYPE REF TO cl_aab_variant.
    DATA s_variant        TYPE zaplink_avar_data=>ts_name.
    DATA s_var_desc       LIKE LINE OF s_fmd_avar-descriptions.
    DATA lt_var_modes     TYPE aab_var_obj_act_tab.
    FIELD-SYMBOLS:
      <o> LIKE LINE OF lt_modes,
      <v> LIKE LINE OF lt_var_modes,
      <w> LIKE LINE OF s_fmd_avar-modes,
      <m> LIKE LINE OF s_fmd_acid-modes.
    TRY.
        CREATE OBJECT components.
        CASE object->type.
          WHEN supportedtypes-variant.
            o_variant ?= object->raw.   s_variant = object->name.
            o_variant->a0_maindata-name = s_variant-name.     o_variant->a0_maindata-local = s_variant-user.
            s_fmd_avar = o_variant->to_data( ).
            CREATE OBJECT o_aab_variant
              EXPORTING
                im_name          = s_variant-name
                im_local         = s_variant-user
              EXCEPTIONS
                name_not_allowed = 1
                no_authorization = 2
                user_not_valid   = 3
                OTHERS           = 4.
            IF sy-subrc <> 0.
              mac_add_name_meth_and_raise 'cl_aab_variant' 'CONSTRUCTOR' sy-subrc 'ZAPLINK_CX_CONNECTOR'.
            ENDIF.
            CALL METHOD o_aab_variant->enqueue
              EXPORTING
                enqueue_mode = 'E'
              EXCEPTIONS
                cts_error    = 1
                foreign_lock = 2
                system_error = 3
                OTHERS       = 4.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_aab_variant 'ENQUEUE' sy-subrc.
            ENDIF.
            CALL METHOD o_aab_variant->get_ids
              IMPORTING
                ex_ids       = lt_var_modes
              EXCEPTIONS
                id_not_valid = 1
                OTHERS       = 2.
            IF sy-subrc = 0.
              LOOP AT lt_var_modes ASSIGNING <v>.
                READ TABLE s_fmd_avar-modes TRANSPORTING NO FIELDS WITH KEY
                    name = <v>-name
                  object = <v>-object.
                CHECK sy-subrc <> 0.
                CALL METHOD o_aab_variant->del_id
                  EXPORTING
                    im_name          = <v>-name
                    im_object        = <v>-object
                  EXCEPTIONS
                    id_not_found     = 0
                    no_authorization = 2
                    OTHERS           = 3.
                IF sy-subrc <> 0.
                  mac_add_obj_meth_and_raise o_aab_variant 'DEL_ID' sy-subrc.
                ENDIF.
              ENDLOOP.
            ENDIF.
            LOOP AT s_fmd_avar-modes ASSIGNING <w>.
              CALL METHOD o_aab_variant->set_id
                EXPORTING
                  im_name              = <w>-name
                  im_object            = <w>-object
                  im_actmode           = <w>-actmode
                EXCEPTIONS
                  id_not_exists        = 1
                  id_not_transportable = 2
                  no_authorization     = 3
                  OTHERS               = 4.
              IF sy-subrc <> 0.
                mac_add_obj_meth_and_raise o_aab_variant 'SET_ID' sy-subrc.
              ENDIF.
            ENDLOOP.
            READ TABLE s_fmd_avar-descriptions INTO s_var_desc WITH KEY langu = sy-langu.
            IF sy-subrc <> 0.     READ TABLE s_fmd_avar-descriptions INTO s_var_desc INDEX 1.     ENDIF.
            IF sy-subrc <> 0.     s_var_desc-descript = s_variant-name.     ENDIF.
            CALL METHOD o_aab_variant->set_descript
              EXPORTING
                im_descript      = s_var_desc-descript
              EXCEPTIONS
                no_authorization = 1
                OTHERS           = 2.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_aab_variant 'SET_DESCRIPT' sy-subrc.
            ENDIF.
            CALL METHOD o_aab_variant->save
              EXCEPTIONS
                cts_error             = 1
                no_changes_found      = 2
                no_descript_specified = 3
                prop_error            = 4
                propt_error           = 5
                var_id_error          = 6
                OTHERS                = 7.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_aab_variant 'SAVE' sy-subrc.
            ENDIF.
            DELETE FROM aab_var_propt WHERE name = s_fmd_avar-header-name
                                       AND local = s_fmd_avar-header-local.
            s_var_desc-name = s_variant-name.     s_var_desc-local = s_variant-user.
            MODIFY s_fmd_avar-descriptions FROM s_var_desc TRANSPORTING name local WHERE name IS INITIAL OR name IS NOT INITIAL.
            INSERT aab_var_propt FROM TABLE s_fmd_avar-descriptions.
            CALL METHOD o_aab_variant->dequeue
              EXPORTING
                dequeue_mode = 'E'.
          WHEN supportedtypes-checkpoint.
            o_checkpoint ?= object->raw.
            o_checkpoint->a0_maindata-name = object->name.
            s_fmd_acid = o_checkpoint->to_data( ).
            s_fmd_acid-header-name = object->name.
            CREATE OBJECT o_aab_id
              EXPORTING
                im_name          = s_fmd_acid-header-name
              EXCEPTIONS
                name_not_allowed = 1
                OTHERS           = 2.
            IF sy-subrc <> 0.
              mac_add_name_meth_and_raise 'cl_aab_id' 'CONSTRUCTOR' sy-subrc 'ZAPLINK_CX_CONNECTOR'.
            ENDIF.
            CALL METHOD o_aab_id->enqueue
              EXPORTING
                enqueue_mode = 'E'
                no_cts       = space
              EXCEPTIONS
                cts_error    = 1
                foreign_lock = 2
                system_error = 3
                OTHERS       = 4.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_aab_id 'ENQUEUE' sy-subrc.
            ENDIF.
            CALL METHOD o_aab_id->get_all_modes
              IMPORTING
                ex_modes_tab  = lt_modes
              EXCEPTIONS
                no_mode_found = 1
                OTHERS        = 2.
            IF sy-subrc = 0.
              LOOP AT lt_modes ASSIGNING <o>.
                READ TABLE s_fmd_acid-modes TRANSPORTING NO FIELDS WITH KEY
                  username = <o>-username
                  server = <o>-server
                  is_program = <o>-is_program
                  actdefault = <o>-actdefault.
                CHECK sy-subrc <> 0.
                CALL METHOD o_aab_id->delete_mode
                  EXPORTING
                    im_user           = <o>-username
                    im_server         = <o>-server
                    im_actdefault     = <o>-actdefault
                    im_delete_from_db = space
                  EXCEPTIONS
                    no_mode_found     = 0
                    no_authorization  = 2
                    act_error         = 1
                    OTHERS            = 4.
                IF sy-subrc <> 0.
                  mac_add_obj_meth_and_raise o_aab_id 'DELETE_MODE' sy-subrc.
                ENDIF.
              ENDLOOP.
            ENDIF.
            LOOP AT s_fmd_acid-modes ASSIGNING <m>.
              CALL METHOD o_aab_id->set_mode
                EXPORTING
                  im_user            = <m>-username
                  im_server          = <m>-server
                  im_actdefault      = <m>-actdefault
                  im_mode            = <m>-actmode
                IMPORTING
                  ex_nr_of_conflicts = d_nb_err
                EXCEPTIONS
                  no_authorization   = 1
                  OTHERS             = 2.
              IF sy-subrc <> 0.
                mac_add_obj_meth_and_raise o_aab_id 'SET_MODE' sy-subrc.
              ELSEIF d_nb_err <> 0.
              ENDIF.
            ENDLOOP.
            CALL METHOD o_aab_id->save
              EXCEPTIONS
                act_error             = 1
                cts_error             = 2
                no_changes_found      = 3
                no_descript_specified = 4
                prop_error            = 5
                propt_error           = 6
                sync_attributes_error = 7
                OTHERS                = 8.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_aab_id 'SAVE' sy-subrc.
            ENDIF.
            DELETE FROM aab_id_propt WHERE name = s_fmd_acid-header-name.
            s_desc-name = s_fmd_acid-header-name.   MODIFY s_fmd_acid-descriptions FROM s_desc TRANSPORTING name WHERE name <> s_fmd_acid-header-name.
            INSERT aab_id_propt FROM TABLE s_fmd_acid-descriptions.
            CALL METHOD o_aab_id->dequeue
              EXPORTING
                dequeue_mode = 'E'.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name object->type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ). " Issue 92
      CATCH zaplink_cx_connector INTO o_mycx.
        ROLLBACK WORK.
        RAISE EXCEPTION o_mycx.
      CATCH zaplink_cx INTO o_cx.
        ROLLBACK WORK.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CHECKPOINTS implementation
CLASS zaplink_clas_data IMPLEMENTATION.
  METHOD anonymize.
    DATA s_fr LIKE LINE OF friends.
    DATA s_re LIKE LINE OF redefinitions.
    super->anonymize( ).
    CLEAR: a0_maindata-author, a0_maindata-createdon, a0_maindata-changedby, a0_maindata-changedon, a0_maindata-chgdanyby, a0_maindata-chgdanyon, a0_maindata-r3release,
      a0_maindata-inheritance-author, a0_maindata-inheritance-createdon, a0_maindata-inheritance-changedby, a0_maindata-inheritance-changedon, a0_maindata-inheritance-version. " Issue 75
    MODIFY friends FROM s_fr TRANSPORTING author createdon changedby changedon version " Issue 75
           WHERE NOT refclsname IS INITIAL OR refclsname IS INITIAL. " Issue 68
    MODIFY redefinitions FROM s_re TRANSPORTING version       " Issue 75
           WHERE NOT refclsname IS INITIAL OR refclsname IS INITIAL.
  ENDMETHOD.
  METHOD class_constructor.
    c_kind = zaplink_connectors=>get_typekind( c_type ).
    CONCATENATE 'begin of #NAME#,' cl_abap_char_utilities=>cr_lf
  '      msgid type symsgid value ''#CLASS#'',' cl_abap_char_utilities=>cr_lf
  '      msgno type symsgno value ''#NUMBER#'',' cl_abap_char_utilities=>cr_lf
  '      attr1 type scx_attrname value ''#A1#'',' cl_abap_char_utilities=>cr_lf
  '      attr2 type scx_attrname value ''#A2#'',' cl_abap_char_utilities=>cr_lf
  '      attr3 type scx_attrname value ''#A3#'',' cl_abap_char_utilities=>cr_lf
  '      attr4 type scx_attrname value ''#A4#'',' cl_abap_char_utilities=>cr_lf
  '    end of #NAME#'
        INTO message_cx_type_source.
  ENDMETHOD.
  METHOD complete_data.
    DATA _val TYPE seovalue.
    DATA _sotr LIKE LINE OF fm_data-exceptions_texts.
    DATA _text TYPE STANDARD TABLE OF sotr_text.
    DATA _attr_text LIKE LINE OF fm_data-component_desc.
    FIELD-SYMBOLS:
      <pt> LIKE LINE OF fm_data-component_desc,
      <st> LIKE LINE OF _sotr-texts,
      <a>  LIKE LINE OF fm_data-attributes.
    obj_name = fm_data-class-clsname.                         " Issue 23
    CALL METHOD super->complete_data
      CHANGING
        fm_data = fm_data.
    IF fm_data-class-category = '40'.  " 40 Exception Class
      LOOP AT fm_data-attributes ASSIGNING <a>
           WHERE attdecltyp = '2'   " Constant
             AND locked = abap_true
             AND type = 'SOTR_CONC'
             AND NOT attvalue IS INITIAL.
        CLEAR _sotr. _sotr-cmpname = <a>-cmpname.
        _sotr-concept = value2sotr( <a>-attvalue ).
        SELECT SINGLE concept_2 INTO _sotr-lhdr-concept
          FROM sotr_link
          WHERE concept_1 = _sotr-concept.
        IF sy-subrc = 0.
          SELECT SINGLE * INTO _sotr-lhdr
            FROM sotr_headu
            WHERE concept = _sotr-lhdr-concept.
          SELECT * INTO TABLE _sotr-longtexts
            FROM sotr_textu
            WHERE concept = _sotr-lhdr-concept.
        ENDIF.
        CALL FUNCTION 'SOTR_GET_CONCEPT'
          EXPORTING
            concept        = _sotr-concept
          IMPORTING
            header         = _sotr-hdr
          TABLES
            entries        = _text
          EXCEPTIONS
            no_entry_found = 1
            OTHERS         = 2.
        IF sy-subrc <> 0.
          CLEAR: _sotr, _val, _text.
          CONTINUE.
        ENDIF.
        _sotr-texts = _text.
        _sotr-cmpname = <a>-cmpname.
        INSERT _sotr INTO TABLE fm_data-exceptions_texts.
        LOOP AT _sotr-texts ASSIGNING <st>
             WHERE NOT text IS INITIAL.
          READ TABLE fm_data-component_desc ASSIGNING <pt>
               WITH KEY cmpname = <a>-cmpname
                          langu = <st>-langu.
          IF sy-subrc = 0.
            IF <pt>-descript IS INITIAL.
              <pt>-descript = <st>-text.
            ENDIF.
          ELSE.
            MOVE-CORRESPONDING <a> TO _attr_text.
            _attr_text-langu = <st>-langu.
            _attr_text-descript = <st>-text.
            INSERT _attr_text INTO TABLE fm_data-component_desc.
          ENDIF.
        ENDLOOP.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD conv_source.
    DATA linecount TYPE i.
    DATA d_line LIKE LINE OF source.                          " Issue 68
    FIELD-SYMBOLS: <l> LIKE LINE OF source.
    IF NOT source IS INITIAL.
      linecount = lines( source ).
      IF linecount > 1.
        READ TABLE source INTO d_line INDEX linecount.
        CONDENSE d_line.    " '   ENDMETHOD.' will also be removed
        IF d_line CP 'ENDMETHOD+.*' OR d_line CP 'ENDMETHOD.*'.
          DELETE source INDEX linecount.
        ENDIF.
      ENDIF.
      READ TABLE source INTO d_line INDEX 1.
      CONDENSE d_line.
      IF d_line CP 'METHOD *'.                            "#EC SYNTCHAR
        DELETE source INDEX 1.
      ENDIF.
      IF NOT source IS INITIAL.
        linecount = lines( source ).
        READ TABLE source ASSIGNING <l> INDEX linecount.
        WHILE <l> IS INITIAL.
          DELETE source INDEX linecount.
          linecount = lines( source ).
          READ TABLE source ASSIGNING <l> INDEX linecount.
          IF NOT <l> IS ASSIGNED.   EXIT.   ENDIF.
        ENDWHILE.
      ENDIF.
    ENDIF.
    result = zaplink_object=>conv_abap_raw2source( source ).
  ENDMETHOD.
  METHOD from_data.
    DATA _in  LIKE LINE OF interfaces.
    DATA _ia  LIKE LINE OF _in-components.
    DATA _t   LIKE LINE OF a0_maindata-texts.
    DATA _fr  LIKE LINE OF friends.
    DATA _re  LIKE LINE OF me->redefinitions.
    DATA _me  LIKE LINE OF methods.
    DATA _dep LIKE LINE OF _dependencies.
    DATA _mk  TYPE seocpdkey.
    DATA _source TYPE zaplink_program=>ts_source.
    FIELD-SYMBOLS:
      <dc> LIKE LINE OF deferred-classes,
      <di> LIKE LINE OF deferred-interfaces,
      <m_> LIKE LINE OF fm_data-includes-methods,
      <im> LIKE LINE OF fm_data-implementings,
      <ei> LIKE LINE OF fm_data-explore_implementings,
      <ic> LIKE LINE OF <ei>-comprisings,
      <rd> LIKE LINE OF fm_data-impl_details,
      <me> LIKE LINE OF methods,
      <fr> LIKE LINE OF fm_data-friendships,
      <re> LIKE LINE OF fm_data-redefinitions.
    FIELD-SYMBOLS:
      <cx>  LIKE LINE OF fm_data-exceptions_texts,
      <cxt> LIKE LINE OF <cx>-texts,
      <cxl> LIKE LINE OF <cx>-longtexts,
      <at>  LIKE LINE OF fm_data-attributes.
    DATA _cx_text  LIKE LINE OF exceptions_texts.
    DATA _sotr_key TYPE sotr_conc.
    DATA _text     LIKE LINE OF _cx_text-texts.
    DATA _fm_data  TYPE t_fm_data.
    DATA s_txt  LIKE LINE OF a0_maindata-texts.
    DATA s_key  TYPE ts_doc_key.
    DATA t_tokens       TYPE STANDARD TABLE OF stokes.
    DATA t_statements   TYPE STANDARD TABLE OF sstmnt.
    DATA d_field        TYPE string.
    DATA d_is_ok        TYPE abap_bool.
    DATA d_len          TYPE i.
    FIELD-SYMBOLS:
      <st> LIKE LINE OF t_statements,
      <tk> LIKE LINE OF t_tokens.
    a0_maindata-hdr = fm_data-class.
    obj_name = a0_maindata-clsname.
    obj_version = a0_maindata-version.
    obj_langu = a0_maindata-langu.
    obj_type = c_type.
    CLEAR a0_maindata-uuid.                                   " Issue 59
    a0_maindata-inheritance = fm_data-inheritance.
    CLEAR a0_maindata-inheritance-clsname.
    a0_maindata-texts = fd_text( descriptions  = fm_data-class_desc
                                     classname = obj_name
                                            id = doc_ids-class-header
                                 documentation = fm_data-documentation ).
    IF NOT a0_maindata-texts IS INITIAL. CLEAR a0_maindata-descript. ENDIF.
    _fm_data = fm_data.
    IF fm_data-class-category = seoc_category_exception.
      DELETE _fm_data-methods
             WHERE clsname = obj_name
               AND cmpname = 'CONSTRUCTOR'.    " Auto generated
      READ TABLE _fm_data-implementings TRANSPORTING NO FIELDS WITH KEY refclsname = intf_4_message_exception_cl.
      IF sy-subrc = 0.      " Message based Exception
        LOOP AT _fm_data-attributes ASSIGNING <at>
             WHERE clsname = obj_name
               AND attdecltyp = '2'   " Constant
               AND locked = abap_true
               AND typtype = '4'
               AND type = ''
               AND NOT typesrc IS INITIAL.
          CLEAR _cx_text.   MOVE-CORRESPONDING <at> TO _cx_text.
          SCAN ABAP-SOURCE  <at>-typesrc TOKENS INTO t_tokens
                                     STATEMENTS INTO t_statements.
          ASSERT sy-subrc = 0.
          CHECK lines( t_statements ) = 8.
          d_is_ok = abap_true.
          LOOP AT t_statements ASSIGNING <st> FROM 2 TO 7.
            CASE sy-tabix.
              WHEN 2.   d_field = message_based_fields-class.
              WHEN 3.   d_field = message_based_fields-number.
              WHEN 4.   d_field = message_based_fields-attribut_1.
              WHEN 5.   d_field = message_based_fields-attribut_2.
              WHEN 6.   d_field = message_based_fields-attribut_3.
              WHEN 7.   d_field = message_based_fields-attribut_4.
              WHEN OTHERS.
                ASSERT sy-tabix >= 2 AND sy-tabix <= 7.
            ENDCASE.
            ADD 1 TO <st>-from.   " CRLF is the first token
            READ TABLE t_tokens ASSIGNING <tk> INDEX <st>-from.
            TRANSLATE <tk>-str TO UPPER CASE.   TRANSLATE d_field TO UPPER CASE.
            IF <tk>-str <> d_field.
              CLEAR d_is_ok.
              EXIT.
            ENDIF.
            READ TABLE t_tokens ASSIGNING <tk> INDEX <st>-to.
            d_len = strlen( <tk>-str ) - 2.
            ASSERT  d_len >= 0.
            <tk>-str = <tk>-str+1(d_len).    " 'ZAPLINK_DEVTOOLS' => ZAPLINK_DEVTOOLS
            CASE d_field.
              WHEN message_based_fields-class.        _cx_text-message-class = <tk>-str.
              WHEN message_based_fields-number.       _cx_text-message-number = <tk>-str.
              WHEN message_based_fields-attribut_1.   _cx_text-message-attribut_1 = <tk>-str.
              WHEN message_based_fields-attribut_2.   _cx_text-message-attribut_2 = <tk>-str.
              WHEN message_based_fields-attribut_3.   _cx_text-message-attribut_3 = <tk>-str.
              WHEN message_based_fields-attribut_4.   _cx_text-message-attribut_4 = <tk>-str.
              WHEN OTHERS.
                ASSERT d_field IS INITIAL.
            ENDCASE.
          ENDLOOP.
          CHECK d_is_ok = abap_true.
          INSERT _cx_text INTO TABLE exceptions_texts.
          DELETE _fm_data-attributes.                 " exception text no logner an attribute
        ENDLOOP.
      ELSE.     " Standard Exception
        LOOP AT _fm_data-attributes ASSIGNING <at>
             WHERE clsname = obj_name
               AND attdecltyp = '2'   " Constant
               AND locked = abap_true
               AND typtype = '1'
               AND type = 'SOTR_CONC'
               AND NOT attvalue IS INITIAL.
          CLEAR _cx_text.   MOVE-CORRESPONDING <at> TO _cx_text. " Issue 71.
          READ TABLE fm_data-exceptions_texts ASSIGNING <cx>
               WITH TABLE KEY cmpname = _cx_text-cmpname.
          IF sy-subrc = 0.
            LOOP AT <cx>-texts ASSIGNING <cxt>.       " Short & Long texts
              CLEAR _text.
              _text-langu = <cxt>-langu.
              _text-short_txt = <cxt>-text.
              READ TABLE <cx>-longtexts ASSIGNING <cxl>
                   WITH KEY langu = _text-langu.
              IF sy-subrc = 0.    " has long texts
                _text-long_txt-_ = <cxl>-text.
                REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=>cr_lf IN _text-long_txt-_ WITH cl_abap_char_utilities=>newline.   " Issue 63 : Text has CR & CR+LF
              ENDIF.
              INSERT _text INTO TABLE _cx_text-texts.
            ENDLOOP.
          ENDIF.
          IF <at>-cmpname = a0_maindata-clsname. CLEAR _cx_text-cmpname. ENDIF.  " do not repeat self exception text : Issue 64
          INSERT _cx_text INTO TABLE exceptions_texts.
          DELETE _fm_data-attributes.                 " exception text no logner an attribute
        ENDLOOP.
      ENDIF.
    ENDIF.
    CALL METHOD super->from_data
      EXPORTING
        fm_data = _fm_data.
    dynpros = _fm_data-dynpros.
    menupainter = _fm_data-menupainter.
    textspool = _fm_data-textspool.
    local-types-_ = conv_source( fm_data-includes-ccdef-raw_source ).
    local-implementations-_ = conv_source( fm_data-includes-ccimp-raw_source ).
    local-macros-_ = conv_source( fm_data-includes-ccmac-raw_source ).
    local-local_test_class-_ = conv_source( fm_data-includes-localtestclass-raw_source ). " Issue 82
    LOOP AT fm_data-implementings ASSIGNING <im>
            WHERE clsname = a0_maindata-clsname.
      CLEAR _in.
      _in-hdr = <im>.
      LOOP AT fm_data-impl_details ASSIGNING <rd>
           WHERE clsname = <im>-clsname
             AND refclsname = <im>-refclsname.
        CLEAR _ia.
        _ia-hdr = <rd>.
        CLEAR: _ia-clsname, _ia-refclsname.
        IF <rd>-attvalue IS INITIAL             " Component is a method
           AND <rd>-mtdabstrct IS INITIAL.      " not abstract : with source code
          CLEAR _mk.
          _mk-clsname = <rd>-clsname.
          CONCATENATE <rd>-refclsname method_separator <rd>-mtdname INTO _mk-cpdname.
          READ TABLE _fm_data-includes-methods ASSIGNING <m_>
               WITH KEY cpdkey = _mk.
          IF sy-subrc = 0.
            _ia-source-_ = conv_source( <m_>-raw_source ).
            IF NOT _ia-source-_ IS INITIAL.
              CLEAR <m_>. " do it once : DELETE _fm_data-includes-methods. dump
            ENDIF.
          ENDIF.
        ENDIF.
        INSERT _ia  INTO TABLE _in-components.
      ENDLOOP.
      CLEAR _in-clsname.
      INSERT _in INTO TABLE interfaces.
    ENDLOOP.
    LOOP AT fm_data-explore_implementings ASSIGNING <ei>
         WHERE NOT comprisings IS INITIAL.
      LOOP AT <ei>-comprisings ASSIGNING <ic>.
        DELETE interfaces WHERE refclsname = <ic>-refclsname.
      ENDLOOP.
    ENDLOOP.
    LOOP AT methods ASSIGNING <me>.
      _mk-clsname = a0_maindata-clsname.
      _mk-cpdname = <me>-cmpname.
      READ TABLE _fm_data-includes-methods ASSIGNING <m_>
           WITH KEY cpdkey = _mk.
      CHECK sy-subrc = 0.
      _source = conv_source( <m_>-raw_source ).
      CHECK NOT _source IS INITIAL.
      <me>-source-_ = _source.
    ENDLOOP.
    LOOP AT fm_data-friendships ASSIGNING <fr>
      WHERE clsname = a0_maindata-clsname.
      CLEAR _fr.  _fr = <fr>.   CLEAR _fr-clsname.
      IF _fr-refclsname = a0_maindata-clsname. CLEAR _fr-refclsname. ENDIF.  " do not repeat self : Issue 64
      INSERT _fr INTO TABLE friends.
    ENDLOOP.
    LOOP AT fm_data-redefinitions ASSIGNING <re>
         WHERE clsname = a0_maindata-clsname.
      CLEAR: _re.
      _re-hdr = <re>.
      _mk-clsname = <re>-clsname.
      _mk-cpdname = <re>-mtdname.
      READ TABLE fm_data-includes-methods ASSIGNING <m_>
           WITH KEY cpdkey = _mk.
      IF sy-subrc = 0.
        _re-source-_ = conv_source( <m_>-raw_source ).
      ENDIF.
      CLEAR _re-clsname.
      INSERT _re INTO TABLE redefinitions.
    ENDLOOP.
    IF fm_data-class-category = seoc_category_exception     " Issue 123 : Exception class should always depend on inheritance because contructor is autogenerated
    OR NOT redefinitions IS INITIAL.
      CLEAR _dep.   _dep-type = c_type.   _dep-name = a0_maindata-inheritance-refclsname. INSERT _dep INTO TABLE _dependencies.
    ENDIF.
    LOOP AT deferred-classes ASSIGNING <dc>.
      CLEAR _dep.   _dep-type = c_type.   _dep-name = <dc>-typegroup.
      INSERT _dep INTO TABLE _dependencies.
    ENDLOOP.
    LOOP AT deferred-interfaces ASSIGNING <di>.
      CLEAR _dep.   _dep-type = object_types-interface.   _dep-name = <di>-typegroup.
      INSERT _dep INTO TABLE _dependencies.
    ENDLOOP.
    clear_tags( ).
  ENDMETHOD.
  METHOD sotr2value.
    CONCATENATE '''' data '''' INTO result.
  ENDMETHOD.
  METHOD to_data.
    DATA _t   LIKE LINE OF a0_maindata-texts.
    DATA _ct  LIKE LINE OF fm_data-class_desc.
    DATA _in  LIKE LINE OF fm_data-implementings.
    DATA _fr  LIKE LINE OF fm_data-friendships.
    DATA _id  LIKE LINE OF fm_data-impl_details.
    DATA _ms  LIKE LINE OF fm_data-method_sources.
    DATA _at  LIKE LINE OF fm_data-attributes.
    DATA _cx  LIKE LINE OF fm_data-exceptions_texts.
    FIELD-SYMBOLS:
      <cx> LIKE LINE OF exceptions_texts,
      <re> LIKE LINE OF redefinitions,
      <in> LIKE LINE OF interfaces,
      <ia> LIKE LINE OF <in>-components,
      <ct> LIKE LINE OF <cx>-texts,
      <fr> LIKE LINE OF friends.
    DATA _text LIKE LINE OF _cx-texts.
    DATA _cx_l LIKE LINE OF _cx-longtexts.
    DATA _cx_t LIKE LINE OF _cx-texts.
    DATA l_obj_name  TYPE  tadir-obj_name.
    DATA d_type_src  TYPE string.
    obj_name = a0_maindata-clsname.
    obj_version = a0_maindata-version.
    obj_langu = a0_maindata-langu.
    obj_type = c_type.
    CALL METHOD super->to_data
      RECEIVING
        fm_data = fm_data.
    fm_data-class = a0_maindata-hdr.
    READ TABLE a0_maindata-texts INTO _t
         WITH TABLE KEY lang = a0_maindata-langu.
    IF sy-subrc = 0.    fm_data-class-descript = _t-text.   ENDIF.
    fm_data-dynpros = dynpros.
    fm_data-textspool = textspool.
    fm_data-locals_def = zaplink_object=>conv_abap_source2raw( local-types-_ ).
    fm_data-locals_imp = zaplink_object=>conv_abap_source2raw( local-implementations-_ ).
    fm_data-locals_mac = zaplink_object=>conv_abap_source2raw( local-macros-_ ).
    fm_data-locals_tst = zaplink_object=>conv_abap_source2raw( local-local_test_class-_ ). " Issue 82
    CALL METHOD td_text
      EXPORTING
        classname     = a0_maindata-clsname
        texts         = a0_maindata-texts
        id            = doc_ids-class-header
      CHANGING
        documentation = fm_data-documentation
        descriptions  = fm_data-class_desc.
    fm_data-inheritance = a0_maindata-inheritance.
    fm_data-inheritance-clsname = a0_maindata-clsname.
    LOOP AT interfaces ASSIGNING <in>.
      CLEAR _in.
      _in = <in>-hdr.
      _in-clsname = a0_maindata-clsname.
      INSERT _in INTO TABLE fm_data-implementings.
      LOOP AT <in>-components ASSIGNING <ia>.
        _id = <ia>-hdr.
        _id-clsname = _in-clsname.
        _id-refclsname = _in-refclsname .
        APPEND _id TO fm_data-impl_details.
        IF <ia>-attvalue IS INITIAL             " Component is a method
           AND <ia>-mtdabstrct IS INITIAL.      " not abstract : with source code
          CLEAR: _ms.
          CONCATENATE <in>-refclsname method_separator <ia>-mtdname INTO _ms-cpdname.
          _ms-redefine = abap_true.
          _ms-source = zaplink_object=>conv_abap_source2raw( <ia>-source-_ ).
          APPEND _ms TO fm_data-method_sources.
        ENDIF.
      ENDLOOP.
    ENDLOOP.
    LOOP AT friends ASSIGNING <fr>.
      CLEAR _fr.
      _fr = <fr>.
      _fr-clsname = a0_maindata-clsname.
      IF _fr-refclsname IS INITIAL. _fr-refclsname = a0_maindata-clsname. ENDIF.  " do not repeat self : Issue 64
      INSERT _fr INTO TABLE fm_data-friendships.
    ENDLOOP.
    LOOP AT redefinitions ASSIGNING <re>.
      CLEAR: _ms.
      <re>-clsname = a0_maindata-clsname.
      APPEND <re>-hdr TO fm_data-redefinitions.
      _ms-cpdname = <re>-mtdname.
      _ms-redefine = abap_true.
      _ms-source = zaplink_object=>conv_abap_source2raw( <re>-source-_ ).
      APPEND _ms TO fm_data-method_sources.
    ENDLOOP.
    LOOP AT exceptions_texts ASSIGNING <cx>.
      CLEAR: _at, _cx.
      _at-clsname = a0_maindata-clsname.    _at-cmpname = <cx>-cmpname.     _at-editorder = <cx>-editorder. " Issue 71.
      IF _at-cmpname IS INITIAL. _at-cmpname = a0_maindata-clsname. ENDIF.  " do not repeat self exception text : Issue 64
      _at-attdecltyp = '2'.   " Constant
      _at-exposure = '2'.     " Public
      _at-state = '1'.        " Implemented
      _at-locked = abap_true.
      IF <cx>-message IS INITIAL.
        _at-typtype = '1'.      " Type
        _at-type = 'SOTR_CONC'.
        CALL FUNCTION 'GUID_CREATE'
          IMPORTING
            ev_guid_32 = _cx-concept.
        _at-attvalue = sotr2value( _cx-concept ).
      ELSE.
        _at-typtype = '4'.      " Type
        d_type_src = message_cx_type_source.
        REPLACE ALL OCCURRENCES OF REGEX '\#NAME\#' IN d_type_src WITH _at-cmpname.
        REPLACE ALL OCCURRENCES OF REGEX '\#CLASS\#' IN d_type_src WITH <cx>-message-class.
        REPLACE ALL OCCURRENCES OF REGEX '\#NUMBER\#' IN d_type_src WITH <cx>-message-number.
        REPLACE ALL OCCURRENCES OF REGEX '\#A1\#' IN d_type_src WITH <cx>-message-attribut_1.
        REPLACE ALL OCCURRENCES OF REGEX '\#A2\#' IN d_type_src WITH <cx>-message-attribut_2.
        REPLACE ALL OCCURRENCES OF REGEX '\#A3\#' IN d_type_src WITH <cx>-message-attribut_3.
        REPLACE ALL OCCURRENCES OF REGEX '\#A4\#' IN d_type_src WITH <cx>-message-attribut_4.
        _at-typesrc = d_type_src.
      ENDIF.
      _cx-cmpname = _at-cmpname.
      l_obj_name = a0_maindata-clsname.
      CALL FUNCTION 'TRINT_TADIR_QUERY'
        EXPORTING
          iv_pgmid    = c_kind
          iv_object   = c_type
          iv_obj_name = l_obj_name
        IMPORTING
          ev_devclass = _cx-paket.
      _cx-trala_type = 1.
      _cx-crea_lan = a0_maindata-langu.
      _cx-objid_vec = '08000000000000000000'.
      _cx-lhdr = _cx-hdr.
      LOOP AT <cx>-texts ASSIGNING <ct>.
        CLEAR: _cx_t, _cx_l.
        _cx_t-concept = _cx-concept.
        _cx_t-langu = <ct>-langu.
        _cx_t-flag_cntxt = abap_true.
        _cx_t-status = 'R'.
        IF NOT <ct>-long_txt IS INITIAL.
          MOVE-CORRESPONDING _cx_t TO _cx_l.
          _cx_l-text = <ct>-long_txt-_.
          APPEND _cx_l TO _cx-longtexts.
        ENDIF.
        _cx_t-length = 255.
        _cx_t-text = <ct>-short_txt.
        APPEND _cx_t TO _cx-texts.
      ENDLOOP.
      IF NOT _cx-texts IS INITIAL OR NOT _cx-longtexts IS INITIAL.    INSERT _cx INTO TABLE fm_data-exceptions_texts.   ENDIF.
      IF NOT _at IS INITIAL.    INSERT _at INTO TABLE fm_data-attributes.   ENDIF.
    ENDLOOP.
    clear_tags( ).
  ENDMETHOD.
  METHOD update_concept.
    DATA lt_types TYPE sotr_objects.
    DATA _type    LIKE LINE OF lt_types.
    DATA _paket   TYPE sotr_pack.
    DATA _entries TYPE sotr_text_tt.
    DATA _entry   LIKE LINE OF _entries.
    DATA lt_cx    TYPE tt_cx_texts.
    DATA ls_cx    LIKE LINE OF fm_data-exceptions_texts.
    FIELD-SYMBOLS:
      <at> LIKE LINE OF fm_data-attributes,
      <cx> LIKE LINE OF fm_data-exceptions_texts,
      <lt> LIKE LINE OF <cx>-longtexts.
    DATA _at     LIKE LINE OF fm_data-attributes.
    DATA concept TYPE  sotr_text-concept.
    DATA t_texts TYPE  sotr_textl_tt.
    DATA s_text  LIKE LINE OF t_texts.
    DATA s_sotrl TYPE sotr_link.
    DATA d_cxtxt TYPE string.
    DEFINE mac_handle_cx.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( subrc = sy-subrc
                                           classname = 'ZAPLINK_CX_CONNECTOR'
                                            funcname = &1 ).
      IF NOT msg_col IS BOUND.
        RAISE EXCEPTION o_mycx.
      ELSE.
        msg_col->add_symsg( ).
        msg_col->add_exception( exception = o_mycx ).
      ENDIF.
    END-OF-DEFINITION.
    TRY.
        LOOP AT fm_data-exceptions_texts ASSIGNING <cx>.
          CALL FUNCTION 'SOTR_OBJECT_GET_OBJECTS'
            EXPORTING
              object_vector    = <cx>-objid_vec
            IMPORTING
              objects          = lt_types
            EXCEPTIONS
              object_not_found = 1
              OTHERS           = 2.
          IF sy-subrc <> 0 OR lt_types IS INITIAL.
            mac_handle_cx 'SOTR_OBJECT_GET_OBJECTS'.
            CONTINUE.
          ENDIF.
          READ TABLE lt_types INTO _type INDEX 1.
          _paket-paket = <cx>-paket.
          IF NOT <cx>-longtexts IS INITIAL.
            LOOP AT <cx>-longtexts ASSIGNING <lt>.
              CLEAR s_text. MOVE-CORRESPONDING <lt> TO s_text.
              APPEND s_text TO t_texts.
            ENDLOOP.
            CALL FUNCTION 'SOTR_STRING_CREATE_CONCEPT'
              EXPORTING
                paket                         = _paket    " <cx>-lhdr-paket
                crea_lan                      = <cx>-lhdr-crea_lan
                object                        = _type
                entries                       = t_texts
              IMPORTING
                concept                       = <cx>-lhdr-concept
              EXCEPTIONS
                package_missing               = 1
                crea_lan_missing              = 2
                object_missing                = 3
                paket_does_not_exist          = 4
                alias_already_exist           = 5
                object_type_not_found         = 6
                langu_missing                 = 7
                identical_context_not_allowed = 8
                text_too_long                 = 9
                error_in_update               = 10
                no_master_langu               = 11
                error_in_concept_id           = 12
                internal_error                = 13
                concept_not_found             = 14
                tadir_entry_creation_failed   = 15
                error_in_correction           = 16
                user_cancelled                = 17
                no_entry_found                = 18
                alias_not_allowed             = 19
                OTHERS                        = 20.
            IF sy-subrc <> 0.
              mac_handle_cx 'SOTR_STRING_CREATE_CONCEPT'.
            ENDIF.
          ENDIF.
          _entries = <cx>-texts.
          MODIFY _entries FROM _entry TRANSPORTING concept WHERE concept <> _entry-concept.
          ls_cx = <cx>.
          TRY.
              CALL FUNCTION 'SOTR_CREATE_CONCEPT'
                EXPORTING
                  paket                         = _paket
                  crea_lan                      = <cx>-crea_lan
                  alias_name                    = <cx>-alias_name
                  object                        = _type
                  entries                       = _entries
                  concept_default               = <cx>-concept
                IMPORTING
                  concept                       = ls_cx-concept
                EXCEPTIONS
                  package_missing               = 1
                  crea_lan_missing              = 2
                  object_missing                = 3
                  paket_does_not_exist          = 4
                  alias_already_exist           = 5
                  object_type_not_found         = 6
                  langu_missing                 = 7
                  identical_context_not_allowed = 8
                  text_too_long                 = 9
                  error_in_update               = 10
                  no_master_langu               = 11
                  error_in_concept_id           = 12
                  alias_not_allowed             = 13
                  tadir_entry_creation_failed   = 14
                  internal_error                = 15
                  error_in_correction           = 16
                  user_cancelled                = 17
                  no_entry_found                = 18
                  OTHERS                        = 19.
            CATCH cx_root.
              CALL FUNCTION 'SOTR_CREATE_CONCEPT'
                EXPORTING
                  paket                         = _paket
                  crea_lan                      = <cx>-crea_lan
                  alias_name                    = <cx>-alias_name
                  object                        = _type
                  entries                       = _entries
                IMPORTING
                  concept                       = ls_cx-concept
                EXCEPTIONS
                  package_missing               = 1
                  crea_lan_missing              = 2
                  object_missing                = 3
                  paket_does_not_exist          = 4
                  alias_already_exist           = 5
                  object_type_not_found         = 6
                  langu_missing                 = 7
                  identical_context_not_allowed = 8
                  text_too_long                 = 9
                  error_in_update               = 10
                  no_master_langu               = 11
                  error_in_concept_id           = 12
                  alias_not_allowed             = 13
                  tadir_entry_creation_failed   = 14
                  internal_error                = 15
                  error_in_correction           = 16
                  user_cancelled                = 17
                  no_entry_found                = 18
                  OTHERS                        = 19.
          ENDTRY.
          IF sy-subrc <> 0.
            mac_handle_cx 'SOTR_CREATE_CONCEPT'.
            CONTINUE.
          ENDIF.
          IF <cx>-lhdr-concept <> ls_cx-concept AND NOT <cx>-lhdr-concept IS INITIAL.
            s_sotrl-concept_1 = ls_cx-concept.    " FLAG_STR_1
            s_sotrl-concept_2 = <cx>-lhdr-concept.    s_sotrl-flag_str_2 = abap_true.
            CALL FUNCTION 'SOTR_LINK_UPDATE_LINK'
              EXPORTING
                sotr_link         = s_sotrl
              EXCEPTIONS
                incomplete_data   = 1
                concept_not_found = 2
                OTHERS            = 3.
            IF sy-subrc <> 0.
              mac_handle_cx 'SOTR_LINK_UPDATE_LINK'.
            ENDIF.
          ENDIF.
          _at-clsname = fm_data-class-clsname.    _at-cmpname = <cx>-cmpname.
          IF <cx>-cmpname IS INITIAL.
            READ TABLE fm_data-attributes ASSIGNING <at>
                 WITH KEY cmpname = fm_data-class-clsname.
          ELSE.
            READ TABLE fm_data-attributes ASSIGNING <at>
                 WITH KEY cmpname = <cx>-cmpname.
          ENDIF.
          IF sy-subrc <> 0.
            d_cxtxt = 'Attribut should exists !!'(f01).
            RAISE EXCEPTION TYPE zaplink_cx_connector
              EXPORTING
                textid  = zaplink_cx=>system_error
                cx_name = d_cxtxt.
          ENDIF.
          <at>-attvalue = sotr2value( ls_cx-concept ).
          CHECK ls_cx-concept <> <cx>-concept.
          INSERT ls_cx INTO TABLE lt_cx.
          DELETE fm_data-exceptions_texts.
        ENDLOOP.
        INSERT LINES OF fm_data-exceptions_texts INTO TABLE lt_cx.
        fm_data-exceptions_texts = lt_cx.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD value2sotr.
    DATA _val TYPE seovalue.
    _val = data.
    REPLACE ALL OCCURRENCES OF '''' IN _val WITH space.
    CONDENSE _val.
    result = _val.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CLAS_DATA implementation
CLASS zaplink_component_4inst IMPLEMENTATION.
ENDCLASS. "ZAPLINK_COMPONENT_4INST implementation
CLASS zaplink_connectors_4extractor IMPLEMENTATION.
ENDCLASS. "ZAPLINK_CONNECTORS_4EXTRACTOR implementation
CLASS zaplink_connectors_4inst IMPLEMENTATION.
ENDCLASS. "ZAPLINK_CONNECTORS_4INST implementation
CLASS zaplink_container_4inst IMPLEMENTATION.
  METHOD class_constructor.
    xmlengine = cl_ixml=>create( ).
  ENDMETHOD.
  METHOD constructor.
    CREATE OBJECT _complist.
    CREATE OBJECT _options.
    mac_create_log log ballog_subobject space.
    log->msgid = 'ZAPLINK'.
    xmldata = xmlengine->create_document( ).
    file = o_file.
  ENDMETHOD.
  METHOD get_content.
    TRY.
        result = _complist->clone( ).
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD get_options.
    result = _options.
  ENDMETHOD.
  METHOD get_root.
    root = xmldata->get_first_child( ).
    CHECK root IS BOUND.
  ENDMETHOD.
  METHOD load_from_file.
    DATA _xml   TYPE string.
    DATA _file  TYPE to_file.
    IF o_file IS BOUND.
      _file = o_file.
    ELSE.
      _file = file.
    ENDIF.
    TRY.
        _file->load( ).
        _xml = _file->get_filecontent( ).
      CATCH zaplink_cx_file.
        RETURN.
    ENDTRY.
    file = _file.
    load_from_xml( _xml ).
  ENDMETHOD.
  METHOD load_from_xml.
    DATA _streamfactory   TYPE REF TO if_ixml_stream_factory.
    DATA _stream          TYPE REF TO if_ixml_istream.
    DATA _parser          TYPE REF TO if_ixml_parser.
    DATA _doc             TYPE REF TO if_ixml_document.
    _streamfactory = xmlengine->create_stream_factory( ).
    _doc = xmlengine->create_document( ).
    _stream = _streamfactory->create_istream_string( xml ).
    _parser = xmlengine->create_parser(  stream_factory = _streamfactory
                                         istream        = _stream
                                         document       = _doc ).
    _parser->parse( ).
    IF _doc IS BOUND.
      xmldata = _doc.
    ENDIF.
    _update_componentslist( ).
  ENDMETHOD.
  METHOD set_options.
    CHECK data <> _options.
    _options = data.
  ENDMETHOD.
  METHOD transport_to_sap.
    DATA o_connector  TYPE to_connector.
    DATA o_list_comp  TYPE to_component.
    DATA o_comp       TYPE to_component.
    DATA o_comp_n     TYPE to_component.
    DATA o_comp_s     TYPE to_component.
    DATA o_listsub    TYPE to_list.
    DATA o_subcomp    TYPE to_component.
    DATA _components  TYPE to_list.
    DATA _xml_comp    TYPE REF TO if_ixml_document.
    DATA _clone       TYPE REF TO if_ixml_node.
    DATA _cx_connector TYPE REF TO zaplink_cx_connector.
    DATA o_raw        TYPE to_raw_base.
    DATA _directory   TYPE ts_directory.
    DATA o_log        TYPE to_log.
    DATA o_todo       TYPE to_list.
    DATA o_remain     TYPE to_list.
    DATA o_skiplist   TYPE to_list.
    DATA o_deplist    TYPE to_list.
    DATA o_chk_exist  TYPE to_component.
    DATA d_chk_name   TYPE td_compname.
    DATA d_chk_type   TYPE td_comptype.
    DATA f_dep_ok     TYPE abap_bool.
    DATA d_name       TYPE td_compname.
    DATA d_type       TYPE td_comptype.
    DATA f_ok         TYPE abap_bool.
    DATA d_msgno      TYPE symsgno.
    DATA d_msgty      TYPE symsgty.
    CHECK object_list IS BOUND.
    IF zaplink_tools=>import_allowed <> abap_true.
      RAISE EXCEPTION TYPE zaplink_cx_import_not_allowed.
    ENDIF.
    TRY.
        object_list->keep_commun_list( _complist ).
        o_todo = object_list->clone( ).
        DO.
          CREATE OBJECT o_skiplist.
          o_remain = o_todo->clone( ).
          o_todo->display_progress = abap_true.
          o_todo->order_kind = zaplink_list=>order_kinds-install.
          o_todo->init_sel_iter( ).
          o_comp_n = o_todo->get_next( ).
          WHILE o_comp_n IS BOUND.
            o_comp = o_comp_n.    o_comp_n = o_todo->get_next( ).    " to allow continue
            o_comp_s = _complist->search( o_comp ).
            o_list_comp = object_list->search( o_comp ).
            o_connector = o_comp_s->connector( ).
            o_connector->options = _options.
            o_log = o_list_comp->get_msg_coll( ).
            IF NOT o_log IS BOUND.
              CREATE OBJECT o_log.
              o_list_comp->set_msg_coll( o_log ).
              CALL METHOD o_log->init
                EXPORTING
                  id_object      = ballog_object
                  id_subobject   = ballog_subobject
                  auto_upd_custo = abap_true
                EXCEPTIONS
                  error          = 1
                  OTHERS         = 2.
              IF sy-subrc <> 0.
                log->add_symsg( ).
              ENDIF.
            ENDIF.
            d_name = o_comp_s->get_name( ).     d_type = o_comp_s->get_type( ).
            SET EXTENDED CHECK OFF.
            IF 1 = 2.   MESSAGE i000 WITH space space.    ENDIF.
            SET EXTENDED CHECK ON.
            CALL METHOD log->add_info
              EXPORTING
                id_msgno = '000'
                id_msgv1 = d_type
                id_msgv2 = d_name.
            _xml_comp = xmlengine->create_document( ).
            _clone = _find_component_node( o_comp_s ).
            _clone = _clone->clone( ).
            _xml_comp->if_ixml_node~append_child( _clone ).
            TRY.
                o_raw = zaplink_connectors=>node_2_raw( _clone ).
                CREATE OBJECT o_deplist.
                o_deplist->add_keys( o_raw->dependencies ).
                IF o_remain->has_any( o_deplist ) = abap_true.
                  o_skiplist->add( o_comp ). " because dependcies will be processed first
                  CONTINUE.
                ENDIF.
                o_deplist->display_progress = abap_false.
                o_deplist->init_iter( ).
                o_chk_exist = o_deplist->get_next( ).
                f_dep_ok = abap_true.     " by default OK : Hot fix
                WHILE o_chk_exist IS BOUND.
                  f_dep_ok = o_chk_exist->do_exists( ).
                  IF f_dep_ok = abap_false.
                    d_chk_name = o_chk_exist->get_name( ).     d_chk_type = o_chk_exist->get_type( ).
                    SET EXTENDED CHECK OFF.
                    IF 1 = 2.   MESSAGE i008 WITH space space.    ENDIF.
                    SET EXTENDED CHECK ON.
                    CALL METHOD o_log->add
                      EXPORTING
                        id_msgty = 'E'
                        id_msgid = 'ZAPLINK'
                        id_msgno = 008
                        id_msgv1 = d_type
                        id_msgv2 = d_name
                        id_msgv3 = d_chk_type
                        id_msgv4 = d_chk_name.
                    EXIT.
                  ENDIF.
                  o_chk_exist = o_deplist->get_next( ).
                ENDWHILE.
                IF f_dep_ok = abap_false.
                  CONTINUE.                     " Skip object
                ENDIF.
                TRY.      " Issue 99 : Error while setting directory mustn't stop importing process
                    _directory = _options->directory->set_directory( o_raw ).
                  CATCH zaplink_cx INTO o_cx.
                    o_log->add_exception( o_cx ).
                ENDTRY.
                o_log->add_from_instance( _options->directory->application_log ).
                o_listsub = o_comp_s->get_subcomponents( ).
                IF o_listsub IS BOUND.
                  o_listsub->display_progress = abap_false.
                  o_listsub->init_iter( ).
                  o_subcomp = o_listsub->get_next( ).
                  WHILE o_subcomp IS BOUND.
                    _clone = _find_component_node( component = o_comp_s
                                                    sub_comp = o_subcomp ).
                    o_raw = zaplink_connectors=>node_2_raw( _clone ).
                    TRY.      " Issue 99 : Error while setting directory mustn't stop importing process
                        _options->directory->set_directory( o_raw ).
                      CATCH zaplink_cx INTO o_cx.
                        o_log->add_exception( o_cx ).
                    ENDTRY.
                    o_log->add_from_instance( _options->directory->application_log ).
                    o_subcomp = o_listsub->get_next( ).
                  ENDWHILE.
                ENDIF.
                _components = o_connector->import_to_sap( _xml_comp ).
                IF _components IS NOT BOUND.   CREATE OBJECT _components.   ELSE.   f_ok = abap_true. ENDIF.
                o_list_comp->set_subcomponents( _components ).
                o_list_comp->set_msg_coll( o_connector->application_log ).
                IF o_connector->application_log IS BOUND.   IF o_connector->application_log->has_messages_of_msgt('W') = abap_true.      f_ok = abap_false. log->add_from_instance( o_connector->application_log ).   ENDIF.   ENDIF.
                IF _components->search( o_comp ) IS BOUND.    _components->remove( o_comp ).    ELSE.     f_ok = abap_false.     ENDIF.
                o_remain->remove( o_comp ).                   " Issue 47
                IF f_ok = abap_true.
                  d_msgty = 'S'.    d_msgno = 004.
                  SET EXTENDED CHECK OFF.
                  IF 1 = 2.   MESSAGE i004 WITH space space.    ENDIF.
                  SET EXTENDED CHECK ON.
                ELSE.
                  d_msgty = 'E'.    d_msgno = 005.
                  SET EXTENDED CHECK OFF.
                  IF 1 = 2.   MESSAGE i005 WITH space space.    ENDIF.
                  SET EXTENDED CHECK ON.
                ENDIF.
                CALL METHOD log->add
                  EXPORTING
                    id_msgty = d_msgty
                    id_msgid = 'ZAPLINK'
                    id_msgno = d_msgno
                    id_msgv1 = d_type
                    id_msgv2 = d_name.
              CATCH zaplink_cx_connector INTO _cx_connector.
                o_list_comp->set_exception( _cx_connector ).
                CALL METHOD log->add_exception
                  EXPORTING
                    exception = _cx_connector.
                mac_add_log o_connector->application_log o_log 'E'.   " append application log if error is present
            ENDTRY.
          ENDWHILE.
          IF o_skiplist->is_empty( ) = abap_true.   EXIT.   ENDIF.
          IF o_todo->get_count( ) = o_skiplist->get_count( ).
            RAISE EXCEPTION TYPE zaplink_cx_container EXPORTING textid = zaplink_cx_container=>circular_dependencies.
          ENDIF.
          o_todo = o_skiplist->clone( ).    o_todo->select_all( ).
        ENDDO.
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD uninstall_from_sap.
    DATA o_connector  TYPE to_connector.
    DATA o_comp       TYPE to_component.
    DATA o_scomp      TYPE to_component.
    DATA object       TYPE to_raw.
    DATA _done        TYPE abap_bool.
    DATA s_key        TYPE ts_component.
    DATA o_log        TYPE to_log.
    DATA s_lock       TYPE tlock_int.                         " Issue 101
    DATA d_flag       TYPE trpari-s_lockflag.                 " Issue 101
    DATA o_raw        TYPE to_raw_base.                       " Issue 101
    DATA _directory   TYPE ts_directory.                      " Issue 101
    DATA o_list       TYPE to_list.                           " Issue 104
    CHECK object_list IS BOUND.
    TRY.
        object_list->display_progress = abap_true.
        object_list->order_kind = zaplink_list=>order_kinds-uninstall.
        object_list->init_sel_iter( ).
        o_comp = object_list->get_next( ).
        WHILE o_comp IS BOUND.
          o_scomp = _complist->search( o_comp ).
          IF o_scomp IS BOUND.
            o_list = o_scomp->get_subcomponents( ).
            IF o_list IS BOUND.
              o_list->display_progress = abap_false.
              o_list->order_kind = zaplink_list=>order_kinds-uninstall.
              o_list->select_all( ).
              o_list->init_sel_iter( ).
              o_scomp = o_list->get_next( ).
              WHILE o_scomp IS BOUND.
                _uninstall_component( o_scomp ).
                o_log = o_scomp->get_msg_coll( ).
                log->add_from_instance( io_msglist        = o_log
                                        if_add_as_subnode = abap_true ).
                o_scomp = o_list->get_next( ).
              ENDWHILE.
            ENDIF.
          ENDIF.
          _uninstall_component( o_comp ).
          o_log = o_comp->get_msg_coll( ).
          log->add_from_instance( io_msglist        = o_log
                                  if_add_as_subnode = abap_true ).
          o_comp = object_list->get_next( ).
        ENDWHILE.
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD _add_to_componentslist.
    DATA o_raw       TYPE to_raw_base.
    DATA o_comp      TYPE to_component.
    DATA o_comp_p    TYPE to_component.
    DATA o_conn      TYPE to_connector.
    DATA o_list      TYPE to_list.
    DATA _index      LIKE LINE OF _nodeindex.
    DATA str         TYPE string.
    DATA d_sub       TYPE abap_bool.
    CHECK node IS BOUND.
    str = node->get_name( ).
    CHECK str = comp_nodename. " Security
    _index-node = node.          " save current node
    d_sub = _is_subcomponent( _index-node ).      " Issue 102
    TRY.
        o_raw = zaplink_connectors=>node_2_raw( _index-node ).
        IF o_raw->name IS INITIAL.
          EXIT.
        ENDIF.
        TRY.
            o_comp = o_raw->get_component( ).
            o_conn = o_comp->connector( ).
          CATCH zaplink_cx_container INTO o_mycx.
            log->add_exception( exception = o_mycx ).
            o_comp = o_raw->get_component( abap_true ).
        ENDTRY.
        IF NOT o_conn IS BOUND.
        ELSE.
          IF o_conn->is_supported_version( o_raw->version ) = abap_false.
          ENDIF.
        ENDIF.
        IF d_sub = abap_false.      " Issue 102 : Root comp
          o_comp_p = _complist->search( o_comp ).
          IF o_comp_p IS BOUND.   o_comp = o_comp_p.    ELSE.   _complist->add( o_comp ).     ENDIF.
        ELSE.
          o_raw = zaplink_connectors=>node_2_raw( o_cursor ).   " Read Parent
          o_comp_p = o_raw->get_component( ).
          o_comp_p = _complist->search( o_comp_p ).
          o_list = o_comp_p->get_subcomponents( ).
          IF NOT o_list IS BOUND.
            CREATE OBJECT o_list.
            o_comp_p->set_subcomponents( o_list ).
          ENDIF.
          IF NOT o_list->search( o_comp ) IS BOUND.   o_list->add( o_comp ).    ENDIF.      " Issue 102
        ENDIF.
        _index-key = o_comp.
        MODIFY TABLE _nodeindex FROM _index.
        IF sy-subrc <> 0.   INSERT _index INTO TABLE _nodeindex.    ENDIF.
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD _find_component_node.
    DATA o_comp   TYPE to_component.
    DATA o_list   TYPE to_list.
    DATA _cx_list TYPE REF TO zaplink_cx_list.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF _nodeindex.
    TRY.
        TRY.
            o_comp = _complist->search( component ).
          CATCH zaplink_cx_list INTO _cx_list.
            IF _cx_list->is_exception_text( zaplink_cx_list=>not_found ) = abap_true.
              EXIT.
            ELSE.
              CREATE OBJECT o_mycx
                EXPORTING
                  textid   = zaplink_cx=>system_error
                  previous = _cx_list.
              o_mycx->update( ).
              RAISE EXCEPTION o_mycx.
            ENDIF.
        ENDTRY.
        CHECK o_comp IS BOUND.
        o_list = o_comp->get_subcomponents( ).
        IF sub_comp IS BOUND AND o_list IS BOUND.
          o_comp = o_list->search( sub_comp ).
        ENDIF.
        READ TABLE _nodeindex ASSIGNING <i>
             WITH TABLE KEY key = o_comp.
        IF sy-subrc = 0.
          node = <i>-node.
        ENDIF.
        mac_def_catch zaplink_cx_container.
    ENDTRY.
  ENDMETHOD.
  METHOD _is_subcomponent.
    DATA _cursor TYPE REF TO if_ixml_node.
    result = abap_false.
    CLEAR o_cursor.
    _cursor = node->get_parent( ).
    WHILE _cursor IS BOUND.
      IF _cursor->get_name( ) = comp_nodename.
        result = abap_true.
        o_cursor = _cursor.
      ENDIF.
      _cursor = _cursor->get_parent( ).
    ENDWHILE.
  ENDMETHOD.
  METHOD _search_components.
    DATA o_iterator  TYPE REF TO if_ixml_node_iterator.
    DATA o_filt_name TYPE REF TO if_ixml_node_filter.
    DATA o_node      TYPE REF TO  if_ixml_node.
    DATA str         TYPE string.
    CHECK node IS BOUND.
    str = node->get_name( ).
    CHECK str <> '#document'.
    o_filt_name = node->create_filter_name( name = comp_nodename ).
    o_iterator = node->create_iterator_filtered( filter = o_filt_name ).
    o_node = o_iterator->get_next( ).
    WHILE o_node IS BOUND.
      TRY.
          _add_to_componentslist( o_node ).
        CATCH zaplink_cx INTO o_cx.
          mac_cascade_raise o_mycx o_cx.
      ENDTRY.
      o_node = o_iterator->get_next( ).
    ENDWHILE.
  ENDMETHOD.
  METHOD _uninstall_component.
    DATA o_connector  TYPE to_connector.
    DATA o_comp       TYPE to_component.
    DATA object       TYPE to_raw.
    DATA _done        TYPE abap_bool.
    DATA s_key        TYPE ts_component.
    DATA _cx_connector TYPE REF TO zaplink_cx_connector.
    DATA o_log        TYPE to_log.
    DATA s_lock       TYPE tlock_int.                         " Issue 101
    DATA d_flag       TYPE trpari-s_lockflag.                 " Issue 101
    DATA o_raw        TYPE to_raw_base.                       " Issue 101
    DATA _directory   TYPE ts_directory.                      " Issue 101
    CHECK component IS BOUND.
    o_comp = component.
    o_connector = o_comp->connector( ).
    o_log = o_comp->get_msg_coll( ).
    IF NOT o_log IS BOUND.
      CREATE OBJECT o_log.
      o_comp->set_msg_coll( o_log ).
      CALL METHOD o_log->init
        EXPORTING
          id_object      = ballog_object
          id_subobject   = ballog_subobject
          auto_upd_custo = abap_true
        EXCEPTIONS
          error          = 1
          OTHERS         = 2.
      IF sy-subrc <> 0.
        log->add_symsg( ).
      ENDIF.
    ENDIF.
    TRY.
        s_key = o_comp->get_key( ).
        IF 1 = 2.   MESSAGE i000 WITH space space.    ENDIF.
        CALL METHOD log->add_info
          EXPORTING
            id_msgno = '000'
            id_msgv1 = s_key-type
            id_msgv2 = s_key-name.
        CALL FUNCTION 'TRINT_CHECK_LOCKS'
          EXPORTING
            wi_lock_key = s_lock
          IMPORTING
            we_lockflag = d_flag
          EXCEPTIONS
            empty_key   = 1
            OTHERS      = 2.
        IF sy-subrc = 0 AND d_flag IS INITIAL.
          CREATE OBJECT o_raw.
          o_raw->set_component( o_comp ).
          _directory = _options->directory->set_directory( o_raw ).
        ENDIF.
        _done = o_connector->delete_from_sap( o_comp ).
        IF _done = abap_true.
          SET EXTENDED CHECK OFF.
          IF 1 = 2. MESSAGE s006 WITH space space. ENDIF.
          SET EXTENDED CHECK ON.
          CALL METHOD log->add_success
            EXPORTING
              id_msgno = '006'
              id_msgv1 = s_key-type
              id_msgv2 = s_key-name.
        ELSE.
          SET EXTENDED CHECK OFF.
          IF 1 = 2. MESSAGE e007 WITH space space. ENDIF.
          SET EXTENDED CHECK ON.
          CALL METHOD log->add_error
            EXPORTING
              id_msgno = '007'
              id_msgv1 = s_key-type
              id_msgv2 = s_key-name.
        ENDIF.
        mac_add_log o_connector->application_log o_log 'W'.
      CATCH zaplink_cx_connector INTO _cx_connector.
        o_log->add_exception( exception = _cx_connector ).
    ENDTRY.
  ENDMETHOD.
  METHOD _update_componentslist.
    DATA o_iterator  TYPE REF TO if_ixml_node_iterator.
    DATA o_node      TYPE REF TO if_ixml_node.
    _complist->clear( ).    REFRESH _nodeindex.     " Issue 102
    o_iterator = xmldata->create_iterator( depth = 1 ).   " Do only root level
    o_node = o_iterator->get_next( ).
    WHILE o_node IS BOUND.
      TRY.
          _search_components( o_node ).
        CATCH zaplink_cx INTO o_cx.
          mac_cascade_raise o_mycx o_cx.
      ENDTRY.
      o_node = o_iterator->get_next( ).
    ENDWHILE.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CONTAINER_4INST implementation
CLASS zaplink_dependencies_analyser IMPLEMENTATION.
  METHOD add_attributs.
    DATA _name TYPE string.
    FIELD-SYMBOLS <a> LIKE LINE OF attributs.
    LOOP AT attributs ASSIGNING <a>.
      CONCATENATE 'Attributs->' <a>-cmpname INTO _name.     "#EC NOTEXT
      stack( _name ).
      process_type( type = <a>-typtype
                  origin = origin
                    name = <a>-type
                  source = <a>-_ ).
      unstack( ).
    ENDLOOP.
  ENDMETHOD.
  METHOD add_class_dep.
    DATA _codes      LIKE LINE OF classes.
    DATA o_raw       TYPE to_raw.
    DATA o_data      TYPE to_class.
    DATA _component  TYPE to_component.
    DATA _key        TYPE td_name.
    DATA d_softcomp  TYPE tdevc-dlvunit.
    DATA d_devclass  TYPE tdevc-devclass.
    DATA _order      LIKE LINE OF order.
    DATA _name       TYPE td_compname.
    DATA f_before    TYPE xfeld.
    DATA d_tabix     TYPE sy-tabix.
    DATA _class      TYPE vseoclass.
    DATA s_key       TYPE seoclskey.
    DATA d_classname TYPE seoclsname.
    DATA d_prog      TYPE td_origin.
    DATA o_cx_childs TYPE REF TO cl_oo_class_relations.
    FIELD-SYMBOLS:
      <cx> LIKE LINE OF o_cx_childs->subclasses,
      <c>  LIKE LINE OF circular_context,
      <f>  LIKE LINE OF o_data->friends.
    CHECK is_excluded_class( type = c_class-type  name = name ) = abap_false.
    READ TABLE order TRANSPORTING NO FIELDS
         WITH KEY name = name
               defered = abap_false.
    IF sy-subrc = 0.    EXIT.   ENDIF.    " already processed => nothing to do
    s_key-clsname = name.
    CALL FUNCTION 'SEO_CLIF_GET'
      EXPORTING
        cifkey       = s_key
      IMPORTING
        class        = _class
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        model_only   = 0
        OTHERS       = 4.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( subrc = sy-subrc
                                           classname = 'ZAPLINK_CX'
                                            funcname = 'SEO_CLIF_GET' ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
    _order-name = name.
    IF _class-category =  objcat-exception.    _order-type = objtype-exception_class.   ELSE.   _order-type = objtype-class.   ENDIF.
    READ TABLE context TRANSPORTING NO FIELDS
         WITH KEY context = name
                     type = _order-type.
    IF sy-subrc = 0.    " Circular reference => Use defered
      stack( context = name   type = _order-type    full = full ).
      d_tabix = sy-tabix + 1.   circular_context = context.   DELETE circular_context FROM d_tabix.
      current_comp = name.    handle_context( ).        " CLEAR:  circular_ref_on, circular_context.
      unstack( ).
      EXIT.
    ENDIF.
    READ TABLE classes TRANSPORTING NO FIELDS WITH TABLE KEY name = name.
    IF sy-subrc = 0.    EXIT.   ENDIF.    " already processed => nothing to do
    d_classname = name.
    d_prog = current_origin = cl_oo_classname_service=>get_classpool_name( d_classname ).
    stack( context = name   type = _order-type    full = full ).
    do_class( name ).
    CREATE OBJECT _component.
    _component->set_type( c_class-type ).   _name = name.   _component->set_name( _name ).
    o_raw = o_object->zaplink_connector~read_from_sap( _component ).    o_data ?= o_raw->raw.
    append_typegroups( o_data->typegroups ).
    append_message( o_data->a0_maindata-msg_id ).
    IF NOT o_data->a0_maindata-inheritance-refclsname IS INITIAL.
      _key = o_data->a0_maindata-inheritance-refclsname.
      add_object_to_list( name = _key
                          full = abap_true
                      position = '=>inheritance-refclsname' ).
    ENDIF.
    add_types( types = o_data->types    origin = d_prog ).
    add_interfaces( o_data->interfaces ).
    add_attributs( attributs = o_data->attributs    origin = d_prog ).
    add_source_to_list( code = o_data->local-types-_   origin = d_prog    position = _name ).
    add_source_to_list( code = o_data->local-implementations-_   origin = d_prog    position = _name ).
    add_source_to_list( code = o_data->local-macros-_  origin = d_prog    position = _name ).
    add_methods( methods = o_data->methods    origin = d_prog ).
    LOOP AT o_data->friends ASSIGNING <f>.
      _key = <f>-refclsname.
      CALL METHOD add_object_to_list( name = _key position = '=>friends' ).
    ENDLOOP.
    do_object_list( name = name ).
    unstack( ).
    insert_order( s_order = _order   context = context ).
    IF _order-type = objtype-exception_class.
      CREATE OBJECT o_cx_childs
        EXPORTING
          clsname      = name
          w_subclasses = seox_true
        EXCEPTIONS
          not_existing = 1
          is_interface = 2
          OTHERS       = 3.
      ASSERT sy-subrc = 0.
      LOOP AT o_cx_childs->subclasses ASSIGNING <cx>.
        add_class_dep( <cx>-clsname ).
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD add_deferred_code.
    DATA _obj      LIKE LINE OF deferred_declaration.
    DATA _line     LIKE LINE OF abapcode.
    READ TABLE deferred_declaration TRANSPORTING NO FIELDS
         WITH TABLE KEY name = name.
    IF sy-subrc = 0.    EXIT.   ENDIF.
    CASE type.
      WHEN objtype-class OR objtype-exception_class.
        CONCATENATE 'CLASS' name 'DEFINITION DEFERRED.' INTO _line SEPARATED BY space.
        APPEND _line TO abapcode.
        _obj-name = name.
        INSERT _obj INTO TABLE deferred_declaration.
      WHEN objtype-interface.
        CONCATENATE 'INTERFACE' name 'DEFERRED.' INTO _line SEPARATED BY space.
        APPEND _line TO abapcode.
        _obj-name = name.
        INSERT _obj INTO TABLE deferred_declaration.
    ENDCASE.
  ENDMETHOD.
  METHOD add_deferred_ok.
    TYPES:
      BEGIN OF ts_dep,
        ori_name TYPE td_name,
        type     TYPE td_classtype,    " 0 Class 1 interface
        full_def TYPE flag,          " Full definition required
        count    TYPE i,
      END OF ts_dep.
    DATA t_tmp     TYPE STANDARD TABLE OF ts_dep WITH DEFAULT KEY.
    DATA s_dep     LIKE LINE OF t_tmp.
    DATA t_deps    TYPE SORTED TABLE OF ts_dep WITH NON-UNIQUE KEY ori_name.
    DATA s_order   LIKE LINE OF new_order.
    FIELD-SYMBOLS:
      <r> LIKE LINE OF remain_requirements,
      <c> LIKE LINE OF remain_classes.
    LOOP AT remain_requirements ASSIGNING <r>.
      CLEAR s_dep.    MOVE-CORRESPONDING <r> TO s_dep.    s_dep-count = 1.
      COLLECT s_dep INTO t_tmp.
    ENDLOOP.
    DELETE t_tmp WHERE type <> objtype-exception_class AND full_def <> abap_true. " Issue 91
    t_deps = t_tmp.
    LOOP AT remain_classes ASSIGNING <c>.
      READ TABLE t_deps TRANSPORTING NO FIELDS WITH TABLE KEY ori_name = <c>-name.
      IF sy-subrc <> 0.
        CLEAR s_order.    s_order-name = <c>-name.    s_order-type = <c>-type.    APPEND s_order TO new_order.    DELETE remain_requirements WHERE name = <c>-name.    result = abap_true.   DELETE remain_classes.
      ENDIF.
    ENDLOOP.
    add_without_requirements( ).
  ENDMETHOD.
  METHOD add_include.
    APPEND name TO includes.
    add_prog_textpool( name ).
  ENDMETHOD.
  METHOD add_interfaces.
    DATA _key        TYPE td_name.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF interfaces.
    LOOP AT interfaces ASSIGNING <i>.
      _key = <i>-refclsname.
      add_object_to_list( name = _key
                          full = abap_true
                      position = '=>interface' ).
    ENDLOOP.
  ENDMETHOD.
  METHOD add_interface_dep.
    DATA _codes      LIKE LINE OF classes.
    DATA o_raw       TYPE to_raw.
    DATA o_data      TYPE to_interface.
    DATA _component  TYPE zaplink_connector=>to_component.
    DATA d_softcomp  TYPE tdevc-dlvunit.
    DATA d_devclass  TYPE tdevc-devclass.
    DATA _order      LIKE LINE OF order.
    DATA _name       TYPE zaplink_connector=>td_compname.
    DATA d_tabix     TYPE sy-tabix.
    DATA d_classname TYPE seoclsname.
    DATA d_prog      TYPE td_origin.
    CHECK is_excluded_class( type = c_interface-type  name = name ) = abap_false.
    _order-name = name.   _order-type = objtype-interface.
    READ TABLE order TRANSPORTING NO FIELDS
         WITH KEY name = _order-name
                  type = _order-type
               defered = abap_false.
    IF sy-subrc = 0.    EXIT.   ENDIF.    " already processed => nothing to do
    READ TABLE context TRANSPORTING NO FIELDS
         WITH KEY context = name
                     type = _order-type.
    IF sy-subrc = 0.      " Circular reference => Use defered
      stack( context = name   type = _order-type    full = full ).
      d_tabix = sy-tabix + 1.   circular_context = context.   DELETE circular_context FROM d_tabix.
      current_comp = name.    handle_context( ).        " CLEAR:  circular_ref_on, circular_context.
      unstack( ).
      EXIT.
    ENDIF.
    READ TABLE classes TRANSPORTING NO FIELDS WITH TABLE KEY name = name.
    IF sy-subrc = 0.    EXIT.   ENDIF.    " already processed => nothing to do
    d_classname = name.
    d_prog = current_origin = cl_oo_classname_service=>get_classpool_name( d_classname ).
    stack( context = name   type = _order-type    full = full ).
    do_class( name ).
    CREATE OBJECT _component.
    _component->set_type( c_interface-type ).   _name = name.   _component->set_name( _name ).
    o_raw = o_object->zaplink_connector~read_from_sap( _component ).
    o_data ?= o_raw->raw.
    append_typegroups( o_data->typegroups ).
    add_types( types = o_data->types    origin = d_prog ).
    add_interfaces( o_data->interfaces ).
    add_attributs( attributs = o_data->attributs    origin = d_prog ).
    add_methods( o_data->methods ).
    do_object_list( name = name ).
    unstack( ).
    insert_order( s_order = _order   context = context ).
  ENDMETHOD.
  METHOD add_methods.
    DATA _name       TYPE string.
    DATA t_objs      TYPE tt_abaprawsource.
    DATA _key        TYPE td_name.
    FIELD-SYMBOLS:
      <o> LIKE LINE OF t_objs,
      <m> LIKE LINE OF methods,
      <p> LIKE LINE OF <m>-parameters,
      <e> LIKE LINE OF <m>-exceptions.
    LOOP AT methods ASSIGNING <m>.
      CONCATENATE 'Method->' <m>-cmpname INTO _name.        "#EC NOTEXT
      stack( _name ).
      LOOP AT <m>-parameters ASSIGNING <p>.
        process_type( type = <p>-typtype
                      name = <p>-type ).
      ENDLOOP.
      IF NOT <m>-mtdnewexc IS INITIAL.
        LOOP AT <m>-exceptions ASSIGNING <e>.
          _key = <e>-sconame.   add_object_to_list( name = _key   position = _name ).
        ENDLOOP.
      ENDIF.
      IF NOT <m>-source-_ IS INITIAL.   add_source_to_list( code = <m>-source-_   origin = origin    position = _name ).    ENDIF.
      unstack( ).
    ENDLOOP.
  ENDMETHOD.
  METHOD add_method_source.
    DATA ref_objs     TYPE tt_abaprawsource.
    DATA _key         TYPE td_name.
    FIELD-SYMBOLS <o> LIKE LINE OF ref_objs.
    CHECK NOT code IS INITIAL.
    ref_objs = analyse_source( code = code   origin = origin ).
    LOOP AT ref_objs ASSIGNING <o>.
      _key = <o>.
      add_object( _key ).
    ENDLOOP.
  ENDMETHOD.
  METHOD add_object.
    DATA _key   TYPE seoclskey.
    DATA o_type TYPE seoclstype.
    DATA o_desc TYPE REF TO cl_abap_typedescr.
    DATA _name  TYPE td_name.
    DATA _class TYPE vseoclass.
    _name = name. TRANSLATE _name TO UPPER CASE.          "#EC SYNTCHAR
    CHECK is_predeftype( _name ) = abap_false.
    CALL FUNCTION 'SEO_CLIF_CHECK_NAME'
      EXPORTING
        clsname                   = _name
      EXCEPTIONS
        reserved                  = 1
        space_not_allowed         = 2
        small_letters_not_allowed = 3
        symbols_not_allowed       = 4
        first_character_no_number = 5
        namespace_error           = 6
        OTHERS                    = 7.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( subrc = sy-subrc
                                           classname = 'ZAPLINK_CX'
                                            funcname = 'SEO_CLIF_CHECK_NAME' ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
    CALL METHOD cl_abap_typedescr=>describe_by_name
      EXPORTING
        p_name         = _name
      RECEIVING
        p_descr_ref    = o_desc
      EXCEPTIONS
        type_not_found = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = 'cl_abap_typedescr'
                                                       method = 'describe_by_name'
                                                        subrc = sy-subrc
                                                 cx_classname = 'ZAPLINK_CX').
      RAISE EXCEPTION o_mycx.
    ENDIF.
    CHECK o_desc->kind = cl_abap_typedescr=>kind_class
       OR o_desc->kind = cl_abap_typedescr=>kind_intf.
    _key-clsname = _name.
    CALL FUNCTION 'SEO_CLIF_GET'
      EXPORTING
        cifkey       = _key
      IMPORTING
        clstype      = o_type
        class        = _class
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        model_only   = 0
        OTHERS       = 4.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( subrc = sy-subrc
                                           classname = 'ZAPLINK_CX'
                                            funcname = 'SEO_CLIF_GET' ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
    ASSERT o_type = objtype-class OR o_type = objtype-interface.
    IF o_type = objtype-class.
      add_class_dep( _name ).
    ELSE.
      add_interface_dep( _name ).
    ENDIF.
    IF context IS INITIAL.
      CALL METHOD _clean_up( ).
    ENDIF.
  ENDMETHOD.
  METHOD add_object_to_list.
    DATA s_obj       LIKE LINE OF required_objects.
    DATA s_key       TYPE seoclskey.
    DATA o_type      TYPE seoclstype.
    DATA s_class     TYPE vseoclass.
    CHECK NOT name IS INITIAL. CHECK is_predeftype( name ) = abap_false.
    s_key-clsname = name.     TRANSLATE s_key-clsname TO UPPER CASE. "#EC SYNTCHAR
    s_obj-name = s_key-clsname.
    CHECK is_excluded_class( name = s_key-clsname ) = abap_false.
    CALL FUNCTION 'SEO_CLIF_GET'
      EXPORTING
        cifkey       = s_key
      IMPORTING
        clstype      = o_type
        class        = s_class
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        model_only   = 0
        OTHERS       = 4.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( subrc = sy-subrc
                                           classname = 'ZAPLINK_CX'
                                            funcname = 'SEO_CLIF_GET' ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
    s_obj-type = o_type.    s_obj-full_def = full.    s_obj-source = position.
    IF s_class-category = '40'.    s_obj-type = objtype-exception_class.   ENDIF.
    APPEND s_obj TO required_objects.
  ENDMETHOD.
  METHOD add_prog_textpool.
    DATA t_texts TYPE tt_txtp_textpools.
    t_texts = zaplink_program_4dep_analyser=>get_prog_textpool( name ).               " Issue 110
    textspool = zaplink_program_4dep_analyser=>fusion_textpool( source = textspool
                                                            completion = t_texts ).   " Issue 110
  ENDMETHOD.
  METHOD add_source.
    DATA _code TYPE string.
    FIELD-SYMBOLS <f> LIKE LINE OF code.
    LOOP AT code ASSIGNING <f>.   CONCATENATE _code <f> line_separator INTO _code.    ENDLOOP.
    add_method_source( code = _code    origin = origin ).
  ENDMETHOD.
  METHOD add_source_to_list.
    DATA t_objs       TYPE tt_abaprawsource.
    DATA _key         TYPE td_name.
    FIELD-SYMBOLS <o> LIKE LINE OF t_objs.
    t_objs = analyse_source( code = code    origin = origin ).
    LOOP AT t_objs ASSIGNING <o>.
      _key = <o>.   add_object_to_list( name = _key   full = full   position = position ).
    ENDLOOP.
  ENDMETHOD.
  METHOD add_types.
    DATA _name TYPE string.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF types.
    LOOP AT types ASSIGNING <t>.
      CONCATENATE 'Type=>' <t>-cmpname INTO _name.          "#EC NOTEXT
      stack( _name ).
      process_type( type = <t>-typtype
                  origin = origin
                    name = <t>-type
                  source = <t>-_ ).
      unstack( ).
    ENDLOOP.
  ENDMETHOD.
  METHOD add_without_requirements.
    DATA s_order   LIKE LINE OF new_order.
    FIELD-SYMBOLS <c> LIKE LINE OF remain_classes.
    LOOP AT remain_classes ASSIGNING <c>.
      READ TABLE remain_requirements TRANSPORTING NO FIELDS
           WITH KEY ori_name = <c>-name.
      IF sy-subrc <> 0.   CLEAR s_order.    s_order-name = <c>-name.    s_order-type = <c>-type.    APPEND s_order TO new_order.    DELETE remain_requirements WHERE name = <c>-name.    result = abap_true.   DELETE remain_classes.    ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD analyse_source.
    CONSTANTS c_symbols_ascii TYPE string VALUE '"$%&()=?\{[]}^+*~#-''.:,;<>|@`!'. "#EC NOTEXT
    DATA t_tokens     TYPE STANDARD TABLE OF stokes.
    DATA t_statments  TYPE STANDARD TABLE OF sstmnt.
    DATA t_string     TYPE STANDARD TABLE OF string.
    DATA d_offset     TYPE i.
    DATA s_obj        LIKE LINE OF objects_list.
    DATA d_tabix      TYPE sy-tabix.
    DATA d_prog       TYPE sy-repid.
    FIELD-SYMBOLS:
      <o> LIKE LINE OF objects_list,
      <t> LIKE LINE OF t_tokens,
      <c> LIKE LINE OF t_tokens.
    CHECK NOT code IS INITIAL.
    SPLIT code AT cl_abap_char_utilities=>newline INTO TABLE t_string.
    SCAN ABAP-SOURCE t_string
             TOKENS INTO t_tokens
         STATEMENTS INTO t_statments.
    LOOP AT t_tokens ASSIGNING <t> WHERE str CP '*=>*'.
      FIND FIRST OCCURRENCE OF '=>' IN <t>-str MATCH OFFSET d_offset.
      s_obj = <t>-str(d_offset). TRANSLATE s_obj TO UPPER CASE. "#EC SYNTCHAR
      CHECK NOT s_obj CA c_symbols_ascii.   " FROM SEO_CLIF_CHECK_NAME
      APPEND s_obj TO objects_list.
    ENDLOOP.
    LOOP AT t_tokens ASSIGNING <t> WHERE str = 'TYPE'.
      d_tabix = sy-tabix + 1.   READ TABLE t_tokens ASSIGNING <c> INDEX d_tabix.
      CHECK sy-subrc = 0.       CHECK <c>-str = 'REF'.
      ADD 1 TO d_tabix.         READ TABLE t_tokens ASSIGNING <c> INDEX d_tabix.
      CHECK sy-subrc = 0.       CHECK <c>-str = 'TO'.
      ADD 1 TO d_tabix.         READ TABLE t_tokens ASSIGNING <c> INDEX d_tabix.
      s_obj = <c>-str. TRANSLATE s_obj TO UPPER CASE.     "#EC SYNTCHAR
      CHECK NOT s_obj CA c_symbols_ascii.   " FROM SEO_CLIF_CHECK_NAME
      APPEND s_obj TO objects_list.
    ENDLOOP.
    SORT objects_list.      DELETE ADJACENT DUPLICATES FROM objects_list.
    IF origin IS NOT INITIAL.
      d_prog = origin.
      LOOP AT objects_list ASSIGNING <o>.
        CALL FUNCTION 'WB_TREE_GET_INCLUDE'
          EXPORTING
            objectname       = <o>
            objecttype       = sana_tok_control_def   " in form search_object
            program          = d_prog
          EXCEPTIONS
            index_not_found  = 1
            object_not_found = 2
            OTHERS           = 3.
        IF sy-subrc <> 0.
          CALL FUNCTION 'WB_TREE_GET_INCLUDE'
            EXPORTING
              objectname       = <o>
              objecttype       = sana_tok_common_def   " in form search_object
              program          = d_prog
            EXCEPTIONS
              index_not_found  = 1
              object_not_found = 2
              OTHERS           = 3.
        ENDIF.
        IF sy-subrc = 0.    DELETE objects_list.    ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD append_message.
    DATA s_msg LIKE LINE OF messages.
    CHECK NOT data IS INITIAL.
    s_msg-name = data.    APPEND s_msg TO messages.
  ENDMETHOD.
  METHOD append_typegroups.
    DATA _tg LIKE LINE OF me->typegroups.
    FIELD-SYMBOLS <t> LIKE LINE OF typegroups.
    LOOP AT typegroups ASSIGNING <t>.
      _tg-name = <t>-typegroup.     APPEND _tg TO me->typegroups.
    ENDLOOP.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _softcomp LIKE LINE OF softcomponents.
    DATA t_types   TYPE sana_type_list.
    DATA s_type    LIKE LINE OF t_types.
    _softcomp-sign = 'I'. _softcomp-option = 'EQ'.
    _softcomp-low = space. APPEND _softcomp TO softcomponents.
    _softcomp-low = 'HOME'. APPEND _softcomp TO softcomponents.
    _softcomp-low = 'LOCAL'. APPEND _softcomp TO softcomponents.
    CREATE OBJECT o_object.
    c_class-type = 'CLAS'.    c_class-kind = zaplink_connectors=>get_typekind( c_class-type ).
    c_interface-type = 'INTF'.    c_interface-kind = zaplink_connectors=>get_typekind( c_interface-type ).
    c_program-type = 'PROG'.    c_program-kind = zaplink_connectors=>get_typekind( c_program-type ).
    c_typegroup-type = 'TYPE'.    c_typegroup-kind = zaplink_connectors=>get_typekind( c_typegroup-type ).
    c_msg_class-type = 'MSAG'.    c_msg_class-kind = zaplink_connectors=>get_typekind( c_msg_class-type ).
    CALL FUNCTION 'RS_GET_PREDEFINED_TYPES'
      IMPORTING
        type_list      = t_types
      EXCEPTIONS
        internal_error = 1
        OTHERS         = 2.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    s_type-name = 'SY'.   APPEND s_type TO t_types.       " Add system name
    s_type-name = 'SYST'.   APPEND s_type TO t_types.
    SORT t_types BY name.   DELETE ADJACENT DUPLICATES FROM t_types.
    predeftypes = t_types.
  ENDMETHOD.
  METHOD convert_line.
    target = zaplink_tools=>conv_abap_line( source ).
  ENDMETHOD.
  METHOD convert_source_upcase.
    FIELD-SYMBOLS <l> LIKE LINE OF targetcode.
    targetcode = sourcecode.
    LOOP AT targetcode ASSIGNING <l>.
      TRANSLATE <l> TO UPPER CASE.                        "#EC SYNTCHAR
    ENDLOOP.
  ENDMETHOD.
  METHOD do_class.
    DATA _codes      LIKE LINE OF classes.
    DATA d_prog      TYPE td_progname.
    DATA d_class     TYPE seoclsname.
    DATA d_includes  TYPE zaplink_object_data=>ts_includes.
    _codes = get_source( name ).
    search_for_include( CHANGING codes = _codes ).
    INSERT _codes INTO TABLE classes.
    d_class = name.
    d_includes = zaplink_object=>get_includes( d_class ).
    d_prog = d_includes-classpool-name.
    add_prog_textpool( d_prog ).
  ENDMETHOD.
  METHOD do_object_list.
    CONSTANTS c_intftype TYPE td_classtype VALUE '9'.
    DATA t_objects TYPE tt_req_objects.
    DATA s_object  LIKE LINE OF required_objects.
    FIELD-SYMBOLS <o> LIKE LINE OF t_objects.
    SORT required_objects BY name full_def DESCENDING.   DELETE ADJACENT DUPLICATES FROM required_objects COMPARING name.
    s_object-type = c_intftype.    MODIFY required_objects FROM s_object TRANSPORTING type WHERE type = objtype-interface.   SORT required_objects BY full_def DESCENDING type DESCENDING name.
    t_objects = required_objects.    CLEAR required_objects.   " memorize object list for recursive calls
    LOOP AT t_objects ASSIGNING <o>.
      stack( context = <o>-source ).    <o>-ori_name = name.    APPEND <o> TO requirements.
      IF <o>-type = c_intftype.   add_interface_dep( name = <o>-name  full = <o>-full_def ).    ELSE.   add_class_dep( name = <o>-name  full = <o>-full_def ).    ENDIF.
      unstack( ).
    ENDLOOP.
  ENDMETHOD.
  METHOD extract_strings.
    CONSTANTS:
      c_crlf          TYPE string VALUE line_separator,
      c_commentedline TYPE string VALUE '*',
      c_commentscheme TYPE string VALUE '*"*',
      c_commentchar   TYPE string VALUE '"'.
    DATA _objects    TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    DATA _max        TYPE sy-tabix.
    DATA _pos        TYPE sy-tabix.
    DATA _idx        TYPE sy-tabix.
    DATA _lines      TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    DATA _line       TYPE string.
    DATA _tmp        TYPE string.
    FIELD-SYMBOLS:
      <l>  LIKE LINE OF _objects,
      <l2> LIKE LINE OF _objects.
    DEFINE mac_split.
      SPLIT _line AT &1 INTO TABLE _lines. " split line into words
      CHECK NOT _lines IS INITIAL.
      READ TABLE _lines INTO _line INDEX 1.
    END-OF-DEFINITION.
    CHECK search_term <> c_crlf.
    IF forward IS INITIAL.
      SPLIT code AT search_term INTO TABLE _objects.
      CHECK NOT _objects IS INITIAL.
      _pos = lines( _objects ).
      DELETE _objects INDEX _pos.  " remove last line (unwanted) because backward search
      LOOP AT _objects ASSIGNING <l>.
        SPLIT <l> AT c_crlf INTO TABLE _lines. " split string into lines
        WHILE NOT _lines IS INITIAL.
          _pos = lines( _lines ).
          READ TABLE _lines INTO _line INDEX _pos.
          _tmp = _line.
          CONDENSE _tmp NO-GAPS.
          IF NOT _tmp IS INITIAL.
            EXIT.
          ENDIF.
          DELETE _lines INDEX _pos.  " empty line
        ENDWHILE.
        CHECK _line(1) <> c_commentedline.      " code line is a comment
        CHECK NOT _line CP c_commentscheme.     " Check line for line comment
        SPLIT _line AT space INTO TABLE _lines. " split line into words
        _pos = lines( _lines ).
        READ TABLE _lines INTO _line INDEX _pos.
        APPEND _line TO results.
      ENDLOOP.
    ELSE.
      SPLIT code AT search_term INTO TABLE _objects.
      CHECK NOT _objects IS INITIAL.
      _max = lines( _objects ) - 1.
      LOOP AT _objects ASSIGNING <l> TO _max.
        _idx = sy-tabix.
        SPLIT <l> AT c_crlf INTO TABLE _lines. " split string into lines
        _pos = lines( _lines ).
        READ TABLE _lines INTO _line INDEX _pos.
        IF NOT _line IS INITIAL.
          CHECK _line(1) <> c_commentedline.        " code line is a comment => ignore
          CHECK NOT _line CP c_commentscheme.       " Check line for line comment
        ENDIF.
        ADD 1 TO _idx.
        READ TABLE _objects ASSIGNING <l2> INDEX _idx.
        SPLIT <l2> AT c_crlf INTO TABLE _lines. " split string into lines
        DELETE _lines WHERE table_line IS INITIAL.
        LOOP AT _lines ASSIGNING <l2>.
          IF <l2>(1) = c_commentedline.
            DELETE _lines.
          ENDIF.
        ENDLOOP.
        LOOP AT _lines INTO _line.
          CLEAR _pos.
          FIND FIRST OCCURRENCE OF c_commentchar IN _line MATCH OFFSET _pos.
          IF NOT _pos IS INITIAL.
            _line = _line(_pos).      " remove comment
          ENDIF.
          _tmp = _line.
          CONDENSE _tmp NO-GAPS.
          IF NOT _tmp IS INITIAL.
            EXIT.
          ENDIF.
        ENDLOOP.
        CONDENSE _line.
        CHECK NOT _line IS INITIAL.
        mac_split space. mac_split ','. mac_split '.'.
        APPEND _line TO results.
      ENDLOOP.
    ENDIF.
    SORT results.
    DELETE ADJACENT DUPLICATES FROM results.
    DELETE results WHERE table_line IS INITIAL.
  ENDMETHOD.
  METHOD get_class_source.
    DATA _clskey     TYPE seoclskey.
    DATA _pos        TYPE sy-tabix.
    DATA t_code      TYPE tt_abaprawsource.
    DATA t_upcode    TYPE tt_abaprawsource.
    DATA _line       LIKE LINE OF t_upcode.
    FIELD-SYMBOLS:
      <l> LIKE LINE OF t_upcode.
    _clskey = name.
    t_code = zaplink_object=>get_class_globalsource( _clskey ).
    zaplink_tools=>remove_comment_on_source( CHANGING table = t_code ).
    ASSERT NOT t_code IS INITIAL.
    t_upcode = convert_source_upcase( t_code ).
    READ TABLE t_upcode ASSIGNING <l> INDEX 1.
    IF <l> CP '*CLASS-POOL*'.   DELETE t_upcode INDEX 1.    DELETE t_code INDEX 1.    ENDIF.
    CONCATENATE 'CLASS' _clskey 'DEFINITION' INTO _line SEPARATED BY space.
    READ TABLE t_upcode TRANSPORTING NO FIELDS FROM _line.
    IF sy-subrc = 0.
      _pos = sy-tabix + 1.
      READ TABLE t_upcode INDEX _pos INTO _line.
      CONDENSE _line NO-GAPS.
      IF _line = 'PUBLIC'.
        DELETE t_code INDEX _pos.       DELETE t_upcode INDEX _pos.
      ENDIF.
    ENDIF.
    CONCATENATE 'CLASS' _clskey 'IMPLEMENTATION.' INTO _line SEPARATED BY space.
    READ TABLE t_upcode TRANSPORTING NO FIELDS FROM _line.
    IF sy-subrc = 0.
      _pos = sy-tabix.
      APPEND LINES OF t_code  FROM _pos TO codes-impl.
      DELETE t_code FROM _pos.    DELETE t_upcode FROM _pos.
      CONCATENATE 'ENDCLASS. "' _clskey ' DEFINITION' INTO _line.
      READ TABLE t_upcode TRANSPORTING NO FIELDS FROM _line.
      ASSERT sy-subrc = 0.
      _pos = sy-tabix.
      APPEND LINES OF t_code TO _pos TO codes-def.
      DELETE t_code TO _pos.    DELETE t_upcode TO _pos.
      codes-macro = t_code.
    ELSE.
      codes-def = t_code.
    ENDIF.
    t_upcode = convert_source_upcase( codes-def ).
    LOOP AT t_upcode ASSIGNING <l>
       WHERE table_line CP '*GLOBAL FRIENDS*'.
      REPLACE FIRST OCCURRENCE OF 'GLOBAL FRIENDS' IN <l> WITH 'FRIENDS'.
      MODIFY codes-def FROM <l> INDEX sy-tabix.
    ENDLOOP.
    remove_def_load( CHANGING codes = codes ).
    codes-name = name.
  ENDMETHOD.
  METHOD get_interface_source.
    DATA _clskey     TYPE seoclskey.
    DATA _line   LIKE LINE OF codes-def.
    DATA _pos        TYPE sy-tabix.
    DATA t_upcode    TYPE tt_abaprawsource.
    _clskey = name.
    codes-def = zaplink_object=>get_interface_globalsource( _clskey ).
    t_upcode = convert_source_upcase( codes-def ).
    CONCATENATE 'INTERFACE' _clskey INTO _line SEPARATED BY space.
    READ TABLE t_upcode TRANSPORTING NO FIELDS
         FROM _line.
    ASSERT sy-subrc = 0.
    _pos = sy-tabix.
    CONCATENATE _line '.' INTO _line.
    MODIFY codes-def FROM _line INDEX _pos.
    ADD 1 TO _pos.
    READ TABLE t_upcode INTO _line INDEX _pos.
    CONDENSE _line NO-GAPS.
    IF _line = 'PUBLIC.'.
      DELETE codes-def INDEX _pos.
    ENDIF.
    remove_def_load( CHANGING codes = codes ).
    codes-name = name.
  ENDMETHOD.
  METHOD get_source.
    DATA _key   TYPE seoclskey.
    DATA o_type TYPE seoclstype.
    DATA _class      TYPE vseoclass.
    _key-clsname = name.
    CALL FUNCTION 'SEO_CLIF_GET'
      EXPORTING
        cifkey       = _key
      IMPORTING
        clstype      = o_type
        class        = _class
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        model_only   = 0
        OTHERS       = 4.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( subrc = sy-subrc
                                           classname = 'ZAPLINK_CX'
                                            funcname = 'SEO_CLIF_GET' ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
    ASSERT o_type = objtype-class OR o_type = objtype-interface.
    IF o_type = objtype-class.
      IF _class-category = '40'.    o_type = objtype-exception_class.   ENDIF.
      codes = get_class_source( name ).
    ELSE.
      codes = get_interface_source( name ).
    ENDIF.
    codes-type = o_type.
  ENDMETHOD.
  METHOD handle_context.
    TYPES:
      BEGIN OF ts_object,
        name  TYPE td_name,
        type  TYPE seoclstype,
        rank  TYPE i,
        tabix TYPE sy-tabix,
        full  TYPE abap_bool,
      END OF ts_object.
    DATA t_objects TYPE STANDARD TABLE OF ts_object WITH DEFAULT KEY.
    DATA s_object  LIKE LINE OF t_objects.
    DATA s_key     TYPE seoclskey.
    DATA d_type    TYPE seoclstype.
    DATA s_class   TYPE vseoclass.
    DATA s_order   LIKE LINE OF order.
    DATA d_tabix   TYPE sy-tabix.
    DATA s_ctx     LIKE LINE OF circular_context.
    FIELD-SYMBOLS:
      <o> LIKE LINE OF t_objects,
      <c> LIKE LINE OF circular_context.
    DELETE circular_context WHERE type IS INITIAL.
    LOOP AT circular_context ASSIGNING <c>.
      CLEAR s_object.   s_object-tabix = sy-tabix.    s_object-name = <c>-context.    s_object-type = <c>-type.   s_object-full = <c>-full_def.
      IF s_object-type = objtype-interface.    s_object-rank = 1.    ELSEIF s_object-type = objtype-exception_class.   s_object-rank = 2.  s_object-type = objtype-exception_class.    ELSE.   s_object-rank = 3.    ENDIF.
      IF s_object-full IS INITIAL.
        ADD 5 TO s_object-rank.
      ENDIF.
      APPEND s_object TO t_objects.
    ENDLOOP.
    SORT t_objects BY name tabix.   DELETE ADJACENT DUPLICATES FROM t_objects COMPARING name.
    IF lines( t_objects ) = 1.    DELETE t_objects WHERE name = current_comp.   ENDIF.
    CHECK NOT t_objects IS INITIAL.   SORT t_objects BY rank tabix.   d_tabix = lines( order ) + 1.   REFRESH circular_context.
    LOOP AT t_objects ASSIGNING <o>.    CLEAR s_ctx.    s_ctx-context = <o>-name.   s_ctx-type = <o>-type.    s_ctx-full_def = <o>-full.    APPEND s_ctx TO circular_context.   ENDLOOP.
    LOOP AT me->context ASSIGNING <c> WHERE NOT type IS INITIAL.
      READ TABLE t_objects TRANSPORTING NO FIELDS WITH KEY name = <c>-context.
      IF sy-subrc <> 0.
        APPEND <c> TO circular_context.
      ENDIF.
    ENDLOOP.
    LOOP AT t_objects ASSIGNING <o>.
      do_class( <o>-name ) .
      CLEAR s_order.  s_order-name = <o>-name.    s_order-type = <o>-type.
      insert_order( s_order = s_order   context = circular_context ).   DELETE circular_context WHERE context = <o>-name.   " <=> should delete index 1.
    ENDLOOP.
    CLEAR: circular_context, circular_ref_on.
  ENDMETHOD.
  METHOD insert_order.
    DATA d_tabix TYPE sy-tabix.
    FIELD-SYMBOLS <c> LIKE LINE OF context.
    DELETE context WHERE type IS INITIAL.   DELETE context WHERE context = s_order-name.
    READ TABLE order TRANSPORTING NO FIELDS
         WITH KEY name = s_order-name
                  type = s_order-type
               defered = abap_false.
    IF sy-subrc = 0.    EXIT.   ENDIF.    " already processed : circular ref
    IF context IS INITIAL.    APPEND s_order TO me->order.    EXIT.   ENDIF.
    inverse_order( CHANGING order = context ).
    LOOP AT context ASSIGNING <c> WHERE full_def = abap_true.
      READ TABLE order TRANSPORTING NO FIELDS
           WITH KEY name = <c>-context
                    type = <c>-type
                 defered = abap_false.
      IF sy-subrc = 0 AND d_tabix > sy-tabix.
        d_tabix = sy-tabix.
      ENDIF.
    ENDLOOP.
    IF d_tabix IS INITIAL.
      d_tabix = lines( order ) + 1.
      LOOP AT context ASSIGNING <c> WHERE full_def = abap_false.
        READ TABLE order TRANSPORTING NO FIELDS
             WITH KEY name = <c>-context
                      type = <c>-type
                   defered = abap_false.
        IF sy-subrc = 0 AND d_tabix > sy-tabix.
          d_tabix = sy-tabix.
        ENDIF.
      ENDLOOP.
    ENDIF.
    INSERT s_order INTO me->order INDEX d_tabix.
    READ TABLE order TRANSPORTING NO FIELDS   " for security
         WITH KEY name = s_order-name
                  type = s_order-type
               defered = abap_false.
    IF sy-subrc <> 0.
      APPEND s_order TO me->order.
    ENDIF.
  ENDMETHOD.
  METHOD inverse_order.
    zaplink_tools=>inverse_table_order( CHANGING my_table = order ).
  ENDMETHOD.
  METHOD is_excluded_class.
    DATA s_excl_c    LIKE LINE OF excluded_classes.
    CLEAR s_comp.   result = abap_true.   READ TABLE excluded_classes TRANSPORTING NO FIELDS WITH TABLE KEY name = name.    CHECK sy-subrc <> 0.
    s_comp-type = type.   s_comp-name = name.
    IF NOT s_comp-type IS INITIAL.
      s_comp-kind = zaplink_connectors=>get_typekind( type ).
      mac_read_tadir s_comp-kind s_comp-type s_comp-name s_comp-devclass s_comp-softcomp.
    ELSE.
      MOVE-CORRESPONDING c_class TO s_comp.
      mac_read_tadir s_comp-kind s_comp-type s_comp-name s_comp-devclass s_comp-softcomp.
      IF sy-subrc <> 0.
        MOVE-CORRESPONDING c_interface TO s_comp.
        mac_read_tadir s_comp-kind s_comp-type s_comp-name s_comp-devclass s_comp-softcomp.
      ENDIF.
    ENDIF.
    IF s_comp-devclass IN packages AND s_comp-softcomp IN softcomponents.    result = abap_false.    ELSE.   s_excl_c-name = name.   INSERT s_excl_c INTO TABLE excluded_classes.    ENDIF.
  ENDMETHOD.
  METHOD is_excluded_include.
    DATA s_excl_c     LIKE LINE OF excluded_includes.
    DATA d_fugr_group TYPE rs38l-area.
    DATA d_class_name TYPE seoclsname.
    DATA d_prog       TYPE rs38l-include.
    CLEAR s_comp.
    result = abap_true.   READ TABLE excluded_includes TRANSPORTING NO FIELDS WITH TABLE KEY name = name.    CHECK sy-subrc <> 0.
    d_prog = name.
    CALL FUNCTION 'RS_PROGNAME_SPLIT'
      EXPORTING
        progname_with_namespace = d_prog
      IMPORTING
        fugr_group              = d_fugr_group
        class_name              = d_class_name
      EXCEPTIONS
        delimiter_error         = 1
        OTHERS                  = 2.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( subrc = sy-subrc
                                           classname = 'ZAPLINK_CX'
                                            funcname = 'RS_PROGNAME_SPLIT' ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
    IF NOT d_fugr_group IS INITIAL.
      s_comp-type = 'FUGR'.
      s_comp-name = d_fugr_group.
    ELSEIF NOT d_class_name IS INITIAL.
      result = is_excluded_class( name = d_class_name ).
      RETURN.
    ELSE.
      s_comp-type = 'PROG'.
      s_comp-name = name.
    ENDIF.
    s_comp-kind = zaplink_connectors=>get_typekind( s_comp-type ).
    mac_read_tadir s_comp-kind s_comp-type s_comp-name s_comp-devclass s_comp-softcomp.
    IF s_comp-devclass IN packages AND s_comp-softcomp IN softcomponents.    result = abap_false.    ELSE.   s_excl_c-name = name.   INSERT s_excl_c INTO TABLE excluded_includes.    ENDIF.
  ENDMETHOD.
  METHOD is_predeftype.
    CHECK NOT name IS INITIAL.
    READ TABLE predeftypes TRANSPORTING NO FIELDS WITH TABLE KEY name = name.
    IF sy-subrc = 0.    result = abap_true.     ENDIF.
  ENDMETHOD.
  METHOD process_type.
    DATA _key        TYPE td_name.
    DATA _obj        TYPE string.
    DATA _type       TYPE string.
    DATA _up_src     TYPE string.
    DATA ctx         LIKE LINE OF context.
    DATA full        TYPE abap_bool.
    ASSERT type <> typetype-code OR NOT origin IS INITIAL.
    _up_src = source.   TRANSLATE _up_src TO UPPER CASE.
    READ TABLE context INTO ctx INDEX 1.
    CASE type.
      WHEN typetype-like OR typetype-type.
        SPLIT name AT '=>' INTO _obj _type.
        CHECK _type <> ''.
        _key = _obj.  full = abap_true.
      WHEN typetype-otype.
        _key = name.
      WHEN typetype-ref.
        _key = name.
      WHEN typetype-code.
        add_source_to_list( code = _up_src   full = abap_true   origin = origin   position = ctx-context ).
        CLEAR _key.   EXIT.
    ENDCASE.
    CHECK NOT _key IS INITIAL.
    add_object_to_list( name = _key   full = full   position = ctx-context ).
  ENDMETHOD.
  METHOD remove_def_load.
    DATA t_upcode    TYPE tt_abaprawsource.
    FIELD-SYMBOLS:
      <l> LIKE LINE OF t_upcode,
      <m> LIKE LINE OF codes-def.
    t_upcode = convert_source_upcase( codes-def ).
    LOOP AT t_upcode ASSIGNING <l>
       WHERE table_line CP '*CLASS * DEFINITION LOAD*'.
      CHECK <l>(1) <> '*'.
      CHECK NOT <l> CP '*"*CLASS * DEFINITION LOAD*'.
      READ TABLE codes-def ASSIGNING <m> INDEX sy-tabix.
      CONCATENATE '*' <m> INTO <m>.
    ENDLOOP.
    LOOP AT t_upcode ASSIGNING <l>
       WHERE table_line CP '*INTERFACE * LOAD*'.
      CHECK <l>(1) <> '*'.
      CHECK NOT <l> CP '*"*INTERFACE * LOAD*'.
      READ TABLE codes-def ASSIGNING <m> INDEX sy-tabix.
      CONCATENATE '*' <m> INTO <m>.
    ENDLOOP.
    t_upcode = convert_source_upcase( codes-macro ).
    LOOP AT t_upcode ASSIGNING <l>
       WHERE table_line CP '*CLASS * DEFINITION LOAD*'.
      CHECK <l>(1) <> '*'.
      CHECK NOT <l> CP '*"*CLASS * DEFINITION LOAD*'.
      READ TABLE codes-macro ASSIGNING <m> INDEX sy-tabix.
      CONCATENATE '*' <m> INTO <m>.
    ENDLOOP.
    LOOP AT t_upcode ASSIGNING <l>
       WHERE table_line CP '*INTERFACE * LOAD*'.
      CHECK <l>(1) <> '*'.
      CHECK NOT <l> CP '*"*INTERFACE * LOAD*'.
      READ TABLE codes-macro ASSIGNING <m> INDEX sy-tabix.
      CONCATENATE '*' <m> INTO <m>.
    ENDLOOP.
  ENDMETHOD.
  METHOD resolve.
    DATA s_order   LIKE LINE OF new_order.
    FIELD-SYMBOLS:
      <o> LIKE LINE OF new_order,
      <c> LIKE LINE OF classes.
    _clean_up( ).
    REFRESH: deferred_declaration.  " staring new program no declaration have been made
    REFRESH: new_order.             " rebuild order list
    remain_classes = classes.
    remain_requirements = requirements.
    WHILE add_without_requirements( ) = abap_true.  ENDWHILE.
    WHILE add_deferred_ok( ) = abap_true.  ENDWHILE.
    IF remain_requirements IS INITIAL.
      LOOP AT remain_classes ASSIGNING <c>.   CLEAR s_order.    s_order-name = <c>-name.    s_order-type = <c>-type.    APPEND s_order TO new_order.    DELETE remain_requirements WHERE name = <c>-name.    DELETE remain_classes.    ENDLOOP.
      order = new_order.
    ELSE.
      LOOP AT new_order ASSIGNING <o>.    WRITE:/ <o>-name.   ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD search_for_include.
    DATA t_includes TYPE tt_abaprawsource.
    DATA d_softcomp TYPE tdevc-dlvunit.
    DATA d_devclass TYPE tdevc-devclass.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF t_includes,
      <l> LIKE LINE OF codes-macro.
    DATA t_tokens TYPE STANDARD TABLE OF stokes.
    DATA t_statements TYPE STANDARD TABLE OF sstmnt.
    DATA t_kw      TYPE STANDARD TABLE OF char255.
    DATA s_kw      LIKE LINE OF t_kw.
    DATA d_tabix   TYPE sy-tabix.
    DATA d_deb     TYPE int4.
    DATA d_fin     TYPE int4.
    DATA d_l_deb   TYPE int4.
    DATA d_l_fin   TYPE int4.
    DATA d_name    TYPE td_name.
    DATA d_prog    TYPE td_progname.
    FIELD-SYMBOLS:
      <st>    LIKE LINE OF t_statements,
      <if>    LIKE LINE OF t_tokens,
      <found> LIKE LINE OF t_tokens,
      <inc>   LIKE LINE OF t_tokens,
      <t_deb> LIKE LINE OF t_tokens,
      <t>     LIKE LINE OF t_tokens.
    s_kw = 'PERFORM'.    APPEND s_kw TO t_kw.
    s_kw = 'INCLUDE'.       APPEND s_kw TO t_kw.
    SCAN ABAP-SOURCE codes-impl TOKENS INTO t_tokens
                            STATEMENTS INTO t_statements
                              KEYWORDS FROM t_kw.
    zaplink_tools=>inverse_table_order( CHANGING my_table = t_statements ).
    LOOP AT t_statements ASSIGNING <st>.
      READ TABLE t_tokens ASSIGNING <t_deb> INDEX <st>-from.    CHECK sy-subrc = 0.
      CASE <t_deb>-str.
        WHEN 'INCLUDE'.
          d_tabix = <st>-from + 1.
          READ TABLE t_tokens ASSIGNING <inc> INDEX d_tabix.    CHECK sy-subrc = 0.
          d_name = <inc>-str.
          CHECK is_excluded_include( d_name ) = abap_false.
          LOOP AT codes-macro FROM <t_deb>-row TO <st>-trow ASSIGNING <l>.
            CASE sy-tabix.
              WHEN <t_deb>-row.
                d_deb = <t_deb>-col.
                IF <t_deb>-row = <st>-trow.
                  d_fin = <st>-tcol - <t_deb>-col + 1.
                ELSE.
                  d_fin = strlen( <l> ) - <t_deb>-col + 1.
                ENDIF.
              WHEN <st>-trow.
                d_deb = 0.
                d_fin = <st>-tcol.
              WHEN OTHERS.
                CLEAR <l>.
            ENDCASE.
            IF NOT <l> IS INITIAL.    REPLACE SECTION OFFSET <t_deb>-col LENGTH <st>-tcol OF <l> WITH space.    ENDIF.
          ENDLOOP.
        WHEN 'PERFORM'.
          LOOP AT t_tokens FROM <st>-from TO <st>-to TRANSPORTING NO FIELDS
               WHERE str CP 'PROGRAM'.
            d_tabix = sy-tabix - 1.   EXIT.
          ENDLOOP.
          CHECK sy-subrc = 0.
          READ TABLE t_tokens ASSIGNING <t_deb> INDEX d_tabix.
          CHECK sy-subrc = 0.   CHECK <t_deb>-str CP 'IN'.   " IN PROGRAM
          d_tabix = d_tabix + 2.    READ TABLE t_tokens ASSIGNING <inc> INDEX d_tabix.
          CHECK sy-subrc = 0 AND NOT <inc>-str IS INITIAL.
          CHECK <inc>-str(1) <> '('.    " Dynamic include name
          d_name = <inc>-str.
          CHECK is_excluded_include( d_name ) = abap_false.
          LOOP AT t_tokens FROM d_tabix TO <st>-to TRANSPORTING NO FIELDS
               WHERE str CP 'FOUND'.
            d_tabix = sy-tabix - 1.   EXIT.
          ENDLOOP.
          IF sy-subrc = 0.
            READ TABLE t_tokens ASSIGNING <if> INDEX d_tabix.
            d_tabix = d_tabix + 1.  READ TABLE t_tokens ASSIGNING <found> INDEX d_tabix.
            IF <if>-str CP 'IF' AND <found>-str CP 'FOUND'.
              d_l_deb = <if>-row.
              d_l_fin = <found>-row.
              LOOP AT codes-impl FROM d_l_deb TO d_l_fin ASSIGNING <l>.
                CASE sy-tabix.
                  WHEN d_l_deb.
                    d_deb = <if>-col.
                    IF d_l_deb = d_l_fin.
                      d_fin = <found>-col + strlen( <found>-str ) - d_deb.
                    ELSE.
                      d_fin = strlen( <l> ) - d_deb.
                    ENDIF.
                  WHEN d_l_fin.
                    d_deb = 0.
                    d_fin = <found>-col + strlen( <found>-str ).
                  WHEN OTHERS.
                    CLEAR <l>.
                ENDCASE.
                IF NOT <l> IS INITIAL.    REPLACE SECTION OFFSET d_deb LENGTH d_fin OF <l> WITH space.    ENDIF.
              ENDLOOP.
            ENDIF.
          ENDIF.
          d_l_deb = <t_deb>-row.
          d_l_fin = <inc>-row.
          d_prog = d_name.      add_include( d_prog ).
          LOOP AT codes-impl FROM d_l_deb TO d_l_fin ASSIGNING <l>.
            CASE sy-tabix.
              WHEN d_l_deb.
                d_deb = <t_deb>-col.
                IF d_l_deb = d_l_fin.
                  d_fin = <inc>-col + strlen( <inc>-str ) - d_deb.
                ELSE.
                  d_fin = strlen( <l> ) - d_deb.
                ENDIF.
              WHEN d_l_fin.
                d_deb = 0.
                d_fin = <inc>-col + strlen( <inc>-str ).
              WHEN OTHERS.
                CLEAR <l>.
            ENDCASE.
            IF NOT <l> IS INITIAL.    REPLACE SECTION OFFSET d_deb LENGTH d_fin OF <l> WITH space.    ENDIF.
          ENDLOOP.
      ENDCASE.
    ENDLOOP.
    SCAN ABAP-SOURCE codes-macro TOKENS INTO t_tokens
                             STATEMENTS INTO t_statements
                               KEYWORDS FROM t_kw.
    zaplink_tools=>inverse_table_order( CHANGING my_table = t_statements ).
    LOOP AT t_statements ASSIGNING <st>.
      READ TABLE t_tokens ASSIGNING <t_deb> INDEX <st>-from.    CHECK sy-subrc = 0.
      CASE <t_deb>-str.
        WHEN 'INCLUDE'.
          d_tabix = <st>-from + 1.
          READ TABLE t_tokens ASSIGNING <inc> INDEX d_tabix.    CHECK sy-subrc = 0.
          d_name = <inc>-str.
          CHECK is_excluded_include( d_name ) = abap_false.
          d_prog = d_name.      add_include( d_prog ).
          LOOP AT codes-macro FROM <t_deb>-row TO <st>-trow ASSIGNING <l>.
            CASE sy-tabix.
              WHEN <t_deb>-row.
                d_deb = <t_deb>-col.
                IF <t_deb>-row = <st>-trow.
                  d_fin = <st>-tcol - <t_deb>-col + 1.
                ELSE.
                  d_fin = strlen( <l> ) - <t_deb>-col + 1.
                ENDIF.
              WHEN <st>-trow.
                d_deb = 0.
                d_fin = <st>-tcol.
              WHEN OTHERS.
                CLEAR <l>.
            ENDCASE.
            IF NOT <l> IS INITIAL.    REPLACE SECTION OFFSET <t_deb>-col LENGTH <st>-tcol OF <l> WITH space.    ENDIF.
          ENDLOOP.
        WHEN 'PERFORM'.
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.
  METHOD set_textpool.
    zaplink_program_4dep_analyser=>set_prog_textpool( program = name
                                                     textpool = textspool ). " Issue 110
  ENDMETHOD.
  METHOD source_2_string.
    FIELD-SYMBOLS <l> LIKE LINE OF data.
    LOOP AT data ASSIGNING <l>.   IF result IS INITIAL.   result = <l>.   ELSE.     CONCATENATE result line_separator <l> INTO result.    ENDIF.    ENDLOOP.
  ENDMETHOD.
  METHOD stack.
    DATA s_ctx LIKE LINE OF context.
    s_ctx-context = context.   s_ctx-type = type.    s_ctx-full_def = full.   INSERT s_ctx INTO me->context INDEX 1.
  ENDMETHOD.
  METHOD unstack.
    IF NOT context IS INITIAL. DELETE context INDEX 1. ENDIF.
    IF context IS INITIAL. CLEAR: circular_ref_on, circular_context. ENDIF.
  ENDMETHOD.
  METHOD _clean_up.
    FIELD-SYMBOLS:
      <r> LIKE LINE OF requirements,
      <c> LIKE LINE OF classes,
      <i> LIKE LINE OF includes,
      <t> LIKE LINE OF typegroups,
      <m> LIKE LINE OF messages.
    SORT requirements BY ori_name name full_def.    DELETE ADJACENT DUPLICATES FROM requirements COMPARING ori_name name full_def.
    LOOP AT requirements ASSIGNING <r>.   CHECK <r>-ori_name = <r>-name.    DELETE requirements.    ENDLOOP.
    inverse_order( CHANGING order = order ).     DELETE ADJACENT DUPLICATES FROM order COMPARING type name.   inverse_order( CHANGING order = order ).
    SORT typegroups.    DELETE ADJACENT DUPLICATES FROM typegroups.
    SORT includes.      DELETE ADJACENT DUPLICATES FROM includes.
    SORT messages.      DELETE ADJACENT DUPLICATES FROM messages.
    REFRESH all_components.
    LOOP AT classes ASSIGNING <c>.    CLEAR s_comp.   IF <c>-type = 0. MOVE-CORRESPONDING c_class TO s_comp. ELSE.   MOVE-CORRESPONDING c_interface TO s_comp.   ENDIF.   s_comp-name = <c>-name.   mac_add_comp.    ENDLOOP.
    LOOP AT typegroups ASSIGNING <t>.    CLEAR s_comp.   MOVE-CORRESPONDING c_typegroup TO s_comp.   s_comp-name = <t>-name.   mac_add_comp.    ENDLOOP.
    LOOP AT includes ASSIGNING <i>.    CLEAR s_comp.   MOVE-CORRESPONDING c_program TO s_comp.   s_comp-name = <i>.   mac_add_comp.    ENDLOOP.
    LOOP AT messages ASSIGNING <m>.    CLEAR s_comp.   MOVE-CORRESPONDING c_msg_class TO s_comp.   s_comp-name = <m>-name.   mac_add_comp.    ENDLOOP.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_DEPENDENCIES_ANALYSER implementation
CLASS zaplink_easyxml_4cnx IMPLEMENTATION.
  METHOD read_object.
    DATA o_raw_base TYPE to_raw_base.
    DATA o_as_raw   TYPE to_raw.
    DATA data_type  TYPE string.
    DATA o_conn     TYPE to_connector.
    DATA _cx        TYPE REF TO cx_root.
    DATA o_cx_cnx   TYPE REF TO zaplink_cx_connector.
    DATA f_newobj   TYPE abap_bool.
    DATA o_raw      TYPE to_raw.
    CHECK object IS BOUND OR typedesc IS BOUND.
    IF NOT object IS BOUND.
      data_type = typedesc->get_relative_name( ).     f_newobj = abap_true.
      TRY.
          CREATE OBJECT object TYPE (data_type).
        CATCH cx_root INTO _cx.
          CALL METHOD application_log->add_exception
            EXPORTING
              exception = _cx.
          EXIT.
      ENDTRY.
    ENDIF.    " for ZL_OBJECT in ZL_TRANSACTION where ZL_OBJECT could be program, transaction or Class
    TRY.
        o_as_raw ?= object.
      CATCH cx_root.
    ENDTRY.
    IF o_as_raw IS BOUND. " object inherited from o_raw_base
      TRY.                  " => Create real data type
          o_raw_base = zaplink_connectors=>node_2_raw( xml_node ).
          o_conn = zaplink_connectors=>create_connector( connuuid = o_raw_base->connector ).
          o_raw = o_conn->create_new_raw( type = o_raw_base->type ).
          IF NOT f_newobj IS INITIAL.
            object = o_raw.                   " Object was not created when calling this method
          ELSE.
            o_as_raw->copy_as( o_raw ).     " Map each fields
          ENDIF.
        CATCH zaplink_cx_connector INTO o_cx_cnx.
          CALL METHOD application_log->add_exception
            EXPORTING
              exception = o_cx_cnx.
          EXIT.
      ENDTRY.
    ENDIF.
    CALL METHOD super->read_object
      EXPORTING
        xml_node = xml_node
        typedesc = typedesc
      CHANGING
        object   = object.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_EASYXML_4CNX implementation
CLASS zaplink_enhancement IMPLEMENTATION.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_id_definition.
    _id-sign = 'I'.
    _id-option = 'EQ'.
    _id-low = 'HY'. APPEND _id TO r_doc_id_definition.
    _id-low = 'BI'. APPEND _id TO r_doc_id_implementation.
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.
    type-type = st_enh_spot.        INSERT type INTO TABLE supported_types.
    type-type = st_comp_enh_spot.   INSERT type INTO TABLE supported_types.
    type-type = st_enh_impl.        INSERT type INTO TABLE supported_types.
    type-type = st_comp_enh_impl.   INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD convert_comp_enh_impl.
    DATA s_comp         TYPE zaplink_enhc_data=>ts_fm_data.
    DATA version        TYPE r3state.
    DATA o_enh          TYPE to_enh_impl_sap.
    DATA o_comp         TYPE to_comp_enh_impl_sap.
    FIELD-SYMBOLS:
      <enh>  LIKE LINE OF raw_object->enhancement_implementations,
      <comp> LIKE LINE OF raw_object->composit_enh_implementations.
    ASSERT sap_object IS BOUND.
    CREATE OBJECT raw_object.
    version = get_version( sap_object ).
    s_comp-header = sap_object->get_enhcompheader( version ).
    IF sub_components >= sub_component-with_required.
      s_comp-comp_enh = sap_object->if_enh_composite~get_composite_childs( version ).
      s_comp-enh = sap_object->if_enh_composite~get_enh_childs( version ).
    ENDIF.
    raw_object->from_data( s_comp ).
    LOOP AT raw_object->enhancement_implementations ASSIGNING <enh>.
      o_enh = _load_enh_impl( <enh>-name ).
      CHECK o_enh IS BOUND.
      CREATE OBJECT <enh>-zl_object.
      <enh>-zl_object->raw = convert_enh_impl( sap_object = o_enh
                                           sub_components = sub_components
                                          components_list = components_list ).
      IF NOT <enh>-zl_object->raw IS BOUND.    CLEAR <enh>-zl_object.     ENDIF.
      IF <enh>-zl_object IS BOUND.      CLEAR <enh>-name.       ENDIF.
    ENDLOOP.
    LOOP AT raw_object->composit_enh_implementations ASSIGNING <comp>.
      o_comp = _load_comp_enh_impl( <comp>-name ).
      CHECK o_comp IS BOUND.
      CREATE OBJECT <comp>-zl_object.
      <comp>-zl_object->raw = convert_comp_enh_impl( sap_object = o_comp
                                                 sub_components = sub_components
                                                components_list = components_list ).
      IF NOT <comp>-zl_object->raw IS BOUND.    CLEAR <comp>-zl_object.     ENDIF.
      IF <comp>-zl_object IS BOUND.      CLEAR <comp>-name.       ENDIF.
    ENDLOOP.
    CLEAR raw_object->a0_maindata-enhcomposite.
  ENDMETHOD.
  METHOD convert_comp_enh_spot.
    DATA s_comp         TYPE zaplink_ensc_data=>ts_fm_data.
    DATA version        TYPE r3state.
    DATA o_enh          TYPE to_enh_spot_sap.
    DATA o_comp         TYPE to_comp_enh_spot_sap.
    FIELD-SYMBOLS:
      <enh>  LIKE LINE OF raw_object->enhancements,
      <comp> LIKE LINE OF raw_object->composit_enhancements.
    ASSERT sap_object IS BOUND.
    CREATE OBJECT raw_object.
    version = get_version( sap_object ).
    s_comp-header = sap_object->get_enhspotcomphead( version ).
    IF sub_components >= sub_component-with_required.
      s_comp-comp_enh = sap_object->if_enh_spot_composite~get_composite_childs( version ).
      s_comp-enh = sap_object->if_enh_spot_composite~get_enh_spot_childs( version ).
    ENDIF.
    raw_object->from_data( s_comp ).
    LOOP AT raw_object->enhancements ASSIGNING <enh>.
      o_enh = _load_enh_spot( <enh>-name ).
      CHECK o_enh IS BOUND.
      CREATE OBJECT <enh>-zl_object.
      <enh>-zl_object->raw = convert_enh_spot( sap_object = o_enh
                                           sub_components = sub_components
                                          components_list = components_list ).
      IF NOT <enh>-zl_object->raw IS BOUND.    CLEAR <enh>-zl_object.     ENDIF.
      IF <enh>-zl_object IS BOUND.      CLEAR <enh>-name.       ENDIF.
    ENDLOOP.
    LOOP AT raw_object->composit_enhancements ASSIGNING <comp>.
      o_comp = _load_comp_enh_spot( <comp>-name ).
      CHECK o_comp IS BOUND.
      CREATE OBJECT <comp>-zl_object.
      <comp>-zl_object->raw = convert_comp_enh_spot( sap_object = o_comp
                                                 sub_components = sub_components
                                                components_list = components_list ).
      IF NOT <comp>-zl_object->raw IS BOUND.    CLEAR <comp>-zl_object.     ENDIF.
      IF <comp>-zl_object IS BOUND.      CLEAR <comp>-name.       ENDIF.
    ENDLOOP.
    CLEAR raw_object->a0_maindata-enhspotcomposite.
  ENDMETHOD.
  METHOD convert_enhancement.
    DATA o_ces      TYPE to_comp_enh_spot_sap.
    DATA o_es       TYPE to_enh_spot_sap.
    DATA o_cei      TYPE to_comp_enh_impl_sap.
    DATA o_ei       TYPE to_enh_impl_sap.
    TRY.
        o_ces ?= sap_object.
        raw_object = convert_comp_enh_spot( sap_object = o_ces
                                        sub_components = sub_components
                                       components_list = components_list ).
      CATCH cx_sy_move_cast_error.    " Wrong Type
    ENDTRY.
    CHECK raw_object IS NOT BOUND.
    TRY.
        o_es ?= sap_object.
        raw_object = convert_enh_spot( sap_object = o_es
                                   sub_components = sub_components
                                  components_list = components_list ).
      CATCH cx_sy_move_cast_error.    " Wrong Type
    ENDTRY.
    CHECK raw_object IS NOT BOUND.
    TRY.
        o_cei ?= sap_object.
        raw_object = convert_comp_enh_impl( sap_object = o_cei
                                        sub_components = sub_components
                                       components_list = components_list ).
      CATCH cx_sy_move_cast_error.    " Wrong Type
    ENDTRY.
    CHECK raw_object IS NOT BOUND.
    TRY.
        o_ei ?= sap_object.
        raw_object = convert_enh_impl( sap_object = o_ei
                                   sub_components = sub_components
                                  components_list = components_list ).
      CATCH cx_sy_move_cast_error.    " Wrong Type
    ENDTRY.
    ASSERT raw_object IS BOUND.
  ENDMETHOD.
  METHOD convert_enh_impl.
    DATA s_comp         TYPE zaplink_enho_data=>ts_fm_data.
    DATA version        TYPE r3state.
    DATA name           TYPE enhname.
    DATA o_store        TYPE REF TO cl_enh_store.   " if_enh_store.
    DATA o_badi_impl    TYPE REF TO cl_enh_tool_badi_impl.
    DATA o_clasenh      TYPE REF TO cl_enh_tool_class.
    DATA o_fugrenh      TYPE REF TO cl_enh_tool_fugr.
    DATA o_hook_impl    TYPE REF TO cl_enh_tool_hook_impl.
    DATA o_intfenh      TYPE REF TO cl_enh_tool_intf.
    DATA o_wdyenh       TYPE REF TO cl_enh_tool_wdy.
    DATA hdr            TYPE enhheader.
    ASSERT sap_object IS BOUND.
    CREATE OBJECT raw_object.
    version = get_version( sap_object ).
    o_store ?= sap_object->get_store( ).
    hdr = o_store->get_enhheader( version ).
    s_comp-header-text_ids-short = hdr-shorttext_id.
    s_comp-header-text_ids-long = hdr-docu_id.
    CLEAR: hdr-data, hdr-data_version.    " binary data
    CALL METHOD sap_object->if_enh_object~get_language
      IMPORTING
        org_langu = s_comp-header-scr-langu.
    CASE hdr-enhtooltype.
      WHEN tooltypes-badi.
        o_badi_impl ?= sap_object.
        o_badi_impl->if_enh_cwb~get_data( EXPORTING i_version = version
                                          IMPORTING    e_data = s_comp-badi_impl-admin ).
      WHEN tooltypes-class.
        o_clasenh ?= sap_object.
        o_clasenh->if_enh_cwb~get_data( EXPORTING i_version = version
                                        IMPORTING    e_data = s_comp-clif_impl ).
      WHEN tooltypes-function_group.
        o_fugrenh ?= sap_object.
        o_fugrenh->if_enh_cwb~get_data( EXPORTING i_version = version
                                        IMPORTING    e_data = s_comp-fugr_impl ).
      WHEN tooltypes-hook.
        o_hook_impl ?= sap_object.
        o_hook_impl->if_enh_cwb~get_data( EXPORTING i_version = version
                                          IMPORTING    e_data = s_comp-hook_impl-admin ).
      WHEN tooltypes-interface.
        o_intfenh ?= sap_object.
        o_intfenh->if_enh_cwb~get_data( EXPORTING i_version = version
                                        IMPORTING    e_data = s_comp-clif_impl ).
      WHEN tooltypes-web_dynpro.
        o_wdyenh ?= sap_object.
        o_wdyenh->if_enh_cwb~get_data( EXPORTING i_version = version
                                       IMPORTING    e_data = s_comp-wdyn_impl ).
    ENDCASE.
    s_comp-header-composite = cl_enh_factory=>enh_find_parent_composite( name ) .
    s_comp-header-hdr = hdr.
    raw_object->from_data( s_comp ).
    CLEAR raw_object->a0_maindata-composite.
  ENDMETHOD.
  METHOD convert_enh_spot.
    DATA s_comp           TYPE zaplink_enhs_data=>ts_fm_data.
    DATA version          TYPE r3state.
    DATA name             TYPE enhspotcompositename.
    DATA texts            TYPE zaplink_enhs_data=>ts_sotr.
    ASSERT sap_object IS BOUND.
    CREATE OBJECT raw_object.
    s_comp-header-version = version = get_version( sap_object ).
    s_comp-header-name = name = sap_object->get_name( ).
    s_comp-header-tool_type = sap_object->get_tool( ).
    SELECT SINGLE shorttextid docuid
      INTO (texts-short, texts-long)
      FROM enhspotheader
      WHERE enhspot = name
        AND version = 'I'.
    IF sy-subrc <> 0.
      SELECT SINGLE shorttextid docuid
        INTO (texts-short, texts-long)
        FROM enhspotheader
        WHERE enhspot = name.
    ENDIF.
    IF texts IS NOT INITIAL.
      s_comp-texts = raw_object->sotr_2_texts( texts ).
    ENDIF.
    sap_object->if_enh_object~get_language( IMPORTING org_langu = s_comp-header-lang-language ) .
    sap_object->get_attributes(
        EXPORTING version = version
        IMPORTING  author = s_comp-header-attrs-author
                createdon = s_comp-header-attrs-createdon
                changedby = s_comp-header-attrs-changedby
                changedon = s_comp-header-attrs-changedon
        ).
    s_comp-header-composite = cl_enh_factory=>enhspot_find_parent_composite( name ).
    s_comp-header-internal_use = sap_object->get_internal( version ).
    raw_object->from_data( s_comp ).
    CLEAR raw_object->a0_maindata-name.
  ENDMETHOD.
  METHOD create_sotr_id.
    CALL FUNCTION 'GUID_CREATE'
      IMPORTING
        ev_guid_32 = result.
    ASSERT result IS NOT INITIAL.
  ENDMETHOD.
  METHOD get_version.
    IF enhancement->has_active_version( ) = abap_true.
      version = 'A'.
    ELSE.
      version = 'I'.
    ENDIF.
  ENDMETHOD.
  METHOD import_to_comp_enh_spot.
    DATA s_comp     TYPE zaplink_ensc_data=>ts_fm_data.
    DATA o_comp     TYPE REF TO if_enh_spot_composite.    "cl_enh_spot_composite.
    s_comp = o_data->to_data( ).
    CALL METHOD cl_r3standard_persistence=>create_spot_composite
      EXPORTING
        name      = o_data->a0_maindata-enhspotcomposite
        scwb_call = abap_false
        run_dark  = abap_true
      IMPORTING
        composite = o_comp.
    o_comp->if_enh_object~save( ).
  ENDMETHOD.
  METHOD load_comp_enh_impl.
    DATA _name      TYPE td_enh_impl_name.
    ASSERT component->get_type( ) = st_comp_enh_impl.
    _name = component->get_name( ).
    object ?= _load_comp_enh_impl( name = _name
                                locking = locking ).
  ENDMETHOD.
  METHOD load_comp_enh_spot.
    DATA _name      TYPE td_comp_enh_spot_name.
    ASSERT component->get_type( ) = st_comp_enh_spot.
    _name = component->get_name( ).
    object ?= _load_comp_enh_spot( name = _name
                                locking = locking ).
  ENDMETHOD.
  METHOD load_enhancement.
    DATA d_type         TYPE td_comptype.
    TRY.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN st_enh_spot.
            object = load_enh_spot( component = component
                                      locking = locking ).
          WHEN st_comp_enh_spot.
            object = load_comp_enh_spot( component = component
                                           locking = locking ).
          WHEN st_enh_impl.
            object = load_enh_impl( component = component
                                      locking = locking ).
          WHEN st_comp_enh_impl.
            object = load_comp_enh_impl( component = component
                                           locking = locking ).
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD load_enh_impl.
    DATA _name      TYPE td_enh_impl_name.
    ASSERT component->get_type( ) = st_enh_impl.
    _name = component->get_name( ).
    object = _load_enh_impl( name = _name
                          locking = locking ).
  ENDMETHOD.
  METHOD load_enh_spot.
    DATA _name      TYPE td_enh_spot_name.
    ASSERT component->get_type( ) = st_enh_spot.
    _name = component->get_name( ).
    object ?= _load_enh_spot( name = _name
                           locking = locking ).
  ENDMETHOD.
  METHOD off_export_from_comp_enh_impl.
    DATA f_subcomp  TYPE td_with_subcomp.
    DATA o_list     TYPE to_list.
    DATA o_sap_intf TYPE to_comp_enh_impl_sap.
    TRY.
        o_sap_intf = load_comp_enh_impl( component ).
        ASSERT o_sap_intf IS BOUND.
        f_subcomp = component->get_with_subcomp( ).
        CREATE OBJECT o_list.
        component->set_subcomponents( o_list ).
        TRY.
            o_list->remove( component ).
          CATCH zaplink_cx_list.
        ENDTRY.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD off_export_from_comp_enh_spot.
    DATA f_subcomp  TYPE td_with_subcomp.
    DATA o_list     TYPE to_list.
    DATA o_sap_intf TYPE to_comp_enh_spot_sap.
    TRY.
        o_sap_intf = load_comp_enh_spot( component ).
        ASSERT o_sap_intf IS BOUND.
        f_subcomp = component->get_with_subcomp( ).
        CREATE OBJECT o_list.
        component->set_subcomponents( o_list ).
        object = convert_comp_enh_spot( sap_object = o_sap_intf
                                    sub_components = f_subcomp
                                   components_list = o_list ).
        TRY.
            o_list->remove( component ).
          CATCH zaplink_cx_list.
        ENDTRY.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD off_export_from_enhancement.
  ENDMETHOD.
  METHOD off_export_from_enh_impl.
    DATA f_subcomp  TYPE td_with_subcomp.
    DATA o_list     TYPE to_list.
    DATA o_sap_intf TYPE to_comp_enh_spot_sap.
    TRY.
        o_sap_intf = load_comp_enh_spot( component ).
        ASSERT o_sap_intf IS BOUND.
        f_subcomp = component->get_with_subcomp( ).
        CREATE OBJECT o_list.
        component->set_subcomponents( o_list ).
        TRY.
            o_list->remove( component ).
          CATCH zaplink_cx_list.
        ENDTRY.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD off_export_from_enh_spot.
  ENDMETHOD.
  METHOD reverse_comp_enh_impl.
    DATA s_comp         TYPE zaplink_enhc_data=>ts_fm_data.
    DATA o_gen          TYPE REF TO if_enh_composite.
    DATA object        TYPE to_comp_enh_impl_sap.
    DATA texts          TYPE zaplink_enhc_data=>ts_sotr.
    DATA l_id           TYPE enhdocuobject.
    FIELD-SYMBOLS: <l>  LIKE LINE OF raw_object->a0_maindata-texts.
    ASSERT raw_object IS BOUND.
    s_comp = raw_object->to_data( ).
    object ?= _load_comp_enh_impl( name = s_comp-header-enhcomposite
                                locking = abap_true ).
    IF object IS BOUND.
    ENDIF.
    cl_enh_factory=>create_enhancement_composite(
          EXPORTING name      = s_comp-header-enhcomposite
                    run_dark  = abap_true
          IMPORTING composite = o_gen ).
    sap_object ?= o_gen.
    l_id = texts-long  = create_sotr_id( ).
    sap_object->if_enh_composite~set_longtext_id( l_id ).
    READ TABLE raw_object->a0_maindata-texts ASSIGNING <l>
        WITH KEY lang = sy-langu.
    IF <l> IS ASSIGNED.
      sap_object->if_enh_object_docu~set_shorttext( <l>-text ).    " not blank string
    ELSE.
      sap_object->if_enh_object_docu~set_shorttext( 'X' ).    " not blank string
    ENDIF.
    sap_object->if_enh_object~save( ).
    texts-short = sap_object->if_enh_composite~get_shorttext_id(  ).
    set_sotr( sotr = texts
             texts = raw_object->a0_maindata-texts ).
  ENDMETHOD.
  METHOD reverse_comp_enh_spot.
    DATA s_comp         TYPE zaplink_ensc_data=>ts_fm_data.
    DATA o_gen          TYPE REF TO if_enh_spot_composite.
    DATA name           TYPE  td_comp_enh_spot_name.
    DATA object         TYPE REF TO if_enh_object.
    DATA texts          TYPE zaplink_enhs_data=>ts_sotr.
    DATA l_id           TYPE enhdocuobject.
    FIELD-SYMBOLS: <l>  LIKE LINE OF raw_object->a0_maindata-texts.
    ASSERT raw_object IS BOUND.
    s_comp = raw_object->to_data( ).
    object ?= _load_comp_enh_spot( name = s_comp-header-enhspotcomposite
                                locking = abap_true ).
    IF object IS BOUND.
      object->delete( run_dark = abap_true ).
      object->unlock( ).
    ENDIF.
    cl_enh_factory=>create_enhancement_spot_comp(
          EXPORTING name      = s_comp-header-enhspotcomposite
                    run_dark  = abap_true
          IMPORTING composite = o_gen ).
    sap_object ?= o_gen.
    l_id = texts-long  = create_sotr_id( ).
    sap_object->if_enh_spot_composite~set_longtext_id( l_id ).
    READ TABLE raw_object->a0_maindata-texts ASSIGNING <l>
        WITH KEY lang = sy-langu.
    IF <l> IS ASSIGNED.
      sap_object->if_enh_object_docu~set_shorttext( <l>-text ).    " not blank string
    ELSE.
      sap_object->if_enh_object_docu~set_shorttext( 'X' ).    " not blank string
    ENDIF.
    sap_object->if_enh_object~save( ).
    texts-short = sap_object->if_enh_spot_composite~get_shorttext_id(  ).
    set_sotr( sotr = texts
             texts = raw_object->a0_maindata-texts ).
  ENDMETHOD.
  METHOD reverse_enh_impl.
    DATA s_comp         TYPE zaplink_enho_data=>ts_fm_data.
    DATA object         TYPE REF TO if_enh_object.
    DATA o_gen          TYPE REF TO if_enh_tool.
    DATA txt_id         TYPE enhdocuobject.
    ASSERT raw_object IS BOUND.
    s_comp = raw_object->to_data( ).
    object ?= _load_enh_impl( name = s_comp-header-enhspot
                           locking = abap_true ).
    IF object IS BOUND.
      object->delete( run_dark = abap_true ).
      object->unlock( ).
    ENDIF.
    cl_enh_factory=>create_enhancement( EXPORTING enhname = s_comp-header-enhspot
                                                  enhtype = cl_abstract_enh_tool_redef=>credefinition
                                              enhtooltype = cl_enh_tool_badi_def=>tooltype
                                                     dark = abap_true
                                    IMPORTING enhancement = o_gen ).
    sap_object ?= o_gen.
  ENDMETHOD.
  METHOD reverse_enh_spot.
  ENDMETHOD.
  METHOD reverse_raw.
    DATA o_ces      TYPE to_comp_enh_spot.
    DATA o_es       TYPE to_enh_spot.
    DATA o_cei      TYPE to_comp_enh_impl.
    DATA o_ei       TYPE to_enh_impl.
    TRY.
        o_ces ?= raw_object.
        o_ces->a0_maindata-enhspotcomposite = name.
        sap_object = reverse_comp_enh_spot( raw_object = o_ces
                                       components_list = components_list ).
      CATCH cx_sy_move_cast_error.    " Wrong Type
    ENDTRY.
    CHECK sap_object IS NOT BOUND.
    TRY.
        o_es ?= raw_object.
        o_es->a0_maindata-name = name.
        sap_object = reverse_enh_spot( raw_object = o_es
                                  components_list = components_list ).
      CATCH cx_sy_move_cast_error.    " Wrong Type
    ENDTRY.
    CHECK sap_object IS NOT BOUND.
    TRY.
        o_cei ?= raw_object.
        o_cei->a0_maindata-enhcomposite = name.
        sap_object = reverse_comp_enh_impl( raw_object = o_cei
                                       components_list = components_list ).
      CATCH cx_sy_move_cast_error.    " Wrong Type
    ENDTRY.
    CHECK sap_object IS NOT BOUND.
    TRY.
        o_ei ?= raw_object.
        o_ei->a0_maindata-enhspot = name.
        sap_object = reverse_enh_impl( raw_object = o_ei
                                  components_list = components_list ).
      CATCH cx_sy_move_cast_error.    " Wrong Type
    ENDTRY.
    ASSERT raw_object IS BOUND.
  ENDMETHOD.
  METHOD set_sotr.
    DATA _txt     TYPE string.
    DATA s_pack   TYPE devclass.
    DATA l_pack   TYPE devclass.
    DATA s_type   TYPE trobjtype.
    DATA l_type   TYPE trobjtype.
    FIELD-SYMBOLS: <t> LIKE LINE OF texts.
    DATA entry    TYPE sotr_text.
    SELECT SINGLE h~paket u~object        " See note 1481544
      INTO (s_pack, s_type)
      FROM sotr_head AS h INNER JOIN sotr_use AS u ON u~concept = h~concept
      WHERE h~concept = sotr-short.
    SELECT SINGLE h~paket u~object
      INTO (l_pack, l_type)
      FROM sotr_head AS h INNER JOIN sotr_use AS u ON u~concept = h~concept
      WHERE h~concept = sotr-long.
    IF sy-subrc <> 0.   l_pack = s_pack.    l_type = s_type.    ENDIF.
    IF sotr-short IS NOT INITIAL.
      CALL FUNCTION 'BTFR_MAINTAIN_SINGLE_TEXT'
        EXPORTING
          package               = s_pack
          object_type           = s_type
          langu                 = sy-langu    "master lang
          concept               = sotr-short
          flag_no_screen        = abap_true
          default_text          = ` `
          flag_correction_entry = abap_false
        EXCEPTIONS
          parameter_error       = 1
          text_not_found        = 2
          invalid_object_type   = 3
          invalid_package       = 4
          header_diff_interface = 5
          invalid_tadir_entry   = 6
          invalid_transl_type   = 7
          invalid_concept       = 8
          OTHERS                = 9.
      IF sy-subrc <> 0.
        mac_raise_mf 'BTFR_MAINTAIN_SINGLE_TEXT' sy-subrc.
      ENDIF.
    ENDIF.
    IF sotr-long IS NOT INITIAL.
      CALL FUNCTION 'BTFR_MAINTAIN_SINGLE_TEXT'
        EXPORTING
          package               = l_pack
          object_type           = l_type
          langu                 = sy-langu    " master lang
          concept               = sotr-long
          flag_string           = abap_true
          flag_no_screen        = abap_true
          default_text          = ` `
          flag_correction_entry = abap_false
        EXCEPTIONS
          parameter_error       = 1
          text_not_found        = 2
          invalid_object_type   = 3
          invalid_package       = 4
          header_diff_interface = 5
          invalid_tadir_entry   = 6
          invalid_transl_type   = 7
          invalid_concept       = 8
          OTHERS                = 9.
      IF sy-subrc <> 0.
        mac_raise_mf 'BTFR_MAINTAIN_SINGLE_TEXT' sy-subrc.
      ENDIF.
    ENDIF.
    LOOP AT texts ASSIGNING <t>.
      IF <t>-text IS NOT INITIAL.
        CLEAR entry.
        entry-langu = <t>-lang.
        entry-text = <t>-text.
        CALL FUNCTION 'SOTR_INSERT_CONCEPT_ENTRY'
          EXPORTING
            concept             = sotr-short
            check_master_langu  = abap_false
            check_master_system = abap_false
          CHANGING
            entry               = entry.
        IF sy-subrc <> 0.
        ENDIF.
      ENDIF.
      IF <t>-_ IS NOT INITIAL.
        _txt = <t>-_.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_conn   TYPE to_connector.
    DATA o_ces    TYPE to_comp_enh_spot.
    DATA o_es     TYPE to_enh_spot.
    DATA o_ei     TYPE to_enh_impl.
    DATA o_cei    TYPE to_comp_enh_impl.
    CREATE OBJECT object.
    CASE type.
      WHEN st_enh_spot.
        CREATE OBJECT o_es.
        object->raw = o_es.
      WHEN st_comp_enh_spot.
        CREATE OBJECT o_ces.
        object->raw = o_ces.
      WHEN st_enh_impl.
        CREATE OBJECT o_ei.
        object->raw = o_ei.
      WHEN st_comp_enh_impl.
        CREATE OBJECT o_cei.
        object->raw = o_cei.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA o_enh    TYPE to_enhancement_sap.
    DATA o_root   TYPE REF TO cx_root.
    DATA type     TYPE td_comptype.
    DATA name     TYPE td_compname.
    type = component->get_type( ).
    name = component->get_name( ).
    TRY.
        o_enh = load_enhancement( component = component
                                    locking = abap_true ).
        o_enh->delete( run_dark = abap_true ).
        result = abap_true.
      CATCH cx_root INTO o_root.
        mac_cascade_raise o_mycx o_root.
    ENDTRY.
    zaplink_tools=>remove_comp_from_working_area( type = type
                                                  name = name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA d_type             TYPE td_comptype.
    DATA d_name             TYPE td_compname.
    DATA n_enh_spot         TYPE td_enh_spot_name.
    DATA n_comp_enh_spot    TYPE td_comp_enh_spot_name.
    DATA n_enh_impl         TYPE td_enh_impl_name.
    DATA n_comp_enh_impl    TYPE td_comp_enh_spot_name.
    exists = me->exists-not_exists.
    d_type = component->get_type( ).
    d_name = component->get_name( ).
    CASE d_type.
      WHEN st_enh_spot.
        n_enh_spot = d_name.
        exists = _enh_spot_exists( n_enh_spot ).
      WHEN st_comp_enh_spot.
        n_comp_enh_spot = d_name.
        exists = _comp_enh_spot_exists( n_comp_enh_spot ).
      WHEN st_enh_impl.
        n_enh_impl = d_name.
        exists = _enh_impl_exists( n_enh_impl ).
      WHEN st_comp_enh_impl.
        n_comp_enh_impl = d_name.
        exists = _comp_enh_impl_exists( n_comp_enh_impl ).
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name d_type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.    result = abap_true.   ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    DATA f_subcomp  TYPE td_with_subcomp.
    DATA o_list     TYPE to_list.
    DATA o_sap_intf TYPE to_enhancement_sap.
    CREATE OBJECT object.
    object->set_component( component ).
    TRY.
        o_sap_intf = load_enhancement( component ).
        ASSERT o_sap_intf IS BOUND.
        f_subcomp = component->get_with_subcomp( ).
        CREATE OBJECT o_list.
        component->set_subcomponents( o_list ).
        object->raw = convert_enhancement( sap_object = o_sap_intf
                                       sub_components = f_subcomp
                                      components_list = o_list ).
        TRY.
            o_list->remove( component ).
          CATCH zaplink_cx_list.
        ENDTRY.
        object->update_connector_data( me ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    DATA o_sap_intf TYPE to_enhancement_sap.
    DATA o_err_list TYPE REF TO cl_wb_checklist.
    TRY.
        ASSERT object->raw IS BOUND.
        CREATE OBJECT components.
        o_sap_intf = reverse_raw( raw_object = object->raw
                                        name = object->name
                             components_list = components ).
        o_sap_intf->check( EXPORTING    version = 'I' " Inactive
                            CHANGING error_list = o_err_list ).
        o_sap_intf->save( run_dark = abap_true ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD _comp_enh_impl_exists.
    DATA d_name         TYPE td_compname.
    exists = me->exists-not_exists.
    SELECT SINGLE enhcomposite INTO d_name
      FROM enhcompheader
      WHERE enhcomposite = name.
    CHECK sy-subrc = 0.
    exists = me->exists-exists.
  ENDMETHOD.
  METHOD _comp_enh_spot_exists.
    DATA d_name         TYPE td_compname.
    exists = me->exists-not_exists.
    SELECT SINGLE enhspotcomposite INTO d_name
      FROM enhspotcomphead
      WHERE enhspotcomposite = name.
    CHECK sy-subrc = 0.
    exists = me->exists-exists.
  ENDMETHOD.
  METHOD _enh_impl_exists.
    DATA d_name         TYPE td_compname.
    exists = me->exists-not_exists.
    SELECT SINGLE enhname INTO d_name
      FROM enhheader
      WHERE enhname = name.
    CHECK sy-subrc = 0.
    exists = me->exists-exists.
  ENDMETHOD.
  METHOD _enh_spot_exists.
    DATA d_name         TYPE td_compname.
    exists = me->exists-not_exists.
    SELECT SINGLE enhspot INTO d_name
      FROM enhspotheader
      WHERE enhspot = name.
    CHECK sy-subrc = 0.
    exists = me->exists-exists.
  ENDMETHOD.
  METHOD _load_comp_enh_impl.
    IF _comp_enh_impl_exists( name ) = abap_true.
      object ?= cl_enh_factory=>load_enhancement_composite( name = name
                                                            lock = locking
                                                        run_dark = abap_true ).
    ENDIF.
  ENDMETHOD.
  METHOD _load_comp_enh_spot.
    DATA o_root         TYPE REF TO cx_root.
    IF _comp_enh_spot_exists( name ) = abap_true.
      TRY.
          object ?= cl_enh_factory=>load_enhancement_spot_comp( name = name
                                                                lock = locking
                                                            run_dark = abap_true ).
        CATCH cx_enh_permission_denied INTO o_root.
        CATCH cx_enh_is_locked INTO o_root.
        CATCH cx_enh_canceled INTO o_root.
      ENDTRY.
      IF o_root IS BOUND.
        mac_cascade_raise o_mycx o_root.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD _load_enh_impl.
    IF _enh_impl_exists( name ) = abap_true.
      object ?= cl_enh_factory=>get_enhancement( enhancement_id = name
                                                           lock = locking
                                                       run_dark = abap_true ).
    ENDIF.
  ENDMETHOD.
  METHOD _load_enh_spot.
    IF _enh_spot_exists( name ) = abap_true.
      object ?= cl_enh_factory=>get_enhancement_spot( spot_name = name
                                                           lock = locking
                                                       run_dark = abap_true ).
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_ENHANCEMENT implementation
CLASS zaplink_enhc_data IMPLEMENTATION.
  METHOD from_data.
    DATA s_enh    LIKE LINE OF enhancement_implementations.
    DATA s_comp   LIKE LINE OF composit_enh_implementations.
    DATA s_txt    TYPE ts_sotr.
    FIELD-SYMBOLS:
      <enh>  LIKE LINE OF data-enh,
      <comp> LIKE LINE OF data-comp_enh.
    a0_maindata-main = data-header.
    s_txt-short = a0_maindata-shorttextid.
    s_txt-long = a0_maindata-docuid.
    CLEAR: a0_maindata-shorttextid, a0_maindata-docuid.
    a0_maindata-texts = sotr_2_texts( s_txt ).
    LOOP AT data-enh ASSIGNING <enh>.
      CLEAR s_enh.
      s_enh-name = <enh>.
      APPEND s_enh TO enhancement_implementations.
    ENDLOOP.
    LOOP AT data-comp_enh ASSIGNING <comp>.
      CLEAR s_comp.
      s_comp-name = <comp>.
      APPEND s_comp TO composit_enh_implementations.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_enh    LIKE LINE OF data-enh.
    DATA s_comp   LIKE LINE OF data-comp_enh.
    FIELD-SYMBOLS:
      <enh>  LIKE LINE OF enhancement_implementations,
      <comp> LIKE LINE OF composit_enh_implementations.
    data-header = a0_maindata-main.
    LOOP AT enhancement_implementations ASSIGNING <enh>.
      CLEAR s_enh.
      s_enh = <enh>-name.
      APPEND s_enh TO data-enh.
    ENDLOOP.
    LOOP AT composit_enh_implementations ASSIGNING <comp>.
      CLEAR s_comp.
      s_comp = <comp>-name.
      APPEND s_comp TO data-comp_enh.
    ENDLOOP.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner_4data~anonymize.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner_4data~unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_ENHC_DATA implementation
CLASS zaplink_enho_data IMPLEMENTATION.
  METHOD clif_sap2int.
    DATA s_line   LIKE LINE OF int_data-sources.
    DATA s_attr   LIKE LINE OF int_data-attributes.
    DATA s_pre_m  LIKE LINE OF int_data-pre_methodes.
    DATA s_pos_m  LIKE LINE OF int_data-post_methodes.
    DATA s_save   LIKE LINE OF int_data-save_enhincinx.
    DATA s_n_met  LIKE LINE OF int_data-new_methodes.
    DATA s_m_inc  LIKE LINE OF int_data-methodes_includes.
    DATA s_event  LIKE LINE OF int_data-events.
    DATA s_impl   LIKE LINE OF int_data-implementings.
    DATA s_ow_me  LIKE LINE OF int_data-overwrite_methodes.
    DATA s_types  LIKE LINE OF int_data-types.
    FIELD-SYMBOLS:
      <e> LIKE LINE OF sap_data-enh_events,
      <m> LIKE LINE OF int_data-methodes,
      <i> LIKE LINE OF sap_data-enh_methsources.
    DATA s_param  LIKE LINE OF <m>-enhparams.
    DATA s_ev_pa  LIKE LINE OF s_event-parameters.
    int_data-name = sap_data-clsname.
    int_data-attributes = sap_data-enh_attributes.
    MODIFY int_data-attributes FROM s_attr TRANSPORTING clsname WHERE clsname = int_data-name.
    int_data-methodes = sap_data-enh_methodes.
    LOOP AT int_data-methodes ASSIGNING <m>.
      MODIFY <m>-enhparams FROM s_param TRANSPORTING clsname WHERE clsname = int_data-name.
    ENDLOOP.
    int_data-pre_methodes = sap_data-enh_premethodes.
    MODIFY int_data-pre_methodes FROM s_pre_m TRANSPORTING methkey-clsname WHERE methkey-clsname = int_data-name.
    int_data-post_methodes = sap_data-enh_postmethodes.
    MODIFY int_data-post_methodes FROM s_pos_m TRANSPORTING methkey-clsname WHERE methkey-clsname = int_data-name.
    int_data-save_enhincinx = sap_data-save_enhincinx.
    MODIFY int_data-save_enhincinx FROM s_save TRANSPORTING enhname WHERE enhname = a0_maindata-enhspot.
    int_data-new_methodes = sap_data-enh_newmethodes.
    MODIFY int_data-new_methodes FROM s_n_met TRANSPORTING methkey-clsname WHERE methkey-clsname = int_data-name.
    LOOP AT sap_data-enh_methsources ASSIGNING <i>.
      CLEAR s_line.
      s_line-name = <i>-cpdname.
      s_line-redefine = <i>-redefine.
      s_line-source-_ = zaplink_enhancement=>conv_abap_raw2source( <i>-source ).
      INSERT s_line INTO TABLE int_data-sources.
    ENDLOOP.
    int_data-methodes_includes = sap_data-enh_methincludes.
    LOOP AT sap_data-enh_events ASSIGNING <e>.
      CLEAR s_event.
      s_event-hdr = <e>-event_header.
      CLEAR s_event-clsname.
      s_event-parameters = <e>-event_param.
      MODIFY s_event-parameters FROM s_ev_pa TRANSPORTING clsname cmpname
                                WHERE clsname = int_data-name AND cmpname = s_event-cmpname.
      INSERT s_event INTO TABLE int_data-events.
    ENDLOOP.
    int_data-implementings = sap_data-enh_implementings.
    MODIFY int_data-implementings FROM s_impl TRANSPORTING clsname WHERE clsname = int_data-name.
    int_data-overwrite_methodes = sap_data-enh_owrmethodes.
    MODIFY int_data-overwrite_methodes FROM s_ow_me TRANSPORTING methkey-clsname WHERE methkey-clsname = int_data-name.
    int_data-types = sap_data-enh_types.
    MODIFY int_data-types FROM s_types TRANSPORTING clsname WHERE clsname = int_data-name.
    int_data-implementation_source-_ = zaplink_enhancement=>conv_abap_raw2source( sap_data-enh_eimpsource ).
    int_data-access_pri_pro = sap_data-enh_access_pri_pro.
  ENDMETHOD.
  METHOD from_data.
    DATA s_badi_impl    LIKE LINE OF badi_implementations.
    DATA s_txt          TYPE ts_sotr.
    DATA s_hook_impl    LIKE LINE OF hook_implementations.
    FIELD-SYMBOLS:
      <table>     LIKE class_implementation,
      <hook_impl> LIKE LINE OF data-hook_impl-enh,
      <badi_impl> LIKE LINE OF data-badi_impl-admin-impl_data.
    a0_maindata-scr = data-header-scr.
    MOVE-CORRESPONDING data-header-hdr TO a0_maindata-scr.
    CLEAR a0_maindata-scr-state.
    a0_maindata-enhspot = data-header-hdr-enhname.
    a0_maindata-texts = sotr_2_texts( data-header-text_ids ).
    a0_maindata-add-type = data-header-hdr-type.
    a0_maindata-add-tool_type = data-header-hdr-enhtooltype.
    a0_maindata-add-upgrade = data-header-hdr-upgrade.
    CASE a0_maindata-add-tool_type.
      WHEN zaplink_enhancement=>tooltypes-badi.
        LOOP AT data-badi_impl-admin-impl_data ASSIGNING <badi_impl>.
          CLEAR s_badi_impl.
          s_badi_impl-main = <badi_impl>.
          s_txt-short = s_badi_impl-impl_shorttext_id.
          s_txt-long = s_badi_impl-impl_longtext_id.
          s_badi_impl-texts = sotr_2_texts( s_txt ).
          CLEAR: s_badi_impl-spot_name, s_badi_impl-impl_name,
                 s_badi_impl-impl_shorttext_id, s_badi_impl-impl_shorttext, s_badi_impl-impl_longtext_id.
          INSERT s_badi_impl INTO TABLE badi_implementations.
        ENDLOOP.
      WHEN zaplink_enhancement=>tooltypes-class OR zaplink_enhancement=>tooltypes-interface.
        IF a0_maindata-add-tool_type = zaplink_enhancement=>tooltypes-class.
          ASSIGN class_implementation TO <table>.
          class_implementation = clif_sap2int( data-clif_impl ).
        ELSEIF a0_maindata-add-tool_type = zaplink_enhancement=>tooltypes-interface.
          ASSIGN interface_implementation TO <table>.
          interface_implementation = clif_sap2int( data-clif_impl ).
        ELSE.
          ASSERT 1 = 0.
        ENDIF.
      WHEN zaplink_enhancement=>tooltypes-function_group.
        function_group_implementation = data-fugr_impl.
      WHEN zaplink_enhancement=>tooltypes-hook.
        IF data-hook_impl-admin-org_obj_name <> data-hook_impl-admin-org_main_name.
          BREAK-POINT.
        ENDIF.
        CLEAR s_hook_impl.
        s_hook_impl-main = data-hook_impl-admin.
        IF s_hook_impl-main-org_obj_name = s_hook_impl-main-org_main_name AND
           s_hook_impl-main-org_obj_type = s_hook_impl-main-org_main_type.
          CLEAR: s_hook_impl-main-org_main_name, s_hook_impl-main-org_main_type.
        ENDIF.
        CLEAR s_hook_impl-main-programname.
        s_hook_impl-enhancement = data-hook_impl-enh.
        INSERT s_hook_impl INTO TABLE hook_implementations.
      WHEN zaplink_enhancement=>tooltypes-web_dynpro.
        web_dynpro_implementation = data-wdyn_impl.
    ENDCASE.
    CLEAR a0_maindata-enhspot.
  ENDMETHOD.
  METHOD to_data.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner_4data~anonymize.
    CLEAR a0_maindata-createdon.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner_4data~unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_ENHO_DATA implementation
CLASS zaplink_enhs_data IMPLEMENTATION.
  METHOD from_data.
    DATA s_def      LIKE LINE OF badi_definitions.
    DATA s_filter   LIKE LINE OF s_def-filters.
    DATA s_texts    TYPE ts_sotr.
    FIELD-SYMBOLS:
      <def> LIKE LINE OF data-def_data,
      <f>   LIKE LINE OF <def>-filters.
    MOVE-CORRESPONDING data-header TO a0_maindata-main.
    a0_maindata-texts = data-texts.
    LOOP AT data-def_data ASSIGNING <def>.
      CLEAR s_def.
      MOVE-CORRESPONDING <def> TO s_def-main.
      s_texts-short = <def>-badi_shorttext_id.        s_texts-long = <def>-badi_longtext_id.
      s_def-texts = sotr_2_texts( s_texts ).
      LOOP AT <def>-filters ASSIGNING <f>.
        MOVE-CORRESPONDING <f> TO s_filter-main.
        s_texts-short = <f>-filtertext_id.            s_texts-long = space.
        s_filter-texts = sotr_2_texts( s_texts ).
        INSERT s_filter INTO TABLE s_def-filters.
      ENDLOOP.
      INSERT s_def INTO TABLE badi_definitions.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_def      LIKE LINE OF data-def_data.
    DATA s_filter   LIKE LINE OF s_def-filters.
    FIELD-SYMBOLS:
      <def> LIKE LINE OF badi_definitions,
      <f>   LIKE LINE OF <def>-filters.
    MOVE-CORRESPONDING a0_maindata-main TO data-header.
    LOOP AT badi_definitions ASSIGNING <def>.
      CLEAR s_def.
      MOVE-CORRESPONDING <def>-main TO s_def.
      LOOP AT <def>-filters ASSIGNING <f>.
        MOVE-CORRESPONDING <f>-main TO s_filter.
        INSERT s_filter INTO TABLE s_def-filters.
      ENDLOOP.
      INSERT s_def INTO TABLE data-def_data.
    ENDLOOP.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner_4data~anonymize.
    CLEAR a0_maindata-createdon.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner_4data~unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_ENHS_DATA implementation
CLASS zaplink_ensc_data IMPLEMENTATION.
  METHOD from_data.
    DATA s_enh    LIKE LINE OF enhancements.
    DATA s_comp   LIKE LINE OF composit_enhancements.
    DATA s_txt    TYPE ts_sotr.
    FIELD-SYMBOLS:
      <enh>  LIKE LINE OF data-enh,
      <comp> LIKE LINE OF data-comp_enh.
    a0_maindata-main = data-header.
    s_txt-short = a0_maindata-shorttextid.
    s_txt-long = a0_maindata-docuid.
    a0_maindata-texts = sotr_2_texts( s_txt ).
    CLEAR: a0_maindata-shorttextid, a0_maindata-docuid.
    LOOP AT data-enh ASSIGNING <enh>.
      CLEAR s_enh.
      s_enh-name = <enh>.
      APPEND s_enh TO enhancements.
    ENDLOOP.
    LOOP AT data-comp_enh ASSIGNING <comp>.
      CLEAR s_comp.
      s_comp-name = <comp>.
      APPEND s_comp TO composit_enhancements.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_enh    LIKE LINE OF data-enh.
    DATA s_comp   LIKE LINE OF data-comp_enh.
    FIELD-SYMBOLS:
      <enh>  LIKE LINE OF enhancements,
      <comp> LIKE LINE OF composit_enhancements.
    data-header = a0_maindata-main.
    LOOP AT enhancements ASSIGNING <enh>.
      CLEAR s_enh.
      s_enh = <enh>-name.
      APPEND s_enh TO data-enh.
    ENDLOOP.
    LOOP AT composit_enhancements ASSIGNING <comp>.
      CLEAR s_comp.
      s_comp = <comp>-name.
      APPEND s_comp TO data-comp_enh.
    ENDLOOP.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner_4data~anonymize.
    CLEAR a0_maindata-createdon.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner_4data~unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_ENSC_DATA implementation
CLASS zaplink_function_group IMPLEMENTATION.
  METHOD calc_function_signature.
    DATA d_src      TYPE string.
    DATA d_lcount   TYPE i.
    DATA t_code     TYPE tt_abaprawsource.
    FIELD-SYMBOLS: <s> LIKE LINE OF function-source.
    CHECK function-source IS NOT INITIAL.   t_code = function-source.
    READ TABLE t_code ASSIGNING <s> INDEX 1.
    IF <s> CP 'FUNCTION *.'.    DELETE t_code INDEX 1.   ENDIF.
    d_lcount = lines( t_code ).
    READ TABLE t_code ASSIGNING <s> INDEX d_lcount.
    IF <s> CP 'ENDFUNCTION*.'.    DELETE t_code INDEX d_lcount.   ENDIF.
    zaplink_tools=>pretty_printer( CHANGING table = t_code ).
    zaplink_tools=>condense_abap_source( CHANGING table = t_code ).
    d_src = zaplink_tools=>table_2_string( t_code ).
    d_src = zaplink_tools=>clean_abap_string( d_src ).
    result = zaplink_tools=>calculate_md5_hash( d_src ).
  ENDMETHOD.
  METHOD class_constructor.
    supportedkinds-group =  zaplink_connectors=>get_typekind( supportedtypes-group ).
    supportedkinds-function =  zaplink_connectors=>get_typekind( supportedtypes-function ).
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.
    type-type = supportedtypes-group.    INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-function. INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD del_function.
    DATA d_pname     TYPE tfdir-pname.
    DATA d_group     TYPE rs38l-area.
    DATA d_msg       TYPE string.
    DATA t_params    TYPE STANDARD TABLE OF spar WITH DEFAULT KEY.
    DATA s_param     LIKE LINE OF t_params.
    DATA d_answer    TYPE c.
    TRY.
        SELECT SINGLE pname INTO d_pname FROM tfdir WHERE funcname = func-header-name.
        IF sy-subrc <> 0.   EXIT.   ENDIF.
        CALL FUNCTION 'FUNCTION_INCLUDE_SPLIT'
          EXPORTING
            program                      = d_pname
          IMPORTING
            group                        = d_group
          EXCEPTIONS
            include_not_exists           = 1
            group_not_exists             = 2
            no_selections                = 3
            no_function_include          = 4
            no_function_pool             = 5
            delimiter_wrong_position     = 6
            no_customer_function_group   = 7
            no_customer_function_include = 8
            reserved_name_customer       = 9
            namespace_too_long           = 10
            area_length_error            = 11
            OTHERS                       = 12.
        IF sy-subrc <> 0.   EXIT.   ENDIF.
        IF d_group <> func-header-str_area.    " No problem on overwrite
          IF sy-batch = abap_true.   "only delete in forground
            EXIT.
          ENDIF.
          MESSAGE i000 WITH d_pname d_group INTO d_msg.
          REFRESH t_params.
          s_param-param = 'FUNCTION'.   s_param-value = func-header-name.         APPEND s_param TO t_params.
          s_param-param = 'GROUP'.      s_param-value = d_group.                  APPEND s_param TO t_params.
          s_param-param = 'CURRENT_G'.  s_param-value = func-header-str_area.     APPEND s_param TO t_params.
          CALL FUNCTION 'POPUP_TO_CONFIRM'
            EXPORTING
              titlebar              = 'Confirm module function deletion'(d00)
              diagnose_object       = 'ZAPLINK_FUNCTION_GROUP-CONF'
              text_question         = d_msg
              text_button_1         = 'Yes'(yes)
              icon_button_1         = 'ICON_DELETE'
              text_button_2         = 'No'(no_)
              icon_button_2         = 'ICON_SKIP'
              default_button        = '3'
              display_cancel_button = 'X'
              userdefined_f1_help   = 'ZAPLINK_FUNCTION_GROUP-CONFH'
              start_column          = 10
              start_row             = 4
              popup_type            = 'ICON_MESSAGE_WARNING'
              iv_quickinfo_button_1 = 'Function is deleted. Function group will be created with this function.'(hye)
              iv_quickinfo_button_2 = 'Function is not deleted and process to next existing function. Function group will be created without this function.'(hno)
            IMPORTING
              answer                = d_answer
            TABLES
              parameter             = t_params
            EXCEPTIONS
              text_not_found        = 1
              OTHERS                = 2.
          IF sy-subrc <> 0.
            mac_add_mf_and_raise 'POPUP_TO_CONFIRM' sy-subrc.
          ELSEIF d_answer = 'N' OR d_answer = '2'.
            EXIT.
          ELSEIF d_answer = 'A'.    " abend
            ROLLBACK WORK.
            mac_add_mf_and_raise 'RS_FUNCTION_DELETE' 1.
          ENDIF.
        ENDIF.
        CALL FUNCTION 'RS_FUNCTION_DELETE'
          EXPORTING
            funcname          = func-header-name
            suppress_popups   = abap_true
          EXCEPTIONS
            cancelled         = 1
            function_released = 2
            OTHERS            = 3.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'RS_FUNCTION_DELETE' sy-subrc.
        ENDIF.
        DELETE FROM tftit WHERE funcname = func-header-name.
        DELETE FROM funct WHERE funcname = func-header-name.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD get_all_includes.
    DATA: _result           LIKE LINE OF results.
    DATA d_include          TYPE rs38l-include.
    DATA d_is_hidden        TYPE abap_bool.
    DATA d_is_extern        TYPE abap_bool.
    DATA d_not_funct        TYPE abap_bool.
    DATA d_suffix           TYPE rs38l-suffix.
    DATA: program           TYPE trdir-name.
    DATA: _fugr_name        TYPE rs38l-area.
    DATA: _is_reserved_name TYPE c.
    DATA: includes          TYPE STANDARD TABLE OF rseuinc.
    FIELD-SYMBOLS:
      <wa> LIKE LINE OF includes.
    program = get_mainprogram( name ).
    SELECT * FROM d010inc
             APPENDING CORRESPONDING FIELDS OF TABLE includes
             WHERE master = program.
    CALL FUNCTION 'RS_WORKING_AREA_ACTIVE_CHECK'
      EXCEPTIONS
        nok = 1.
    IF sy-subrc = 0.
      SELECT * FROM rseuinc
               APPENDING CORRESPONDING FIELDS OF TABLE includes
               WHERE master = program.
    ENDIF.
    SORT includes BY include.
    DELETE ADJACENT DUPLICATES FROM includes COMPARING include.
    LOOP AT includes ASSIGNING <wa>.
      d_include = <wa>-include.
      CALL FUNCTION 'FUNCTION_INCLUDE_SPLIT'
        IMPORTING
          group                        = _fugr_name
          no_function_include          = d_is_extern
          no_function_module           = d_not_funct
          suffix                       = d_suffix
          reserved_name                = _is_reserved_name
          hidden_name                  = d_is_hidden
        CHANGING
          include                      = d_include
        EXCEPTIONS
          include_not_exists           = 1
          group_not_exists             = 2
          no_selections                = 3
          no_function_include          = 4
          no_function_pool             = 5
          delimiter_wrong_position     = 6
          no_customer_function_group   = 7
          no_customer_function_include = 8
          reserved_name_customer       = 9
          namespace_too_long           = 10
          area_length_error            = 11
          OTHERS                       = 12.
      IF sy-subrc = 0 AND _fugr_name = name AND d_is_extern = abap_false AND
        ( with_code = abap_true OR
                ( d_not_funct = abap_true AND d_is_hidden = abap_false AND
                          ( d_suffix = 'TOP' OR _is_reserved_name = abap_false ) ) ) .
        _result-name = <wa>-include.
        _result-source = get_prog_rawsource( _result-name ).
        APPEND _result TO results.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_function_signature.
    DATA d_src      TYPE string.
    DATA s_fm_func  TYPE ts_fmd_func.
    s_fm_func = read_function( name ).
    result = calc_function_signature( s_fm_func ).
  ENDMETHOD.
  METHOD get_group_signature.
    DATA t_includes  TYPE tt_includes.
    DATA t_code      TYPE tt_abaprawsource.
    DATA d_src       TYPE string.
    DATA d_mainprog  TYPE td_progname.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF t_includes.
    d_mainprog = get_mainprogram( group_name ).
    t_code = get_prog_rawsource( d_mainprog ).
    t_includes = get_all_includes( name = group_name
                              with_code = abap_true  ).
    LOOP AT t_includes ASSIGNING <i>.   APPEND LINES OF <i>-source TO t_code.   ENDLOOP.
    zaplink_tools=>pretty_printer( CHANGING table = t_code ).
    zaplink_tools=>condense_abap_source( CHANGING table = t_code ).
    d_src = zaplink_tools=>table_2_string( t_code ).
    d_src = zaplink_tools=>clean_abap_string( d_src ).
    result = zaplink_tools=>calculate_md5_hash( d_src ).
  ENDMETHOD.
  METHOD get_mainprogram.
    DATA s_rs38l TYPE rs38l.
    CALL FUNCTION 'FUNCTION_INCLUDE_SPLIT'
      EXPORTING
        complete_area = name
      IMPORTING
        namespace     = s_rs38l-namespace
        group         = s_rs38l-str_area
      EXCEPTIONS
        OTHERS        = 6.
    CONCATENATE s_rs38l-namespace c_mainprog_prefix s_rs38l-str_area INTO result.
  ENDMETHOD.
  METHOD read_function.
    DATA o_data     TYPE to_group.
    DATA s_fmd_fugr TYPE ts_fmd_fugr.
    DATA d_name     TYPE rs38l-name.
    DATA type       TYPE td_comptype.
    DATA d_mainprog TYPE td_progname.
    DATA d_soft_comp TYPE tdevc-dlvunit.
    DATA s_func LIKE LINE OF s_fmd_fugr-functions.
    DATA t_doc TYPE STANDARD TABLE OF rsfdo WITH DEFAULT KEY.
    DATA t_src TYPE STANDARD TABLE OF rssource WITH DEFAULT KEY.
    DATA t_src_new TYPE rsfb_source.    " Issue 98
    DATA t_tmp_doc TYPE tt_docs.
    DATA d_doc TYPE doku_obj.
    DATA s_doc_param TYPE zaplink_fugr_data=>ts_doc_param.
    IF prev_func-name = name.   result = prev_func-data.    RETURN.   ENDIF.    " Use Cache
    TRY.
        result-header-name = s_doc_param-func =  name.
        s_doc_param-param = '*'.    d_doc = s_doc_param.
        result-docs = zaplink_documentation=>get( ids = zaplink_fugr_data=>r_doc_ids-function
                                               object =  d_doc ).
        CALL FUNCTION 'RPY_FUNCTIONMODULE_READ_NEW'
          EXPORTING
            functionname       = result-header-name
          IMPORTING
            global_flag        = result-header-global
            remote_call        = result-header-remote
            update_task        = result-header-utask
            function_pool      = result-header-str_area
          TABLES
            import_parameter   = result-import_p
            changing_parameter = result-changing_p
            export_parameter   = result-export_p
            tables_parameter   = result-tables
            exception_list     = result-exceptions
            documentation      = t_doc
            source             = t_src
          CHANGING
            new_source         = t_src_new
          EXCEPTIONS
            error_message      = 1
            function_not_found = 2
            invalid_name       = 3
            OTHERS             = 4.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'RPY_FUNCTIONMODULE_READ_NEW' sy-subrc.
        ENDIF.
        IF NOT t_src_new IS INITIAL.    result-source = t_src_new.    ELSE.   result-source = t_src.    ENDIF.
        SELECT * INTO TABLE result-texts FROM tftit WHERE funcname = result-header-name.
        SELECT * INTO TABLE result-param_texts FROM funct WHERE funcname = result-header-name.
        prev_func-data = result.    prev_func-name = name.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD write_function.
    DATA t_doc       TYPE STANDARD TABLE OF rsfdo WITH DEFAULT KEY.
    DATA t_src       TYPE STANDARD TABLE OF rssource WITH DEFAULT KEY.
    DATA fm_include  TYPE rs38l-include.                      " Issue 122
    TRY.
        CALL FUNCTION 'RPY_FUNCTIONMODULE_INSERT'
          EXPORTING
            funcname                = func-header-name
            function_pool           = func-header-str_area
            interface_global        = func-header-global
            remote_call             = func-header-remote
            short_text              = space
            suppress_corr_check     = abap_false
            update_task             = func-header-utask
          IMPORTING
            function_include        = fm_include                    " Issue 122
          TABLES
            import_parameter        = func-import_p
            export_parameter        = func-export_p
            tables_parameter        = func-tables
            changing_parameter      = func-changing_p
            exception_list          = func-exceptions
            parameter_docu          = t_doc
            source                  = t_src
          EXCEPTIONS
            double_task             = 1
            error_message           = 2
            function_already_exists = 3
            invalid_function_pool   = 4
            invalid_name            = 5
            too_many_functions      = 6
            no_modify_permission    = 7
            no_show_permission      = 8
            enqueue_system_failure  = 9
            canceled_in_corr        = 10
            OTHERS                  = 11.
        IF sy-subrc <> 0.
          ROLLBACK WORK.
          mac_add_mf_and_raise 'RPY_FUNCTIONMODULE_INSERT' sy-subrc.
        ENDIF.
        set_prog_rawsource( program = fm_include                        " Issue 122
                                raw = func-source ).
        MODIFY tftit FROM TABLE func-texts.
        MODIFY funct FROM TABLE func-param_texts.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD write_include.
    DATA _oname   TYPE e071-obj_name.
    DATA _rep     TYPE progdir.
    DATA _fugr    TYPE rs38l-area.
    DATA _sufix   TYPE rs38l-suffix.
    DATA f_noinc  TYPE abap_bool.
    DATA _include TYPE rs38l-include.
    _rep-name = _oname = _include = include-name.
    CALL FUNCTION 'FUNCTION_INCLUDE_SPLIT'
      IMPORTING
        group                        = _fugr
        no_function_include          = f_noinc
        suffix                       = _sufix
      CHANGING
        include                      = _include
      EXCEPTIONS
        include_not_exists           = 1
        group_not_exists             = 2
        no_selections                = 3
        no_function_include          = 4
        no_function_pool             = 5
        delimiter_wrong_position     = 6
        no_customer_function_group   = 7
        no_customer_function_include = 8
        reserved_name_customer       = 9
        namespace_too_long           = 10
        area_length_error            = 11
        OTHERS                       = 12.
    IF sy-subrc <> 0.
      mac_add_mf_and_raise 'FUNCTION_INCLUDE_SPLIT' sy-subrc.
    ENDIF.
    IF _sufix <> 'TOP' OR _fugr <> area OR NOT f_noinc IS INITIAL.
      CALL FUNCTION 'RS_CREATE_NEW_INCLUDE'
        EXPORTING
          master                   = mainprogram
          include_name             = _rep-name
          new_include              = abap_true
          insert_include_statement = abap_true
        TABLES
          master_source            = source
        EXCEPTIONS
          program_enqueued         = 1
          OTHERS                   = 2.
      IF sy-subrc <> 0.
        mac_add_mf_and_raise 'RS_CREATE_NEW_INCLUDE' sy-subrc.
      ENDIF.
    ENDIF.
    CALL FUNCTION 'RS_INSERT_INTO_WORKING_AREA'
      EXPORTING
        object            = 'REPS'
        obj_name          = _oname
      EXCEPTIONS
        wrong_object_name = 1
        OTHERS            = 2.
    IF sy-subrc <> 0.
      mac_add_mf_and_raise 'RS_INSERT_INTO_WORKING_AREA' sy-subrc.
    ENDIF.
    _rep-subc = 'I'.
    _rep-varcl = abap_true.   " Case sensitive
    _rep-appl = 'S'.    " System
    _rep-state = 'I'.   MODIFY progdir FROM _rep.
    _rep-state = 'A'.   MODIFY progdir FROM _rep.
    set_prog_rawsource( program = include-name
                            raw = include-source ).
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~anonymize.
    DATA o_group    TYPE to_group.
    DATA o_function TYPE to_function.
    CHECK object IS BOUND.
    CASE object->type.
      WHEN supportedtypes-group.
        o_group ?= object->raw.
        o_group->anonymize( ).
      WHEN supportedtypes-function.
        o_function ?= object->raw.
        o_function->anonymize( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name object->type.
    ENDCASE.
    TRY.
        super->zaplink_cnx_ext_cleaner~anonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~unanonymize.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_code_signature~get_signature.
    DATA d_group TYPE td_functiongroup_name.
    DATA d_func  TYPE td_function_name.
    DATA d_type  TYPE td_comptype.
    TRY.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN supportedtypes-group.
            d_group = component->get_name( ).
            result = get_group_signature( d_group ).
          WHEN supportedtypes-function.
            d_func = component->get_name( ).
            result = get_function_signature( d_func ).
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_group    TYPE to_group.
    DATA o_function TYPE to_function.
    DATA o_raw_func TYPE to_raw_function.
    CASE type.
      WHEN supportedtypes-group.
        CREATE OBJECT object.
        CREATE OBJECT o_group.
        object->raw = o_group.
      WHEN supportedtypes-function.
        CREATE OBJECT o_raw_func.
        object = o_raw_func.
        CREATE OBJECT o_function.
        object->raw = o_function.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA pool   TYPE rs38l-area.
    DATA d_func TYPE rs38l-name.
    DATA type   TYPE td_comptype.
    DATA name   TYPE td_compname.
    TRY.
        type = component->get_type( ).
        CASE type.
          WHEN supportedtypes-function.
            d_func = name = component->get_name( ).
            CALL FUNCTION 'RS_FUNCTION_DELETE'
              EXPORTING
                funcname          = d_func
                suppress_popups   = abap_true
              EXCEPTIONS
                cancelled         = 1
                function_released = 2
                OTHERS            = 3.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise 'RS_FUNCTION_DELETE' sy-subrc.
            ENDIF.
          WHEN supportedtypes-group.
            pool = name = component->get_name( ).
            CALL FUNCTION 'FUNCTION_POOL_DELETE'
              EXPORTING
                pool              = pool
                skip_progress_ind = 'X'
              EXCEPTIONS
                functions_exists  = 1
                not_found         = 0
                OTHERS            = 3.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise 'FUNCTION_POOL_DELETE' sy-subrc.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    result = abap_true.
    zaplink_tools=>remove_comp_from_working_area( type = type
                                                  name = name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA d_group    TYPE td_functiongroup_name.
    DATA d_function TYPE td_function_name.
    DATA type       TYPE td_comptype.
    exists = me->exists-not_exists.
    TRY.
        type = component->get_type( ).
        CASE type.
          WHEN supportedtypes-group.
            d_group = component->get_name( ).
            CALL FUNCTION 'RS_FUNCTION_POOL_EXISTS'
              EXPORTING
                function_pool   = d_group
              EXCEPTIONS
                pool_not_exists = 1
                OTHERS          = 2.
            IF sy-subrc = 0.    exists = me->exists-exists.   ENDIF.
          WHEN supportedtypes-function.
            d_function = component->get_name( ).
            CALL FUNCTION 'FUNCTION_EXISTS'
              EXPORTING
                funcname           = d_function
              EXCEPTIONS
                function_not_exist = 1
                OTHERS             = 2.
            IF sy-subrc = 0.    exists = me->exists-exists.   ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.
      result = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    DATA o_group    TYPE to_group.
    DATA o_function TYPE to_function.
    DATA s_fmd_fugr TYPE ts_fmd_fugr.
    DATA s_fmd_func TYPE ts_fmd_func.
    DATA d_name     TYPE td_compname.
    DATA type       TYPE td_comptype.
    DATA d_mainprog TYPE td_progname.
    DATA d_soft_comp TYPE tdevc-dlvunit.
    DATA t_functions TYPE tt_rs38l_incl.
    DATA d_doc TYPE doku_obj.
    FIELD-SYMBOLS:
      <f> LIKE LINE OF t_functions.
    TRY.
        type = component->get_type( ).
        CREATE OBJECT object.
        object->set_component( component ).
        CASE type.
          WHEN supportedtypes-function.
            s_fmd_func-header-name = object->name.
            s_fmd_func = read_function( s_fmd_func-header-name ).
            s_fmd_func-code_signature = calc_function_signature( s_fmd_func ).
            CREATE OBJECT o_function.
            o_function->from_data( s_fmd_func ).
            CLEAR o_function->a0_maindata-name.
            object->raw = o_function.
          WHEN supportedtypes-group.
            s_fmd_fugr-header-area = d_name = object->name.
            CALL FUNCTION 'RS_FUNCTION_POOL_CONTENTS'
              EXPORTING
                function_pool           = s_fmd_fugr-header-area
              TABLES
                functab                 = t_functions
              EXCEPTIONS
                function_pool_not_found = 1
                OTHERS                  = 2.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise 'RS_FUNCTION_POOL_CONTENTS' sy-subrc.
            ENDIF.
            d_doc = d_mainprog = get_mainprogram( s_fmd_fugr-header-area ).
            s_fmd_fugr-docs = zaplink_documentation=>get( ids = zaplink_fugr_data=>r_doc_ids-group
                                                      object = d_doc  ).
            SELECT * INTO TABLE s_fmd_fugr-texts FROM tlibt WHERE area = s_fmd_fugr-header-area.
            LOOP AT t_functions ASSIGNING <f>.
              s_fmd_func = read_function( <f>-funcname ).   CLEAR s_fmd_func-header-str_area.
              s_fmd_func-code_signature = calc_function_signature( s_fmd_func ).
              INSERT s_fmd_func INTO TABLE s_fmd_fugr-functions.
            ENDLOOP.
            SELECT SINGLE dlvunit INTO d_soft_comp
              FROM v_tralan
              WHERE pgmid = supportedkinds-group
                AND object = supportedtypes-group
                AND obj_name = s_fmd_fugr-header-area.
            s_fmd_fugr-includes = get_all_includes( s_fmd_fugr-header-area ).
            s_fmd_fugr-textspool = get_prog_textpool( d_mainprog ).
            s_fmd_fugr-dynpros = get_dynpros( d_mainprog ).
            s_fmd_fugr-menupainter = get_menus( d_mainprog ).
            CREATE OBJECT o_group.
            o_group->from_data( s_fmd_fugr ).
            o_group->_code_signature = get_group_signature( o_group->a0_maindata-area ).
            CLEAR o_group->a0_maindata-area.
            object->raw = o_group.
          WHEN OTHERS.
            CLEAR object.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        object->update_connector_data( me ).                    " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    DATA o_group      TYPE to_group.
    DATA o_function   TYPE to_function.
    DATA s_fmd_fugr   TYPE ts_fmd_fugr.
    DATA s_fmd_func   TYPE ts_fmd_func.
    DATA _comp        TYPE to_component.
    DATA d_pname      TYPE tfdir-pname.
    DATA d_group      TYPE rs38l-area.
    DATA _name        TYPE td_compname.
    DATA d_mainprog   TYPE td_progname.
    DATA t_functions  TYPE tt_rs38l_incl.
    DATA d_msg        TYPE string.
    DATA d_answer     TYPE c.
    DATA t_doc        TYPE STANDARD TABLE OF rsfdo WITH DEFAULT KEY.
    DATA t_src        TYPE STANDARD TABLE OF rssource WITH DEFAULT KEY.
    DATA t_params     TYPE STANDARD TABLE OF spar WITH DEFAULT KEY.
    DATA t_source     TYPE tt_abaprawsource.
    DATA s_param      LIKE LINE OF t_params.
    DATA o_source     TYPE REF TO cl_wb_source.
    DATA t_key        TYPE  trkey.
    DATA source_name  TYPE  trdir-name.
    FIELD-SYMBOLS:
      <i>  LIKE LINE OF s_fmd_fugr-includes,
      <fi> LIKE LINE OF t_functions,
      <f>  LIKE LINE OF s_fmd_fugr-functions.
    TRY.
        CREATE OBJECT components.
        CASE object->type.
          WHEN supportedtypes-function.
            o_function ?= object->raw.
            o_function->a0_maindata-name = object->name.
            s_fmd_func = o_function->to_data( ).
            del_function( s_fmd_func ).
            write_function( s_fmd_func ).
            CALL FUNCTION 'RS_FUNCTION_POOL_CONTENTS'
              EXPORTING
                function_pool           = s_fmd_func-header-str_area
              TABLES
                functab                 = t_functions
              EXCEPTIONS
                function_pool_not_found = 1
                OTHERS                  = 2.
            IF sy-subrc <> 0.
              ROLLBACK WORK.
              mac_add_mf_and_raise 'RS_FUNCTION_POOL_CONTENTS' sy-subrc.
            ENDIF.
            READ TABLE t_functions ASSIGNING <fi> WITH KEY funcname = s_fmd_func-header-name.
            IF sy-subrc <> 0. mac_add_mf_and_raise 'RS_FUNCTION_POOL_CONTENTS' 2. ENDIF.
          WHEN supportedtypes-group.
            o_group ?= object->raw.
            o_group->a0_maindata-area = object->name.
            s_fmd_fugr = o_group->to_data( ).
            d_mainprog = get_mainprogram( s_fmd_fugr-header-area ).
            CALL FUNCTION 'RS_FUNCTION_POOL_DELETE'
              EXPORTING
                area                   = s_fmd_fugr-header-area
                suppress_popups        = abap_true
                skip_progress_ind      = abap_true
              EXCEPTIONS
                canceled_in_corr       = 1
                enqueue_system_failure = 2
                function_exist         = 3
                not_executed           = 4
                no_modify_permission   = 5
                no_show_permission     = 6
                permission_failure     = 7
                pool_not_exist         = 0
                cancelled              = 9
                OTHERS                 = 10.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise 'RS_FUNCTION_POOL_DELETE' sy-subrc.
            ENDIF.
            IF sy-batch = abap_false.   "only delete in foreground
              LOOP AT s_fmd_fugr-functions ASSIGNING <f>.
                del_function( <f> ).
              ENDLOOP.
            ENDIF.
            CALL FUNCTION 'RS_FUNCTION_POOL_INSERT'
              EXPORTING
                function_pool           = s_fmd_fugr-header-area
                short_text              = space
              EXCEPTIONS
                name_already_exists     = 1
                name_not_correct        = 2
                function_already_exists = 3
                invalid_function_pool   = 4
                invalid_name            = 5
                too_many_functions      = 6
                no_modify_permission    = 7
                no_show_permission      = 8
                enqueue_system_failure  = 9
                canceled_in_corr        = 10
                undefined_error         = 11
                OTHERS                  = 12.
            IF sy-subrc <> 0.
              ROLLBACK WORK.
              mac_add_mf_and_raise 'RS_FUNCTION_POOL_INSERT' sy-subrc.
            ENDIF.
            set_prog_textpool( program = d_mainprog
                              textpool = s_fmd_fugr-textspool ).
            set_dynpros( program = d_mainprog
                         dynpros = s_fmd_fugr-dynpros ).
            set_menus( program = d_mainprog
                         menus = s_fmd_fugr-menupainter ).
            DELETE FROM tlibt WHERE area = s_fmd_fugr-header-area.
            MODIFY tlibt FROM TABLE s_fmd_fugr-texts.
            t_key-obj_type = supportedtypes-group.
            t_key-obj_name = s_fmd_fugr-header-area.
            t_key-sub_type = 'REPS'.
            t_key-sub_name = d_mainprog.
            CREATE OBJECT o_source
              EXPORTING
                transport_key = t_key
                source_name   = d_mainprog.
            CALL METHOD o_source->read_source
              IMPORTING
                source_tab         = t_source
              EXCEPTIONS
                cancelled          = 1
                enhancement_locked = 2
                not_found          = 3
                read_protected     = 4
                OTHERS             = 5.
            IF sy-subrc <> 0.
              mac_add_obj_meth_and_raise o_source 'READ_SOURCE' sy-subrc.
            ENDIF.
            LOOP AT s_fmd_fugr-includes ASSIGNING <i>.
              write_include( EXPORTING area = s_fmd_fugr-header-area " ISSUE 125
                                mainprogram = d_mainprog
                                    include = <i>
                            CHANGING source = t_source ).
            ENDLOOP.
            o_source->set_source_tab( t_source ).             " ISSUE 125
            LOOP AT s_fmd_fugr-functions ASSIGNING <f>.
              write_function( <f> ).
            ENDLOOP.
            COMMIT WORK.      " Otherwise Pool conent is empty because inlcude UXX is not up to date
            CALL FUNCTION 'RS_FUNCTION_POOL_CONTENTS'
              EXPORTING
                function_pool           = s_fmd_fugr-header-area
              TABLES
                functab                 = t_functions
              EXCEPTIONS
                function_pool_not_found = 1
                OTHERS                  = 2.
            IF sy-subrc <> 0.
              ROLLBACK WORK.
              mac_add_mf_and_raise 'RS_FUNCTION_POOL_CONTENTS' sy-subrc.
            ENDIF.
            LOOP AT s_fmd_fugr-functions ASSIGNING <f>.
              READ TABLE t_functions ASSIGNING <fi>
                   WITH KEY funcname = <f>-header-name.
              IF sy-subrc <> 0.
                ROLLBACK WORK.
                mac_add_mf_and_raise 'RPY_FUNCTIONMODULE_INSERT' 11.    " Issue 137
              ENDIF.
            ENDLOOP.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name object->type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ). " Issue 92
      CATCH zaplink_cx_connector INTO o_mycx.
        ROLLBACK WORK.
        RAISE EXCEPTION o_mycx.
      CATCH zaplink_cx INTO o_cx.
        ROLLBACK WORK.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_FUNCTION_GROUP implementation
CLASS zaplink_gui IMPLEMENTATION.
  METHOD add_object.
    DATA o_cont   TYPE to_container.
    DATA obj_list TYPE to_list.
    DATA obj      TYPE to_component.
    DATA _objname TYPE string.
    DATA _cx      TYPE REF TO zaplink_cx.
    IF objtype IS INITIAL.
      RAISE EXCEPTION TYPE zaplink_cx_gui EXPORTING textid = zaplink_cx_gui=>missing_objtype.
    ELSEIF name IS INITIAL.
      RAISE EXCEPTION TYPE zaplink_cx_gui EXPORTING textid = zaplink_cx_gui=>missing_name.
    ENDIF.
    TRY.
        CALL METHOD _load
          EXPORTING
            file      = file
          IMPORTING
            container = o_cont.
        CREATE OBJECT obj.
        obj->set_type( objtype ).
        _objname = name.
        obj->set_name( _objname ).
        obj->set_with_subcomp( with_subcomp ).
        IF obj->connector_exists( ) = zaplink_component=>connexists-not_exists. " OR NOT obj->connector( ) IS BOUND.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid = zaplink_cx_connector=>invalid_type
              type   = objtype.
        ENDIF.
        CREATE OBJECT obj_list.
        obj_list->add( obj ).
        obj_list->select( obj ).
        IF o_options IS BOUND.
          o_cont->set_options( o_options ).
        ENDIF.
        o_cont->add_components( obj_list ).
        CALL METHOD _save
          EXPORTING
            file      = file
          IMPORTING
            container = o_cont.
        IF o_cont->log->has_messages_of_msgt( id_msgty = 'E' ) = abap_true.
          o_mycx ?= zaplink_cx=>create_from_application_log( cx_name = 'ZAPLINK_CX_GUI'
                                                   message_collector = o_cont->log ).
          RAISE EXCEPTION o_mycx.
        ENDIF.
        mac_def_catch zaplink_cx_gui.
    ENDTRY.
  ENDMETHOD.
  METHOD change_selection.
    TRY.
        IF NOT action IS INITIAL.
          list->select_default( action ).
        ENDIF.
        list->change_selection( ).
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD class_constructor.
    mac_create_log application_log ballog_subobject space.
  ENDMETHOD.
  METHOD containerfile_select.
    DATA o_file    TYPE to_file.
    DATA o_cx_file TYPE REF TO zaplink_cx_file.
    DATA d_msg     TYPE string.
    TRY.
        CREATE OBJECT o_file.
        o_file->set_filetype( zaplink_file=>filetypes-local ).
        o_file->load_dialog( filename ).
        filename = o_file->get_filename( ).
      CATCH zaplink_cx_file INTO o_cx_file.
        CHECK o_cx_file->is_exception_text( zaplink_cx_file=>dialog_canceled ) IS INITIAL.
        d_msg = o_cx_file->get_text( ).
        MESSAGE d_msg TYPE 'W'.
    ENDTRY.
  ENDMETHOD.
  METHOD create.
    DATA s_info    TYPE ts_contdata.
    DATA container TYPE to_container.
    DATA def_fn    TYPE td_filename.
    IF name IS INITIAL.
      RAISE EXCEPTION TYPE zaplink_cx_gui EXPORTING textid = zaplink_cx_gui=>missing_container_name.
    ENDIF.
    TRY.
        s_info-name = name.
        container = zaplink_container=>create_new( o_file = file
                                                     data = s_info ).
        container->save_to_file( ).
        mac_def_catch zaplink_cx_gui.
    ENDTRY.
  ENDMETHOD.
  METHOD create_file.
    DATA _cx TYPE REF TO zaplink_cx_file.
    TRY.
        CREATE OBJECT o_file.
        o_file->set_filetype( filetype ).
        o_file->set_filename( filename ).
      CATCH zaplink_cx_file INTO _cx.
        mac_cascade_raise o_mycx _cx.
    ENDTRY.
  ENDMETHOD.
  METHOD export.
    DATA o_cont     TYPE to_container.
    TRY.
        CALL METHOD _get_objlist
          EXPORTING
            file      = file
          IMPORTING
            container = o_cont.
        IF o_options IS BOUND.
          o_cont->set_options( o_options ).
        ENDIF.
        _update_subobj( o_list = objlist
                         f_sub = with_subcomp ).
        o_cont->add_components( objlist ).
        CALL METHOD _save
          EXPORTING
            file      = file
          IMPORTING
            container = o_cont.
        mac_def_catch zaplink_cx_gui.
    ENDTRY.
  ENDMETHOD.
  METHOD get_objlist.
    TRY.
        CALL METHOD _get_objlist
          EXPORTING
            file = file
          IMPORTING
            list = list.
      CATCH zaplink_cx_gui INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD get_values.
    DATA o_conn TYPE to_connector.
    CHECK NOT type IS INITIAL.
    TRY.
        o_conn = zaplink_connectors=>create_connector( type = type ).
      CATCH zaplink_cx INTO o_cx.
        IF o_cx->is_exception_text( zaplink_cx_connector=>invalid_type ) = abap_true.
          MESSAGE w050 WITH type.
          EXIT.
        ELSE.
          RAISE EXCEPTION o_cx.
        ENDIF.
    ENDTRY.
    TRY.
        CALL METHOD o_conn->get_values
          EXPORTING
            type = type
          CHANGING
            name = value.
      CATCH zaplink_cx_connector INTO o_cx.
        RAISE EXCEPTION o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD import.
    DATA o_cont    TYPE to_container.
    DATA _cx       TYPE REF TO zaplink_cx.
    DATA o_activ   TYPE to_activate.
    DATA o_list    TYPE to_list.
    DATA t_keys    TYPE tt_compkeys.
    DATA t_keys_ko TYPE tt_compkeys.
    DATA o_comp    TYPE to_component.
    DATA s_key     LIKE LINE OF t_keys_ko.
    TRY.
        CALL METHOD _get_objlist
          EXPORTING
            file      = file
          IMPORTING
            list      = list
            container = o_cont
            cont_name = name.
        _update_subobj( o_list = list
                         f_sub = with_subcomp ).
        list->select_default( zaplink_list=>sel_actions-import ).
        list->change_selection( ).
        _update_selection( list ).
        IF o_options IS BOUND.
          o_cont->set_options( o_options ).
        ENDIF.
        o_cont->transport_to_sap( list ).
        IF activate = abap_true.
          o_list = list->selection_as_list( ).
          t_keys = o_list->get_keys( ).
          CREATE OBJECT o_activ.
          o_activ->add_keys( t_keys ).
          t_keys_ko = o_activ->activate( force_activation = activate_anyway ).
          SORT t_keys_ko BY type name.
          list->init_sel_iter( ).
          list->display_progress = abap_false.
          o_comp = list->get_next( ).
          WHILE o_comp IS BOUND.
            s_key-type = o_comp->get_type( ).   s_key-name = o_comp->get_name( ).
            READ TABLE t_keys_ko TRANSPORTING NO FIELDS
                 WITH KEY type = s_key-type
                          name = s_key-name.
            IF sy-subrc = 0.    o_comp->set_action( zaplink_list=>sel_actions-not_active ).   ELSE.   o_comp->set_action( zaplink_list=>sel_actions-activated ).   ENDIF.
            o_comp = list->get_next( ).
          ENDWHILE.
        ENDIF.
      CATCH zaplink_cx INTO _cx.
        CREATE OBJECT o_mycx
          EXPORTING
            textid   = zaplink_cx_gui=>system_error
            previous = _cx.
        o_mycx->update( ).
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD refresh.
    DATA o_cont     TYPE to_container.
    TRY.
        CALL METHOD _get_objlist
          EXPORTING
            file      = file
          IMPORTING
            list      = objlist
            container = o_cont.
        IF o_options IS BOUND.
          o_cont->set_options( o_options ).
        ENDIF.
        _update_subobj( o_list = objlist
                         f_sub = with_subcomp ).
        objlist->select_default( zaplink_list=>sel_actions-export ).
        objlist->change_selection( ).
        o_cont->add_components( objlist ).
        CALL METHOD _save
          EXPORTING
            file      = file
          IMPORTING
            container = o_cont.
        mac_def_catch zaplink_cx_gui.
    ENDTRY.
  ENDMETHOD.
  METHOD uninstall.
    DATA o_list TYPE to_list.
    DATA o_cont TYPE to_container.
    TRY.
        CALL METHOD _get_objlist
          EXPORTING
            file      = file
          IMPORTING
            list      = o_list
            container = o_cont
            cont_name = name.
        IF list IS BOUND.
          o_list->keep_commun_list( list ).
        ENDIF.
        _update_subobj( o_list = o_list
                         f_sub = with_subcomp ).
        o_list->select_default( zaplink_list=>sel_actions-uninstall ).
        o_list->change_selection( ).
        o_cont->uninstall_from_sap( o_list ).
        list = o_list.
        mac_def_catch zaplink_cx_gui.
    ENDTRY.
  ENDMETHOD.
  METHOD update_subobj.
    _update_subobj( o_list = o_list
                     f_sub = f_sub ).
  ENDMETHOD.
  METHOD _get_objlist.
    TRY.
        CALL METHOD _load
          EXPORTING
            file      = file
          IMPORTING
            container = container
            cont_name = cont_name.
        CHECK container IS BOUND.
        list = container->get_content( ).
        mac_def_catch zaplink_cx_gui.
    ENDTRY.
  ENDMETHOD.
  METHOD _load.
    DATA d_filename TYPE td_filename.
    IF NOT file IS BOUND.
      RAISE EXCEPTION TYPE zaplink_cx_gui EXPORTING textid = zaplink_cx_gui=>missing_filename.
    ENDIF.
    TRY.
        d_filename = file->get_filename( ).
        IF file->get_filetype( ) = zaplink_file=>filetypes-local.
          IF 1 = 2. MESSAGE i002 WITH d_filename. ENDIF.
          CALL METHOD application_log->add
            EXPORTING
              id_msgty = 'I'
              id_msgid = 'ZAPLINK_GUI'
              id_msgno = '002'
              id_msgv1 = d_filename.
        ELSEIF file->get_filetype( ) = zaplink_file=>filetypes-server.
          IF 1 = 2. MESSAGE i004 WITH d_filename. ENDIF.
          CALL METHOD application_log->add
            EXPORTING
              id_msgty = 'I'
              id_msgid = 'ZAPLINK_GUI'
              id_msgno = '004'
              id_msgv1 = d_filename.
        ENDIF.
        CREATE OBJECT container
          EXPORTING
            o_file = file.
        container->load_from_file( ).
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD _save.
    DATA _fn    TYPE td_filename.
    TRY.
        _fn = file->get_filename( ).
        IF _fn IS INITIAL.
          CALL METHOD file->save_dialog
            EXPORTING
              filename = _fn.
        ENDIF.
        file->set_filename( _fn ).
        container->save_to_file( file ).
        mac_def_catch zaplink_cx_gui.
    ENDTRY.
  ENDMETHOD.
  METHOD _update_selection.
    DATA o_comp   TYPE to_component.
    DATA o_slist  TYPE to_list.
    o_list->init_sel_iter( ).
    o_list->display_progress = abap_false.
    o_comp = o_list->get_next( ).
    WHILE o_comp IS BOUND.
      CLEAR o_slist.    o_slist = o_comp->get_subcomponents( ).
      IF o_slist IS BOUND.    o_slist->select_all( ).   ENDIF.    " for display list
      o_comp = o_list->get_next( ).
    ENDWHILE.
  ENDMETHOD.
  METHOD _update_subobj.
    DATA o_comp   TYPE to_component.
    o_list->init_iter( ).
    o_list->display_progress = abap_false.
    o_comp = o_list->get_next( ).
    WHILE o_comp IS BOUND.
      o_comp->set_with_subcomp( f_sub ).
      o_comp = o_list->get_next( ).
    ENDWHILE.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_GUI implementation
CLASS zaplink_intf_data IMPLEMENTATION.
  METHOD anonymize.
    super->anonymize( ).
    CLEAR:
      a0_maindata-author,
      a0_maindata-createdon,
      a0_maindata-changedby,
      a0_maindata-changedon,
      a0_maindata-chgdanyby,
      a0_maindata-chgdanyon,
      a0_maindata-r3release.
  ENDMETHOD.
  METHOD complete_data.
    obj_name = fm_data-interface-clsname.
    super->complete_data( CHANGING fm_data = fm_data ).
  ENDMETHOD.
  METHOD from_data.
    DATA _t   LIKE LINE OF a0_maindata-texts.
    DATA _in  LIKE LINE OF interfaces.
    FIELD-SYMBOLS:
      <co> LIKE LINE OF fm_data-comprisings,
      <ec> LIKE LINE OF fm_data-explore_comprisings.
    FIELD-SYMBOLS:
      <desc> LIKE LINE OF fm_data-class_desc,
      <doc>  LIKE LINE OF fm_data-documentation,
      <dt>   LIKE LINE OF <doc>-texts.
    DATA s_txt  LIKE LINE OF a0_maindata-texts.
    DATA s_key  TYPE ts_doc_key.
    a0_maindata-hdr = fm_data-interface.
    obj_name = a0_maindata-clsname.
    obj_version = a0_maindata-version.
    obj_langu = a0_maindata-langu.
    obj_type = object_types-interface.
    CLEAR a0_maindata-uuid.                                   " Issue 59
    a0_maindata-texts = fd_text( descriptions  = fm_data-class_desc
                                     classname = obj_name
                                            id = doc_ids-interface-header
                                 documentation = fm_data-documentation ).
    IF NOT a0_maindata-texts IS INITIAL. CLEAR a0_maindata-descript. ENDIF.
    CALL METHOD super->from_data
      EXPORTING
        fm_data = fm_data.
    LOOP AT fm_data-comprisings ASSIGNING <co>
      WHERE clsname = a0_maindata-clsname.
      CLEAR _in.
      MOVE-CORRESPONDING <co> TO _in.
      CLEAR _in-clsname.
      INSERT _in INTO TABLE interfaces.
    ENDLOOP.
    clear_tags( ).
  ENDMETHOD.
  METHOD to_data.
    DATA _t   LIKE LINE OF a0_maindata-texts.
    DATA _ct  LIKE LINE OF fm_data-class_desc.
    DATA _co  LIKE LINE OF fm_data-comprisings.
    DATA _ec  LIKE LINE OF fm_data-explore_comprisings.
    DATA _d   LIKE LINE OF documentation.
    DATA _dt  LIKE LINE OF _d-texts.
    FIELD-SYMBOLS:
      <t>  LIKE LINE OF a0_maindata-texts,
      <in> LIKE LINE OF interfaces.
    obj_name = a0_maindata-clsname.
    obj_version = a0_maindata-version.
    obj_langu = a0_maindata-langu.
    obj_type = object_types-interface.
    CALL METHOD super->to_data
      RECEIVING
        fm_data = fm_data.
    fm_data-interface = a0_maindata-hdr.
    READ TABLE a0_maindata-texts INTO _t
         WITH TABLE KEY lang = a0_maindata-langu.
    IF sy-subrc = 0.    fm_data-interface-descript = _t-text.    ENDIF.
    CALL METHOD td_text
      EXPORTING
        classname     = a0_maindata-clsname
        texts         = a0_maindata-texts
        id            = doc_ids-interface-header
      CHANGING
        documentation = fm_data-documentation
        descriptions  = fm_data-class_desc.
    LOOP AT interfaces ASSIGNING <in>.
      CLEAR: _co.
      MOVE-CORRESPONDING <in> TO _co.
      _co-clsname = a0_maindata-clsname.
      INSERT _co INTO TABLE fm_data-comprisings.
    ENDLOOP.
    clear_tags( ).
  ENDMETHOD.
ENDCLASS. "ZAPLINK_INTF_DATA implementation
CLASS zaplink_object IMPLEMENTATION.
  METHOD check_class_sections.
    DATA includes      TYPE t_fm_data-includes.
    DATA _msgid        TYPE symsgid.
    IF application_log IS BOUND.    _msgid = application_log->msgid.    application_log->msgid = 'ZAPLINK_OBJECT'.    ENDIF.
    includes = get_includes( classkey-clsname ).
    CALL METHOD _check_class_sections
      EXPORTING
        classkey        = classkey
        pub_source      = includes-pubsec-raw_source
        pro_source      = includes-prosec-raw_source
        pri_source      = includes-prisec-raw_source
        application_log = application_log.
    IF application_log IS BOUND.    application_log->msgid = _msgid.    ENDIF.
  ENDMETHOD.
  METHOD check_clas_sections.
    DATA classkey      TYPE seoclskey.
    classkey-clsname = class-class-clsname.
    CALL METHOD _check_class_sections
      EXPORTING
        classkey        = classkey
        pub_source      = class-includes-pubsec-raw_source
        pro_source      = class-includes-prosec-raw_source
        pri_source      = class-includes-prisec-raw_source
        application_log = application_log.
  ENDMETHOD.
  METHOD check_intf_section.
    DATA pubsec_source TYPE seo_section_source.
    DATA intkey        TYPE seoclskey.
    CHECK interface-interface-state <> seoc_state_model_only.        " Issue 111
    intkey-clsname = interface-interface-clsname.
    CALL FUNCTION 'SEO_INTERFACE_GENERATE_SECTION'
      EXPORTING
        intkey                         = intkey
        return_generated_sections_only = seox_true
      IMPORTING
        interface_source               = pubsec_source
      EXCEPTIONS
        not_existing                   = 1
        model_only                     = 2
        interf_section_not_generated   = 3
        interf_section_not_initialised = 4
        OTHERS                         = 5.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_INTERFACE_GENERATE_SECTION'
                                                  subrc = sy-subrc
                                              classname = 'ZAPLINK_CX_CONNECTOR' ).
      application_log->add_symsg( ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
    IF pubsec_source = interface-includes-intfsec-raw_source.
      CLEAR pubsec_source.
    ELSE.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE w003 WITH TEXT-pub intkey. ENDIF.
      SET EXTENDED CHECK ON.
      CALL METHOD application_log->add_warning
        EXPORTING
          id_msgno = '003'
          id_msgv1 = 'Public section'(pub)
          id_msgv2 = intkey.
    ENDIF.
    IF NOT pubsec_source IS INITIAL.
      CALL FUNCTION 'SEO_INTERFACE_GENERATE_SECTION'
        EXPORTING
          intkey                         = intkey
          return_generated_sections_only = seox_false
        EXCEPTIONS
          not_existing                   = 1
          model_only                     = 2
          interf_section_not_generated   = 3
          interf_section_not_initialised = 4
          OTHERS                         = 5.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_INTERFACE_GENERATE_SECTION'
                                                    subrc = sy-subrc
                                                classname = 'ZAPLINK_CX_CONNECTOR' ).
        application_log->add_symsg( ).
        RAISE EXCEPTION o_mycx.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD cleanup_class.
    DATA o_cnx TYPE REF TO zaplink_object.
    CREATE OBJECT o_cnx.
    o_cnx->load_clas( EXPORTING classkey = classkey ).
    has_change = o_cnx->_cleanup_class( ).
  ENDMETHOD.
  METHOD cleanup_typeusage.
    DATA new_code     TYPE tt_abaprawsource.
    DATA t_typegrp    TYPE seot_typepusages_r.
    DATA s_tgroup     LIKE LINE OF t_typegrp.
    DATA s_grp_key    TYPE seotpukey.
    DATA s_clas_key   TYPE seotpukey.
    search_defered_declaration( EXPORTING sourcecode = include-raw_source
                                           typepools = object_data-typeusages
                            IMPORTING new_sourcecode = new_code
                                       new_typepools = t_typegrp ).
    IF NOT new_code IS INITIAL.
      set_prog_rawsource( program = include-name
                              raw = new_code ).
      has_change = abap_true.
    ENDIF.
    IF NOT t_typegrp IS INITIAL.
      SORT t_typegrp BY typegroup.  DELETE ADJACENT DUPLICATES FROM t_typegrp COMPARING typegroup.
      LOOP AT t_typegrp INTO s_tgroup.
        s_tgroup-clsname = object_data-class-clsname.
        s_tgroup-version = object_data-class-version.
        CASE s_tgroup-tputype.
          WHEN 0.     " Type-pool
            MOVE-CORRESPONDING s_tgroup TO s_grp_key.
            CALL FUNCTION 'SEO_TYPEPUSAGE_GET'
              EXPORTING
                tplkey        = s_grp_key
              EXCEPTIONS
                not_existing  = 1
                deleted       = 2
                is_clsdeferrd = 3
                is_intdeferrd = 4
                OTHERS        = 5.
            IF sy-subrc = 0.
              CALL FUNCTION 'SEO_TYPEPUSAGE_DELETE_W_DEPS'
                EXPORTING
                  tplkey        = s_grp_key
                  save          = seox_false
                EXCEPTIONS
                  not_existing  = 1
                  is_clsdeferrd = 2
                  is_intdeferrd = 3
                  not_deleted   = 4
                  db_error      = 5
                  OTHERS        = 6.
              IF sy-subrc <> 0.
                o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_TYPEPUSAGE_DELETE_W_DEPS'
                                                            subrc = sy-subrc
                                                        classname = 'ZAPLINK_CX_CONNECTOR' ).
                application_log->add_symsg( ).
                RAISE EXCEPTION o_mycx.
              ENDIF.
            ENDIF.
            CALL FUNCTION 'SEO_TYPEPUSAGE_CREATE_F_DATA'
              EXPORTING
                save          = seox_false
              CHANGING
                typepusage    = s_tgroup
              EXCEPTIONS
                existing      = 1
                is_clsdeferrd = 2
                is_intdeferrd = 3
                not_created   = 4
                db_error      = 5
                OTHERS        = 6.
            IF sy-subrc <> 0.
              o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_TYPEPUSAGE_CREATE_F_DATA'
                                                          subrc = sy-subrc
                                                      classname = 'ZAPLINK_CX_CONNECTOR' ).
              application_log->add_symsg( ).
              RAISE EXCEPTION o_mycx.
            ENDIF.
          WHEN 1.     " Class
            s_clas_key-clsname = s_tgroup-clsname.      s_clas_key-typegroup = s_tgroup-typegroup.
            CALL FUNCTION 'SEO_CLSDEFERRD_GET'
              EXPORTING
                cdfkey        = s_clas_key
              EXCEPTIONS
                not_existing  = 1
                deleted       = 2
                is_intdeferrd = 3
                is_typepusage = 4
                OTHERS        = 5.
            IF sy-subrc = 0.
              CALL FUNCTION 'SEO_CLSDEFERRD_DELETE_W_DEPS'
                EXPORTING
                  cdfkey        = s_clas_key
                  save          = seox_false
                EXCEPTIONS
                  not_existing  = 1
                  is_intdeferrd = 2
                  is_typepusage = 3
                  not_deleted   = 4
                  db_error      = 5
                  OTHERS        = 6.
              IF sy-subrc <> 0.
                o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLSDEFERRD_DELETE_W_DEPS'
                                                            subrc = sy-subrc
                                                        classname = 'ZAPLINK_CX_CONNECTOR' ).
                application_log->add_symsg( ).
                RAISE EXCEPTION o_mycx.
              ENDIF.
            ENDIF.
            CALL FUNCTION 'SEO_CLSDEFERRD_CREATE_F_DATA'
              EXPORTING
                save          = seox_false
              CHANGING
                clsdeferrd    = s_tgroup
              EXCEPTIONS
                existing      = 1
                is_intdeferrd = 2
                is_typepusage = 3
                not_created   = 4
                db_error      = 5
                OTHERS        = 6.
            IF sy-subrc <> 0.
              o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLSDEFERRD_CREATE_F_DATA'
                                                          subrc = sy-subrc
                                                      classname = 'ZAPLINK_CX_CONNECTOR' ).
              application_log->add_symsg( ).
              RAISE EXCEPTION o_mycx.
            ENDIF.
          WHEN 2.     " Interface
            s_clas_key-clsname = s_tgroup-clsname.      s_clas_key-typegroup = s_tgroup-typegroup.
            CALL FUNCTION 'SEO_INTDEFERRD_GET'
              EXPORTING
                idfkey        = s_clas_key
              EXCEPTIONS
                not_existing  = 1
                deleted       = 2
                is_typepusage = 3
                is_clsdeferrd = 4
                OTHERS        = 5.
            IF sy-subrc = 0.
              CALL FUNCTION 'SEO_INTDEFERRD_DELETE_W_DEPS'
                EXPORTING
                  idfkey        = s_clas_key
                  save          = seox_false
                EXCEPTIONS
                  not_existing  = 1
                  is_typepusage = 2
                  is_clsdeferrd = 3
                  not_deleted   = 4
                  db_error      = 5
                  OTHERS        = 6.
              IF sy-subrc <> 0.
                o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_INTDEFERRD_DELETE_W_DEPS'
                                                            subrc = sy-subrc
                                                        classname = 'ZAPLINK_CX_CONNECTOR' ).
                application_log->add_symsg( ).
                RAISE EXCEPTION o_mycx.
              ENDIF.
            ENDIF.
            CALL FUNCTION 'SEO_INTDEFERRD_CREATE_F_DATA'
              EXPORTING
                save          = seox_false
              CHANGING
                intdeferrd    = s_tgroup
              EXCEPTIONS
                existing      = 1
                is_typepusage = 2
                is_clsdeferrd = 3
                not_created   = 4
                db_error      = 5
                OTHERS        = 6.
            IF sy-subrc <> 0.
              o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_INTDEFERRD_CREATE_F_DATA'
                                                          subrc = sy-subrc
                                                      classname = 'ZAPLINK_CX_CONNECTOR' ).
              application_log->add_symsg( ).
              RAISE EXCEPTION o_mycx.
            ENDIF.
          WHEN OTHERS.
            ASSERT s_tgroup-tputype >= 0 AND s_tgroup-tputype <= 2.
        ENDCASE.
        INSERT s_tgroup INTO TABLE object_data-typeusages.
        SET EXTENDED CHECK OFF.
        IF 1 = 2. MESSAGE w002 WITH s_tgroup-typegroup object_data-class-clsname text. ENDIF.
        SET EXTENDED CHECK ON.
        CALL METHOD application_log->add_warning
          EXPORTING
            id_msgno = '002'
            id_msgv1 = s_tgroup-typegroup
            id_msgv2 = object_data-class-clsname
            id_msgv3 = text.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.
    application_log->msgid = 'ZAPLINK_OBJECT'.
    type-type = zaplink_object_data=>object_types-class.       INSERT type INTO TABLE supported_types.
    type-type = zaplink_object_data=>object_types-interface.    INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
    CALL FUNCTION 'SEO_BUFFER_INIT'. " Init buffers
  ENDMETHOD.
  METHOD export_from_sap_class.
    DATA obj_mask   TYPE doku_obj.
    DATA docu_key   TYPE zaplink_object_data=>ts_doc_key.
    DATA classkey   TYPE seoclskey.
    DATA d_flag     TYPE abap_bool.
    TRY.
        CHECK component->get_type( ) = zaplink_object_data=>object_types-class.
        classkey-clsname = component->get_name( ).
        CALL FUNCTION 'SEO_BUFFER_REFRESH'.
        CALL FUNCTION 'SEO_CLASS_GET'
          EXPORTING
            clskey       = classkey
            version      = seoc_version_inactive     " Issue 111
            state        = seoc_state_model_only     " Issue 111
          IMPORTING
            class        = object_data-class
          EXCEPTIONS
            not_existing = 1
            deleted      = 2
            is_interface = 3
            model_only   = 4
            OTHERS       = 5.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'SEO_CLASS_GET' sy-subrc.
        ENDIF.
        load_clas( EXPORTING classkey = classkey ).
        object_data-includes = get_includes( object_data-class-clsname ).
        check_clas_sections( object_data ).
        d_flag = _cleanup_class( ).
        IF NOT d_flag IS INITIAL.   load_clas( EXPORTING classkey = classkey ).   ENDIF.
        docu_key-name = component->get_name( ).
        docu_key-other = '*'.
        obj_mask = docu_key.
        object_data-documentation = zaplink_documentation=>get( ids = zaplink_object_data=>r_doc_ids-class
                                                    object = obj_mask ).
        CREATE OBJECT object.
        object->complete_data( CHANGING fm_data = object_data ).
        object_data-dynpros = get_dynpros( object_data-includes-classpool-name ). " Issue 8
        object_data-menupainter = get_menus( object_data-includes-classpool-name ). " Issue 9
        object_data-textspool = get_prog_textpool( object_data-includes-classpool-name ). " Issue 1
        object->from_data( object_data ).
        object->_code_signature = get_class_signature( classkey ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_from_sap_interface.
    DATA obj_mask       TYPE doku_obj.
    DATA docu_key       TYPE zaplink_object_data=>ts_doc_key.
    DATA classkey TYPE seoclskey.
    DATA _d       TYPE t_fm_data.
    TRY.
        CHECK component->get_type( ) = zaplink_object_data=>object_types-interface.
        classkey-clsname = component->get_name( ).
        CALL FUNCTION 'SEO_BUFFER_REFRESH'.
        CALL FUNCTION 'SEO_INTERFACE_GET'
          EXPORTING
            intkey       = classkey
            version      = seoc_version_inactive   " Issue 111
            state        = seoc_state_model_only   " Issue 111
          IMPORTING
            interface    = _d-interface
          EXCEPTIONS
            not_existing = 1
            deleted      = 2
            is_class     = 3
            model_only   = 4
            OTHERS       = 5.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'SEO_INTERFACE_GET' sy-subrc.
        ENDIF.
        CALL FUNCTION 'SEO_INTERFACE_TYPEINFO_GET'
          EXPORTING
            intkey                  = classkey
            version                 = _d-interface-version
            state                   = _d-interface-state
            with_master_language    = seox_true
            with_enhancements       = seox_true
          IMPORTING
            interface               = _d-interface
            attributes              = _d-attributes
            methods                 = _d-methods
            events                  = _d-events
            parameters              = _d-parameters
            exceps                  = _d-exceps
            comprisings             = _d-comprisings
            typepusages             = _d-typeusages
            clsdeferrds             = _d-clsdeferrds
            intdeferrds             = _d-intdeferrds
            explore_comprisings     = _d-explore_comprisings
            aliases                 = _d-aliases
            types                   = _d-types
            enhancement_methods     = _d-enhancement_methods
            enhancement_attributes  = _d-enhancement_attributes
            enhancement_events      = _d-enhancement_events
            enhancement_comprisings = _d-enhancement_comprisings
          EXCEPTIONS
            not_existing            = 1
            is_class                = 2
            model_only              = 3
            OTHERS                  = 4.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'SEO_INTERFACE_TYPEINFO_GET' sy-subrc.
        ENDIF.
        _d-includes = get_includes( _d-interface-clsname ).
        check_intf_section( _d ).
        docu_key-name = component->get_name( ).
        docu_key-other = '*'.
        obj_mask = docu_key.
        _d-documentation = zaplink_documentation=>get( ids = zaplink_object_data=>r_doc_ids-interface
                                                    object = obj_mask ).
        CREATE OBJECT object.
        object->complete_data( CHANGING fm_data = _d ).
        object->from_data( _d ).
        object->_code_signature = get_interface_signature( classkey ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD generate_class.
    DATA t_comps      TYPE tt_compkeys.
    DATA o_activ      TYPE REF TO zaplink_activate.
    DATA s_comp       LIKE LINE OF t_comps.
    DATA t_err        TYPE tt_compkeys.
    s_comp-type = zaplink_object_data=>object_types-class.    s_comp-name = class.
    APPEND s_comp TO t_comps.
    CREATE OBJECT o_activ.
    o_activ->add_keys( t_comps ).
    t_err = o_activ->generate( ).
    IF t_err IS INITIAL.    result = abap_true.    ENDIF.
  ENDMETHOD.
  METHOD get_classsource_4signature.
    DATA t_upcode    TYPE td_sourcecode.
    DATA _line       LIKE LINE OF t_upcode.
    DATA d_class     TYPE  vseoclass.
    DATA t_attrs     TYPE  seoo_attributes_r.
    FIELD-SYMBOLS:
      <a> LIKE LINE OF t_attrs.
    CALL FUNCTION 'SEO_CLASS_GET'
      EXPORTING
        clskey       = class_name
        version      = seoc_version_inactive
        state        = '0'
      IMPORTING
        class        = d_class
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        is_interface = 3
        model_only   = 4
        OTHERS       = 5.
    IF sy-subrc <> 0.
      RAISE not_a_class.
    ENDIF.
    result = get_class_globalsource( class_name ).
    zaplink_tools=>pretty_printer( CHANGING table = result ).
    IF d_class-category = '40'.  " 40 Exception Class
      CALL FUNCTION 'SEO_CLASS_TYPEINFO_GET'
        EXPORTING
          clskey       = class_name
        IMPORTING
          attributes   = t_attrs
        EXCEPTIONS
          not_existing = 1
          is_interface = 2
          model_only   = 3
          OTHERS       = 4.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ENDIF.
      DELETE t_attrs
             WHERE   exposure <> 2    " Public
                OR attdecltyp <> 2    " Cosntant
                OR NOT type CP 'SOTR_CONC'.
      LOOP AT t_attrs ASSIGNING <a>.
        REPLACE ALL OCCURRENCES OF <a>-attvalue IN TABLE result WITH space.   " Issue 71, remove SOTR GUID values when calculating code signature
      ENDLOOP.
    ENDIF.
    zaplink_tools=>condense_abap_source( CHANGING table = result ).
    t_upcode = result.
    zaplink_tools=>conv_table_2upcase( CHANGING table = t_upcode ).
    CONCATENATE 'CLASS' class_name 'DEFINITION' INTO _line SEPARATED BY space.
    READ TABLE t_upcode TRANSPORTING NO FIELDS  FROM _line.
    CHECK sy-subrc = 0.
    SUBTRACT 1 FROM sy-tabix.   CHECK sy-tabix >= 1.    DELETE result TO sy-tabix.
  ENDMETHOD.
  METHOD get_class_globalsource.
    DATA includes TYPE zaplink_object_data=>ts_includes.      " Issue 82
    FIELD-SYMBOLS:
      <m>           LIKE LINE OF includes-methods,
      <source_line> LIKE LINE OF includes-classpool-raw_source.
    includes = get_includes( class_name-clsname ).            " Issue 82
    CHECK NOT includes-classpool-name IS INITIAL. " check it's a class
    SORT includes-methods BY cpdkey.         " Issue 68 : Force alphabetic order
    LOOP AT includes-classpool-raw_source ASSIGNING <source_line>.
      IF <source_line> CS includes-pubsec-name.
        APPEND LINES OF includes-pubsec-raw_source TO result.
      ELSEIF <source_line> CS includes-prosec-name.
        APPEND LINES OF includes-prosec-raw_source TO result.
      ELSEIF <source_line> CS includes-prisec-name.
        APPEND LINES OF includes-prisec-raw_source TO result.
      ELSEIF <source_line> CS includes-cl-name.
        APPEND LINES OF includes-cl-raw_source TO result.
      ELSEIF <source_line> CS includes-ccdef-name.
        APPEND LINES OF includes-ccdef-raw_source TO result.
      ELSEIF <source_line> CS includes-ccimp-name.
        APPEND LINES OF includes-ccimp-raw_source TO result.
      ELSEIF <source_line> CS includes-ccmac-name.
        APPEND LINES OF includes-ccmac-raw_source TO result.
      ELSEIF <source_line> CS includes-localtestclass-name.   " Ignore this include
      ELSEIF <source_line> CS 'include methods'.
        LOOP AT includes-methods ASSIGNING <m>
          WHERE NOT raw_source IS INITIAL.
          APPEND LINES OF <m>-raw_source TO result.
        ENDLOOP.
      ELSE.
        APPEND <source_line> TO result.
      ENDIF .
    ENDLOOP.
  ENDMETHOD.
  METHOD get_class_signature.
    DATA t_code    TYPE td_sourcecode.
    DATA d_src     TYPE string.
    DATA _key      TYPE string.
    t_code = get_classsource_4signature( class_name ).
    d_src = zaplink_tools=>table_2_string( t_code ).
    d_src = zaplink_tools=>clean_abap_string( d_src ).
    result = zaplink_tools=>calculate_md5_hash( d_src ).
    CONCATENATE zaplink_object_data=>object_types-class '/' class_name INTO _key.
  ENDMETHOD.
  METHOD get_includes.
    DATA d_cifkey  TYPE seoclskey.
    DATA d_clstype TYPE seoclstype.
    DATA t_methods TYPE seop_methods_w_include.
    DATA s_method  LIKE LINE OF includes-methods.
    FIELD-SYMBOLS <m> LIKE LINE OF t_methods.
    DEFINE lmac_get_load.
      includes-&1-name = cl_oo_classname_service=>&2( clsname ).
      IF NOT includes-&1-name IS INITIAL.   includes-&1-raw_source = get_prog_rawsource( includes-&1-name ).    ENDIF.
    END-OF-DEFINITION.
    d_cifkey-clsname = clsname.
    CALL FUNCTION 'SEO_CLIF_GET'
      EXPORTING
        cifkey       = d_cifkey
      IMPORTING
        clstype      = d_clstype
      EXCEPTIONS
        not_existing = 1
        deleted      = 2
        model_only   = 3
        OTHERS       = 4.
    IF sy-subrc = 0.
      IF d_clstype EQ 0.
        lmac_get_load classpool get_classpool_name.
        lmac_get_load pubsec get_pubsec_name.
        lmac_get_load prosec get_prosec_name.
        lmac_get_load prisec get_prisec_name.
        lmac_get_load cl get_cl_name.
        lmac_get_load ccdef get_ccdef_name.
        lmac_get_load ccimp get_ccimp_name.
        lmac_get_load ccmac get_ccmac_name.
        lmac_get_load localtestclass get_local_testclasses_include. " Issue 82
        CALL METHOD cl_oo_classname_service=>get_all_method_includes
          EXPORTING
            clsname            = clsname
          RECEIVING
            result             = t_methods
          EXCEPTIONS
            class_not_existing = 0
            OTHERS             = 0.   " Ignore exception : Class may not exits
        LOOP AT t_methods ASSIGNING <m>.
          CLEAR s_method.   s_method-hdr = <m>.
          s_method-raw_source = get_prog_rawsource( <m>-incname ).
          APPEND s_method TO includes-methods.
        ENDLOOP.
      ELSEIF d_clstype EQ 1.
        lmac_get_load interfacepool get_interfacepool_name.
        lmac_get_load intfsec get_intfsec_name.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD get_interface_globalsource.
    DATA d_prog     TYPE program.
    DATA t_upcode   TYPE td_sourcecode.
    DATA _line      LIKE LINE OF t_upcode.
    d_prog = cl_oo_classname_service=>get_intfsec_name( interface_name-clsname ).
    READ REPORT d_prog INTO result.
    zaplink_tools=>pretty_printer( CHANGING table = result ).
    zaplink_tools=>condense_abap_source( CHANGING table = result ).
    t_upcode = result.    zaplink_tools=>conv_table_2upcase( CHANGING table = t_upcode ).
    CONCATENATE 'INTERFACE' interface_name INTO _line SEPARATED BY space.
    READ TABLE t_upcode TRANSPORTING NO FIELDS  FROM _line.
    CHECK sy-subrc = 0.
    SUBTRACT 1 FROM sy-tabix.   CHECK sy-tabix >= 1.   DELETE result TO sy-tabix.
  ENDMETHOD.
  METHOD get_interface_signature.
    DATA t_code    TYPE td_sourcecode.
    DATA d_src     TYPE string.
    t_code = get_interface_globalsource( interface_name ).
    d_src = zaplink_tools=>table_2_string( t_code ).
    d_src = zaplink_tools=>clean_abap_string( d_src ).
    result = zaplink_tools=>calculate_md5_hash( d_src ).
  ENDMETHOD.
  METHOD import_to_sap_class.
    DATA _d               TYPE t_fm_data.
    DATA i_korrnr         TYPE trkorr.            "#EC NEEDED for debug
    DATA _component       TYPE to_component.
    DATA _name            TYPE td_compname.
    DATA d_key            TYPE seoclskey.
    DATA f_exists         TYPE abap_bool.
    TRY.
        _d = o_data->to_data( ).
        IF NOT _d-exceptions_texts IS INITIAL.
          zaplink_clas_data=>update_concept( EXPORTING msg_col = application_log
                                             CHANGING  fm_data = _d ).
        ENDIF.
        d_key-clsname = _d-class-clsname.
        CALL FUNCTION 'SEO_CLIF_EXISTENCE_CHECK'                " Issue 119
          EXPORTING
            cifkey        = d_key
          EXCEPTIONS
            not_specified = 1
            not_existing  = 2
            OTHERS        = 3.
        IF sy-subrc = 0.
          f_exists = abap_true.
        ENDIF.
        CALL FUNCTION 'SEO_CLASS_CREATE_COMPLETE'
          EXPORTING
            overwrite                 = 'X'                   "overwrite
            method_sources            = _d-method_sources    " Methods source
            locals_def                = _d-locals_def        " LOCAL_TYPES
            locals_imp                = _d-locals_imp        " LOCAL_IMP
            locals_mac                = _d-locals_mac        " MACROS
          IMPORTING
            korrnr                    = i_korrnr
          TABLES
            class_descriptions        = _d-class_desc
            component_descriptions    = _d-component_desc
            subcomponent_descriptions = _d-subcomponent_desc
          CHANGING
            class                     = _d-class
            inheritance               = _d-inheritance
            redefinitions             = _d-redefinitions
            implementings             = _d-implementings
            impl_details              = _d-impl_details
            attributes                = _d-attributes
            methods                   = _d-methods
            events                    = _d-events
            types                     = _d-types
            parameters                = _d-parameters
            exceps                    = _d-exceps
            aliases                   = _d-aliases
            typepusages               = _d-typeusages
            clsdeferrds               = _d-clsdeferrds
            intdeferrds               = _d-intdeferrds
            friendships               = _d-friendships
          EXCEPTIONS
            existing                  = 1
            is_interface              = 2
            db_error                  = 3
            component_error           = 4
            no_access                 = 5
            other                     = 6
            OTHERS                    = 7.
        IF sy-subrc = 4 AND f_exists IS INITIAL.                " Issue 119
          CALL FUNCTION 'SEO_BSP_CLASS_DELETE_COMPLETE'         " Brute force delete
            EXPORTING
              clskey = d_key.
          CALL FUNCTION 'SEO_CLASS_CREATE_COMPLETE'
            EXPORTING
              overwrite                 = 'X'                   "overwrite
              method_sources            = _d-method_sources    " Methods source
              locals_def                = _d-locals_def        " LOCAL_TYPES
              locals_imp                = _d-locals_imp        " LOCAL_IMP
              locals_mac                = _d-locals_mac        " MACROS
            IMPORTING
              korrnr                    = i_korrnr
            TABLES
              class_descriptions        = _d-class_desc
              component_descriptions    = _d-component_desc
              subcomponent_descriptions = _d-subcomponent_desc
            CHANGING
              class                     = _d-class
              inheritance               = _d-inheritance
              redefinitions             = _d-redefinitions
              implementings             = _d-implementings
              impl_details              = _d-impl_details
              attributes                = _d-attributes
              methods                   = _d-methods
              events                    = _d-events
              types                     = _d-types
              parameters                = _d-parameters
              exceps                    = _d-exceps
              aliases                   = _d-aliases
              typepusages               = _d-typeusages
              clsdeferrds               = _d-clsdeferrds
              intdeferrds               = _d-intdeferrds
              friendships               = _d-friendships
            EXCEPTIONS
              existing                  = 1
              is_interface              = 2
              db_error                  = 3
              component_error           = 4
              no_access                 = 5
              other                     = 6
              OTHERS                    = 7.
        ENDIF.
        IF sy-subrc <> 0.
          o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLASS_CREATE_COMPLETE'
                                                      subrc = sy-subrc
                                                  classname = 'ZAPLINK_CX_CONNECTOR' ).
          application_log->add_symsg( ).
          RAISE EXCEPTION o_mycx.
        ENDIF.
        _d-includes = get_includes( _d-class-clsname ).
        IF NOT _d-class-with_unit_tests IS INITIAL.             " Issue 82
          d_key-clsname = _d-class-clsname.
          CALL FUNCTION 'SEO_CLASS_GENERATE_LOCALS'
            EXPORTING
              clskey                 = d_key
              locals_testclasses     = _d-locals_tst
            EXCEPTIONS
              not_existing           = 1
              model_only             = 2
              locals_not_generated   = 3
              locals_not_initialised = 4
              OTHERS                 = 5.
          IF sy-subrc <> 0.
            o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLASS_GENERATE_LOCALS'
                                                        subrc = sy-subrc
                                                    classname = 'ZAPLINK_CX_CONNECTOR' ).
            application_log->add_symsg( ).
            RAISE EXCEPTION o_mycx.
          ENDIF.
        ENDIF.                                          " End of Issue 82
        set_dynpros( program = _d-includes-classpool-name       " Issue 8
                     dynpros = _d-dynpros ).
        set_menus( program = _d-includes-classpool-name         " Issue 9
                     menus = _d-menupainter ).
        set_prog_textpool( program = _d-includes-classpool-name " Issue 1
                          textpool = _d-textspool ).
        zaplink_documentation=>set( _d-documentation ).
        zaplink_object=>check_class_sections( classkey = d_key
                                       application_log = application_log ).
        CREATE OBJECT _component.
        _component->set_type( zaplink_object_data=>object_types-class ).
        _name = _d-class-clsname.
        _component->set_name( _name ).
        CREATE OBJECT components.
        components->add( _component ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_to_sap_interface.
    DATA _d           TYPE t_fm_data.
    DATA i_korrnr     TYPE trkorr.                "#EC NEEDED for debug
    DATA _component   TYPE to_component.
    DATA _name        TYPE td_compname.
    DATA intkey       TYPE seoclskey.
    DATA type         TYPE vseotype.
    DATA f_exists     TYPE abap_bool.
    FIELD-SYMBOLS <alias> LIKE LINE OF _d-aliases.
    TRY.
        _d = o_data->to_data( ).
        MOVE-CORRESPONDING _d-interface TO intkey.
        CALL FUNCTION 'SEO_CLIF_EXISTENCE_CHECK'      " Issue 119
          EXPORTING
            cifkey        = intkey
          EXCEPTIONS
            not_specified = 1
            not_existing  = 2
            OTHERS        = 3.
        IF sy-subrc = 0.
          f_exists = abap_true.
        ENDIF.
        CALL FUNCTION 'SEO_INTERFACE_CREATE_COMPLETE'
          EXPORTING
            overwrite                 = seox_true
          IMPORTING
            korrnr                    = i_korrnr
          TABLES
            class_descriptions        = _d-class_desc
            component_descriptions    = _d-component_desc
            subcomponent_descriptions = _d-subcomponent_desc
          CHANGING
            interface                 = _d-interface
            comprisings               = _d-comprisings
            attributes                = _d-attributes
            methods                   = _d-methods
            events                    = _d-events
            parameters                = _d-parameters
            exceps                    = _d-exceps
            aliases                   = _d-aliases
            typepusages               = _d-typeusages
            clsdeferrds               = _d-clsdeferrds
            intdeferrds               = _d-intdeferrds
            types                     = _d-types
          EXCEPTIONS
            existing                  = 1
            is_class                  = 2
            db_error                  = 3
            component_error           = 4
            no_access                 = 5
            other                     = 6
            OTHERS                    = 7.
        IF sy-subrc = 4 AND f_exists IS INITIAL.            " Issue 119
          CALL FUNCTION 'SEO_BSP_CLASS_DELETE_COMPLETE'     " Brute force delete
            EXPORTING
              clskey = intkey.
          CALL FUNCTION 'SEO_INTERFACE_CREATE_COMPLETE'
            EXPORTING
              overwrite                 = seox_true
            IMPORTING
              korrnr                    = i_korrnr
            TABLES
              class_descriptions        = _d-class_desc
              component_descriptions    = _d-component_desc
              subcomponent_descriptions = _d-subcomponent_desc
            CHANGING
              interface                 = _d-interface
              comprisings               = _d-comprisings
              attributes                = _d-attributes
              methods                   = _d-methods
              events                    = _d-events
              parameters                = _d-parameters
              exceps                    = _d-exceps
              aliases                   = _d-aliases
              typepusages               = _d-typeusages
              clsdeferrds               = _d-clsdeferrds
              intdeferrds               = _d-intdeferrds
              types                     = _d-types
            EXCEPTIONS
              existing                  = 1
              is_class                  = 2
              db_error                  = 3
              component_error           = 4
              no_access                 = 5
              other                     = 6
              OTHERS                    = 7.
        ENDIF.
        IF sy-subrc <> 0.                                       " Issue 118
          o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_INTERFACE_CREATE_COMPLETE'
                                                      subrc = sy-subrc
                                                  classname = 'ZAPLINK_CX_CONNECTOR' ).
          application_log->add_symsg( ).
          RAISE EXCEPTION o_mycx.
        ENDIF.
        LOOP AT _d-aliases ASSIGNING <alias>
                WHERE cmptype = seoo_cmptype_type.
          MOVE-CORRESPONDING <alias> TO type.
          type-alias = seox_true.
          type-state = seoc_state_implemented.
          CALL FUNCTION 'SEO_TYPE_CREATE_F_DATA'
            EXPORTING
              save   = seox_false
            CHANGING
              type   = type
            EXCEPTIONS
              OTHERS = 1.
          IF sy-subrc <> 0.
            IF sy-msgid = 'OO' AND sy-msgno = '002'.            " Issue 113
              IF 1 = 2. MESSAGE w002(oo) WITH type-cmpname.   ENDIF.
            ELSE.
              CALL METHOD application_log->add_symsg
                EXPORTING
                  id_msgty = 'W'.
            ENDIF.
          ENDIF.
        ENDLOOP.
        CALL FUNCTION 'SEO_CLIF_SAVE_ALL'
          EXPORTING
            cifkey                        = intkey
            suppress_refactoring_entries  = seox_true
            suppress_modification_support = seox_true
          EXCEPTIONS
            db_error                      = 1
            OTHERS                        = 2.
        IF sy-subrc <> 0.
          CALL METHOD application_log->add_symsg
            EXPORTING
              id_msgty = 'W'.
        ENDIF.
        zaplink_documentation=>set( _d-documentation ).
        CREATE OBJECT _component.
        _component->set_type( zaplink_object_data=>object_types-interface ).
        _name = _d-interface-clsname.
        _component->set_name( _name ).
        CREATE OBJECT components.
        components->add( _component ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD load_clas.
    CALL FUNCTION 'SEO_CLASS_TYPEINFO_GET'
      EXPORTING
        clskey                        = classkey
        version                       = object_data-class-version
        state                         = object_data-class-state
        resolve_eventhandler_typeinfo = seox_true
        with_master_language          = seox_true
        with_enhancements             = seox_true
      IMPORTING
        class                         = object_data-class
        attributes                    = object_data-attributes
        methods                       = object_data-methods
        events                        = object_data-events
        types                         = object_data-types
        parameters                    = object_data-parameters
        exceps                        = object_data-exceps
        implementings                 = object_data-implementings
        inheritance                   = object_data-inheritance
        redefinitions                 = object_data-redefinitions
        impl_details                  = object_data-impl_details
        friendships                   = object_data-friendships
        typepusages                   = object_data-typeusages
        clsdeferrds                   = object_data-clsdeferrds
        intdeferrds                   = object_data-intdeferrds
        explore_inheritance           = object_data-explore_inheritance
        explore_implementings         = object_data-explore_implementings
        aliases                       = object_data-aliases
        enhancement_methods           = object_data-enhancement_methods
        enhancement_attributes        = object_data-enhancement_attributes
        enhancement_events            = object_data-enhancement_events
        enhancement_implementings     = object_data-enhancement_implementings
      EXCEPTIONS
        not_existing                  = 1
        is_interface                  = 2
        model_only                    = 3
        OTHERS                        = 4.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLASS_TYPEINFO_GET'
                                                  subrc = sy-subrc
                                              classname = 'ZAPLINK_CX_CONNECTOR' ).
      application_log->add_symsg( ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
    CALL FUNCTION 'SEO_CLASS_RESOLVE_INHERITANCE'
      EXPORTING
        clskey        = classkey
        version       = object_data-class-version
        state         = object_data-class-state
      IMPORTING
        attributes    = object_data-attributes
        methods       = object_data-methods
        events        = object_data-events
        types         = object_data-types
        parameters    = object_data-parameters
        exceps        = object_data-exceps
        implementings = object_data-implementings
        aliases       = object_data-aliases
      EXCEPTIONS
        not_existing  = 1
        is_interface  = 2
        model_only    = 3
        OTHERS        = 4.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLASS_RESOLVE_INHERITANCE'
                                                  subrc = sy-subrc
                                              classname = 'ZAPLINK_CX_CONNECTOR' ).
      application_log->add_symsg( ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
  ENDMETHOD.
  METHOD search_defered_declaration.
    DATA d_tabix        TYPE sy-tabix.
    DATA t_tokens       TYPE STANDARD TABLE OF stokes.
    DATA t_statements   TYPE STANDARD TABLE OF sstmnt.
    DATA s_tp           LIKE LINE OF new_typepools.
    DATA d_flag         TYPE abap_bool.
    DATA d_comment      TYPE abap_bool.
    DATA d_line         TYPE i.
    DATA is_public      TYPE abap_bool.
    FIELD-SYMBOLS:
      <s>  LIKE LINE OF new_sourcecode,
      <st> LIKE LINE OF t_statements,
      <t>  LIKE LINE OF t_tokens,
      <n>  LIKE LINE OF t_tokens.
    CHECK NOT sourcecode IS INITIAL.
    new_sourcecode = sourcecode.    zaplink_tools=>conv_table_2upcase( CHANGING table = new_sourcecode ).
    SCAN ABAP-SOURCE new_sourcecode
                     TOKENS INTO t_tokens
                     STATEMENTS INTO t_statements.
    READ TABLE t_statements ASSIGNING <st> INDEX 2.      " public section. ?
    IF <st> IS ASSIGNED.
      READ TABLE new_sourcecode ASSIGNING <s> INDEX <st>-trow.
      ASSERT <s> IS ASSIGNED.
      IF <s> = 'PUBLIC SECTION.'.
        is_public = abap_true.
        LOOP AT new_sourcecode FROM <st>-trow TRANSPORTING NO FIELDS WHERE table_line IS INITIAL.
          d_line = sy-tabix.
          EXIT.
        ENDLOOP.
      ENDIF.
    ENDIF.
    zaplink_tools=>inverse_table_order( CHANGING my_table = t_statements ).
    new_sourcecode = sourcecode.
    LOOP AT t_statements ASSIGNING <st>.
      CHECK is_public IS INITIAL OR <st>-trow > d_line.
      READ TABLE t_tokens ASSIGNING <t> INDEX <st>-from.
      ASSERT sy-subrc = 0.
      CLEAR d_comment.
      CASE <t>-str.
        WHEN 'TYPE-POOLS'.
          d_tabix = <st>-from + 1.
          d_comment = abap_true.
          LOOP AT t_tokens ASSIGNING <n> FROM d_tabix TO <st>-to.     " do all type pools
            READ TABLE typepools TRANSPORTING NO FIELDS
                 WITH KEY typegroup = <n>-str
                           explicit = abap_true.
            CHECK sy-subrc <> 0.
            CLEAR s_tp.
            s_tp-typegroup = <n>-str.
            s_tp-tputype = 0.     " Type group use                (TYPE-POOLS tp)
            s_tp-explicit = abap_true.
            s_tp-implicit = abap_false.
            APPEND s_tp TO new_typepools.             d_flag = abap_true.
          ENDLOOP.
        WHEN 'CLASS' OR 'INTERFACE'.
          d_tabix = <st>-to - 1.
          READ TABLE t_tokens ASSIGNING <n> INDEX d_tabix.
          CHECK sy-subrc = 0.
          CHECK <n>-str = 'DEFINITION'.
          READ TABLE t_tokens ASSIGNING <n> INDEX <st>-to.
          CHECK sy-subrc = 0.
          CHECK <n>-str = 'LOAD'.
          d_tabix = <st>-from + 1.
          READ TABLE t_tokens ASSIGNING <n> INDEX d_tabix.
          CHECK sy-subrc = 0.
          d_comment = abap_true.
          READ TABLE typepools TRANSPORTING NO FIELDS
               WITH KEY typegroup = <n>-str
                         explicit = abap_true.
          CHECK sy-subrc <> 0.
          CLEAR s_tp.
          s_tp-typegroup = <n>-str.
          CASE <t>-str.
            WHEN 'CLASS'.
              s_tp-tputype = 1.     " 1 Forward declaration class     (CLASS c DEFINITION DEFERRED)
            WHEN 'INTERFACE'.
              s_tp-tputype = 2.     " 2 Forward declaration interface (INTERFACE i DEFINITION DEF...
            WHEN OTHERS.
              ASSERT <t>-str = 'CLASS' OR <t>-str = 'INTERFACE'.
          ENDCASE.
          s_tp-explicit = abap_true.
          s_tp-implicit = abap_false.
          APPEND s_tp TO new_typepools.             d_flag = abap_true.
        WHEN OTHERS.
          CONTINUE.
      ENDCASE.
      IF NOT d_comment IS INITIAL.
        zaplink_tools=>comment_statement( EXPORTING statement = <st>
                                                       tokens = t_tokens
                                                CHANGING code = new_sourcecode ).
      ENDIF.
    ENDLOOP.
    IF d_flag IS INITIAL. CLEAR new_sourcecode. ENDIF.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~anonymize.
    DATA _o_class       TYPE to_class.
    DATA _o_interface   TYPE to_interface.
    CHECK object IS BOUND.
    CASE object->type.
      WHEN zaplink_object_data=>object_types-class.
        _o_class ?= object->raw.
        _o_class->anonymize( ).
      WHEN zaplink_object_data=>object_types-interface.
        _o_interface ?= object->raw.
        _o_interface->anonymize( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name object->type.
    ENDCASE.
    TRY.
        super->zaplink_cnx_ext_cleaner~anonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~unanonymize.
    DATA _o_class       TYPE to_class.
    DATA _o_interface   TYPE to_interface.
    TRY.
        super->zaplink_cnx_ext_cleaner~unanonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
    CASE object->type.
      WHEN zaplink_object_data=>object_types-class.
        _o_class ?= object->raw.
        _o_class->unanonymize( ).
      WHEN zaplink_object_data=>object_types-interface.
        _o_interface ?= object->raw.
        _o_interface->unanonymize( ).
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_code_signature~get_signature.
    DATA clskey TYPE seoclskey.
    DATA d_type TYPE td_comptype.
    TRY.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN zaplink_object_data=>object_types-class.
            clskey-clsname = component->get_name( ).
            result = get_class_signature( clskey ).
          WHEN zaplink_object_data=>object_types-interface.
            clskey-clsname = component->get_name( ).
            result = get_interface_signature( clskey ).
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_clas TYPE to_class.
    DATA o_intf TYPE to_interface.
    CREATE OBJECT object.
    CASE type.
      WHEN zaplink_object_data=>object_types-class.
        CREATE OBJECT o_clas.
        object->raw = o_clas.
      WHEN zaplink_object_data=>object_types-interface.
        CREATE OBJECT o_intf.
        object->raw = o_intf.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA clskey  TYPE seoclskey.
    DATA d_type  TYPE td_comptype.
    DATA s_subrc TYPE sy-subrc.
    DATA d_name  TYPE td_compname.
    TRY.
        d_type = component->get_type( ).
        clskey-clsname = d_name = component->get_name( ).
        CASE d_type.
          WHEN zaplink_object_data=>object_types-class.
            CALL FUNCTION 'SEO_CLASS_DELETE_COMPLETE'
              EXPORTING
                clskey       = clskey
              EXCEPTIONS
                not_existing = 1
                is_interface = 2
                db_error     = 3
                no_access    = 4
                other        = 5
                OTHERS       = 6.
            IF sy-subrc <> 0.
              CASE sy-subrc.
                WHEN 1.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>not_found.
                WHEN OTHERS.
                  s_subrc = sy-subrc.
                  CALL FUNCTION 'SEO_BSP_CLASS_DELETE_COMPLETE'     " Issue 119 : Brute force delete
                    EXPORTING
                      clskey = clskey.
                  IF do_exists( component ) = abap_true.
                    o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLASS_DELETE_W_DEPS'
                                                                subrc = s_subrc
                                                            classname = 'ZAPLINK_CX_CONNECTOR' ).
                    application_log->add_symsg( ).
                    RAISE EXCEPTION o_mycx.
                  ENDIF.
              ENDCASE.
            ENDIF.
          WHEN zaplink_object_data=>object_types-interface.
            CALL FUNCTION 'SEO_INTERFACE_DELETE_COMPLETE'
              EXPORTING
                intkey               = clskey
                authority_check      = seox_true
                suppress_docu_delete = seox_true
              EXCEPTIONS
                not_existing         = 1
                is_class             = 2
                db_error             = 3
                no_access            = 4
                other                = 5
                OTHERS               = 6.
            IF sy-subrc <> 0.
              CASE sy-subrc.
                WHEN 1.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>not_found.
                WHEN OTHERS.
                  s_subrc = sy-subrc.
                  CALL FUNCTION 'SEO_BSP_CLASS_DELETE_COMPLETE'     " Issue 119 : Brute force delete
                    EXPORTING
                      clskey = clskey.
                  IF do_exists( component ) = abap_true.
                    o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_INTERFACE_DELETE_COMPLETE'
                                                                subrc = s_subrc
                                                            classname = 'ZAPLINK_CX_CONNECTOR' ).
                    application_log->add_symsg( ).
                    RAISE EXCEPTION o_mycx.
                  ENDIF.
              ENDCASE.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    result = abap_true.
    zaplink_tools=>remove_comp_from_working_area( type = d_type
                                                  name = d_name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA clskey TYPE seoclskey.
    DATA d_type TYPE td_comptype.
    TRY.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN zaplink_object_data=>object_types-class.
            clskey-clsname = component->get_name( ).
            CALL FUNCTION 'SEO_CLASS_EXISTENCE_CHECK'
              EXPORTING
                clskey        = clskey
              EXCEPTIONS
                not_specified = 1
                not_existing  = 2
                is_interface  = 3
                no_text       = 4
                inconsistent  = 5
                OTHERS        = 6.
            IF sy-subrc = 0.
              exists = 'X'.
            ENDIF.
          WHEN zaplink_object_data=>object_types-interface.
            clskey-clsname = component->get_name( ).
            CALL FUNCTION 'SEO_INTERFACE_EXISTENCE_CHECK'
              EXPORTING
                intkey        = clskey
              EXCEPTIONS
                not_specified = 1
                not_existing  = 2
                is_class      = 3
                no_text       = 4
                inconsistent  = 5
                OTHERS        = 6.
            IF sy-subrc = 0.
              exists = 'X'.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver OR version = '1.0'.   " version 1.01 is downward compatible with version 1.0
      result = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    DATA o_clas TYPE to_class.
    DATA o_intf TYPE to_interface.
    DATA d_type TYPE td_comptype.
    TRY.
        CREATE OBJECT object.
        object->set_component( component ).
        d_type = component->get_type( ).
        CASE d_type.
          WHEN zaplink_object_data=>object_types-class.
            TRY.
                o_clas = export_from_sap_class( component ).
              CATCH zaplink_cx_connector INTO o_mycx.
                IF NOT o_mycx->messages IS BOUND.
                  o_mycx->messages = application_log.
                  o_mycx->update( ).
                ENDIF.
                RAISE EXCEPTION o_mycx.
            ENDTRY.
            CLEAR o_clas->a0_maindata-clsname.
            object->raw = o_clas.
          WHEN zaplink_object_data=>object_types-interface.
            TRY.
                o_intf = export_from_sap_interface( component ).
              CATCH zaplink_cx_connector INTO o_mycx.
                IF NOT o_mycx->messages IS BOUND.
                  o_mycx->messages = application_log.
                  o_mycx->update( ).
                ENDIF.
                RAISE EXCEPTION o_mycx.
            ENDTRY.
            CLEAR o_intf->a0_maindata-clsname.
            object->raw = o_intf.
          WHEN OTHERS.
            CLEAR object.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        object->update_connector_data( me ).                    " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    DATA _o_class       TYPE to_class.
    DATA _o_interface   TYPE to_interface.
    DATA o_comp         TYPE to_component.                    " Issue 92
    TRY.
        CASE object->type.
          WHEN zaplink_object_data=>object_types-class.
            _o_class ?= object->raw.
            _o_class->a0_maindata-clsname = object->name.
            TRY.
                components = import_to_sap_class( _o_class ).
              CATCH zaplink_cx_connector INTO o_mycx.
                IF NOT o_mycx->messages IS BOUND.
                  o_mycx->messages = application_log.
                  o_mycx->update( ).
                ENDIF.
                RAISE EXCEPTION o_mycx.
            ENDTRY.
          WHEN zaplink_object_data=>object_types-interface.
            _o_interface ?= object->raw.
            _o_interface->a0_maindata-clsname = object->name.
            TRY.
                components = import_to_sap_interface( _o_interface ).
              CATCH zaplink_cx_connector INTO o_mycx.
                IF NOT o_mycx->messages IS BOUND.
                  o_mycx->messages = application_log.
                  o_mycx->update( ).
                ENDIF.
                RAISE EXCEPTION o_mycx.
            ENDTRY.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name object->type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ). " Issue 92
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD _check_class_sections.
    DATA pubsec_source TYPE seo_section_source.
    DATA prosec_source TYPE seo_section_source.
    DATA prisec_source TYPE seo_section_source.
    DATA d_text        TYPE string.
    DATA d_name        TYPE td_compname.
    IF NOT application_log IS BOUND.
      d_text = 'APPLICATION_LOG can''t be null'(eal).
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          textid  = zaplink_cx_connector=>system_error
          cx_name = d_text.
    ENDIF.
    CALL FUNCTION 'SEO_CLASS_TYPEINFO_BY_VIS'         " Issue 105 : First call for nothing to ensure method order
      EXPORTING
        clskey       = classkey
        version      = seoc_version_inactive
        state        = seoc_state_implemented
      EXCEPTIONS
        not_existing = 1
        is_interface = 2
        model_only   = 3
        OTHERS       = 4.
    IF sy-subrc = 3.        " Issue 111
      RETURN.
    ELSEIF sy-subrc = 1.
      d_name = classkey.
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          textid = zaplink_cx_connector=>not_found
          type   = zaplink_object_data=>object_types-class
          name   = d_name.
    ELSEIF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLASS_TYPEINFO_BY_VIS'
                                                  subrc = sy-subrc
                                              classname = 'ZAPLINK_CX_CONNECTOR' ).
      application_log->add_symsg( ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
    CALL FUNCTION 'SEO_CLASS_GENERATE_SECTIONS'
      EXPORTING
        clskey                         = classkey
        public                         = seox_true
        protected                      = seox_true
        private                        = seox_true
        return_generated_sections_only = seox_true
      IMPORTING
        pubsec_source                  = pubsec_source
        prosec_source                  = prosec_source
        prisec_source                  = prisec_source
      EXCEPTIONS
        not_existing                   = 1
        model_only                     = 2
        public_sec_not_generated       = 3
        protected_sec_not_generated    = 4
        private_sec_not_generated      = 5
        public_sec_not_initialised     = 6
        protected_sec_not_initialised  = 7
        private_sec_not_initialised    = 8
        _internal_class_not_existing   = 9
        OTHERS                         = 10.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLASS_GENERATE_SECTIONS'
                                                  subrc = sy-subrc
                                              classname = 'ZAPLINK_CX_CONNECTOR' ).
      application_log->add_symsg( ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
    IF pubsec_source = pub_source.
      CLEAR pubsec_source.
    ELSE.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE w002 WITH TEXT-pub classkey. ENDIF.
      SET EXTENDED CHECK ON.
      CALL METHOD application_log->add_warning
        EXPORTING
          id_msgno = '002'
          id_msgv1 = 'Public section'(pub)
          id_msgv2 = classkey.
    ENDIF.
    IF prosec_source = pro_source.
      CLEAR prosec_source.
    ELSE.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE w002 WITH TEXT-pro classkey. ENDIF.
      SET EXTENDED CHECK ON.
      CALL METHOD application_log->add_warning
        EXPORTING
          id_msgno = '002'
          id_msgv1 = 'Protected section'(pro)
          id_msgv2 = classkey.
    ENDIF.
    IF prisec_source = pri_source.
      CLEAR prisec_source.
    ELSE.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE w002 WITH TEXT-pri classkey. ENDIF.
      SET EXTENDED CHECK ON.
      CALL METHOD application_log->add_warning
        EXPORTING
          id_msgno = '002'
          id_msgv1 = 'Private section'(pri)
          id_msgv2 = classkey.
    ENDIF.
    IF NOT pubsec_source IS INITIAL OR NOT prosec_source IS INITIAL OR NOT prisec_source IS INITIAL.
      CALL FUNCTION 'SEO_CLASS_GENERATE_SECTIONS'
        EXPORTING
          clskey                        = classkey
          public                        = seox_true
          protected                     = seox_true
          private                       = seox_true
        EXCEPTIONS
          not_existing                  = 1
          model_only                    = 2
          public_sec_not_generated      = 3
          protected_sec_not_generated   = 4
          private_sec_not_generated     = 5
          public_sec_not_initialised    = 6
          protected_sec_not_initialised = 7
          private_sec_not_initialised   = 8
          _internal_class_not_existing  = 9
          OTHERS                        = 10.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLASS_GENERATE_SECTIONS'
                                                    subrc = sy-subrc
                                                classname = 'ZAPLINK_CX_CONNECTOR' ).
        application_log->add_symsg( ).
        RAISE EXCEPTION o_mycx.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD _cleanup_class.
    DATA f_has_error  TYPE abap_bool.
    DATA t_types      TYPE STANDARD TABLE OF seotypepls.
    DATA s_key        TYPE seotpukey.
    DATA d_classkey   TYPE seoclskey.
    DATA s_data       TYPE vseocdefer.
    FIELD-SYMBOLS <t> LIKE LINE OF t_types.
    TRY.
        IF generate_class( object_data-class-clsname ) IS INITIAL.    f_has_error = abap_true.    ENDIF.
        IF cleanup_typeusage( include = object_data-includes-pubsec
                                 text = 'Public section'(pub) ) = abap_true.
          has_change = abap_true.
        ENDIF.
        IF cleanup_typeusage( include = object_data-includes-prosec
                                 text = 'Protected section'(pro) ) = abap_true.
          has_change = abap_true.
        ENDIF.
        IF cleanup_typeusage( include = object_data-includes-prisec
                                 text = 'Private section'(pri) ) = abap_true.
          has_change = abap_true.
        ENDIF.
        IF NOT has_change IS INITIAL.
          d_classkey-clsname = object_data-class-clsname.
          CALL FUNCTION 'SEO_CLIF_SAVE_ALL'
            EXPORTING
              cifkey                   = d_classkey
            EXCEPTIONS
              not_existing             = 1
              nothing_to_do            = 2
              access_error             = 3
              db_error                 = 4
              error_in_code_generation = 5
              OTHERS                   = 6.
          IF sy-subrc <> 0.
            o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLIF_SAVE_ALL'
                                                        subrc = sy-subrc
                                                    classname = 'ZAPLINK_CX_CONNECTOR' ).
            application_log->add_symsg( ).
            RAISE EXCEPTION o_mycx.
          ENDIF.
        ENDIF.
        IF f_has_error IS INITIAL.
          SELECT * INTO TABLE t_types
            FROM seotypepls
            WHERE clsname = object_data-class-clsname
              AND tputype <> 0    " no type-pool
              AND explicit = abap_false
              AND implicit = abap_true.
          LOOP AT t_types ASSIGNING <t>.
            CLEAR: s_key.    s_key-clsname = <t>-clsname.      s_key-typegroup = <t>-typegroup.
            CASE <t>-tputype.
              WHEN 1.
                CALL FUNCTION 'SEO_CLSDEFERRD_DELETE_W_DEPS'
                  EXPORTING
                    cdfkey        = s_key
                    save          = seox_true
                  EXCEPTIONS
                    not_existing  = 1
                    is_intdeferrd = 2
                    is_typepusage = 3
                    not_deleted   = 4
                    db_error      = 5
                    OTHERS        = 6.
                IF sy-subrc <> 0.
                  o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLSDEFERRD_DELETE_W_DEPS'
                                                              subrc = sy-subrc
                                                          classname = 'ZAPLINK_CX_CONNECTOR' ).
                  application_log->add_symsg( ).
                  RAISE EXCEPTION o_mycx.
                ENDIF.
              WHEN 2.     " interface*
                CALL FUNCTION 'SEO_INTDEFERRD_DELETE_W_DEPS'
                  EXPORTING
                    idfkey        = s_key
                    save          = seox_true
                  EXCEPTIONS
                    not_existing  = 1
                    is_typepusage = 2
                    is_clsdeferrd = 3
                    not_deleted   = 4
                    db_error      = 5
                    OTHERS        = 6.
                IF sy-subrc <> 0.
                  o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_INTDEFERRD_DELETE_W_DEPS'
                                                              subrc = sy-subrc
                                                          classname = 'ZAPLINK_CX_CONNECTOR' ).
                  application_log->add_symsg( ).
                  RAISE EXCEPTION o_mycx.
                ENDIF.
              WHEN OTHERS.
                ASSERT <t>-tputype >= 1 AND <t>-tputype <= 2.
                CONTINUE.
            ENDCASE.
            IF NOT generate_class( s_key-clsname ) IS INITIAL.
              has_change = abap_true.
            ELSE.
              MOVE-CORRESPONDING <t> TO s_data.
              CASE <t>-tputype.
                WHEN 1.
                  CALL FUNCTION 'SEO_CLSDEFERRD_CREATE_F_DATA'
                    EXPORTING
                      save          = seox_true
                    CHANGING
                      clsdeferrd    = s_data
                    EXCEPTIONS
                      existing      = 1
                      is_intdeferrd = 2
                      is_typepusage = 3
                      not_created   = 4
                      db_error      = 5
                      OTHERS        = 6.
                  IF sy-subrc <> 0.
                    o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_CLSDEFERRD_CREATE_F_DATA'
                                                                subrc = sy-subrc
                                                            classname = 'ZAPLINK_CX_CONNECTOR' ).
                    application_log->add_symsg( ).
                    RAISE EXCEPTION o_mycx.
                  ENDIF.
                WHEN 2.     " interface
                  CALL FUNCTION 'SEO_INTDEFERRD_CREATE_F_DATA'
                    EXPORTING
                      save          = seox_true
                    CHANGING
                      intdeferrd    = s_data
                    EXCEPTIONS
                      existing      = 1
                      is_typepusage = 2
                      is_clsdeferrd = 3
                      not_created   = 4
                      db_error      = 5
                      OTHERS        = 6.
                  IF sy-subrc <> 0.
                    o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'SEO_INTDEFERRD_CREATE_F_DATA'
                                                                subrc = sy-subrc
                                                            classname = 'ZAPLINK_CX_CONNECTOR' ).
                    application_log->add_symsg( ).
                    RAISE EXCEPTION o_mycx.
                  ENDIF.
                WHEN OTHERS.
                  ASSERT <t>-tputype >= 1 AND <t>-tputype <= 2.
                  CONTINUE.
              ENDCASE.
            ENDIF.
          ENDLOOP.
        ENDIF.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_OBJECT implementation
CLASS zaplink_package IMPLEMENTATION.
  METHOD add_elements_list.
    DATA _err       TYPE scomeldata.
    DATA _err_lst   TYPE scomeldata.
    DATA alv_data   TYPE tt_ele.
    DATA a_data     LIKE LINE OF alv_data.
    DATA exception  TYPE REF TO zaplink_cx_connector.
    DATA title      TYPE lvc_title.
    DATA errormsg   TYPE string.
    FIELD-SYMBOLS <e> LIKE LINE OF _err.
    FIELD-SYMBOLS <l> LIKE LINE OF interface->elements.
    CALL METHOD interface->if->add_elements
      EXPORTING
        i_elements_data        = interface->elements
      IMPORTING
        e_mismatched_elem_data = _err " Should be empty if all OK
      EXCEPTIONS
        object_invalid         = 1
        intern_err             = 2
        OTHERS                 = 3.
    IF sy-subrc <> 0 OR NOT _err IS INITIAL.
      IF _err IS INITIAL.
        errormsg = 'Package interface elements creation failed !'(e91).
      ELSEIF sy-batch = 'X' OR ask_user IS INITIAL.
        errormsg = build_error_msg( _err ).
        CONCATENATE 'Package interface elements failed to add : '(e92) errormsg INTO errormsg.
      ELSE. " ask user
        LOOP AT _err ASSIGNING <e>.
          READ TABLE interface->elements ASSIGNING <l>
               WITH KEY intf_name = <e>-intf_name
                        elem_type = <e>-elem_type
                         elem_key = <e>-elem_key.
          IF sy-subrc <> 0.
            RAISE EXCEPTION TYPE zaplink_cx_connector
              EXPORTING
                textid = zaplink_cx_connector=>system_error.
          ENDIF.
          <e> = <l>. " back to original value
        ENDLOOP.
        alv_data = elements2alv( _err ).
        a_data-elem_pack = interface->if->publisher_package_name.
        MODIFY alv_data FROM a_data TRANSPORTING elem_pack WHERE elem_pack IS INITIAL.   "update package
        title = 'Inconsistant TADIR entries please select elements that will change package. All unselected entries won''t be in this interface'(alv).
        CALL FUNCTION 'REUSE_ALV_GRID_DISPLAY'
          EXPORTING
            i_grid_title  = title
            is_layout     = cat_layout
            it_fieldcat   = cat_ele
          TABLES
            t_outtab      = alv_data
          EXCEPTIONS
            program_error = 1
            OTHERS        = 2.
        IF sy-subrc <> 0.
          errormsg = build_error_msg( _err ).
          CONCATENATE 'Package interface elements failed to add : '(e92) errormsg INTO errormsg.
        ELSE.
          change_tadir( CHANGING alv_data = alv_data ).
          LOOP AT _err ASSIGNING <e>.
            CLEAR a_data.
            READ TABLE alv_data INTO a_data WITH KEY elem_type = <e>-elem_type
                                                      elem_key = <e>-elem_key.
            IF sy-subrc <> 0 OR a_data-select IS INITIAL.
              APPEND <e> TO _err_lst.
              DELETE _err.
            ENDIF.
          ENDLOOP.
          TRY.
              interface->elements = _err.
              CALL METHOD add_elements_list
                EXPORTING
                  interface = interface.
            CATCH zaplink_cx_connector INTO exception.
              RAISE EXCEPTION exception.
          ENDTRY.
          IF _err_lst IS INITIAL.
            EXIT. " if every thing is OK
          ELSE.
            errormsg = build_error_msg( _err_lst ).
            CONCATENATE 'Package interface elements failed to add : '(e92) errormsg INTO errormsg.
          ENDIF.
        ENDIF.
      ENDIF.
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          textid  = zaplink_cx_connector=>system_error
          cx_name = errormsg.
    ENDIF.
    CALL METHOD interface->if->save_elements
      EXPORTING
        i_transport_request   = transport_request
      IMPORTING
        e_transport_request   = transport_request
      EXCEPTIONS
        cancelled_in_corr     = 1
        intern_err            = 2
        object_invalid        = 3
        object_not_changeable = 4
        permission_failure    = 5
        unexpected_error      = 6
        OTHERS                = 7.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_method_cx( class = interface->if
                                                  method = 'SAVE_ELEMENTS'
                                                   subrc = sy-subrc
                                            cx_classname = 'ZAPLINK_CX_CONNECTOR' ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
  ENDMETHOD.
  METHOD build_error_msg.
    DATA obj_key    TYPE string.
    FIELD-SYMBOLS:
      <e> LIKE LINE OF elements.
    LOOP AT elements ASSIGNING <e>.
      CONCATENATE <e>-elem_key '(' <e>-elem_type ')' INTO obj_key.
      IF errormsg IS INITIAL.
        errormsg = obj_key.
      ELSE.
        CONCATENATE errormsg ', ' obj_key INTO errormsg.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD change_tadir.
    DATA object   TYPE tadir-object.
    DATA obj_name TYPE tadir-obj_name.
    DATA korrnum  TYPE tadir-korrnum.
    DATA d_kind   TYPE tadir-pgmid.
    FIELD-SYMBOLS:
      <e> LIKE LINE OF alv_data.
    korrnum = transport_request.
    LOOP AT alv_data ASSIGNING <e>
            WHERE NOT select IS INITIAL.
      object = <e>-elem_type.
      obj_name = <e>-elem_key.
      d_kind = zaplink_connectors=>get_typekind( object ).
      CALL FUNCTION 'TRINT_TADIR_INTERFACE'
        EXPORTING
          wi_test_modus                  = ' '
          wi_tadir_pgmid                 = d_kind
          wi_tadir_object                = object
          wi_tadir_obj_name              = obj_name
          wi_tadir_korrnum               = korrnum
          wi_tadir_devclass              = <e>-elem_pack
        EXCEPTIONS
          tadir_entry_not_existing       = 1
          tadir_entry_ill_type           = 2
          no_systemname                  = 3
          no_systemtype                  = 4
          original_system_conflict       = 5
          object_reserved_for_devclass   = 6
          object_exists_global           = 7
          object_exists_local            = 8
          object_is_distributed          = 9
          obj_specification_not_unique   = 10
          no_authorization_to_delete     = 11
          devclass_not_existing          = 12
          simultanious_set_remove_repair = 13
          order_missing                  = 14
          no_modification_of_head_syst   = 15
          pgmid_object_not_allowed       = 16
          masterlanguage_not_specified   = 17
          devclass_not_specified         = 18
          specify_owner_unique           = 19
          loc_priv_objs_no_repair        = 20
          gtadir_not_reached             = 21
          object_locked_for_order        = 22
          change_of_class_not_allowed    = 23
          no_change_from_sap_to_tmp      = 24
          OTHERS                         = 25.
      IF sy-subrc <> 0.
        CLEAR <e>-select.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD class_constructor.
    DATA ls_fieldcat  LIKE LINE OF  cat_ele.
    ls_fieldcat-fieldname = 'ELEM_TYPE'.
    ls_fieldcat-seltext_l = 'Object Type'(c01).
    APPEND ls_fieldcat TO cat_ele.
    ls_fieldcat-fieldname = 'ELEM_KEY'.
    ls_fieldcat-seltext_l = 'Object Name'(c02).
    APPEND ls_fieldcat TO cat_ele.
    ls_fieldcat-fieldname = 'TD_PACK'.
    ls_fieldcat-seltext_l = 'TADIR Package'(c03).
    APPEND ls_fieldcat TO cat_ele.
    ls_fieldcat-fieldname = 'ELEM_PACK'.
    ls_fieldcat-seltext_s = 'New package'(c04).
    ls_fieldcat-seltext_l = 'New package when validated'(l04).
    APPEND ls_fieldcat TO cat_ele.
    cat_layout-box_fieldname     = 'SELECT'.
    cat_layout-colwidth_optimize = 'X'.
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.      " create my application before parent do the same
    application_log->msgid = 'ZAPLINK_PACKAGE'.
    type-type = st_package. INSERT type INTO TABLE supported_types.
    type-type = st_interface. INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD conv_interface.
    DATA elements   TYPE tpak_package_interf_elem_list.
    DATA elem       LIKE LINE OF o_data->elements.
    DATA _component  TYPE to_component.
    FIELD-SYMBOLS:
      <e> LIKE LINE OF elements.
    TRY.
        CREATE OBJECT o_data.
        CALL METHOD interface->get_all_attributes
          IMPORTING
            e_package_interface_data = o_data->a0_maindata
          EXCEPTIONS
            object_invalid           = 1
            OTHERS                   = 2.
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid  = zaplink_cx_connector=>system_error
              cx_name = 'error in interface->get_all_attributes'.
        ENDIF.
        CREATE OBJECT _component.
        _component->set_type( st_interface ).
        _component->set_name( o_data->a0_maindata-intf_name ).
        subcomponents->add( _component ).
        CALL METHOD interface->get_elements
          EXPORTING
            i_with_deleted_elements = 'X'
          IMPORTING
            e_elements              = elements
          EXCEPTIONS
            object_invalid          = 1
            intern_err              = 2
            OTHERS                  = 3.
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid  = zaplink_cx_connector=>system_error
              cx_name = 'interface->get_elements'.
        ELSEIF NOT elements IS INITIAL.
          LOOP AT elements ASSIGNING <e>.
            CALL METHOD <e>->get_all_attributes
              IMPORTING
                e_element_data = elem
              EXCEPTIONS
                object_invalid = 1
                OTHERS         = 2.
            IF sy-subrc <> 0.
              RAISE EXCEPTION TYPE zaplink_cx_connector
                EXPORTING
                  textid  = zaplink_cx_connector=>system_error
                  cx_name = 'error in interface->get_all_attributes'.
            ENDIF.
            APPEND elem TO o_data->elements.
          ENDLOOP.
        ENDIF.
        IF NOT o_data->a0_maindata-acl_flag IS INITIAL.
          CALL METHOD interface->get_access_control_list
            IMPORTING
              e_user_list    = o_data->acls
            EXCEPTIONS
              object_invalid = 1
              no_acl         = 0
              intern_err     = 3
              OTHERS         = 4.
          IF sy-subrc <> 0.
            RAISE EXCEPTION TYPE zaplink_cx_connector
              EXPORTING
                textid  = zaplink_cx_connector=>system_error
                cx_name = 'interface->get_access_control_list'.
          ENDIF.
        ENDIF.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD conv_interface_raw.
    DATA o_comp     TYPE to_component.
    DATA _data      TYPE to_interface.
    DATA _cx        TYPE REF TO zaplink_cx.
    TRY.
        _data = conv_interface( interface = interface
                            subcomponents = subcomponents ).
        CREATE OBJECT o_comp.
        o_comp->set_type( st_interface ).
        o_comp->set_name( _data->a0_maindata-intf_name ).
        CREATE OBJECT o_data
          EXPORTING
            o_comp = o_comp.
        o_data->raw = _data.
      CATCH zaplink_cx INTO _cx.
        CREATE OBJECT o_mycx
          EXPORTING
            textid   = zaplink_cx=>system_error
            previous = _cx.
        o_mycx->update( ).
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD conv_package.
    DATA perm_data   LIKE LINE OF o_data->acls.
    DATA permissions TYPE tpak_permission_to_use_list.
    DATA interfaces  TYPE tpak_package_interface_list.
    DATA intf        LIKE LINE OF o_data->interfaces.
    DATA packages    TYPE scompaklis.
    DATA pack        LIKE LINE OF o_data->packages.
    DATA _component  TYPE to_component.
    FIELD-SYMBOLS:
      <pack> LIKE LINE OF packages,
      <itf>  LIKE LINE OF interfaces,
      <p>    LIKE LINE OF permissions.
    TRY.
        CLEAR o_mycx.
        CREATE OBJECT o_data.
        CALL METHOD package->get_all_attributes
          IMPORTING
            e_package_data  = o_data->a0_maindata
          EXCEPTIONS
            object_invalid  = 1
            package_deleted = 2
            intern_err      = 3
            OTHERS          = 4.
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid  = zaplink_cx_connector=>system_error
              cx_name = 'error in package->get_all_attributes'.
        ENDIF.
        CLEAR: o_data->a0_maindata-dlvu_text, o_data->a0_maindata-component, o_data->a0_maindata-comp_text,
               o_data->a0_maindata-namespace, o_data->a0_maindata-layer_text.
        CREATE OBJECT _component.
        _component->set_type( st_package ).
        _component->set_name( o_data->a0_maindata-devclass ).
        subcomponents->add( _component ).
        CALL METHOD package->get_permissions_to_use
          IMPORTING
            e_permissions    = permissions
          EXCEPTIONS
            object_invalid   = 1
            unexpected_error = 2
            OTHERS           = 3.
        IF sy-subrc <> 0.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid  = zaplink_cx_connector=>system_error
              cx_name = 'package->get_permissions_to_use'.
        ELSEIF NOT permissions IS INITIAL.
          LOOP AT permissions ASSIGNING <p>.
            CHECK <p>->deleted_in_memory IS INITIAL.
            perm_data-intf_name = <p>->package_interface_name.
            perm_data-err_sever = <p>->error_severity.
            APPEND perm_data TO o_data->acls.
          ENDLOOP.
        ENDIF.
        IF with_subcomp = abap_true.
          CALL METHOD package->get_interfaces
            IMPORTING
              e_package_interfaces = interfaces
            EXCEPTIONS
              object_invalid       = 1
              unexpected_error     = 2
              intern_err           = 3
              OTHERS               = 4.
          IF sy-subrc <> 0.
            RAISE EXCEPTION TYPE zaplink_cx_connector
              EXPORTING
                textid = zaplink_cx_connector=>system_error.
          ELSEIF NOT interfaces IS INITIAL.
            LOOP AT interfaces ASSIGNING <itf>.
              TRY.
                  intf-zl_object = conv_interface_raw( interface = <itf>
                                                   subcomponents = subcomponents ).
                CATCH zaplink_cx_connector INTO o_mycx.
                  application_log->add_exception( o_mycx ).
              ENDTRY.
              APPEND intf TO o_data->interfaces.
            ENDLOOP.
          ENDIF.
          CALL METHOD package->get_sub_packages
            IMPORTING
              e_sub_packages   = packages
            EXCEPTIONS
              object_invalid   = 1
              leaf_package     = 0   " 053(PAK) : Package &1 does not contain any sub-packages
              unexpected_error = 3
              OTHERS           = 4.
          IF sy-subrc <> 0.
            RAISE EXCEPTION TYPE zaplink_cx_connector
              EXPORTING
                textid = zaplink_cx_connector=>system_error.
          ELSEIF NOT packages IS INITIAL.
            LOOP AT packages ASSIGNING <pack>.
              TRY.
                  pack-zl_object = conv_package_raw( package = <pack>
                                               subcomponents = subcomponents ).
                CATCH zaplink_cx_connector INTO o_mycx.
                  application_log->add_exception( o_mycx ).
              ENDTRY.
              APPEND pack TO o_data->packages.
            ENDLOOP.
          ENDIF.
        ENDIF.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    IF o_mycx IS BOUND.   RAISE EXCEPTION o_mycx.   ENDIF.
  ENDMETHOD.
  METHOD conv_package_raw.
    DATA o_comp     TYPE to_component.
    DATA _data      TYPE to_package.
    DATA _cx        TYPE REF TO zaplink_cx.
    TRY.
        _data = conv_package( package = package
                        subcomponents = subcomponents ).
        CREATE OBJECT o_comp.
        o_comp->set_type( st_package ).
        o_comp->set_name( _data->a0_maindata-devclass ).
        CREATE OBJECT o_data
          EXPORTING
            o_comp = o_comp.
        o_data->raw = _data.
        CLEAR: _data->a0_maindata-devclass, _data->a0_maindata-parentcl. " Issue 48
      CATCH zaplink_cx INTO _cx.
        CREATE OBJECT o_mycx
          EXPORTING
            textid   = zaplink_cx=>system_error
            previous = _cx.
        o_mycx->update( ).
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD create_interface.
    DATA _component      TYPE to_component.
    DATA name       TYPE td_interface.
    DATA transport_request  TYPE  e070-trkorr.
    name = interface->a0_maindata-intf_name.
    SET EXTENDED CHECK OFF.
    IF 1 = 2. MESSAGE e013 WITH name. ENDIF.
    SET EXTENDED CHECK ON.
    application_log->add_info( id_msgno = 013
                               id_msgv1 = name ).
    CALL METHOD update_interface
      EXPORTING
        data      = interface->a0_maindata
      CHANGING
        interface = interface->if.
    CALL METHOD interface->if->save
      EXPORTING
        i_transport_request   = transport_request
      IMPORTING
        e_transport_request   = transport_request
      EXCEPTIONS
        object_invalid        = 1
        object_not_changeable = 2
        cancelled_in_corr     = 3
        permission_failure    = 4
        unexpected_error      = 5
        intern_err            = 6
        OTHERS                = 7.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_method_cx( class = interface->if
                                                  method = 'SAVE'
                                                   subrc = sy-subrc
                                            cx_classname = 'ZAPLINK_CX_CONNECTOR' ).
      RAISE EXCEPTION o_mycx.
    ELSE.
      CREATE OBJECT _component.
      _component->set_type( st_interface ).
      _component->set_name( name ).
      components->add( _component ).
    ENDIF.
  ENDMETHOD.
  METHOD create_package.
    DATA name               TYPE td_package.
    DATA transport_request  TYPE  e070-trkorr.
    DATA _component         TYPE to_component.
    DATA o_intf             TYPE to_interface.
    DATA o_package          TYPE to_package.
    FIELD-SYMBOLS:
      <p> LIKE LINE OF package->packages,
      <i> LIKE LINE OF package->interfaces.
    name = package->a0_maindata-devclass.
    SET EXTENDED CHECK OFF.
    IF 1 = 2. MESSAGE e003 WITH space. ENDIF.
    SET EXTENDED CHECK ON.
    application_log->add_info( id_msgno = 003
                               id_msgv1 = name ).
    CALL METHOD update_package
      EXPORTING
        data    = package->a0_maindata
      CHANGING
        package = package->if.
    CALL METHOD package->if->save
      EXPORTING
        i_transport_request   = transport_request
      IMPORTING
        e_transport_request   = transport_request
      EXCEPTIONS
        object_invalid        = 1
        object_not_changeable = 2
        cancelled_in_corr     = 3
        permission_failure    = 4
        unexpected_error      = 5
        intern_err            = 6
        OTHERS                = 7.
    IF sy-subrc <> 0.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE e009 WITH space. ENDIF.
      SET EXTENDED CHECK ON.
      application_log->add_error( id_msgno = 009
                                  id_msgv1 = name ).
      application_log->add_symsg( ).
    ELSE.
      CREATE OBJECT _component.
      _component->set_type( st_package ).
      _component->set_name( name ).
      components->add( _component ).
    ENDIF.
    LOOP AT package->interfaces ASSIGNING <i>.
      o_intf ?= <i>-zl_object->raw.
      CALL METHOD create_interface
        EXPORTING
          interface  = o_intf
          overwrite  = overwrite
          components = components.
    ENDLOOP.
    LOOP AT package->packages ASSIGNING <p>.
      o_package ?= <p>-zl_object->raw.
      o_package->a0_maindata-devclass = <p>-zl_object->name.    o_package->a0_maindata-parentcl = package->a0_maindata-devclass. " Issue 48
      CALL METHOD create_package
        EXPORTING
          package    = o_package
          overwrite  = overwrite
          components = components.
    ENDLOOP.
  ENDMETHOD.
  METHOD elements2alv.
    DATA _wa     LIKE LINE OF alv_data.
    DATA d_kind  TYPE td_transport_kind.
    FIELD-SYMBOLS: <e> LIKE LINE OF elements.
    LOOP AT elements ASSIGNING <e>.
      MOVE-CORRESPONDING <e> TO _wa.
      d_kind = zaplink_connectors=>get_typekind( _wa-elem_type ).
      SELECT SINGLE devclass
        INTO _wa-td_pack
        FROM tadir
        WHERE pgmid = d_kind
          AND object = _wa-elem_type
          AND obj_name = _wa-elem_key.
      IF sy-subrc <> 0.
        CONTINUE.
      ENDIF.
      IF _wa-td_pack = _wa-elem_pack. CONTINUE. ENDIF.
      IF _wa-td_pack = '$TMP'. _wa-select = abap_true. ENDIF.
      APPEND _wa TO alv_data.
    ENDLOOP.
  ENDMETHOD.
  METHOD export_from_sap_interface.
    DATA sap_obj   TYPE REF TO if_package_interface.
    DATA name       TYPE td_interface.
    DATA o_list     TYPE to_list.
    TRY.
        CHECK component->get_type( ) = st_interface.
        name = component->get_name( ).
        CREATE OBJECT o_list.
        component->set_subcomponents( o_list ).
        sap_obj = load_intf( name ).
        object = conv_interface( interface = sap_obj
                             subcomponents = o_list ).
        o_list->remove( component ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_from_sap_package.
    DATA sap_obj    TYPE REF TO if_package.
    DATA devclass   TYPE devclass.
    DATA o_list     TYPE to_list.
    DATA f_subcomp  TYPE td_with_subcomp.
    TRY.
        CHECK component->get_type( ) = st_package.
        f_subcomp = component->get_with_subcomp( ).
        devclass = component->get_name( ).
        CREATE OBJECT o_list.
        component->set_subcomponents( o_list ).
        sap_obj = load_devc( devclass ).
        object = conv_package( package = sap_obj
                          with_subcomp = f_subcomp
                         subcomponents = o_list ).
        o_list->remove( component ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_to_sap_interface.
    TRY.
        CREATE OBJECT components.
        create_interface( overwrite = 'X'
                          interface = o_data
                         components = components ).
        set_interface_attrib( interface = o_data ).
        application_log->raise_on_error( ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_to_sap_package.
    TRY.
        CREATE OBJECT components.
        create_package( overwrite = 'X'
                          package = o_data
                       components = components ).
        set_package_attrib( package = o_data ).
        application_log->raise_on_error( ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD load_devc.
    CALL METHOD cl_package=>if_package~load_package
      EXPORTING
        i_package_name             = key
        i_force_reload             = 'X'
      IMPORTING
        e_package                  = obj
      EXCEPTIONS
        object_not_existing        = 1
        unexpected_error           = 2
        intern_err                 = 3
        object_locked_and_modified = 4
        OTHERS                     = 5.
    IF sy-subrc <> 0.
      CLEAR obj.
      CASE sy-subrc.
        WHEN OTHERS.
          SET EXTENDED CHECK OFF.
          IF 1 = 2. MESSAGE e008 WITH space. ENDIF.
          SET EXTENDED CHECK ON.
          application_log->add_warning( id_msgno = 008
                       id_msgv1 = 'ZAPLINK_PACKAGE'
                       id_msgv2 = 'LOAD_DEVC' ).
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid = zaplink_cx_connector=>system_error.
      ENDCASE.
    ENDIF.
  ENDMETHOD.
  METHOD load_intf.
    CALL METHOD cl_package_interface=>if_package_interface~load_package_interface
      EXPORTING
        i_package_interface_name   = key
        i_force_reload             = 'X'
      IMPORTING
        e_package_interface        = obj
      EXCEPTIONS
        db_read_error              = 1
        unexpected_error           = 2
        object_not_existing        = 3
        shorttext_not_existing     = 4
        object_locked_and_modified = 5
        OTHERS                     = 6.
    IF sy-subrc <> 0.
      CLEAR obj.
      CASE sy-subrc.
        WHEN OTHERS.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid = zaplink_cx_connector=>system_error.
      ENDCASE.
    ENDIF.
  ENDMETHOD.
  METHOD set_interface_attrib.
    DATA name       TYPE scomifnam.
    DATA csubrc     TYPE string.
    DATA transport_request  TYPE  e070-trkorr.
    name = interface->a0_maindata-intf_name.
    SET EXTENDED CHECK OFF.
    IF 1 = 2. MESSAGE i014 WITH space. ENDIF.
    SET EXTENDED CHECK ON.
    application_log->add_info( id_msgno = 014
                               id_msgv1 = name ).
    IF NOT interface->if IS BOUND.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE a016 WITH space space space. ENDIF.
      SET EXTENDED CHECK ON.
      application_log->add_abend( id_msgno = 016
                                  id_msgv1 = 'ZAPLINK_PACKAGE'
                                  id_msgv2 = 'SET_INTERFACE_ATTRIB'
                                  id_msgv3 = 'interface->if'
                              id_probclass = '1' ).
      EXIT.
    ENDIF.
    IF NOT interface->acls IS INITIAL.
      CALL METHOD interface->if->add_access_control_elements
        EXPORTING
          i_user_list            = interface->acls
        EXCEPTIONS
          no_acl                 = 1
          entry_already_existing = 2
          object_not_changeable  = 3
          object_invalid         = 4
          local_package          = 5
          intern_err             = 6
          OTHERS                 = 7.
      IF sy-subrc <> 0.
        csubrc = sy-subrc.
        SET EXTENDED CHECK OFF.
        IF 1 = 2. MESSAGE e017 WITH space space space space. ENDIF.
        SET EXTENDED CHECK ON.
        application_log->add_error( id_msgno = 017
                                    id_msgv1 = 'ZAPLINK_PACKAGE'
                                    id_msgv2 = 'SET_INTERFACE_ATTRIB'
                                    id_msgv3 = 'add_access_control_elements'
                                    id_msgv4 = csubrc ).
      ENDIF.
    ENDIF.
    TRY.
        CALL METHOD add_elements_list
          EXPORTING
            interface  = interface
            ask_user   = abap_true
            add_remain = abap_true.
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
    CALL METHOD interface->if->save
      EXPORTING
        i_transport_request   = transport_request
      IMPORTING
        e_transport_request   = transport_request
      EXCEPTIONS
        object_invalid        = 1
        object_not_changeable = 2
        cancelled_in_corr     = 3
        permission_failure    = 4
        unexpected_error      = 5
        intern_err            = 6
        OTHERS                = 7.
    IF sy-subrc <> 0.
      o_mycx ?= zaplink_cx=>create_from_method_cx( class = interface->if
                                                  method = 'SAVE'
                                                   subrc = sy-subrc
                                            cx_classname = 'ZAPLINK_CX_CONNECTOR' ).
      RAISE EXCEPTION o_mycx.
    ENDIF.
  ENDMETHOD.
  METHOD set_package_attrib.
    DATA name       TYPE scomifnam.
    DATA csubrc     TYPE string.
    DATA o_intf     TYPE to_interface.
    DATA o_package  TYPE to_package.
    FIELD-SYMBOLS:
      <a> LIKE LINE OF package->acls,
      <p> LIKE LINE OF package->packages,
      <i> LIKE LINE OF package->interfaces.
    name = package->a0_maindata-devclass.
    SET EXTENDED CHECK OFF.
    IF 1 = 2. MESSAGE e015 WITH space. ENDIF.
    SET EXTENDED CHECK ON.
    application_log->add_info( id_msgno = 015
                               id_msgv1 = name ).
    IF NOT package->if IS BOUND.
      SET EXTENDED CHECK OFF.
      IF 1 = 2. MESSAGE e016 WITH space space space. ENDIF.
      SET EXTENDED CHECK ON.
      application_log->add_abend( id_msgno = 016
                                  id_msgv1 = 'ZAPLINK_PACKAGE'
                                  id_msgv2 = 'SET_PACKAGE_ATTRIB'
                                  id_msgv3 = 'package->if'
                                  id_probclass = '1' ).
      EXIT.
    ENDIF.
    LOOP AT package->acls ASSIGNING <a>.
      CALL METHOD package->if->add_permission_to_use
        EXPORTING
          i_pkg_permission_data   = <a>
        EXCEPTIONS
          object_not_changeable   = 1
          object_access_error     = 2
          object_already_existing = 3
          object_invalid          = 4
          unexpected_error        = 5
          OTHERS                  = 6.
      IF sy-subrc <> 0.
        csubrc = sy-subrc.
        SET EXTENDED CHECK OFF.
        IF 1 = 2. MESSAGE e017 WITH space space space space. ENDIF.
        SET EXTENDED CHECK ON.
        application_log->add_error( id_msgno = 017
                                    id_msgv1 = 'ZAPLINK_PACKAGE'
                                    id_msgv2 = 'SET_PACKAGE_ATTRIB'
                                    id_msgv3 = 'add_permission_to_use'
                                    id_msgv4 = csubrc ).
      ENDIF.
    ENDLOOP.
    LOOP AT package->interfaces ASSIGNING <i>.
      TRY.
          o_intf ?= <i>-zl_object->raw.
          CALL METHOD set_interface_attrib
            EXPORTING
              interface = o_intf.
        CATCH zaplink_cx_connector INTO o_mycx.
          RAISE EXCEPTION o_mycx.
      ENDTRY.
    ENDLOOP.
    LOOP AT package->packages ASSIGNING <p>.
      TRY.
          o_package ?= <p>-zl_object->raw.
          CALL METHOD set_package_attrib
            EXPORTING
              package = o_package.
        CATCH zaplink_cx_connector INTO o_mycx.
          RAISE EXCEPTION o_mycx.
      ENDTRY.
    ENDLOOP.
  ENDMETHOD.
  METHOD update_interface.
    DATA _data      TYPE scompidtln.
    DATA _data_f    TYPE scompisign.
    _data = data.
    IF NOT interface IS BOUND.        " Issue 106 : Check if interface exists
      CALL METHOD cl_package_interface=>if_package_interface~load_package_interface
        EXPORTING
          i_package_interface_name   = data-intf_name
        IMPORTING
          e_package_interface        = interface
        EXCEPTIONS
          db_read_error              = 1
          object_locked_and_modified = 2
          object_not_existing        = 0
          shorttext_not_existing     = 4
          unexpected_error           = 5
          OTHERS                     = 6.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( subrc = sy-subrc
                                                class_name = 'CL_PACKAGE_INTERFACE'
                                                    method = 'IF_PACKAGE_INTERFACE~LOAD_PACKAGE_INTERFACE'
                                              cx_classname = 'ZAPLINK_CX_CONNECTOR').
        RAISE EXCEPTION o_mycx.
      ENDIF.
    ENDIF.
    IF interface IS BOUND.
      _data_f = sy-uline.
      CALL METHOD interface->set_changeable
        EXPORTING
          i_changeable                = 'X'
        EXCEPTIONS
          object_already_changeable   = 0
          object_already_unlocked     = 0
          object_deleted              = 3
          object_invalid              = 4
          object_just_created         = 5
          object_locked_by_other_user = 6
          object_modified             = 7
          object_not_existing         = 8
          permission_failure          = 9
          unexpected_error            = 10
          OTHERS                      = 11.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( subrc = sy-subrc
                                                     class = interface
                                                    method = 'set_changeable'
                                              cx_classname = 'ZAPLINK_CX_CONNECTOR').
        RAISE EXCEPTION o_mycx.
      ENDIF.
      CALL METHOD interface->set_all_attributes
        EXPORTING
          i_package_interface_data = _data
          i_data_sign              = _data_f
        EXCEPTIONS
          acl_not_empty            = 1
          author_not_existing      = 2
          interface_not_empty      = 3
          object_deleted           = 4
          object_invalid           = 5
          object_not_changeable    = 6
          object_type_mismatch     = 7
          OTHERS                   = 8.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( subrc = sy-subrc
                                                     class = interface
                                                    method = 'set_all_attributes'
                                              cx_classname = 'ZAPLINK_CX_CONNECTOR').
        RAISE EXCEPTION o_mycx.
      ENDIF.
    ELSE.
      CALL METHOD cl_package_interface=>if_package_interface~create_new_package_interface
        EXPORTING
          i_pkg_interface_name    = _data-intf_name
          i_publisher_pkg_name    = _data-pack_name
          i_pkg_interface_data    = _data
        IMPORTING
          e_package_interface     = interface
        EXCEPTIONS
          interface_name_invalid  = 1
          no_changes_allowed      = 2
          object_already_existing = 3
          object_just_created     = 4
          unexpected_error        = 5
          OTHERS                  = 6.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( class_name = 'cl_package_interface'
                                                         method = 'if_package_interface~create_new_package_interface'
                                                          subrc = sy-subrc
                                                   cx_classname = 'ZAPLINK_CX_CONNECTOR').
        RAISE EXCEPTION o_mycx.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD update_package.
    DATA _data      TYPE scompkdtln.
    DATA _data_f    TYPE scompksign.
    _data = data.
    IF NOT package IS BOUND.        " Issue 106 : Check if package exists
      CALL METHOD cl_package=>if_package~load_package
        EXPORTING
          i_package_name             = data-devclass
        IMPORTING
          e_package                  = package
        EXCEPTIONS
          intern_err                 = 1
          object_locked_and_modified = 2
          object_not_existing        = 0
          unexpected_error           = 4
          OTHERS                     = 5.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( subrc = sy-subrc
                                                class_name = 'CL_PACKAGE'
                                                    method = 'if_package~load_package'
                                              cx_classname = 'ZAPLINK_CX_CONNECTOR').
        RAISE EXCEPTION o_mycx.
      ENDIF.
    ENDIF.
    IF package IS BOUND.
      _data_f = sy-uline.
      CALL METHOD package->set_changeable
        EXPORTING
          i_changeable                = 'X'
        EXCEPTIONS
          object_already_changeable   = 0
          object_already_unlocked     = 0
          object_deleted              = 3
          object_invalid              = 4
          object_just_created         = 5
          object_locked_by_other_user = 6
          object_modified             = 7
          object_not_existing         = 8
          permission_failure          = 9
          unexpected_error            = 10
          OTHERS                      = 11.
      IF sy-subrc <> 0.
        o_mycx ?= zaplink_cx=>create_from_method_cx( subrc = sy-subrc
                                                     class = package
                                                    method = 'set_changeable'
                                              cx_classname = 'ZAPLINK_CX_CONNECTOR').
        RAISE EXCEPTION o_mycx.
      ENDIF.
      CALL METHOD package->set_all_attributes
        EXPORTING
          i_package_data             = _data
          i_data_sign                = _data_f
        EXCEPTIONS
          authorize_failure          = 1
          author_not_existing        = 99
          component_not_existing     = 3
          component_missing          = 4
          intern_err                 = 5
          korrflag_invalid           = 6
          layer_invalid              = 7
          local_package              = 8
          object_deleted             = 9
          object_invalid             = 10
          object_not_changeable      = 11
          prefix_in_use              = 12
          short_text_missing         = 13
          software_component_invalid = 14
          unexpected_error           = 15
          OTHERS                     = 16.
      IF sy-subrc <> 0 AND sy-subrc <> 99.
        o_mycx ?= zaplink_cx=>create_from_method_cx( subrc = sy-subrc
                                                     class = package
                                                    method = 'set_all_attributes'
                                              cx_classname = 'ZAPLINK_CX_CONNECTOR').
        RAISE EXCEPTION o_mycx.
      ENDIF.
    ELSE.
      CALL METHOD cl_package=>if_package~create_new_package
        IMPORTING
          e_package                  = package
        CHANGING
          c_package_data             = _data
        EXCEPTIONS
          author_not_existing        = 99
          component_not_existing     = 2
          component_missing          = 3
          intern_err                 = 4
          invalid_package_name       = 5
          layer_invalid              = 6
          not_authorized             = 7
          object_already_existing    = 8
          object_just_created        = 9
          prefix_in_use              = 10
          reserved_local_name        = 11
          short_text_missing         = 12
          software_component_invalid = 13
          undefined_name             = 14
          unexpected_error           = 15
          wrong_name_prefix          = 16
          OTHERS                     = 17.
      IF sy-subrc <> 0 AND sy-subrc <> 99.
        o_mycx ?= zaplink_cx=>create_from_method_cx( subrc = sy-subrc
                                                class_name = 'CL_PACKAGE'
                                                    method = 'if_package~create_new_package'
                                              cx_classname = 'ZAPLINK_CX_CONNECTOR').
        RAISE EXCEPTION o_mycx.
      ENDIF.
    ENDIF.
    IF sy-subrc = 99 AND _data-as4user <> sy-uname.         "#EC *
      _data-as4user = sy-uname.
      CALL METHOD update_package
        EXPORTING
          data    = _data
        CHANGING
          package = package.
    ENDIF.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~anonymize.
    DATA o_package   TYPE to_package.
    DATA o_interface TYPE to_interface.
    CHECK object IS BOUND.
    CASE object->type.
      WHEN st_package.
        o_package ?= object->raw.
        o_package->anonymize( ).
      WHEN st_interface.
        o_interface ?= object->raw.
        o_interface->anonymize( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name object->type.
    ENDCASE.
    TRY.
        super->zaplink_cnx_ext_cleaner~anonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~unanonymize.
    DATA o_package   TYPE to_package.
    DATA o_interface TYPE to_interface.
    TRY.
        super->zaplink_cnx_ext_cleaner~unanonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
    CASE object->type.
      WHEN st_package.
        o_package ?= object->raw.
        o_package->unanonymize( ).
      WHEN st_interface.
        o_interface ?= object->raw.
        o_interface->unanonymize( ).
      WHEN OTHERS.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_devc   TYPE to_package.
    DATA o_pinf   TYPE to_interface.
    DATA o_raw_i  TYPE to_raw_interface.
    DATA o_raw_p  TYPE to_raw_package.
    CASE type.
      WHEN st_package.
        CREATE OBJECT o_raw_p.
        object = o_raw_p.
        CREATE OBJECT o_devc.
        object->raw = o_devc.
      WHEN st_interface.
        CREATE OBJECT o_raw_i.
        object = o_raw_i.
        CREATE OBJECT o_pinf.
        object->raw = o_pinf.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA key_devc   TYPE devclass.
    DATA key_intf   TYPE scomifnam.
    DATA package    TYPE REF TO if_package.
    DATA interface  TYPE REF TO if_package_interface.
    DATA d_type     TYPE td_comptype.
    DATA d_name     TYPE td_compname.
    TRY.
        d_type = component->get_type( ).
        d_name = component->get_name( ).
        CASE d_type.
          WHEN st_package.
            key_devc = d_name.
            TRY.
                package = load_devc( key_devc ).
                _delete_devc( package ).
              CATCH zaplink_cx_connector INTO o_mycx.
                IF NOT o_mycx->messages IS BOUND.
                  o_mycx->messages = application_log.
                  o_mycx->update( ).
                ENDIF.
                RAISE EXCEPTION o_mycx.
            ENDTRY.
          WHEN st_interface.
            key_intf = d_name.
            TRY.
                interface = load_intf( key_intf ).
                _delete_intf( interface ).
              CATCH zaplink_cx_connector INTO o_mycx.
                IF NOT o_mycx->messages IS BOUND.
                  o_mycx->messages = application_log.
                  o_mycx->update( ).
                ENDIF.
                RAISE EXCEPTION o_mycx.
            ENDTRY.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    result = abap_true.
    zaplink_tools=>remove_comp_from_working_area( type = d_type
                                                  name = d_name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA key   TYPE scomifnam.
    DATA _devc TYPE REF TO if_package.            "#EC NEEDED for debug
    DATA _pinf TYPE REF TO if_package_interface.  "#EC NEEDED for debug
    DATA type  TYPE td_comptype.
    TRY.
        key = component->get_name( ).
        type = component->get_type( ).
        CASE type.
          WHEN st_package.
            CALL METHOD cl_package=>if_package~load_package
              EXPORTING
                i_package_name             = key
                i_force_reload             = 'X'
              IMPORTING
                e_package                  = _devc
              EXCEPTIONS
                object_not_existing        = 1
                object_locked_and_modified = 0.
            IF sy-subrc = 0.
              exists = 'X'.
            ENDIF.
          WHEN st_interface.
            CALL METHOD cl_package_interface=>if_package_interface~load_package_interface
              EXPORTING
                i_package_interface_name   = key
                i_force_reload             = 'X'
              IMPORTING
                e_package_interface        = _pinf
              EXCEPTIONS
                object_not_existing        = 3
                shorttext_not_existing     = 0
                object_locked_and_modified = 0.
            IF sy-subrc = 0.
              exists = 'X'.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.
      result = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    DATA o_package   TYPE to_package.
    DATA o_interface TYPE to_interface.
    DATA type  TYPE td_comptype.
    TRY.
        CREATE OBJECT object.
        object->set_component( component ).
        type = component->get_type( ).
        CASE type.
          WHEN st_package.
            TRY.
                o_package = export_from_sap_package( component ).
              CATCH zaplink_cx_connector INTO o_mycx.
                IF NOT o_mycx->messages IS BOUND.
                  o_mycx->messages = application_log.
                  o_mycx->update( ).
                ENDIF.
                RAISE EXCEPTION o_mycx.
            ENDTRY.
            CLEAR o_package->a0_maindata-devclass.
            object->raw = o_package.
          WHEN st_interface.
            TRY.
                o_interface = export_from_sap_interface( component ).
              CATCH zaplink_cx_connector INTO o_mycx.
                IF NOT o_mycx->messages IS BOUND.
                  o_mycx->messages = application_log.
                  o_mycx->update( ).
                ENDIF.
                RAISE EXCEPTION o_mycx.
            ENDTRY.
            CLEAR o_interface->a0_maindata-intf_name.
            object->raw = o_interface.
          WHEN OTHERS.
            CLEAR object.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        object->update_connector_data( me ).                    " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    DATA _o_class       TYPE to_package.
    DATA _o_interface   TYPE to_interface.
    DATA o_comp         TYPE to_component.                    " Issue 92
    TRY.
        CREATE OBJECT components. " Issue 92
        CASE object->type.
          WHEN st_package.
            _o_class ?= object->raw.
            _o_class->a0_maindata-devclass = object->name.
            TRY.
                components = import_to_sap_package( _o_class ).
              CATCH zaplink_cx_connector INTO o_mycx.
                IF NOT o_mycx->messages IS BOUND.
                  o_mycx->messages = application_log.
                  o_mycx->update( ).
                ENDIF.
                RAISE EXCEPTION o_mycx.
            ENDTRY.
          WHEN st_interface.
            _o_interface ?= object->raw.
            _o_interface->a0_maindata-intf_name = object->name.
            TRY.
                components = import_to_sap_interface( _o_interface ).
              CATCH zaplink_cx_connector INTO o_mycx.
                IF NOT o_mycx->messages IS BOUND.
                  o_mycx->messages = application_log.
                  o_mycx->update( ).
                ENDIF.
                RAISE EXCEPTION o_mycx.
            ENDTRY.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name object->type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ). " Issue 92
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD _delete_devc.
    DATA interfaces  TYPE tpak_package_interface_list.
    DATA packages    TYPE scompaklis.
    DATA cx_name     TYPE string.
    FIELD-SYMBOLS:
      <pack> LIKE LINE OF packages,
      <itf>  LIKE LINE OF interfaces.
    CALL METHOD package->set_changeable
      EXPORTING
        i_changeable                = 'X'
      EXCEPTIONS
        object_locked_by_other_user = 1
        permission_failure          = 2
        object_already_changeable   = 0
        object_already_unlocked     = 0
        object_just_created         = 5
        object_deleted              = 6
        object_modified             = 7
        object_not_existing         = 8
        object_invalid              = 9
        unexpected_error            = 10
        OTHERS                      = 11.
    IF sy-subrc <> 0.
      CASE sy-subrc.
        WHEN OTHERS.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid = zaplink_cx_connector=>system_error.
      ENDCASE.
    ENDIF.
    CALL METHOD package->get_interfaces
      IMPORTING
        e_package_interfaces = interfaces
      EXCEPTIONS
        object_invalid       = 1
        unexpected_error     = 2
        intern_err           = 3
        OTHERS               = 4.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          textid = zaplink_cx_connector=>system_error.
    ELSEIF NOT interfaces IS INITIAL.
      LOOP AT interfaces ASSIGNING <itf>.
        TRY.
            _delete_intf( <itf> ).
          CATCH zaplink_cx_connector INTO o_mycx.
            RAISE EXCEPTION o_mycx.
        ENDTRY.
      ENDLOOP.
    ENDIF.
    CALL METHOD package->get_sub_packages
      IMPORTING
        e_sub_packages   = packages
      EXCEPTIONS
        object_invalid   = 1
        leaf_package     = 0   " has no sub packages
        unexpected_error = 3
        OTHERS           = 4.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          textid = zaplink_cx_connector=>system_error.
    ELSEIF NOT packages IS INITIAL.
      LOOP AT packages ASSIGNING <pack>.
        TRY.
            _delete_devc( <pack> ).
          CATCH zaplink_cx_connector INTO o_mycx.
            RAISE EXCEPTION o_mycx.
        ENDTRY.
      ENDLOOP.
    ENDIF.
    _delete_elements( package ). " try to delete TADIR entries that prevent package deletion
    CALL METHOD package->delete
      EXCEPTIONS
        object_not_empty      = 1
        object_not_changeable = 2
        object_invalid        = 3
        intern_err            = 4
        OTHERS                = 5.
    IF sy-subrc <> 0.
      CALL METHOD application_log->add_symsg( ).
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4
              INTO cx_name.
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          cx_name = cx_name
          textid  = zaplink_cx_connector=>system_error.
    ENDIF.
    CALL METHOD package->save
      EXPORTING
        i_transport_request   = space
      EXCEPTIONS
        object_invalid        = 1
        object_not_changeable = 2
        cancelled_in_corr     = 3
        permission_failure    = 4
        unexpected_error      = 5
        intern_err            = 6
        OTHERS                = 7.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          textid = zaplink_cx_connector=>system_error.
    ENDIF.
  ENDMETHOD.
  METHOD _delete_elements.
    DATA t_elements TYPE pakdevelemtab.
    DATA f_errors   TYPE abap_bool.
    DATA d_name     TYPE tadir-obj_name.
    DATA s_tadir    TYPE tadir.
    DATA f_exists   TYPE saus_dpara-tadirexist.
    FIELD-SYMBOLS:
      <e> LIKE LINE OF t_elements.
    f_errors = abap_false.
    CALL METHOD package->get_elements
      IMPORTING
        e_elements = t_elements.
    LOOP AT t_elements ASSIGNING <e>.
      IF <e>->dev_elem_type = st_package.   " do not try to remove DEVC
        DELETE t_elements.
        CONTINUE.
      ENDIF.
      d_name = <e>->dev_elem_key.
      CALL FUNCTION 'TRINT_TADIR_DELETE'
        EXPORTING
          object                   = <e>->dev_elem_type
          obj_name                 = d_name
          pgmid                    = <e>->dev_elem_pgmid
          iv_test_mode             = abap_true
        EXCEPTIONS
          tadir_entry_not_existing = 1
          object_exists            = 2
          object_locked            = 3
          object_distributed       = 4
          OTHERS                   = 5.
      IF sy-subrc <> 0.
        CASE sy-subrc.
          WHEN 2 OR 3.
            CALL METHOD application_log->add_symsg( ).
            SET EXTENDED CHECK OFF.
            IF 1 = 2. MESSAGE i020(zaplink_package) WITH <e>->dev_elem_pgmid <e>->dev_elem_type d_name. ENDIF.
            SET EXTENDED CHECK ON.
            CALL METHOD application_log->add
              EXPORTING
                id_msgty = 'I'
                id_msgid = 'ZAPLINK_PACKAGE'
                id_msgno = '020'
                id_msgv1 = <e>->dev_elem_pgmid
                id_msgv2 = <e>->dev_elem_type
                id_msgv3 = d_name.
          WHEN OTHERS.
            CALL METHOD application_log->add_symsg( ).
        ENDCASE.
        f_errors = abap_true.
      ENDIF.
    ENDLOOP.
    IF f_errors = abap_false.
      LOOP AT t_elements ASSIGNING <e>.
        d_name = <e>->dev_elem_key.
        CALL FUNCTION 'TRINT_TADIR_QUERY'
          EXPORTING
            iv_pgmid     = <e>->dev_elem_pgmid
            iv_object    = <e>->dev_elem_type
            iv_obj_name  = d_name
          IMPORTING
            ev_srcsystem = s_tadir-srcsystem
            ev_author    = s_tadir-author
            ev_genflag   = s_tadir-genflag
            ev_exist     = f_exists.
        CALL FUNCTION 'TRINT_TADIR_DELETE'
          EXPORTING
            object                   = <e>->dev_elem_type
            obj_name                 = d_name
            pgmid                    = <e>->dev_elem_pgmid
            iv_test_mode             = abap_false
          EXCEPTIONS
            tadir_entry_not_existing = 1
            object_exists            = 2
            object_locked            = 3
            object_distributed       = 4
            OTHERS                   = 5.
        IF sy-subrc <> 0.
          ROLLBACK WORK.
          CALL METHOD application_log->add_symsg( ).
          EXIT.
        ELSEIF NOT f_exists IS INITIAL.
          SET EXTENDED CHECK OFF.
          IF 1 = 2. MESSAGE w018(zaplink_package) WITH <e>->dev_elem_pgmid <e>->dev_elem_type d_name. ENDIF.
          SET EXTENDED CHECK ON.
          CALL METHOD application_log->add
            EXPORTING
              id_msgty = 'W'
              id_msgid = 'ZAPLINK_PACKAGE'
              id_msgno = '018'
              id_msgv1 = <e>->dev_elem_pgmid
              id_msgv2 = <e>->dev_elem_type
              id_msgv3 = d_name.
          SET EXTENDED CHECK OFF.
          IF 1 = 2. MESSAGE i019(zaplink_package) WITH <e>->dev_elem_pgmid <e>->dev_elem_type d_name. ENDIF.
          SET EXTENDED CHECK ON.
          CALL METHOD application_log->add
            EXPORTING
              id_msgty = 'I'
              id_msgid = 'ZAPLINK_PACKAGE'
              id_msgno = '019'
              id_msgv1 = s_tadir-srcsystem
              id_msgv2 = s_tadir-author
              id_msgv3 = s_tadir-genflag.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ENDMETHOD.
  METHOD _delete_intf.
    CALL METHOD interface->set_changeable
      EXPORTING
        i_changeable                = 'X'
      EXCEPTIONS
        object_locked_by_other_user = 1
        permission_failure          = 2
        object_already_changeable   = 0
        object_already_unlocked     = 0
        object_just_created         = 5
        object_deleted              = 6
        object_modified             = 7
        object_not_existing         = 8
        object_invalid              = 9
        unexpected_error            = 10
        OTHERS                      = 11.
    IF sy-subrc <> 0.
      CASE sy-subrc.
        WHEN OTHERS.
          RAISE EXCEPTION TYPE zaplink_cx_connector
            EXPORTING
              textid = zaplink_cx_connector=>system_error.
      ENDCASE.
    ENDIF.
    CALL METHOD interface->delete
      EXCEPTIONS
        object_not_empty      = 1
        object_not_changeable = 2
        object_invalid        = 3
        intern_err            = 4
        OTHERS                = 5.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          textid = zaplink_cx_connector=>system_error.
    ENDIF.
    CALL METHOD interface->save
      EXPORTING
        i_transport_request   = space
      EXCEPTIONS
        object_invalid        = 1
        object_not_changeable = 2
        cancelled_in_corr     = 3
        permission_failure    = 4
        unexpected_error      = 5
        intern_err            = 6
        OTHERS                = 7.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE zaplink_cx_connector
        EXPORTING
          textid = zaplink_cx_connector=>system_error.
    ENDIF.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_PACKAGE implementation
CLASS zaplink_program IMPLEMENTATION.
  METHOD class_constructor.
    DATA _id    LIKE LINE OF r_doc_id.
    DATA f_ok   TYPE abap_bool.
    _id-sign = 'I'.
    _id-option = 'EQ'.
    _id-low = 'CF'. APPEND _id TO r_doc_id.
    _id-low = 'CM'. APPEND _id TO r_doc_id.
    _id-low = 'RE'. APPEND _id TO r_doc_id.
    PERFORM check_vari_form_exists IN PROGRAM (sy-repid) CHANGING f_ok IF FOUND.
    IF NOT f_ok IS INITIAL.   report = sy-repid.    RETURN.   ENDIF.
    PERFORM check_vari_form_exists  CHANGING f_ok .
    IF NOT f_ok IS INITIAL.
      report = 'ZAPLINK_VARI'.    " Dump if program name is in lower case
    ENDIF.
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.    application_log->msgid = 'ZAPLINK_PROGRAM'.
    type-type = supportedtypes-program. INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-sys_variant. INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-appl_variant. INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD get_param_value.
    current_param-value = value.
  ENDMETHOD.
  METHOD get_program_signature.
    DATA t_code TYPE tt_abaprawsource.
    DATA d_src  TYPE string.
    t_code = get_prog_rawsource( program_name ).
    zaplink_tools=>pretty_printer( CHANGING table = t_code ).
    zaplink_tools=>condense_abap_source( CHANGING table = t_code ).
    d_src = zaplink_tools=>table_2_string( t_code ).
    d_src = zaplink_tools=>clean_abap_string( d_src ).
    result = zaplink_tools=>calculate_md5_hash( d_src ).
  ENDMETHOD.
  METHOD get_selectoption_value.
    DATA my_value LIKE LINE OF current_param-values.
    FIELD-SYMBOLS:
      <v> TYPE any.
    CHECK NOT value[] IS INITIAL.
    LOOP AT value ASSIGNING <v>.
      CLEAR my_value.
      MOVE-CORRESPONDING <v> TO my_value.
      APPEND my_value TO current_param-values.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_variant_params.
    DATA p_key     TYPE rsvarkey.
    DATA t_screens TYPE STANDARD TABLE OF rsscr.
    DATA t_vari    TYPE STANDARD TABLE OF rvari.
    DATA p_subrc   TYPE sy-subrc.
    DATA p_subrc_s TYPE sy-subrc.
    DATA s_subrc   TYPE string.
    DATA s_subrc_s TYPE string.
    DATA d_param   LIKE LINE OF current_param-params.
    DATA d_mandt   TYPE sy-mandt.
    TYPES tt_vdat TYPE STANDARD TABLE OF rsvarivdat.
    TYPES tt_vdyn TYPE STANDARD TABLE OF rsvaridyn.
    TYPES tt_vdd  TYPE STANDARD TABLE OF rsvdatdyn.
    FIELD-SYMBOLS:
      <vdat> TYPE tt_vdat,
      <vdyn> TYPE tt_vdyn,
      <vdd>  TYPE tt_vdd,
      <dat>  LIKE LINE OF <vdat>,
      <s>    LIKE LINE OF t_screens,
      <v>    LIKE LINE OF t_vari.
    DATA: BEGIN OF l_formname_0,
            prefix(7) VALUE '%_LINK_',
            suffix(8),
          END OF l_formname_0.
    DATA d_formname TYPE string.
    p_key-report = program.
    p_key-variant = variant.
    PERFORM import_var_selc IN PROGRAM saplsvar TABLES t_screens t_vari
                                                 USING p_key-report p_key
                                              CHANGING p_subrc p_subrc_s.
    IF NOT p_subrc_s IS INITIAL.
      IF 1 = 2.   MESSAGE i000 WITH space space space.  ENDIF.
      s_subrc = p_subrc_s.
      CALL METHOD application_log->add_error
        EXPORTING
          id_msgno = '000'
          id_msgv1 = s_subrc
          id_msgv2 = p_key-report
          id_msgv3 = p_key-variant.
      RETURN.
    ELSEIF NOT p_subrc IS INITIAL.
      IF 1 = 2.   MESSAGE i001 WITH space space space.  ENDIF.
      s_subrc = p_subrc.
      CALL METHOD application_log->add_error
        EXPORTING
          id_msgno = '001'
          id_msgv1 = s_subrc
          id_msgv2 = p_key-report
          id_msgv3 = p_key-variant.
      RETURN.
    ENDIF.
    ASSIGN ('(SAPLSVAR)varivdat[]') TO <vdat>.
    ASSIGN ('(SAPLSVAR)varidyn[]') TO <vdyn>.
    ASSIGN ('(SAPLSVAR)varivdat_dyn[]') TO <vdd>.
    IF variant CP zaplink_vari_data=>variant_prefix-system OR variant CP zaplink_vari_data=>variant_prefix-customer.    d_mandt = '000'.    ELSE.   d_mandt = sy-mandt.    ENDIF.
    PERFORM %_import_vari_clnt IN PROGRAM (p_key-report)
                               USING p_key p_subrc_s d_mandt
                               CHANGING p_subrc
                               IF FOUND.
    IF NOT p_subrc IS INITIAL OR NOT p_subrc_s IS INITIAL.
      IF 1 = 2.   MESSAGE i002 WITH space space space space.  ENDIF.
      s_subrc = p_subrc.
      s_subrc_s = p_subrc_s.
      CALL METHOD application_log->add_error
        EXPORTING
          id_msgno = '002'
          id_msgv1 = s_subrc_s
          id_msgv2 = s_subrc
          id_msgv3 = p_key-report
          id_msgv4 = p_key-variant.
      RETURN.
    ENDIF.
    PERFORM set_object  USING me .
    LOOP AT t_vari ASSIGNING <v>.
      CLEAR current_param.
      MOVE-CORRESPONDING <v> TO current_param.
      IF <v>-xflag1 O flags-varid-noimp.      current_param-no_import = abap_true.    ENDIF.
      IF <v>-xflag1 O flags-vari-obli.        current_param-obli = abap_true.         ENDIF.
      IF <v>-xflag1 O flags-vari-noint.       current_param-noint = abap_true.        ENDIF.
      IF <v>-xflag1 Z flags-vari-nospagpa.
        READ TABLE t_screens ASSIGNING <s> WITH KEY name = <v>-name.
        IF sy-subrc = 0 AND <s>-spagpa NE space.    current_param-spagpa = abap_true.   ENDIF.
      ENDIF.
      MOVE <v>-name TO l_formname_0-suffix.
      CONCATENATE 'GET_VAL_' <v>-kind INTO d_formname.
      IF 1 = 2.                                             "#EC *
        PERFORM get_val_p  USING space space space .        "#EC *
      ENDIF.
      PERFORM (l_formname_0) IN PROGRAM (p_key-report)
             USING 'ZAPLINK_VARI' d_formname p_subrc IF FOUND.
      LOOP AT <vdat> ASSIGNING <dat>
           WHERE selname = <v>-name.
        MOVE-CORRESPONDING <dat> TO d_param.
        APPEND d_param TO current_param-params.
      ENDLOOP.
      IF current_param-no_import = abap_true.   CLEAR: current_param-value, current_param-values, current_param-params.    ENDIF.
      INSERT current_param INTO TABLE result.
    ENDLOOP.
    PERFORM clear_object  USING me.
  ENDMETHOD.
  METHOD read_variants.
    DATA t_dynnr     TYPE STANDARD TABLE OF rsdynnr WITH DEFAULT KEY.
    DATA t_varis     TYPE STANDARD TABLE OF rsdynnr WITH DEFAULT KEY.
    DATA t_varit     TYPE STANDARD TABLE OF varit WITH DEFAULT KEY.
    DATA s_vari      LIKE LINE OF result.
    DATA s_varis     LIKE LINE OF t_varis.
    FIELD-SYMBOLS:
      <v> LIKE LINE OF variants,
      <t> LIKE LINE OF t_varit,
      <s> LIKE LINE OF t_varis.
    SELECT * INTO TABLE t_varit
      FROM varit CLIENT SPECIFIED
      FOR ALL ENTRIES IN variants
      WHERE mandt = variants-mandt
        AND report = variants-report
        AND variant = variants-variant.
    LOOP AT variants ASSIGNING <v>.
      CLEAR s_vari.   s_vari-header = <v>.
      LOOP AT t_varit ASSIGNING <t>
           WHERE mandt = <v>-mandt
            AND report = <v>-report
           AND variant = <v>-variant.
        INSERT <t> INTO TABLE s_vari-texts.
      ENDLOOP.
      CALL FUNCTION 'RS_GET_SCREENS_4_1_VARIANT'
        EXPORTING
          program              = <v>-report
          variant              = <v>-variant
        TABLES
          dynnr                = t_dynnr
          variscreens          = t_varis
        EXCEPTIONS
          no_screens           = 1
          variant_not_existent = 2
          OTHERS               = 3.
      IF sy-subrc <> 0.
        mac_add_mf_and_raise 'RS_GET_SCREENS_4_1_VARIANT' sy-subrc.
      ENDIF.
      DELETE t_varis WHERE dynnr = '*'.   " only one screen
      MODIFY t_varis FROM s_varis TRANSPORTING kind WHERE NOT kind IS INITIAL.    " not used on import
      s_vari-screens = t_varis.
      s_vari-params = get_variant_params( program = <v>-report   variant = <v>-variant ).
      INSERT s_vari INTO TABLE result.
    ENDLOOP.
  ENDMETHOD.
  METHOD set_param_value.
    value = current_param-value.
  ENDMETHOD.
  METHOD set_selectoption_value.
    value = current_param-values.
  ENDMETHOD.
  METHOD set_variant_params.
    TYPES tt_vdat TYPE STANDARD TABLE OF rsvarivdat.
    TYPES tt_vdyn TYPE STANDARD TABLE OF rsvaridyn.
    TYPES tt_vdd  TYPE STANDARD TABLE OF rsvdatdyn.
    DATA p_key     TYPE rsvarkey.
    DATA t_screens TYPE STANDARD TABLE OF rsscr.
    DATA t_vari    TYPE STANDARD TABLE OF rvari.
    DATA p_subrc   TYPE sy-subrc.
    DATA p_subrc_s TYPE sy-subrc.
    DATA d_param   LIKE LINE OF current_param-params.
    DATA t_dyns_fields TYPE STANDARD TABLE OF rsdsfields WITH DEFAULT KEY.
    DATA t_varivdat TYPE tt_vdat.
    DATA t_varidyn TYPE tt_vdyn.
    DATA t_vdatdyn TYPE tt_vdd.
    DATA t_texpr   TYPE rsds_texpr.
    DATA s_vdat    LIKE LINE OF t_varivdat.
    DATA: BEGIN OF imex,
            vari,
            dyns,
          END   OF imex.
    FIELD-SYMBOLS:
      <s> LIKE LINE OF t_vari,
      <p> LIKE LINE OF current_param-params,
      <v> LIKE LINE OF data.
    DATA: BEGIN OF l_formname_0,
            prefix(7) VALUE '%_LINK_',
            suffix(8),
          END OF l_formname_0.
    DATA d_formname TYPE string.
    p_key-report = program.
    p_key-variant = variant.
    result = abap_true.
    PERFORM import_var_selc IN PROGRAM saplsvar TABLES t_screens t_vari
                                                 USING p_key-report p_key
                                              CHANGING p_subrc p_subrc_s.
    PERFORM set_object IN PROGRAM (report) USING me IF FOUND.   " for installer
    IF 1 = 2.   PERFORM set_object  USING me .  ENDIF.
    LOOP AT data INTO current_param.
      READ TABLE t_vari ASSIGNING <s> WITH KEY name = current_param-name.    " BINARY SEARCH.
      CHECK sy-subrc = 0.   " Else ignore field value
      <s>-vtype = current_param-vtype.    <s>-vname = current_param-vname.
      <s>-appendage = current_param-appendage.    <s>-invisible = current_param-invisible.    <s>-protected = current_param-protected.
      IF current_param-spagpa = abap_true.    <s>-xflag1 = <s>-xflag1 BIT-AND flags-vari-spagpa.    ELSE.   <s>-xflag1 = <s>-xflag1 BIT-OR flags-vari-nospagpa.   ENDIF.
      IF current_param-obli = abap_true.      <s>-xflag1 = <s>-xflag1 BIT-OR flags-vari-obli.       ELSE.   <s>-xflag1 = <s>-xflag1 BIT-AND flags-vari-no_obli.   ENDIF.
      IF current_param-no_import = abap_true. <s>-xflag1 = <s>-xflag1 BIT-OR flags-varid-noimp.     ELSE.   <s>-xflag1 = <s>-xflag1 BIT-AND flags-varid-imp.      ENDIF.
      IF current_param-noint = abap_true.     <s>-xflag1 = <s>-xflag1 BIT-OR flags-vari-noint.      ELSE.   <s>-xflag1 = <s>-xflag1 BIT-AND flags-vari-int.       ENDIF.
      MOVE <s>-name TO l_formname_0-suffix.
      CONCATENATE 'SET_VAL_' <s>-kind INTO d_formname.
      IF 1 = 2.                                             "#EC *
        PERFORM set_val_p  USING space space space .        "#EC *
      ENDIF.
      PERFORM (l_formname_0) IN PROGRAM (p_key-report)
             USING report d_formname p_subrc IF FOUND.
      IF p_subrc <> 0.    result = abap_false.    ENDIF.
      LOOP AT current_param-params ASSIGNING <p>.
        CLEAR s_vdat.   MOVE-CORRESPONDING <p> TO s_vdat.   s_vdat-selname = current_param-name.
        APPEND s_vdat TO t_varivdat.
      ENDLOOP.
    ENDLOOP.
    PERFORM clear_object IN PROGRAM (report) USING me IF FOUND.   " for installer
    IF 1 = 2.   PERFORM clear_object  USING me .   ENDIF.
    PERFORM export_variant_static IN PROGRAM rsdbspvd TABLES   t_dyns_fields
                                                       USING   t_vari
                                                               t_varivdat
                                                               t_varidyn
                                                               t_vdatdyn
                                                               t_texpr imex
                                                               p_key
                                                               p_subrc.
    IF p_subrc <> 0.    result = abap_false.    ENDIF.
    PERFORM export_%_vari IN PROGRAM saplsvar USING p_key-report
                                                    p_key
                                                    sy-mandt
                                                    space.    " FLAG_NOIMPORT.
  ENDMETHOD.
  METHOD write_variants.
    DATA t_varis     TYPE STANDARD TABLE OF rsdynnr WITH DEFAULT KEY.
    DATA t_varit     TYPE STANDARD TABLE OF varit WITH DEFAULT KEY.
    DATA t_params    TYPE STANDARD TABLE OF rsparams WITH DEFAULT KEY.
    DATA s_param     LIKE LINE OF t_params.
    DATA d_subrc     TYPE sy-subrc.
    DATA d_is_work_i  TYPE abap_bool.
    DATA d_is_inactiv TYPE abap_bool.
    DATA d_obj_name   TYPE e071-obj_name.
    DATA t_variants   TYPE tt_variants.
    DATA f_ok         TYPE abap_bool.
    DATA o_activate   TYPE REF TO zaplink_activate.
    DATA t_comps      TYPE zaplink_list=>tt_compkeys.
    DATA s_comp       LIKE LINE OF t_comps.
    FIELD-SYMBOLS:
      <v>   LIKE LINE OF variants,
      <p>   LIKE LINE OF <v>-params,
      <val> LIKE LINE OF <p>-values.
    t_variants = variants.    SORT t_variants.    s_comp-type = 'PROG'.
    LOOP AT t_variants ASSIGNING <v>.
      AT NEW header-report.
        f_ok = abap_true.
        d_obj_name = <v>-header-report.
        CALL FUNCTION 'RS_OBJECT_IN_WORKING_AREA'
          EXPORTING
            object                  = 'REPS'
            obj_name                = d_obj_name
          IMPORTING
            object_is_work_item     = d_is_work_i     " My inactive object
            object_inactive_version = d_is_inactiv.
        IF NOT d_is_work_i IS INITIAL OR NOT d_is_inactiv IS INITIAL.
          REFRESH t_comps.    s_comp-name = <v>-header-report.    APPEND s_comp TO t_comps.
          CREATE OBJECT o_activate.
          o_activate->add_keys( t_comps ).
          t_comps = o_activate->activate( ).
          IF NOT t_comps IS INITIAL.      CLEAR f_ok.     ENDIF.
        ENDIF.
      ENDAT.
      IF f_ok IS INITIAL.
        SET EXTENDED CHECK OFF.
        IF 1 = 2.   MESSAGE i003 WITH <v>-header-report <v>-header-variant.   ENDIF.
        SET EXTENDED CHECK ON.
        CALL METHOD application_log->add_error
          EXPORTING
            id_msgno = '003'
            id_msgv1 = <v>-header-report
            id_msgv2 = <v>-header-variant.
      ENDIF.
      CHECK f_ok = abap_true.
      REFRESH t_params.
      LOOP AT <v>-params ASSIGNING <p>.
        IF NOT <p>-value IS INITIAL.
          CLEAR s_param.    s_param-kind = 'P'.       s_param-selname = <p>-name.     s_param-low = <p>-value.                  APPEND s_param TO t_params.
        ELSEIF NOT <p>-values IS INITIAL.
          LOOP AT <p>-values ASSIGNING <val>.
            CLEAR s_param.    s_param-kind = 'S'.     s_param-selname = <p>-name.     MOVE-CORRESPONDING <val> TO s_param.      APPEND s_param TO t_params.
          ENDLOOP.
        ENDIF.
      ENDLOOP.
      t_varit = <v>-texts.
      t_varis = <v>-screens.
      CALL FUNCTION 'RS_VARIANT_EXISTS'
        EXPORTING
          report              = <v>-header-report
          variant             = <v>-header-variant
        IMPORTING
          r_c                 = d_subrc
        EXCEPTIONS
          not_authorized      = 1
          no_report           = 2
          report_not_existent = 3
          report_not_supplied = 4
          OTHERS              = 5.
      IF sy-subrc = 0 AND d_subrc = 0.
        CALL FUNCTION 'RS_VARIANT_DELETE'
          EXPORTING
            report               = <v>-header-report
            variant              = <v>-header-variant
            flag_confirmscreen   = abap_true
            flag_delallclient    = abap_true    " other wise popup screen
          EXCEPTIONS
            not_authorized       = 1
            not_executed         = 2
            no_report            = 3
            report_not_existent  = 4
            report_not_supplied  = 5
            variant_locked       = 6
            variant_not_existent = 7
            no_corr_insert       = 8
            variant_protected    = 9
            OTHERS               = 10.
        IF sy-subrc <> 0.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ENDIF.
      ENDIF.
      CALL FUNCTION 'RS_CREATE_VARIANT'
        EXPORTING
          curr_report               = <v>-header-report
          curr_variant              = <v>-header-variant
          vari_desc                 = <v>-header
        TABLES
          vari_contents             = t_params
          vari_text                 = t_varit
          vscreens                  = t_varis
        EXCEPTIONS
          illegal_report_or_variant = 1
          illegal_variantname       = 2
          not_authorized            = 3
          not_executed              = 4
          report_not_existent       = 5
          report_not_supplied       = 6
          variant_exists            = 7
          variant_locked            = 8
          OTHERS                    = 9.
      IF sy-subrc <> 0.
        MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
      ELSE.
        IF set_variant_params( program = <v>-header-report   variant = <v>-header-variant    data = <v>-params ) = abap_true.
          APPEND <v> TO result.
        ENDIF.
        PERFORM deq_variant IN PROGRAM saplsvar USING <v>-header-report <v>-header-variant.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~anonymize.
    DATA o_prog     TYPE to_program.
    DATA o_variant  TYPE to_variant.
    CHECK object IS BOUND.
    CASE object->type.
      WHEN supportedtypes-sys_variant OR supportedtypes-appl_variant.
        o_variant ?= object->raw.
        o_variant->anonymize( ).
      WHEN supportedtypes-program.
        o_prog ?= object->raw.
        o_prog->anonymize( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name object->type.
    ENDCASE.
    TRY.
        super->zaplink_cnx_ext_cleaner~anonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~unanonymize.
    DATA o_prog     TYPE to_program.
    DATA o_variant  TYPE to_variant.
    TRY.
        super->zaplink_cnx_ext_cleaner~unanonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
    CHECK object IS BOUND.
    CASE object->type.
      WHEN supportedtypes-sys_variant OR supportedtypes-appl_variant.
        o_variant ?= object->raw.
        o_variant->unanonymize( ).
      WHEN supportedtypes-program.
        o_prog ?= object->raw.
        o_prog->unanonymize( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name object->type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_code_signature~get_signature.
    DATA d_type TYPE td_comptype.
    DATA d_prog TYPE td_progname.
    TRY.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN supportedtypes-program.
            d_prog = component->get_name( ).
            result = get_program_signature( d_prog ).
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_prog     TYPE to_program.
    DATA o_variant  TYPE to_variant.
    DATA o_raw_var  TYPE to_raw_variant.
    CASE type.
      WHEN supportedtypes-sys_variant OR supportedtypes-appl_variant.
        CREATE OBJECT o_raw_var.
        object = o_raw_var.
        CREATE OBJECT o_variant.
        object->raw = o_variant.
      WHEN supportedtypes-program.
        CREATE OBJECT object.
        CREATE OBJECT o_prog.
        object->raw = o_prog.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA d_name     TYPE td_compname.
    DATA type       TYPE td_comptype.
    DATA program    TYPE sy-repid.
    DATA s_variant  TYPE ts_variant_key.
    TRY.
        type = component->get_type( ).
        d_name = component->get_name( ).
        CASE type.
          WHEN supportedtypes-sys_variant OR supportedtypes-appl_variant.
            CHECK do_exists( component ) = exists-exists.     " UI when variant do not exists (detected with Issue 104)
            s_variant = zaplink_vari_data=>name_2_key( d_name ).
            CALL FUNCTION 'RS_VARIANT_DELETE'
              EXPORTING
                report               = s_variant-program
                variant              = s_variant-variant
                flag_delallclient    = abap_true
              EXCEPTIONS
                not_authorized       = 1
                not_executed         = 2
                no_report            = 3
                report_not_existent  = 4
                report_not_supplied  = 5
                variant_locked       = 6
                variant_not_existent = 7
                no_corr_insert       = 8
                variant_protected    = 9
                OTHERS               = 10.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise 'RS_VARIANT_DELETE' sy-subrc.
            ENDIF.
          WHEN supportedtypes-program.
            program = d_name.
            CALL FUNCTION 'RS_DELETE_PROGRAM'
              EXPORTING
                program            = program
                suppress_popup     = 'X'
              EXCEPTIONS
                enqueue_lock       = 1
                object_not_found   = 2
                permission_failure = 3
                reject_deletion    = 4
                OTHERS             = 5.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise 'RS_DELETE_PROGRAM' sy-subrc.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    result = abap_true.
    zaplink_tools=>remove_comp_from_working_area( type = type
                                                  name = d_name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA d_name     TYPE td_compname.
    DATA type       TYPE td_comptype.
    DATA d_subrc    TYPE sy-subrc.
    DATA s_variant  TYPE ts_variant_key.
    exists = me->exists-not_exists.
    TRY.
        type = component->get_type( ).
        d_name = component->get_name( ).
        CASE type.
          WHEN supportedtypes-sys_variant OR supportedtypes-appl_variant.
            s_variant = zaplink_vari_data=>name_2_key( d_name ).
            CALL FUNCTION 'RS_VARIANT_EXISTS'
              EXPORTING
                report              = s_variant-program
                variant             = s_variant-variant
              IMPORTING
                r_c                 = d_subrc
              EXCEPTIONS
                not_authorized      = 1
                no_report           = 2
                report_not_existent = 3
                report_not_supplied = 4
                OTHERS              = 5.
            IF sy-subrc = 0 AND d_subrc = 0.    exists = me->exists-exists.   ENDIF.
          WHEN supportedtypes-program.
            SELECT SINGLE name INTO d_name
              FROM trdir
              WHERE name = d_name.
            IF sy-subrc = 0.    exists = me->exists-exists.   ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~get_values.
    DATA s_variant   TYPE ts_variant_key.                     " Issue 53
    CASE type.
      WHEN supportedtypes-sys_variant OR supportedtypes-appl_variant.
        s_variant = zaplink_vari_data=>name_2_key( name ).
        IF s_variant-program IS INITIAL.
          CALL METHOD super->zaplink_connector~get_values
            EXPORTING
              type = supportedtypes-program
            CHANGING
              name = name.
          s_variant-program = name.
        ENDIF.
        CHECK NOT s_variant-program IS INITIAL.
        CALL FUNCTION 'RS_VARIANT_CATALOG'
          EXPORTING
            report               = s_variant-program
            variant              = s_variant-variant
          IMPORTING
            sel_variant          = s_variant-variant
          EXCEPTIONS
            no_report            = 1
            report_not_existent  = 2
            report_not_supplied  = 3
            no_variants          = 4
            no_variant_selected  = 0
            variant_not_existent = 6
            OTHERS               = 7.
        IF sy-subrc <> 0.
          MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
                  WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
        ELSE.
          name = zaplink_vari_data=>key_2_name( s_variant ).
        ENDIF.
      WHEN supportedtypes-program.
        CALL METHOD super->zaplink_connector~get_values
          EXPORTING
            type = type
          CHANGING
            name = name.
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.    result = abap_true.   ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    TYPES:                                                    " Issue 7
      BEGIN OF ts_doc,
        prog        TYPE programm,
        wildcard(1) TYPE c,
      END OF ts_doc.
    DATA s_obj       TYPE ts_doc.                             " Issue 7
    DATA o_prog      TYPE to_program.
    DATA s_fmd_prog  TYPE ts_fm_data.
    DATA o_variant   TYPE to_variant.
    DATA s_fmd_vari  TYPE ts_fmd_vari.
    DATA _prog       TYPE td_progname.
    DATA d_name      TYPE td_compname.
    DATA _obj        TYPE doku_obj.
    DATA type        TYPE td_comptype.
    DATA t_varid     TYPE tt_variant_list.                    " Issue 53
    DATA s_variant   TYPE ts_variant_key.                     " Issue 53
    DATA f_subcomp   TYPE td_with_subcomp.
    DATA l_mandt     LIKE sy-mandt.                           " Issue 99
    TRY.
        type = component->get_type( ).
        d_name = component->get_name( ).
        f_subcomp = component->get_with_subcomp( ).
        CREATE OBJECT object.
        object->set_component( component ).
        CASE type.
          WHEN supportedtypes-sys_variant OR supportedtypes-appl_variant.
            CREATE OBJECT o_variant.
            object->raw = o_variant.
            s_variant = zaplink_vari_data=>name_2_key( d_name ).
            PERFORM get_mandt IN PROGRAM saplsvar USING s_variant-variant " Issue 99
                                               CHANGING l_mandt.
            SELECT * UP TO 1 ROWS
              INTO TABLE t_varid
              FROM varid CLIENT SPECIFIED
              WHERE mandt = l_mandt
                AND report = s_variant-program
                AND variant = s_variant-variant.
            s_fmd_prog-variants = read_variants( t_varid ).
            CHECK NOT s_fmd_prog-variants IS INITIAL.
            READ TABLE s_fmd_prog-variants INDEX 1 INTO s_fmd_vari.
            o_variant->from_data( s_fmd_vari ).
            CLEAR: o_variant->a0_maindata-mandt, o_variant->a0_maindata-report, o_variant->a0_maindata-variant.
          WHEN supportedtypes-program.
            _prog = d_name = object->name.
            CREATE OBJECT o_prog.
            SELECT SINGLE *
              INTO s_fmd_prog-header
              FROM progdir    " reposrc
              WHERE name = d_name
                AND state = 'A'.        " Active
            IF sy-subrc <> 0.
              SELECT SINGLE *
                INTO s_fmd_prog-header
                FROM progdir    "reposrc
                WHERE name = d_name
                  AND state = 'I'.      " Inactive
            ENDIF.
            s_fmd_prog-source = get_prog_source( _prog ).
            s_fmd_prog-textspool = get_prog_textpool( _prog ).
            s_fmd_prog-dynpros = get_dynpros( _prog ).
            s_fmd_prog-menupainter = get_menus( _prog ).
            SELECT *
              INTO TABLE s_fmd_prog-texts
              FROM trdirti
              WHERE name = d_name.
            s_obj-prog = d_name.
            s_obj-wildcard = '*'.
            _obj = s_obj.
            s_fmd_prog-docs = zaplink_documentation=>get( ids = zaplink_prog_data=>r_doc_ids-prog
                                                      object = _obj ).
            IF f_subcomp >= sub_component-with_mine.
              SELECT * INTO TABLE t_varid
                FROM varid CLIENT SPECIFIED
                WHERE mandt = '000'
                  AND report = _prog.
              IF f_subcomp >= sub_component-with_required.
                SELECT * APPENDING TABLE t_varid
                  FROM varid
                  WHERE report = _prog
                    AND transport <> zaplink_vari_data=>transport-normal.
                IF f_subcomp >= sub_component-with_all.
                  SELECT * APPENDING TABLE t_varid
                    FROM varid
                    WHERE report = _prog
                      AND transport = zaplink_vari_data=>transport-normal.
                ENDIF.
              ENDIF.
              SORT t_varid BY mandt report variant. DELETE ADJACENT DUPLICATES FROM t_varid COMPARING mandt report variant.
              s_fmd_prog-variants = read_variants( t_varid ).
            ENDIF.
            o_prog->from_data( s_fmd_prog ).
            o_prog->_code_signature = get_program_signature( o_prog->a0_maindata-name ).
            CLEAR o_prog->a0_maindata-name.
            object->raw = o_prog.
          WHEN OTHERS.
            CLEAR object.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        object->update_connector_data( me ).                    " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    DATA o_prog      TYPE to_program.
    DATA o_vari      TYPE to_variant.
    DATA s_variant   TYPE ts_variant_key.
    DATA _prog       TYPE programm.
    DATA _oname      TYPE e071-obj_name.
    DATA _rep        TYPE progdir.
    DATA o_comp      TYPE to_component.
    DATA s_fmd_prog  TYPE ts_fm_data.
    DATA s_fmd_vari  TYPE ts_fmd_vari.
    DATA t_vari      TYPE tt_variants.
    FIELD-SYMBOLS <v> LIKE LINE OF o_prog->variants.
    TRY.
        CREATE OBJECT components. " Issue 92
        CASE object->type.
          WHEN supportedtypes-sys_variant OR supportedtypes-appl_variant.
            o_vari ?= object->raw.    s_variant = zaplink_vari_data=>name_2_key( object->name ).
            o_vari->a0_maindata-report = s_variant-program.   o_vari->a0_maindata-variant = s_variant-variant.
            s_fmd_vari = o_vari->to_data( ).    APPEND s_fmd_vari TO s_fmd_prog-variants.
            write_variants( s_fmd_prog-variants ).
          WHEN supportedtypes-program.
            o_prog ?= object->raw.
            _oname = _prog = o_prog->a0_maindata-name = object->name.
            s_fmd_prog = o_prog->to_data( ).
            CALL FUNCTION 'RS_INSERT_INTO_WORKING_AREA'
              EXPORTING
                object            = 'REPS'
                obj_name          = _oname
              EXCEPTIONS
                wrong_object_name = 1
                OTHERS            = 2.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise 'RS_INSERT_INTO_WORKING_AREA' sy-subrc.
            ENDIF.
            CALL FUNCTION 'RS_INSERT_INTO_WORKING_AREA'
              EXPORTING
                object            = 'REPT'
                obj_name          = _oname
              EXCEPTIONS
                wrong_object_name = 1
                OTHERS            = 2.
            IF sy-subrc <> 0.
              mac_add_mf_and_raise 'RS_INSERT_INTO_WORKING_AREA' sy-subrc.
            ENDIF.
            MOVE-CORRESPONDING s_fmd_prog-header TO _rep.
            _rep-state = 'I'.   MODIFY progdir FROM _rep.
            _rep-state = 'A'.   MODIFY progdir FROM _rep.
            set_prog_source( program = _prog
                              source = s_fmd_prog-source ).
            set_prog_textpool( program = _prog
                              textpool = s_fmd_prog-textspool ).
            set_dynpros( program = _prog
                         dynpros = s_fmd_prog-dynpros ).
            set_menus( program = _prog
                         menus = s_fmd_prog-menupainter ).
            zaplink_documentation=>set( t_docs = s_fmd_prog-docs ).
            DELETE FROM trdirti WHERE name = s_fmd_prog-header-name.
            MODIFY trdirti FROM TABLE s_fmd_prog-texts.
            t_vari = write_variants( s_fmd_prog-variants ).
            LOOP AT o_prog->variants ASSIGNING <v>.
              o_vari ?= <v>-zl_object->raw.
              READ TABLE t_vari TRANSPORTING NO FIELDS WITH KEY header-variant = o_vari->a0_maindata-variant.
              IF sy-subrc = 0.
                o_comp = <v>-zl_object->get_component( abap_true ).
                components->add( o_comp ).    components->select( o_comp ).
              ENDIF.
            ENDLOOP.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name object->type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ). " Issue 92
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_PROGRAM implementation
CLASS zaplink_raw IMPLEMENTATION.
  METHOD constructor.
    super->constructor( o_comp ).
  ENDMETHOD.
  METHOD copy_as.
    me->type = raw->type.
    me->name = raw->name.
    me->connector = raw->connector.
    me->version = raw->version.
    me->directory = raw->directory.
    me->checksum = raw->checksum.
    me->dependencies = raw->dependencies.
    me->code_signature = raw->code_signature.
    me->raw = raw->raw.
  ENDMETHOD.
  METHOD update_connector_data.
    DATA o_raw_data      TYPE to_raw_data.
    o_raw_data = me->raw.
    IF NOT o_raw_data->_dependencies IS INITIAL.    me->dependencies = o_raw_data->_dependencies.     CLEAR o_raw_data->_dependencies.    ENDIF.  " Issue 47 : Introducing dependencies
    IF NOT o_raw_data->_code_signature IS INITIAL.  me->code_signature = o_raw_data->_code_signature. CLEAR o_raw_data->_code_signature.  ENDIF.  " Issue 65 : Source Code signature
    super->update_connector_data( o_connector = o_connector ).
    me->set_checksum( ).
  ENDMETHOD.
ENDCLASS. "ZAPLINK_RAW implementation
CLASS zaplink_tabl_data IMPLEMENTATION.
  METHOD anonymize.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF indexes,
      <t> LIKE LINE OF texts.
    CLEAR: a0_maindata-as4user, a0_maindata-as4date, a0_maindata-as4time,
           a0_maindata-technical_settings-as4user, a0_maindata-technical_settings-as4date, a0_maindata-technical_settings-as4time.
    LOOP AT texts ASSIGNING <t>.    CLEAR: <t>-long_txt-tdfuser, <t>-long_txt-tdfdate, <t>-long_txt-tdftime.    ENDLOOP.
    LOOP AT indexes ASSIGNING <i>.    <i>-zl_object->anonymize( ).    ENDLOOP.
  ENDMETHOD.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_ids.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = doc_ids-header. APPEND _id TO r_doc_ids.
  ENDMETHOD.
  METHOD conv_index.
    DATA s_index LIKE LINE OF result.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF fm_data-indexes.
    LOOP AT fm_data-indexes ASSIGNING <i>.
      CLEAR s_index.    s_index-header = <i>.
      s_index-fields = fm_data-idx_fields.    DELETE s_index-fields WHERE indexname <> <i>-indexname.
      s_index-texts = fm_data-idx_texts.    DELETE s_index-texts WHERE indexname <> <i>-indexname.
      s_index-docs = fm_data-docs.
      APPEND s_index TO result.
    ENDLOOP.
  ENDMETHOD.
  METHOD conv_indexes.
    DATA s_index LIKE LINE OF fm_data-indexes.
    FIELD-SYMBOLS:
      <i> LIKE LINE OF indexes.
    LOOP AT indexes ASSIGNING <i>.
      CLEAR s_index.    s_index = <i>-header.       APPEND s_index TO fm_data-indexes.
      APPEND LINES OF <i>-fields TO fm_data-idx_fields.
      APPEND LINES OF <i>-texts  TO fm_data-idx_texts.
      APPEND LINES OF <i>-docs   TO fm_data-docs.
    ENDLOOP.
  ENDMETHOD.
  METHOD from_data.
    DATA s_text  LIKE LINE OF texts.
    DATA s_field LIKE LINE OF fields.
    DATA s_sh_f  LIKE LINE OF s_field-search_help-fields.
    DATA s_fk_f  LIKE LINE OF s_field-forein_key-fields.
    DATA s_f_txt LIKE LINE OF s_field-texts.
    DATA s_index LIKE LINE OF indexes.
    DATA d_str   TYPE string.
    DATA t_index TYPE tt_fm_data.
    FIELD-SYMBOLS:
      <f>  LIKE LINE OF fm_data-fields,
      <ft> LIKE LINE OF fm_data-fields_texts,
      <s>  LIKE LINE OF fm_data-search_helps,
      <sf> LIKE LINE OF fm_data-sh_fields,
      <k>  LIKE LINE OF fm_data-forein_keys,
      <ff> LIKE LINE OF fm_data-fk_fields,
      <id> LIKE LINE OF t_index,
      <i>  LIKE LINE OF fm_data-indexes,
      <if> LIKE LINE OF fm_data-idx_fields,
      <d>  LIKE LINE OF fm_data-docs,
      <dt> LIKE LINE OF <d>-texts,
      <t>  LIKE LINE OF fm_data-texts.
    DATA p_table TYPE REF TO data.
    FIELD-SYMBOLS:
      <tc>    TYPE STANDARD TABLE,
      <cl>    TYPE any,
      <mandt> TYPE sy-mandt.
    a0_maindata-hdr = fm_data-header.
    a0_maindata-technical_settings = fm_data-tech.
    CLEAR: a0_maindata-technical_settings-tabname,
           a0_maindata-technical_settings-as4local,
           a0_maindata-technical_settings-as4vers.
    LOOP AT fm_data-texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-langu = <t>-ddlanguage.
      s_text-short_txt = <t>-ddtext.
      READ TABLE fm_data-docs ASSIGNING <d>
           WITH KEY id = doc_ids-header
                object = a0_maindata-tabname.
      IF sy-subrc = 0.
        READ TABLE <d>-texts ASSIGNING <dt>
            WITH KEY tdspras = s_text-langu.
        IF sy-subrc = 0.
          s_text-long_txt = <dt>.
          CLEAR s_text-long_txt-tdspras.
        ENDIF.
      ENDIF.
      INSERT s_text INTO TABLE texts.
    ENDLOOP.
    LOOP AT fm_data-fields ASSIGNING <f>
            WHERE tabname = a0_maindata-tabname.
      CLEAR s_field.      s_field-hdr = <f>.      CLEAR: s_field-tabname.
      LOOP AT fm_data-fields_texts ASSIGNING <ft>
              WHERE tabname = <f>-tabname
              AND fieldname = <f>-fieldname.
        CLEAR s_f_txt.
        s_f_txt-langu = <ft>-ddlanguage.
        s_f_txt-short_txt = <ft>-ddtext.
        INSERT s_f_txt INTO TABLE s_field-texts.
      ENDLOOP.
      LOOP AT fm_data-search_helps ASSIGNING <s>
              WHERE tabname = <f>-tabname
              AND fieldname = <f>-fieldname.
        IF s_field-search_help IS NOT INITIAL. sy-subrc = sy-tabix / 0. ENDIF.    " should not append
        s_field-search_help-hdr = <s>.      CLEAR: s_field-search_help-tabname, s_field-search_help-fieldname.
        LOOP AT fm_data-sh_fields ASSIGNING <sf>
                WHERE tabname = <s>-tabname
                AND fieldname = <s>-fieldname
                 AND shlpname = <s>-shlpname.
          CLEAR s_sh_f.     s_sh_f = <sf>.    CLEAR: s_sh_f-tabname, s_sh_f-fieldname, s_sh_f-shlpname.
          IF s_sh_f-shtable = a0_maindata-tabname.    CLEAR: s_sh_f-shtable.    IF s_sh_f-shfield = s_field-fieldname.    CLEAR: s_sh_f-shfield. ENDIF. ENDIF.
          INSERT s_sh_f INTO TABLE s_field-search_help-fields.
        ENDLOOP.
      ENDLOOP.
      LOOP AT fm_data-forein_keys ASSIGNING <k>
              WHERE tabname = <f>-tabname
              AND fieldname = <f>-fieldname.
        IF s_field-forein_key IS NOT INITIAL. sy-subrc = sy-tabix / 0. ENDIF.    " should not append
        s_field-forein_key-hdr = <k>.      CLEAR: s_field-forein_key-tabname, s_field-forein_key-fieldname, s_field-checktable.
        LOOP AT fm_data-fk_fields ASSIGNING <ff>
                WHERE tabname = <k>-tabname
                AND fieldname = <k>-fieldname
               AND checktable = <k>-checktable.
          CLEAR s_fk_f.     s_fk_f = <ff>.    CLEAR: s_fk_f-tabname, s_fk_f-fieldname, s_fk_f-checktable.
          IF s_fk_f-fortable = a0_maindata-tabname.    CLEAR: s_fk_f-fortable.    IF s_fk_f-forkey = s_field-fieldname.    CLEAR: s_fk_f-forkey. ENDIF. ENDIF.
          INSERT s_fk_f INTO TABLE s_field-forein_key-fields.
        ENDLOOP.
      ENDLOOP.
      INSERT s_field INTO TABLE fields.
    ENDLOOP.
    t_index = conv_index( fm_data ).
    SORT t_index BY header-indexname.
    LOOP AT t_index ASSIGNING <id>.
      CLEAR s_index.
      CREATE OBJECT s_index-zl_object
        EXPORTING
          fm_data = <id>.
      APPEND s_index TO indexes.
    ENDLOOP.
    IF fm_data-with_content = abap_true AND fm_data-header-tabclass <> 'INTTAB'.    " skip for structures
      TRY.
          CREATE DATA content TYPE STANDARD TABLE OF (a0_maindata-tabname).
          ASSIGN content->* TO <tc>.
          ASSERT sy-subrc = 0.
          SELECT *
            FROM (a0_maindata-tabname)
            INTO TABLE <tc>.
          IF NOT <tc> IS INITIAL.
            READ TABLE fm_data-fields ASSIGNING <f>
                WITH KEY tabname = a0_maindata-tabname
                         keyflag = abap_true
                        datatype = 'CLNT'.   " Mandant
            IF sy-subrc = 0.
              LOOP AT <tc> ASSIGNING <cl>.
                ASSIGN COMPONENT <f>-fieldname OF STRUCTURE <cl> TO <mandt>.
                ASSERT sy-subrc = 0.
                CLEAR <mandt>.
              ENDLOOP.
            ENDIF.
          ENDIF.
        CATCH cx_sy_create_data_error.
      ENDTRY.
    ENDIF.
  ENDMETHOD.
  METHOD to_data.
    DATA s_text  LIKE LINE OF fm_data-texts.
    DATA s_doc   LIKE LINE OF fm_data-docs.
    DATA s_dtxt  LIKE LINE OF s_doc-texts.
    DATA s_idx_f LIKE LINE OF fm_data-idx_fields.
    DATA s_field LIKE LINE OF fm_data-fields.
    DATA s_f_txt LIKE LINE OF fm_data-fields_texts.
    DATA s_sh    LIKE LINE OF fm_data-search_helps.
    DATA s_sh_f  LIKE LINE OF fm_data-sh_fields.
    DATA s_fk    LIKE LINE OF fm_data-forein_keys.
    DATA s_fk_f  LIKE LINE OF fm_data-fk_fields.
    DATA t_index TYPE tt_fm_data.
    DATA s_index LIKE LINE OF t_index.
    FIELD-SYMBOLS:
      <i>  LIKE LINE OF indexes,
      <f>  LIKE LINE OF fields,
      <ft> LIKE LINE OF <f>-texts,
      <sf> LIKE LINE OF <f>-search_help-fields,
      <ff> LIKE LINE OF <f>-forein_key-fields,
      <d>  LIKE LINE OF fm_data-docs,
      <t>  LIKE LINE OF texts.
    fm_data-header = a0_maindata-hdr.
    IF NOT a0_maindata-technical_settings IS INITIAL.         " Issue 84
      fm_data-tech = a0_maindata-technical_settings.
      fm_data-tech-tabname = fm_data-header-tabname.
      fm_data-tech-as4local = 'A'.
      fm_data-tech-as4vers = '0000'.
    ENDIF.
    LOOP AT texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-tabname = fm_data-header-tabname.
      s_text-ddlanguage = <t>-langu.
      s_text-as4local = 'A'. " Active
      s_text-as4vers = '0000'. " Active
      s_text-ddtext = <t>-short_txt.
      INSERT s_text INTO TABLE fm_data-texts.
      IF NOT <t>-long_txt IS INITIAL.
        IF fm_data-docs IS INITIAL.
          s_doc-application = 'DOKU'.
          s_doc-id = doc_ids-header.
          s_doc-object = fm_data-header-tabname.
          s_doc-langu = <t>-langu.
          s_doc-masterlang = abap_true.
          s_doc-typ = 'E'.
          s_doc-dokform = 'S_DOCU_SHOW'.
          s_doc-dokstyle = 'S_DOCUS1'.
          INSERT s_doc INTO TABLE fm_data-docs.
        ENDIF.
        READ TABLE fm_data-docs ASSIGNING <d> INDEX 1.
        s_dtxt = <t>-long_txt.
        s_dtxt-tdspras = <t>-langu.
        INSERT s_dtxt INTO TABLE <d>-texts.
      ENDIF.
    ENDLOOP.
    LOOP AT indexes ASSIGNING <i>.
      s_index = <i>-zl_object->to_data( ).
      APPEND s_index TO t_index.
    ENDLOOP.
    conv_indexes( EXPORTING indexes = t_index
                   CHANGING fm_data = fm_data ).
    LOOP AT fields ASSIGNING <f>.
      CLEAR s_field.      s_field = <f>-hdr.      s_field-tabname = a0_maindata-tabname.
      LOOP AT <f>-texts ASSIGNING <ft>.
        CLEAR s_f_txt.    s_f_txt-ddlanguage = <ft>-langu.    s_f_txt-ddtext = <ft>-short_txt.    s_f_txt-tabname = s_field-tabname.    s_f_txt-fieldname = s_field-fieldname.
        INSERT s_f_txt INTO TABLE fm_data-fields_texts.
      ENDLOOP.
      IF NOT <f>-search_help IS INITIAL.
        CLEAR s_sh.   s_sh = <f>-search_help-hdr.   s_sh-tabname = s_field-tabname.   s_sh-fieldname = s_field-fieldname.
        INSERT s_sh INTO TABLE fm_data-search_helps.
        LOOP AT <f>-search_help-fields ASSIGNING <sf>.
          CLEAR s_sh_f.     s_sh_f = <sf>.    s_sh_f-tabname = s_sh-tabname.    s_sh_f-fieldname = s_sh-fieldname.    s_sh_f-shlpname = s_sh-shlpname.
          IF s_sh_f-shtable IS INITIAL. s_sh_f-shtable = a0_maindata-tabname.    IF s_sh_f-shfield IS INITIAL. s_sh_f-shfield = <f>-fieldname.    ENDIF. ENDIF.
          INSERT s_sh_f INTO TABLE fm_data-sh_fields.
        ENDLOOP.
      ENDIF.
      IF NOT <f>-forein_key IS INITIAL.
        CLEAR s_fk.   s_fk = <f>-forein_key-hdr.   s_fk-tabname = s_field-tabname.   s_fk-fieldname = s_field-fieldname.
        INSERT s_fk INTO TABLE fm_data-forein_keys.
        s_field-checktable = s_fk-checktable.
        LOOP AT <f>-forein_key-fields ASSIGNING <ff>.
          CLEAR s_fk_f.     s_fk_f = <ff>.    s_fk_f-tabname = s_fk-tabname.   s_fk_f-fieldname = s_fk-fieldname.   s_fk_f-checktable = s_fk-checktable.
          IF s_fk_f-fortable IS INITIAL.    s_fk_f-fortable = a0_maindata-tabname.    IF s_fk_f-forkey IS INITIAL.  s_fk_f-forkey = s_field-fieldname.   ENDIF. ENDIF.
          INSERT s_fk_f INTO TABLE fm_data-fk_fields.
        ENDLOOP.
      ENDIF.
      INSERT s_field INTO TABLE fm_data-fields.
    ENDLOOP.
    IF NOT content IS INITIAL.
      fm_data-with_content = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_TABL_DATA implementation
CLASS zaplink_transaction IMPLEMENTATION.
  METHOD class_constructor.
    DATA _id LIKE LINE OF r_doc_id.
    _id-sign = 'I'. _id-option = 'EQ'.
    _id-low = c_msg_id. APPEND _id TO r_doc_id.
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.
    type-type = st_transaction. INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~anonymize.
    DATA o_data  TYPE to_data.
    CHECK object IS BOUND.
    CASE object->type.
      WHEN st_transaction.
        o_data ?= object->raw.
        o_data->anonymize( ).
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name object->type.
    ENDCASE.
    TRY.
        super->zaplink_cnx_ext_cleaner~anonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    DATA o_data TYPE to_data.
    CREATE OBJECT object.
    CASE type.
      WHEN st_transaction.
        CREATE OBJECT o_data.
        object->raw = o_data.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA d_name TYPE tstc-tcode.
    DATA d_type TYPE td_comptype.
    DATA _name  TYPE td_compname.
    TRY.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN st_transaction.
            d_name = _name = component->get_name( ).
            CALL FUNCTION 'RPY_TRANSACTION_DELETE'
              EXPORTING
                transaction      = d_name
              EXCEPTIONS
                not_excecuted    = 1
                object_not_found = 2
                OTHERS           = 3.
            IF sy-subrc <> 0. " SAP NameSpace
              CASE sy-subrc.
                WHEN 2.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>not_found
                      type   = d_type
                      name   = _name.
                WHEN OTHERS.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>system_error.
              ENDCASE.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    result = abap_true.
    zaplink_tools=>remove_comp_from_working_area( type = d_type
                                                  name = _name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA d_name TYPE tstc-tcode.
    DATA type  TYPE td_comptype.
    exists = me->exists-not_exists.
    TRY.
        type = component->get_type( ).
        CASE type.
          WHEN st_transaction.
            d_name = component->get_name( ).
            SELECT SINGLE tcode INTO d_name      " From MF RPY_TRANSACTION_READ
              FROM tstc
              WHERE tcode = d_name.
            IF sy-subrc = 0.
              exists = me->exists-exists.
            ENDIF.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.
      result = abap_true.
    ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    DATA o_data  TYPE to_data.
    DATA d_name  TYPE tstc-tcode.
    DATA s_fm_data TYPE zaplink_tran_data=>ts_fm_data.
    DATA t_tstc  TYPE STANDARD TABLE OF tstc WITH DEFAULT KEY.
    DATA t_tstcc TYPE STANDARD TABLE OF tstcc WITH DEFAULT KEY.
    DATA d_remotedata TYPE string.
    DATA t_param TYPE STANDARD TABLE OF rsparam.
    DATA o_conn  TYPE to_connector.
    DATA o_comp  TYPE to_component.
    DATA _name   TYPE td_compname.
    DATA d_type TYPE td_comptype.
    FIELD-SYMBOLS:
      <param> TYPE STANDARD TABLE,
      <scr>   TYPE rsstcd,
      <g>     TYPE s_gui_inhe,
      <t>     LIKE LINE OF t_tstc,
      <a>     LIKE LINE OF t_tstcc.
    DATA f_subcomp  TYPE td_with_subcomp.
    TRY.
        CREATE OBJECT object.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN st_transaction.
            f_subcomp = component->get_with_subcomp( ).
            d_name = component->get_name( ).
            PERFORM refresh_global_data IN PROGRAM saplseuk.    " to initialize data : Issue 67
            CALL FUNCTION 'RPY_TRANSACTION_READ'
              EXPORTING
                transaction      = d_name
              TABLES
                tcodes           = t_tstc
                gui_attributes   = t_tstcc
              EXCEPTIONS
                permission_error = 1
                cancelled        = 2
                not_found        = 3
                object_not_found = 4
                OTHERS           = 5.
            IF sy-subrc <> 0.
              o_mycx ?= zaplink_cx=>create_from_mf_cx( funcname = 'RPY_TRANSACTION_READ'
                                                          subrc = sy-subrc
                                                      classname = 'ZAPLINK_CX_CONNECTOR' ).
              application_log->add_symsg( ).
              RAISE EXCEPTION o_mycx.
            ENDIF.
            READ TABLE t_tstc ASSIGNING <t>
                 WITH KEY tcode = d_name.
            CHECK sy-subrc = 0.
            CREATE OBJECT o_data.
            s_fm_data-tstc = <t>.
            PERFORM select_tstc_tables_new IN PROGRAM saplseuk USING d_name space space.
            d_remotedata = '(SAPLSEUK)G_GUI_INHE'.
            ASSIGN (d_remotedata) TO <g>.
            IF sy-subrc = 0. s_fm_data-gui_inh = <g>. ENDIF.
            d_remotedata = '(SAPLSEUK)param[]'.
            ASSIGN (d_remotedata) TO <param>.
            IF sy-subrc = 0. s_fm_data-t_params = <param>. ENDIF.
            d_remotedata = '(SAPLSEUK)RSSTCD'.
            ASSIGN (d_remotedata) TO <scr>.
            IF sy-subrc = 0. s_fm_data-rsstcd = <scr>. ENDIF.
            SELECT * INTO TABLE s_fm_data-tstct
              FROM tstct
              WHERE tcode = d_name.
            SELECT * INTO TABLE s_fm_data-tstca
              FROM tstca
              WHERE tcode = d_name.
            READ TABLE t_tstcc ASSIGNING <a>
                 WITH KEY tcode = d_name.
            IF sy-subrc = 0.
              s_fm_data-tstcc = <a>.
            ENDIF.
            IF s_fm_data-tstc-cinfo O transaction_types-prog_variant.    SUBTRACT transaction_types-prog_variant FROM s_fm_data-tstc-cinfo.   ENDIF.    " Issue 67 : Transaction of program with variant
            CREATE OBJECT o_data.
            o_data->from_data( s_fm_data ).
            IF f_subcomp >= sub_component-with_all.
              IF o_data->a0_maindata-cinfo O transaction_types-object.
                _name = o_data->a0_maindata-classname.
                IF NOT _name IS INITIAL.
                  o_conn = zaplink_connectors=>create_connector( type = t_component-object ).
                  IF o_conn IS BOUND.
                    CREATE OBJECT o_comp.
                    o_comp->set_type( t_component-object ).
                    o_comp->set_name( _name ).
                    o_data->zl_object = o_conn->read_from_sap( o_comp ).
                    IF o_data->zl_object IS BOUND.
                      CLEAR o_data->a0_maindata-classname.
                    ENDIF.
                  ENDIF.
                ENDIF.
              ELSEIF o_data->a0_maindata-cinfo O transaction_types-program.
                _name = o_data->a0_maindata-pgmna.
                IF NOT _name IS INITIAL.
                  o_conn = zaplink_connectors=>create_connector( type = t_component-program ).
                  IF o_conn IS BOUND.
                    CREATE OBJECT o_comp.
                    o_comp->set_type( t_component-program ).
                    o_comp->set_name( _name ).
                    o_data->zl_object = o_conn->read_from_sap( o_comp ).
                    IF o_data->zl_object IS BOUND.
                      CLEAR o_data->a0_maindata-pgmna.
                    ENDIF.
                  ENDIF.
                ENDIF.
              ELSEIF o_data->a0_maindata-cinfo O transaction_types-transaction.
                _name = o_data->a0_maindata-call_tcode.
                IF NOT _name IS INITIAL AND _name <> d_name.
                  CREATE OBJECT o_comp.
                  o_comp->set_type( st_transaction ).
                  o_comp->set_name( _name ).
                  o_data->zl_object = zaplink_connector~read_from_sap( o_comp ).
                  IF o_data->zl_object IS BOUND.
                    CLEAR o_data->a0_maindata-call_tcode.
                  ENDIF.
                ENDIF.
              ENDIF.
            ENDIF.
            object->set_component( component ).
            CLEAR o_data->a0_maindata-tcode.
            object->raw = o_data.
          WHEN OTHERS.
            CLEAR object.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        object->update_connector_data( me ).                    " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    TYPES:              " FROM LSEUKTOP(82)
      BEGIN OF cobj,
        field TYPE tstca-field,
        value TYPE tstca-value,
        olen  TYPE dfies-outputlen,
      END OF cobj.
    DATA t_cobj TYPE STANDARD TABLE OF cobj.
    DATA s_cobj LIKE LINE OF t_cobj.
    DATA o_data TYPE to_data.
    DATA o_comp TYPE to_component.
    DATA d_name TYPE td_compname.
    DATA s_fm_data TYPE zaplink_tran_data=>ts_fm_data.
    DATA d_remotedata TYPE string.
    DATA s_tstca LIKE LINE OF s_fm_data-tstca.
    DATA s_tstct LIKE LINE OF s_fm_data-tstct.
    DATA o_conn  TYPE to_connector.
    DATA o_list  TYPE to_list.
    FIELD-SYMBOLS:
      <t>  LIKE LINE OF s_fm_data-tstct,
      <st> TYPE STANDARD TABLE,
      <v>  LIKE LINE OF s_fm_data-tstca,
      <a>  TYPE any.
    DEFINE lmac_assign.
      d_remotedata = &1.
      ASSIGN (d_remotedata) TO <a>.
      IF sy-subrc = 0. <a> = &2. ENDIF.
    END-OF-DEFINITION.
    DEFINE lmac_assign_table.
      d_remotedata = &1.
      ASSIGN (d_remotedata) TO <st>.
      IF sy-subrc = 0. <st> = &2. ENDIF.
    END-OF-DEFINITION.
    TRY.
        CREATE OBJECT components.
        CASE object->type.
          WHEN st_transaction.
            o_data ?= object->raw.
            o_data->a0_maindata-tcode = object->name.
            IF o_data->zl_object IS BOUND.
              IF o_data->a0_maindata-cinfo O transaction_types-object.
                o_data->a0_maindata-classname = o_data->zl_object->name.
                o_conn = zaplink_connectors=>create_connector( type = t_component-object ).
              ELSEIF o_data->a0_maindata-cinfo O transaction_types-program.
                o_data->a0_maindata-pgmna = o_data->zl_object->name.
                o_conn = zaplink_connectors=>create_connector( type = t_component-program ).
              ELSEIF o_data->a0_maindata-cinfo O transaction_types-transaction.
                o_data->a0_maindata-call_tcode = o_data->zl_object->name.
                o_conn = me.
              ENDIF.
              IF o_conn IS BOUND.
                o_list = o_conn->write_to_sap( o_data->zl_object ).
                IF o_conn->application_log IS BOUND.    application_log->add_from_instance( o_conn->application_log ).   ENDIF.
                components->add_list( o_list ).
              ENDIF.
            ENDIF.
            s_fm_data = o_data->to_data( ).
            PERFORM refresh_global_data IN PROGRAM saplseuk.    " to load program in memory
            LOOP AT s_fm_data-tstca ASSIGNING <v>.
              IF sy-tabix = 1. lmac_assign '(SAPLSEUK)TSTCA' <v>. ENDIF.
              s_cobj-field = <v>-field.
              s_cobj-value = <v>-value.
              APPEND s_cobj TO t_cobj.
            ENDLOOP.
            lmac_assign '(SAPLSEUK)COBJ[]' t_cobj.
            lmac_assign '(SAPLSEUK)TSTCC' s_fm_data-tstcc.
            IF s_fm_data-tstc-cinfo O transaction_types-check. lmac_assign '(SAPLSEUK)TC_CHK' transaction_types-check. SUBTRACT transaction_types-check FROM s_fm_data-tstc-cinfo .  ENDIF.
            IF s_fm_data-tstc-cinfo O transaction_types-enqueue. lmac_assign '(SAPLSEUK)TC_ENQ' transaction_types-enqueue. SUBTRACT transaction_types-enqueue FROM s_fm_data-tstc-cinfo .  ENDIF.
            lmac_assign '(SAPLSEUK)TC_TYP' s_fm_data-tstc-cinfo.
            lmac_assign '(SAPLSEUK)RSSTCD' s_fm_data-rsstcd.
            IF NOT s_fm_data-rsstcd-call_tcode IS INITIAL. lmac_assign '(SAPLSEUK)PARAM_VARI' abap_true. ENDIF.      " For transaction parameter @*
            lmac_assign '(SAPLSEUK)TSTC' s_fm_data-tstc.
            IF NOT s_fm_data-tstct IS INITIAL.
              READ TABLE s_fm_data-tstct INTO s_tstct INDEX 1.
              lmac_assign '(SAPLSEUK)TRAN_LANGU' s_tstct-sprsl.
              lmac_assign '(SAPLSEUK)TSTCT' s_tstct.
            ENDIF.
            lmac_assign_table '(SAPLSEUK)param[]' s_fm_data-t_params.
            lmac_assign '(SAPLSEUK)G_GUI_INHE' s_fm_data-gui_inh.
            IF s_fm_data-tstcc-s_webgui = '2'.    " LSEUKF01(426-427)
              lmac_assign '(SAPLSEUK)G_IAC_EWT' 'X'.
            ENDIF.
            PERFORM save_tcode IN PROGRAM saplseuk.
            PERFORM save_classification IN PROGRAM saplseuk.
            MODIFY tstct FROM TABLE s_fm_data-tstct.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name object->type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ). " Issue 92
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_TRANSACTION implementation
CLASS zaplink_tran_data IMPLEMENTATION.
  METHOD anonymize.
  ENDMETHOD.
  METHOD data_2_type.
  ENDMETHOD.
  METHOD from_data.
    DATA s_text  LIKE LINE OF texts.
    DATA s_auth  TYPE ts_authority.
    DATA s_value LIKE LINE OF s_auth-values.
    FIELD-SYMBOLS:
      <o> LIKE LINE OF fm_data-tstca,
      <t> LIKE LINE OF fm_data-tstct.
    MOVE-CORRESPONDING fm_data-tstc TO a0_maindata.
    MOVE-CORRESPONDING fm_data-tstcc TO a0_maindata.
    MOVE-CORRESPONDING fm_data-rsstcd TO a0_maindata.
    a0_maindata-gui_inh = fm_data-gui_inh.
    CLEAR a0_maindata-tc_type.          " transaction type in text
    parameters = fm_data-t_params.
    LOOP AT fm_data-tstct ASSIGNING <t>.
      CLEAR s_text.
      s_text-langu = <t>-sprsl.
      s_text-short_txt = <t>-ttext.
      INSERT s_text INTO TABLE texts.
    ENDLOOP.
    CLEAR authorization.
    LOOP AT fm_data-tstca ASSIGNING <o>.
      AT NEW objct.
        CLEAR s_auth.
        s_auth-object = <o>-objct.
      ENDAT.
      CLEAR s_value.
      s_value-field = <o>-field.
      s_value-value = <o>-value.
      INSERT s_value INTO TABLE s_auth-values.
      AT END OF objct.
        IF NOT authorization IS INITIAL.
        ENDIF.
        authorization = s_auth.
      ENDAT.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA s_text  LIKE LINE OF fm_data-tstct.
    DATA s_value LIKE LINE OF fm_data-tstca.
    FIELD-SYMBOLS:
      <o> LIKE LINE OF authorization-values,
      <t> LIKE LINE OF texts.
    MOVE-CORRESPONDING a0_maindata TO fm_data-tstc.
    MOVE-CORRESPONDING a0_maindata TO fm_data-tstcc.
    MOVE-CORRESPONDING a0_maindata TO fm_data-rsstcd.
    fm_data-gui_inh = a0_maindata-gui_inh.
    fm_data-t_params = parameters.
    LOOP AT texts ASSIGNING <t>.
      CLEAR s_text.
      s_text-tcode = a0_maindata-tcode.
      s_text-sprsl = <t>-langu.
      s_text-ttext = <t>-short_txt.
      INSERT s_text INTO TABLE fm_data-tstct.
    ENDLOOP.
    LOOP AT authorization-values ASSIGNING <o>.
      CLEAR s_value.
      s_value-tcode = a0_maindata-tcode.
      s_value-objct = authorization-object.
      s_value-field = <o>-field.
      s_value-value = <o>-value.
      INSERT s_value INTO TABLE fm_data-tstca.
    ENDLOOP.
  ENDMETHOD.
  METHOD unanonymize.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_TRAN_DATA implementation
CLASS zaplink_container IMPLEMENTATION.
  METHOD add_components.
    DATA o_comp    TYPE zaplink_list=>to_component.
    DATA msg       TYPE string.
    DATA _msg_col  TYPE to_log.
    CHECK object_list IS BOUND.
    TRY.
        object_list->order_kind = zaplink_list=>order_kinds-no_order.
        object_list->init_sel_iter( ).
        object_list->display_progress = abap_true.
        o_comp = object_list->get_next( ).
        WHILE o_comp IS BOUND.
          TRY.
              _add_component( component = o_comp ).
            CATCH zaplink_cx_container INTO o_mycx.
              CALL METHOD log->add_exception
                EXPORTING
                  exception    = o_mycx
                  id_probclass = log->probcl-medium.
              _msg_col = o_comp->get_msg_coll( ).
              IF _msg_col IS BOUND.
                CALL METHOD log->add_from_instance
                  EXPORTING
                    io_msglist        = _msg_col
                    if_add_as_subnode = abap_true.
              ENDIF.
          ENDTRY.
          o_comp = object_list->get_next( ).
        ENDWHILE.
        _complist->refresh( ).    " Issue 102
        compact( ).
        _update_componentslist( ).
        mac_def_catch zaplink_cx_container.
    ENDTRY.
  ENDMETHOD.
  METHOD class_constructor.
    xmlengine = cl_ixml=>create( ).
  ENDMETHOD.
  METHOD compact.
    DATA o_list TYPE to_list.
    DATA o_comp TYPE to_component.
    DATA o_subcomps TYPE to_list.
    TRY.
        _complist->init_iter( ).
        _complist->display_progress = abap_false.
        o_comp = _complist->get_next( ).
        WHILE o_comp IS BOUND.
          o_list = _complist->clone( ).
          o_list->remove( o_comp ).
          o_subcomps = o_comp->get_subcomponents( ).
          IF o_subcomps IS NOT BOUND.
            CREATE OBJECT o_subcomps.
          ELSE.
            o_subcomps = o_subcomps->clone( ).    " Issue 49 : DO not use list itself because generate nested loop
          ENDIF.
          o_subcomps->add( o_comp ).
          IF o_list->is_included( o_subcomps ) = abap_true.
            _remove_component( o_comp ).
          ENDIF.
          o_comp = _complist->get_next( ).
        ENDWHILE.
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD create_new.
    CHECK NOT data-name IS INITIAL.
    CREATE OBJECT result
      EXPORTING
        o_file = o_file.
    result->data-public = data.
    result->data-version = version.
    result->data-class = zaplink_tools=>get_clas_name( result ).
    result->_update_header( ).
  ENDMETHOD.
  METHOD remove_components.
    DATA o_comp    TYPE zaplink_list=>to_component.
    CHECK object_list IS BOUND.
    TRY.
        object_list->order_kind = zaplink_list=>order_kinds-no_order.
        object_list->init_sel_iter( ).
        object_list->display_progress = abap_true.
        o_comp = object_list->get_next( ).
        WHILE o_comp IS BOUND.
          TRY.
              _remove_component( o_comp ).
            CATCH zaplink_cx_connector.
          ENDTRY.
          o_comp = object_list->get_next( ).
        ENDWHILE.
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
  ENDMETHOD.
  METHOD save_to_file.
    DATA _streamfactory TYPE REF TO if_ixml_stream_factory.
    DATA _outputstream  TYPE REF TO if_ixml_ostream.
    DATA _renderer      TYPE REF TO if_ixml_renderer.
    DATA _tempstring    TYPE string.
    DATA _printxmldoc   TYPE REF TO cl_xml_document.
    DATA _rc            TYPE sysubrc.
    DATA _file          TYPE to_file.
    DATA go_encoding    TYPE REF TO if_ixml_encoding.
    IF NOT xmldata IS BOUND.
      EXIT.
    ENDIF.
    _streamfactory = xmlengine->create_stream_factory( ).
    _outputstream = _streamfactory->create_ostream_cstring( _tempstring ).
    go_encoding = _outputstream->get_encoding( ).
    go_encoding->set_character_set( 'utf-8' ).    " issue 136
    _update_header( ).
    _renderer = xmlengine->create_renderer( document = xmldata
                                             ostream = _outputstream ).
    _renderer->set_normalizing( ).
    _rc = _renderer->render( ).
    CREATE OBJECT _printxmldoc.
    _rc = _printxmldoc->parse_string( _tempstring ).
    WHILE _tempstring(1) <> '<'.
      SHIFT _tempstring LEFT BY 1 PLACES.
    ENDWHILE.
    IF o_file IS BOUND.
      _file = o_file.
    ELSE.
      _file = file.
    ENDIF.
    TRY.
        _file->set_filecontent( _tempstring ).
        _file->save( ).
      CATCH zaplink_cx_file.
        RETURN.
    ENDTRY.
    file = _file.
  ENDMETHOD.
  METHOD _add_component.
    DATA o_connector TYPE zaplink_component=>to_connector.
    DATA root      TYPE REF TO if_ixml_element.
    DATA _base     TYPE REF TO if_ixml_node.
    DATA rval      TYPE i.
    DATA _comp     TYPE zaplink_component=>ts_component.
    DATA object    TYPE to_xml.
    DATA _index    LIKE LINE OF _nodeindex.
    DATA o_cx_cnx  TYPE REF TO zaplink_cx_connector.
    DATA o_cx_list TYPE REF TO zaplink_cx_list.
    CHECK component IS BOUND.
    TRY.
        _comp = component->get_key( ).
        o_connector = component->connector( ).
      CATCH zaplink_cx INTO o_cx.
        TRY.
            component->set_exception( o_cx ).
          CATCH zaplink_cx INTO o_cx.
            mac_cascade_raise o_mycx o_cx.
        ENDTRY.
        RAISE EXCEPTION TYPE zaplink_cx_container
          EXPORTING
            textid = zaplink_cx_container=>add_comp_failed
            type   = _comp-type
            name   = _comp-name.
    ENDTRY.
    ASSERT o_connector IS BOUND.
    TRY.
        o_connector->options = _options.
        object = o_connector->export_from_sap( component ).
        component->set_msg_coll( o_connector->application_log ).
        mac_add_log o_connector->application_log log 'W'.
      CATCH zaplink_cx_connector INTO o_cx_cnx.
        TRY.
            component->set_exception( o_cx_cnx ).
            component->set_msg_coll( o_connector->application_log ).
          CATCH zaplink_cx INTO o_cx.
            mac_cascade_raise o_mycx o_cx.
        ENDTRY.
        RAISE EXCEPTION TYPE zaplink_cx_container
          EXPORTING
            textid   = zaplink_cx_container=>add_comp_failed
            previous = o_cx_cnx
            type     = _comp-type
            name     = _comp-name.
      CATCH zaplink_cx INTO o_cx.
        mac_cascade_raise o_mycx o_cx.
    ENDTRY.
    IF NOT object IS BOUND.
      RAISE EXCEPTION TYPE zaplink_cx_container
        EXPORTING
          textid = zaplink_cx_container=>add_comp_failed
          type   = _comp-type
          name   = _comp-name.
    ENDIF.
    TRY.
        root = object->get_root_element( ).
        _base = get_root( ). " xmldata
        CHECK root IS BOUND.
        _remove_component( component ).
        rval = _base->append_child( root ).
        IF rval <> 0.
          EXIT.
        ENDIF.
        _search_components( root ).     " Issue 102 : to keep comp list up to date
      CATCH zaplink_cx_container INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD _remove_component.
    DATA node   TYPE REF TO if_ixml_node.
    DATA o_comp TYPE to_component.
    TRY.
        node = _find_component_node( component ).
        WHILE node IS BOUND.
          node->remove_node( ).
          IF sy-subrc = 0.
            DELETE _nodeindex WHERE node = node.
            o_comp = _complist->search( component ).
            IF o_comp IS BOUND.
              DELETE _nodeindex WHERE key = o_comp.
            ELSE. " for security
              DELETE _nodeindex WHERE key = component.
            ENDIF.
            _complist->remove( component ).
          ENDIF.
          node = _find_component_node( component ).
        ENDWHILE.
        mac_def_catch zaplink_cx_container.
    ENDTRY.
  ENDMETHOD.
  METHOD _update_header.
    DATA _root TYPE REF TO if_ixml_element.
    DATA _ezxml TYPE REF TO zaplink_easyxml.
    _root = xmldata->get_root_element( ).
    IF NOT _root IS BOUND.
      _root = xmldata->create_element( name = tn_container_root ).
      xmldata->if_ixml_node~append_child( _root ).
    ENDIF.
    CREATE OBJECT _ezxml.
    _ezxml->add_any( EXPORTING xml_node = _root
                                    any = data
                                 xmldoc = xmldata ).
  ENDMETHOD.
ENDCLASS. "ZAPLINK_CONTAINER implementation
CLASS zaplink_devc_raw IMPLEMENTATION.
  METHOD anonymize.
    DATA o_raw   TYPE to_mydata.
    IF raw IS BOUND.    o_raw ?= raw.   o_raw->anonymize( ).    ENDIF.
    super->anonymize( ).
  ENDMETHOD.
  METHOD constructor.
    DATA o_raw TYPE to_mydata.
    CALL METHOD super->constructor
      EXPORTING
        o_comp = o_comp.
    CREATE OBJECT o_raw.
    raw ?= o_raw.                   " Issue 50
  ENDMETHOD.
ENDCLASS. "ZAPLINK_DEVC_RAW implementation
CLASS zaplink_func_raw IMPLEMENTATION.
  METHOD anonymize.
    DATA o_raw   TYPE to_mydata.
    IF raw IS BOUND.    o_raw ?= raw.   o_raw->anonymize( ).    ENDIF.
    super->anonymize( ).
  ENDMETHOD.
  METHOD constructor.
    DATA o_comp  TYPE to_component.
    DATA o_raw   TYPE to_mydata.
    DATA o_conn  TYPE to_connector.
    IF fm_data IS INITIAL.    " create from ZL_EZXML
      CREATE OBJECT o_comp.
    ELSE.
      CREATE OBJECT o_comp.
      o_comp->set_type( zaplink_function_group=>supportedtypes-function ).   o_comp->set_name( fm_data-header-name ).
    ENDIF.
    CALL METHOD super->constructor
      EXPORTING
        o_comp = o_comp.
    CREATE OBJECT o_raw.
    raw ?= o_raw.
    IF NOT fm_data IS INITIAL.    o_raw->from_data( fm_data ).      CLEAR: o_raw->a0_maindata-name.     ENDIF.
    CREATE OBJECT o_conn TYPE zaplink_function_group.
    update_connector_data( o_conn ).
  ENDMETHOD.
  METHOD to_data.
    DATA o_raw   TYPE to_mydata.
    o_raw ?= raw.
    o_raw->a0_maindata-name = me->name.
    fm_data = o_raw->to_data( ).
  ENDMETHOD.
ENDCLASS. "ZAPLINK_FUNC_RAW implementation
CLASS zaplink_infos IMPLEMENTATION.
  METHOD class_constructor.
    DATA s_pack LIKE LINE OF cnx_packages.
    s_pack-sign = 'I'.    s_pack-option = 'EQ'.
    s_pack-low = '$TMP'.      APPEND s_pack TO cnx_packages.
    s_pack-low = 'ZAPLINK-CONNECTORS'.      APPEND s_pack TO cnx_packages.
    s_pack-low = 'ZAPLINK-CONNECTORS-MAIN'.      APPEND s_pack TO cnx_packages.
    s_pack-low = 'ZAPLINK-CONNECTORS-OTHERS'.      APPEND s_pack TO cnx_packages.
    c_class-type = 'CLAS'.    c_class-kind = zaplink_connectors=>get_typekind( c_class-type ).
    c_interface-type = 'INTF'.    c_interface-kind = zaplink_connectors=>get_typekind( c_interface-type ).
    c_program-type = 'PROG'.    c_program-kind = zaplink_connectors=>get_typekind( c_program-type ).
    c_typegroup-type = 'TYPE'.    c_typegroup-kind = zaplink_connectors=>get_typekind( c_typegroup-type ).
    c_msg_class-type = 'MSAG'.    c_msg_class-kind = zaplink_connectors=>get_typekind( c_msg_class-type ).
  ENDMETHOD.
  METHOD constructor.
    me->get_sap_data( ).
    me->get_zl_data( ).
  ENDMETHOD.
  METHOD get_sap_data.
    TYPES:
      BEGIN OF ts_ver_tab,
        line(80) TYPE c,
      END OF ts_ver_tab.
    DATA version_info TYPE STANDARD TABLE OF ts_ver_tab.
    FIELD-SYMBOLS:
      <v> LIKE LINE OF version_info.
    TYPES:
      BEGIN OF ts_ver_info,
        name  TYPE string,
        value TYPE string,
      END OF ts_ver_info.
    DATA t_values_ver TYPE STANDARD TABLE OF ts_ver_info.
    DATA s_value LIKE LINE OF t_values_ver.
    DATA d_char(255) TYPE c.
    DATA it_comptab    TYPE STANDARD TABLE OF spam_cvers.
    DATA s_comp        LIKE LINE OF sap-_components.
    FIELD-SYMBOLS:
      <c> LIKE LINE OF it_comptab.
    DEFINE mac_read_val.
      READ TABLE t_values_ver INTO s_value
           WITH KEY name = &1.
      IF sy-subrc = 0.    &2 = s_value-value.   ENDIF.
    END-OF-DEFINITION.
    CALL 'SAPCORE' ID 'ID' FIELD 'VERSION'
                   ID 'TABLE' FIELD version_info.
    LOOP AT version_info ASSIGNING <v>.
      CLEAR s_value.
      s_value-name = <v>(21).   s_value-value = <v>+21.
      APPEND s_value TO t_values_ver.
    ENDLOOP.
    mac_read_val:
      'SAP version' sap-status-sap_ver,                     "#EC NOTEXT
      'operating system' sap-status-os,                     "#EC NOTEXT
      'machine type' sap-status-machine_type,               "#EC NOTEXT
      'database system' sap-status-db_sys,                  "#EC NOTEXT
      'kernel release' sap-status-kernel,                   "#EC NOTEXT
      'database library' sap-status-db_lib,                 "#EC NOTEXT
      'ABAP load version' sap-status-abap_ver,              "#EC NOTEXT
      'CUA load version' sap-status-cua_ver.                "#EC NOTEXT
    CALL FUNCTION 'DB_GET_RELEASE'
      IMPORTING
        release = d_char.
    sap-status-db_release = d_char.
    IF cl_abap_char_utilities=>charsize = 1.
      sap-status-unicode = 'Yes'(oui).
    ELSE.
      sap-status-unicode = 'No'(non).
    ENDIF.
    CALL FUNCTION 'SPAM_READ_PAT03'
      TABLES
        tt_pat03_selected          = sap-_hot_packages
      EXCEPTIONS
        wrong_release_string       = 1
        wrong_patch_type           = 2
        no_component_available     = 3
        wrong_component_id_release = 4
        wrong_addon_id_release     = 5
        OTHERS                     = 6.
    IF sy-subrc <> 0.   CLEAR sap-_hot_packages.    ENDIF.
    SORT sap-_hot_packages BY component  ASCENDING
                              addon_id   ASCENDING
                              imple_date ASCENDING
                              imple_time ASCENDING.
    CALL FUNCTION 'OCS_GET_INSTALLED_COMPS'
      TABLES
        tt_comptab = it_comptab
      EXCEPTIONS
        OTHERS     = 0.
    CALL FUNCTION 'OCS_SORT_COMPS_HIERARCHICAL'
      TABLES
        tt_comptab = it_comptab
      EXCEPTIONS
        OTHERS     = 0.
    LOOP AT it_comptab ASSIGNING <c>.
      CLEAR s_comp.   s_comp-hdr = <c>.
      IF sy-saprl < '701'.                                    " Issue 90
        CALL FUNCTION 'OCS_GET_COMPONENT_STATE'
          EXPORTING
            iv_component      = <c>-component
          IMPORTING
            ev_comp_rel       = s_comp-release
            ev_comp_type      = s_comp-comp_type
            ev_comp_level     = s_comp-level
            ev_comp_spp_level = s_comp-spp_level
            ev_last_patch     = s_comp-high_package
            ev_last_spp       = s_comp-high_spp
            ev_comp_active    = s_comp-active
            ev_comp_patchable = s_comp-patchable
            ev_is_subcomp     = s_comp-state
          EXCEPTIONS
            unknown_component = 1
            OTHERS            = 2.
      ELSE.
        CALL FUNCTION 'OCS_GET_COMPONENT_STATE'
          EXPORTING
            iv_component      = <c>-component
          IMPORTING
            ev_comp_rel       = s_comp-release
            ev_comp_type      = s_comp-comp_type
            ev_comp_level     = s_comp-level
            ev_last_patch     = s_comp-high_package
            ev_comp_active    = s_comp-active
            ev_comp_patchable = s_comp-patchable
            ev_is_subcomp     = s_comp-state
          EXCEPTIONS
            unknown_component = 1
            OTHERS            = 2.
      ENDIF.
      IF sy-subrc = 0.    APPEND s_comp TO sap-_components.   ENDIF.
    ENDLOOP.
  ENDMETHOD.
  METHOD get_zl_data.
    DATA t_comps      TYPE tt_compkeys.
    DATA r_packages   TYPE tr_packages.
    DATA s_package    LIKE LINE OF r_packages.
    DATA s_comp       LIKE LINE OF zaplink-components.
    DATA o_list       TYPE to_list.
    DATA o_cnx        TYPE to_connector.
    DATA o_raw        TYPE to_raw.
    DATA o_ref        TYPE REF TO cl_abap_classdescr.
    DATA o_comp       TYPE to_component.
    DATA o_c_n        TYPE to_component.
    DATA i_sign       TYPE ti_code_signature.
    DATA s_cnx        LIKE LINE OF zaplink-connectors.
    DATA s_subcomp    LIKE LINE OF s_cnx-_components.
    DATA _comp        TYPE ts_component.
    DATA cnx_name     TYPE seoclskey.
    DATA o_generator  TYPE to_generator.
    DATA d_classname  TYPE td_classname.
    DATA o_cnxcomp    TYPE to_component.
    DATA t_global_c   TYPE tt_zl_comps.
    DATA t_commun_c   TYPE tt_zl_comps.
    DATA d_cnx        LIKE LINE OF t_global_c.
    DATA d_kind       TYPE td_transport_kind.
    DATA _regex TYPE string.
    FIELD-SYMBOLS:
      <st> LIKE LINE OF o_cnx->supported_types,
      <x>  LIKE LINE OF zaplink-connectors,
      <sc> LIKE LINE OF <x>-_components,
      <o>  LIKE LINE OF o_generator->all_components,
      <c>  LIKE LINE OF t_comps.
    zaplink-framework_version = framework_version.
    o_list = zaplink_connectors_4inst=>get_connectorlist( ).
    o_list->select_default( zaplink_list=>sel_actions-export ).
    o_list->order_kind = zaplink_list=>order_kinds-no_order.
    o_list->init_sel_iter( ).
    o_list->display_progress = abap_true.
    o_c_n = o_list->get_next( ).
    WHILE o_c_n IS BOUND.
      o_comp = o_c_n.     o_c_n = o_list->get_next( ).
      CLEAR: s_cnx, _comp.
      _comp = o_comp->get_key( ).
      d_kind = o_comp->get_typekind( ).
      CREATE OBJECT o_cnx TYPE (_comp-name).
      s_cnx-hdr = _comp.    s_cnx-uuid = o_cnx->uuid.     s_cnx-version = o_cnx->version.   s_cnx-supported_types = o_cnx->supported_types.
      cnx_name-clsname = _comp-name.  s_cnx-signature = zaplink_object=>get_class_signature( cnx_name ).
      SELECT SINGLE devclass INTO s_cnx-devclass
        FROM tadir
        WHERE    pgmid = d_kind
          AND   object = _comp-type
          AND obj_name = _comp-name.
      CREATE OBJECT o_generator.
      o_generator->packages = cnx_packages.
      d_classname = _comp-name.
      o_generator->add_object( d_classname ).
      LOOP AT o_generator->all_components ASSIGNING <o>.
        CHECK <o>-type <> _comp-type OR <o>-name <> _comp-name.
        CLEAR s_subcomp.    s_subcomp-name = <o>-name.    s_subcomp-type = <o>-type.    s_subcomp-devclass = <o>-devclass.
        READ TABLE t_commun_c TRANSPORTING NO FIELDS
             WITH TABLE KEY type = s_subcomp-type
                            name = s_subcomp-name.
        CHECK sy-subrc <> 0.    " not commun comp
        READ TABLE t_global_c TRANSPORTING NO FIELDS
             WITH TABLE KEY type = s_subcomp-type
                            name = s_subcomp-name.
        IF sy-subrc = 0.
          INSERT s_subcomp INTO TABLE t_commun_c.   " component is present twice time on 2 differents connectors
          CONTINUE.
        ENDIF.
        INSERT s_subcomp INTO TABLE s_cnx-_components.
        CLEAR d_cnx. d_cnx-name = s_subcomp-name.   d_cnx-type = s_subcomp-type.
        INSERT d_cnx INTO TABLE t_global_c.
      ENDLOOP.
      TRY.
          CONCATENATE '\\' c_class-type '=' INTO _regex.
          LOOP AT o_cnx->supported_types ASSIGNING <st>.
            o_raw = o_cnx->create_new_raw( <st>-type ).
            CHECK o_raw->raw IS BOUND.
            CLEAR s_subcomp.    s_subcomp-name = cl_abap_classdescr=>get_class_name( o_raw->raw ).    s_subcomp-type = c_class-type.
            REPLACE FIRST OCCURRENCE OF REGEX _regex IN s_subcomp-name WITH ``.
            SELECT SINGLE devclass INTO s_subcomp-devclass
              FROM v_tralan
              WHERE pgmid = c_class-kind
                AND object = s_subcomp-type
                AND obj_name = s_subcomp-name.
            s_subcomp-raw_data_type = abap_true.
            MODIFY TABLE s_cnx-_components FROM s_subcomp.
            IF sy-subrc <> 0.   INSERT s_subcomp INTO TABLE s_cnx-_components.    ENDIF.
            CLEAR d_cnx. d_cnx-name = s_subcomp-name.   d_cnx-type = s_subcomp-type.
            INSERT d_cnx INTO TABLE t_global_c.
          ENDLOOP.
      ENDTRY.
      IF NOT s_cnx IS INITIAL.  INSERT s_cnx INTO TABLE zaplink-connectors.   ENDIF.
      CLEAR d_cnx. d_cnx-name = _comp-name.
      IF NOT d_cnx IS INITIAL.  d_cnx-type = c_class-type.  INSERT d_cnx INTO TABLE t_global_c.   ENDIF.
    ENDWHILE.
    LOOP AT zaplink-connectors ASSIGNING <x>.
      LOOP AT <x>-_components ASSIGNING <sc>
              WHERE raw_data_type = abap_false.
        READ TABLE t_commun_c TRANSPORTING NO FIELDS
             WITH TABLE KEY type = <sc>-type
                            name = <sc>-name.
        CHECK sy-subrc = 0.                 " component is a commun comp
        DELETE TABLE <x>-_components FROM <sc>.
      ENDLOOP.
      LOOP AT <x>-_components ASSIGNING <sc>.
        o_comp = zaplink_component_4inst=>create_new( <sc>-hdr ).
        CHECK o_comp IS BOUND.    o_cnx = o_comp->connector( ).
        CHECK o_cnx IS BOUND.
        CHECK o_cnx->do_exists( o_comp ) = abap_true.
        TRY.
            i_sign ?= o_cnx.
            <sc>-signature = i_sign->get_signature( o_comp ).
          CATCH cx_root.
        ENDTRY.
        DELETE TABLE t_commun_c FROM <sc>.
      ENDLOOP.
      DELETE TABLE t_commun_c
             WITH TABLE KEY type = <x>-type
                            name = <x>-name.
    ENDLOOP.
    s_package-sign = 'I'. s_package-option = 'EQ'.    s_package-low = 'ZAPLINK'.
    APPEND s_package TO r_packages.
    t_comps = zaplink_tools=>get_keys_from_package( packages = r_packages ).
    SORT t_comps BY type name.
    LOOP AT t_comps ASSIGNING <c>.
      READ TABLE t_global_c TRANSPORTING NO FIELDS
           WITH TABLE KEY type = <c>-type
                          name = <c>-name.
      IF sy-subrc = 0.
        READ TABLE t_commun_c TRANSPORTING NO FIELDS
             WITH TABLE KEY type = <sc>-type
                            name = <sc>-name.
        IF sy-subrc <> 0.
          CONTINUE.
        ENDIF.
      ENDIF.
      CLEAR s_comp.   s_comp-hdr = <c>.
      o_comp = zaplink_component_4inst=>create_new( <c> ).
      CHECK o_comp IS BOUND.    o_cnx = o_comp->connector( ).
      CHECK o_cnx IS BOUND.
      CHECK o_cnx->do_exists( o_comp ) = abap_true.
      d_kind = o_comp->get_typekind( ).
      SELECT SINGLE devclass INTO s_comp-devclass
        FROM tadir
        WHERE    pgmid = d_kind
          AND   object = <c>-type
          AND obj_name = <c>-name.
      TRY.
          i_sign ?= o_cnx.
        CATCH cx_root.
      ENDTRY.
      IF i_sign IS BOUND.   s_comp-signature = i_sign->get_signature( o_comp ).     ENDIF.
      APPEND s_comp TO zaplink-components.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_INFOS implementation
CLASS zaplink_pinf_raw IMPLEMENTATION.
  METHOD anonymize.
    DATA o_raw   TYPE to_mydata.
    IF raw IS BOUND.    o_raw ?= raw.   o_raw->anonymize( ).    ENDIF.
    super->anonymize( ).
  ENDMETHOD.
  METHOD constructor.
    DATA o_raw TYPE to_mydata.
    CALL METHOD super->constructor
      EXPORTING
        o_comp = o_comp.
    CREATE OBJECT o_raw.
    raw ?= o_raw.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_PINF_RAW implementation
CLASS zaplink_program_4dep_analyser IMPLEMENTATION.
  METHOD constructor.
    super->constructor( ).
    CLEAR: supported_types, uuid, version.     " Prevent having 2 connectors for the same UUID
  ENDMETHOD.
ENDCLASS. "ZAPLINK_PROGRAM_4DEP_ANALYSER implementation
CLASS zaplink_standalone_generator IMPLEMENTATION.
  METHOD active_report.
    DATA o_activ      TYPE REF TO zaplink_activate.
    DATA t_comps      TYPE tt_compkeys.
    DATA s_key        LIKE LINE OF t_comps.
    DATA f_err        TYPE abap_bool.
    s_key-type = 'PROG'.   s_key-name = name.   APPEND s_key TO t_comps.
    CREATE OBJECT o_activ.
    o_activ->add_keys( t_comps ).
    t_comps = o_activ->activate( ).
    IF NOT t_comps IS INITIAL.
      RAISE EXCEPTION TYPE zaplink_cx_release
        EXPORTING
          textid         = zaplink_cx_release=>generation_failed
          target_program = name.
    ENDIF.
  ENDMETHOD.
  METHOD add_connectors.
    DATA _line LIKE LINE OF connectors_sourcecode.
    DATA _comp TYPE REF TO zaplink_component.
    DATA _classname TYPE zaplink_component=>td_connclass.
    DATA o_conn TYPE REF TO zaplink_connector.
    DATA _classes TYPE SORTED TABLE OF zaplink_component=>td_connclass WITH UNIQUE KEY table_line.
    FIELD-SYMBOLS:
      <c> LIKE LINE OF zaplink_connectors=>supported_types.
    REFRESH connectors_sourcecode.
    add_object( 'ZAPLINK_CONNECTORS' ).                     "#EC NOTEXT
    _line = 'ZAPLINK_CONNECTORS=>clear_connectors( ).'. APPEND _line TO connectors_sourcecode. "#EC NOTEXT : remove ABAP class connector to add only local ones
    _line = 'DATA _cx_90335e5d44316adf4805a732f type ref to ZAPLINK_CX_COMPONENT.'. APPEND _line TO connectors_sourcecode. "#EC NOTEXT
    _line = 'TRY.'. APPEND _line TO connectors_sourcecode.  "#EC NOTEXT
    LOOP AT zaplink_connectors=>supported_types ASSIGNING <c>.
      CREATE OBJECT _comp.
      _comp->set_type( <c>-type ).
      o_conn = _comp->connector( ).
      _classname = zaplink_connectors=>get_classname( o_conn ).
      CHECK NOT _classname IS INITIAL.
      READ TABLE _classes TRANSPORTING NO FIELDS
           WITH TABLE KEY table_line = _classname.
      IF sy-subrc <> 0.
        INSERT _classname INTO TABLE _classes.
        add_object( _classname ).
        CLEAR _line.
        CONCATENATE 'ZAPLINK_CONNECTORS=>ADD_LOCAL_CONNECTOR(''' _classname ''').' INTO _line. "#EC NOTEXT
        APPEND _line TO connectors_sourcecode.
      ENDIF.
    ENDLOOP.
    _line = 'CATCH ZAPLINK_CX_COMPONENT INTO _cx_90335e5d44316adf4805a732f.'. APPEND _line TO connectors_sourcecode. "#EC NOTEXT
    _line = '_cx_90335e5d44316adf4805a732f->write( ).'. APPEND _line TO connectors_sourcecode. "#EC NOTEXT
    _line = 'BREAK-POINT.'. APPEND _line TO connectors_sourcecode. "#EC NOTEXT
    _line = 'RAISE EXCEPTION _cx_90335e5d44316adf4805a732f.'. APPEND _line TO connectors_sourcecode. "#EC NOTEXT
    _line = 'ENDTRY.'. APPEND _line TO connectors_sourcecode. "#EC NOTEXT
  ENDMETHOD.
  METHOD add_data_element.
    DATA s_data  LIKE LINE OF data_order.
    s_data-name = name. TRANSLATE s_data-name TO UPPER CASE. "#EC SYNTCHAR
    SELECT SINGLE datatype leng INTO (s_data-type, s_data-len)
      FROM dd04l
      WHERE rollname = s_data-name
        AND as4local = 'A'
        AND as4vers = '0000'.
    IF sy-subrc = 0.
      READ TABLE data_order TRANSPORTING NO FIELDS WITH KEY name = s_data-name.
      IF sy-subrc <> 0.
        APPEND s_data TO data_order.
      ENDIF.
    ENDIF.
  ENDMETHOD.
  METHOD constructor.
    DATA sourcecode  TYPE tt_abaprawsource.
    super->constructor( ).
    master_program = master.
    IF NOT master_program IS INITIAL.
      master_sourcecode = sourcecode = zaplink_program_4dep_analyser=>get_prog_rawsource( master_program ). " Issue 110
      add_source( code = sourcecode   origin = master_program ).
    ENDIF.
  ENDMETHOD.
  METHOD generate.
    DATA _tmp_code TYPE ts_source.
    DATA _line     LIKE LINE OF _tmp_code-def.
    DATA _tmp      TYPE tt_abaprawsource.
    DATA _pos      TYPE sy-tabix.
    DATA _order    TYPE tt_order.
    DATA d_report  TYPE programm.
    FIELD-SYMBOLS:
      <t> LIKE LINE OF typegroups,
      <i> LIKE LINE OF includes,
      <c> LIKE LINE OF classes,
      <u> LIKE LINE OF other_comps,
      <o> LIKE LINE OF order.
    DATA t_tokens TYPE STANDARD TABLE OF stokes.
    DATA t_statements TYPE STANDARD TABLE OF sstmnt.
    DATA t_kw      TYPE STANDARD TABLE OF char255.
    DATA s_kw      LIKE LINE OF t_kw.
    DATA s_line    LIKE LINE OF code.
    DATA d_type    TYPE string.
    FIELD-SYMBOLS:
      <t_deb> LIKE LINE OF t_tokens,
      <data>  LIKE LINE OF data_order,
      <st>    LIKE LINE OF t_statements.
    resolve( ).
    LOOP AT typegroups ASSIGNING <t>.   IF _line IS INITIAL. CONCATENATE 'TYPE-POOLS: ' <t>-name INTO _line. ELSE. CONCATENATE _line ', ' <t>-name INTO _line. ENDIF.   ENDLOOP.
    IF NOT _line IS INITIAL. CONCATENATE _line '.' INTO _line. APPEND _line TO code. ENDIF.
    LOOP AT data_order ASSIGNING <data>.
      CLEAR s_line.
      CASE <data>-type.
        WHEN 'ACCP'.  " Posting period YYYYMM
          CONCATENATE 'TYPES ' <data>-name '(6) TYPE N.' INTO s_line.
        WHEN 'CHAR'.  " Character String
          d_type = 'C'.
        WHEN 'CLNT'.  " Client
          CONCATENATE 'TYPES ' <data>-name ' LIKE SY-MANDT.' INTO s_line.
        WHEN 'CUKY'.  " Currency key, referenced by CURR fields
          CONCATENATE 'TYPES ' <data>-name ' LIKE SY-MANDT.' INTO s_line.
        WHEN 'CURR'.  " Currency field, stored as DEC
        WHEN 'DATS'.  " Date field (YYYYMMDD) stored as char(8)
          CONCATENATE 'TYPES ' <data>-name ' LIKE SY-DATUM.' INTO s_line.
        WHEN 'DEC'.  " Counter or amount field with comma and sign
        WHEN 'FLTP'.  " Floating point number, accurate to 8 bytes
          d_type = 'F'.
        WHEN 'INT1'.  " 1-byte integer, integer number <= 255
          CONCATENATE 'TYPES ' <data>-name ' TYPE B.' INTO s_line.
        WHEN 'INT2'.  " 2-byte integer, only for length field before LCHR or LRAW
          CONCATENATE 'TYPES ' <data>-name ' TYPE S.' INTO s_line.
        WHEN 'INT4'.  " 4-byte integer, integer number with sign
          CONCATENATE 'TYPES ' <data>-name ' TYPE I.' INTO s_line.
        WHEN 'LANG'.  " Language key
          CONCATENATE 'TYPES ' <data>-name ' LIKE SY-LANGU.' INTO s_line.
        WHEN 'LCHR'.  " Long character string, requires preceding INT2 field
          d_type = 'C'.
        WHEN 'LRAW'.  " Long byte string, requires preceding INT2 field
          d_type = 'X'.
        WHEN 'NUMC'.  " Character string with only digits
          d_type = 'N'.
        WHEN 'PREC'.  " Precision of a QUAN field
        WHEN 'QUAN'.  " Quantity field, points to a unit field with format UNIT
        WHEN 'RAW'  " Uninterpreted sequence of bytes
          OR 'RAWSTRING'.  " Byte String of Variable Length
          CONCATENATE 'TYPES ' <data>-name ' XSTRING.' INTO s_line.
        WHEN 'SSTRING'  " Short Character String of Variable Length
          OR 'STRING'.  " Character String of Variable Length
          CONCATENATE 'TYPES ' <data>-name ' STRING.' INTO s_line.
        WHEN 'TIMS'.  " Time field (hhmmss), stored as char(6)
          CONCATENATE 'TYPES ' <data>-name ' LIKE SY-UZEIT.' INTO s_line.
        WHEN 'UNIT'.  " Unit key for QUAN fields
        WHEN 'VARC'.  " Long character string, no longer supported from Rel. 3.0
          d_type = 'C'.
      ENDCASE.
      IF s_line IS INITIAL.
        sy-tabix = <data>-len.
        s_line = sy-tabix. CONDENSE s_line.
        CONCATENATE <data>-name '(' s_line ')' INTO s_line.
        CONCATENATE 'TYPES' s_line 'TYPE' d_type '.' INTO s_line SEPARATED BY space.
      ENDIF.
      APPEND s_line TO code.
    ENDLOOP.
    _order = order.
    SORT _order BY name type.
    DELETE ADJACENT DUPLICATES FROM _order COMPARING name.
    LOOP AT _order ASSIGNING <o>.
      add_deferred_code( EXPORTING     type = <o>-type
                                       name = <o>-name
                          CHANGING abapcode = code ).
    ENDLOOP.
    LOOP AT other_comps ASSIGNING <u>.
      APPEND <u>-source TO code.
    ENDLOOP.
    LOOP AT order ASSIGNING <o>.
      IF NOT <o>-defered IS INITIAL.
        add_deferred_code( EXPORTING     type = <o>-type
                                         name = <o>-name
                            CHANGING abapcode = _tmp_code-def ).
      ELSE.
        READ TABLE classes ASSIGNING <c>
             WITH TABLE KEY name = <o>-name.
        IF sy-subrc <> 0.
          CONTINUE.
        ENDIF.
        APPEND LINES OF <c>-def TO _tmp_code-def.
        APPEND LINES OF <c>-macro TO _tmp_code-macro.
        APPEND LINES OF <c>-impl TO _tmp_code-impl.
      ENDIF.
    ENDLOOP.
    APPEND LINES OF _tmp_code-def TO code.
    s_kw = 'PROGRAM'.    APPEND s_kw TO t_kw.
    s_kw = 'REPORT'.     APPEND s_kw TO t_kw.
    LOOP AT includes ASSIGNING <i>.
      d_report = <i>.   CLEAR _tmp.
      READ REPORT d_report INTO _tmp.
      CHECK sy-subrc = 0.
      SCAN ABAP-SOURCE _tmp TOKENS INTO t_tokens
                        STATEMENTS INTO t_statements
                          KEYWORDS FROM t_kw.
      zaplink_tools=>inverse_table_order( CHANGING my_table = t_statements ).
      LOOP AT t_statements ASSIGNING <st>.
        READ TABLE t_tokens ASSIGNING <t_deb> INDEX <st>-from.    CHECK sy-subrc = 0.
        DELETE _tmp FROM <t_deb>-row TO <st>-trow.
      ENDLOOP.
      APPEND LINES OF _tmp TO code.
    ENDLOOP.
    APPEND LINES OF _tmp_code-macro TO code.
    APPEND LINES OF _tmp_code-impl TO code.
    abap_sourcecode = master_sourcecode.
    IF NOT abap_sourcecode IS INITIAL.
      REFRESH t_kw.
      s_kw = 'START-OF-SELECTION'.    APPEND s_kw TO t_kw.
      s_kw = 'REPORT'.                APPEND s_kw TO t_kw.
      SCAN ABAP-SOURCE abap_sourcecode TOKENS INTO t_tokens
                                   STATEMENTS INTO t_statements
                                     KEYWORDS FROM t_kw.
      IF NOT connectors_sourcecode IS INITIAL.
        READ TABLE t_tokens ASSIGNING <t_deb> WITH KEY str = 'START-OF-SELECTION'.
        ASSERT sy-subrc = 0.  _pos = sy-tabix.
        READ TABLE t_statements ASSIGNING <st> WITH KEY from = _pos.
        ASSERT sy-subrc = 0.
        READ TABLE t_tokens ASSIGNING <t_deb> INDEX <st>-to.
        ASSERT sy-subrc = 0.
        _pos = <t_deb>-row + 1.
        INSERT LINES OF connectors_sourcecode INTO abap_sourcecode INDEX _pos.
      ENDIF.
      READ TABLE t_tokens ASSIGNING <t_deb> WITH KEY str = 'REPORT'.
      ASSERT sy-subrc = 0.  _pos = sy-tabix.
      READ TABLE t_statements ASSIGNING <st> WITH KEY from = _pos.
      ASSERT sy-subrc = 0.
      READ TABLE t_tokens ASSIGNING <t_deb> INDEX <st>-to.
      ASSERT sy-subrc = 0.
      _pos = <t_deb>-row + 1.
      INSERT LINES OF code INTO abap_sourcecode INDEX _pos.
      code = abap_sourcecode.
    ENDIF.
    remove_checkpoints( CHANGING code = code ).               " Issue 107
    zaplink_tools=>remove_comment_on_source( CHANGING table = code ).
    abap_sourcecode = code.
  ENDMETHOD.
  METHOD remove_checkpoints.
    DATA c_log        TYPE string VALUE 'LOG-POINT'.
    DATA c_assert     TYPE string VALUE 'ASSERT'.
    DATA c_break      TYPE string VALUE 'BREAK-POINT'.
    DATA t_tokens     TYPE STANDARD TABLE OF stokes.
    DATA t_statements TYPE STANDARD TABLE OF sstmnt.
    DATA t_kw         TYPE STANDARD TABLE OF char255.
    DATA s_kw         LIKE LINE OF t_kw.
    DATA d_line       TYPE i.
    FIELD-SYMBOLS:
      <t_deb> LIKE LINE OF t_tokens,
      <st>    LIKE LINE OF t_statements.
    s_kw = c_assert.      APPEND s_kw TO t_kw.
    s_kw = c_log.         APPEND s_kw TO t_kw.
    s_kw = c_break.       APPEND s_kw TO t_kw.
    SCAN ABAP-SOURCE code TOKENS INTO t_tokens
                      STATEMENTS INTO t_statements
                        KEYWORDS FROM t_kw.
    zaplink_tools=>inverse_table_order( CHANGING my_table = t_statements ).
    LOOP AT t_statements ASSIGNING <st>.
      READ TABLE t_tokens ASSIGNING <t_deb> INDEX <st>-from.    CHECK sy-subrc = 0.
      CASE <t_deb>-str.
        WHEN c_log.
        WHEN OTHERS.
          d_line = <st>-from + 1.   CHECK d_line <= <st>-to.
          READ TABLE t_tokens ASSIGNING <t_deb> INDEX d_line.    CHECK sy-subrc = 0.
          IF <t_deb>-str <> 'ID'.   CONTINUE.   ENDIF.
      ENDCASE.
      zaplink_tools=>comment_statement( EXPORTING statement = <st>
                                                     tokens = t_tokens
                                              CHANGING code = code ).
    ENDLOOP.
  ENDMETHOD.
  METHOD save_report.
    DATA t_source    TYPE tt_abaprawsource.
    DATA _prog       TYPE progdir.
    DATA _oname      TYPE e071-obj_name.
    IF code IS INITIAL.
      t_source = abap_sourcecode.
    ELSE.
      t_source = code.
      zaplink_tools=>remove_comment_on_source( CHANGING table = t_source ).
    ENDIF.
    CALL FUNCTION 'RS_CORR_INSERT'
      EXPORTING
        object              = report
        object_class        = 'ABAP'
        mode                = 'I'    " Insert
        devclass            = package
      EXCEPTIONS
        cancelled           = 1
        permission_failure  = 2
        unknown_objectclass = 3
        OTHERS              = 4.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    _oname = report.
    CALL FUNCTION 'RS_INSERT_INTO_WORKING_AREA'
      EXPORTING
        object            = 'REPS'
        obj_name          = _oname
      EXCEPTIONS
        wrong_object_name = 1
        OTHERS            = 2.
    IF sy-subrc <> 0.
      MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    _prog-name = report.
    _prog-state = 'I'.
    _prog-edtx = 'X'.
    _prog-varcl = 'X'.
    _prog-rstat = 'T'.
    _prog-vern = 1.
    _prog-subc = '1'.    "Executable program
    _prog-unam = _prog-cnam = sy-uname.
    _prog-sdate = _prog-idate = _prog-udat = _prog-cdat = sy-datum.
    _prog-stime = _prog-itime = sy-uzeit.
    _prog-rmand = sy-mandt.
    _prog-rload = sy-langu.
    MODIFY progdir FROM _prog.
    zaplink_program_4dep_analyser=>set_prog_rawsource( program = report
                                                           raw = t_source ). " Issue 110
    set_textpool( report ).
    saved_program = report.
  ENDMETHOD.
  METHOD scan_report.
    DATA d_prog TYPE td_progname.
    DATA t_list       TYPE tt_uc_comps.
    DATA l_tabix      TYPE i.
    FIELD-SYMBOLS:
      <n> LIKE LINE OF t_list,
      <c> LIKE LINE OF t_list.
    IF program IS INITIAL.    d_prog = saved_program.     ELSE.     d_prog = program.   ENDIF.
    SELECT u~otype d~object u~name INTO TABLE t_list
      FROM wbcrossgt AS u INNER JOIN tadir AS d ON d~pgmid = 'R3TR'
                                               AND d~obj_name = u~name
      WHERE include = d_prog
        AND direct = abap_true
        AND srcsystem = sy-sysid.
    SORT t_list BY name c_type t_type.
    LOOP AT t_list ASSIGNING <c>.
      result = abap_true.
      CASE <c>-c_type.
        WHEN cl_abap_compiler=>tag_type.    " Missing Type
          SELECT SINGLE typekind INTO <c>-t_type
            FROM ddtypes
            WHERE typename = <c>-name.
          CASE <c>-t_type.
            WHEN 'DTEL'.  add_data_element( <c>-name ).
          ENDCASE.
      ENDCASE.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_STANDALONE_GENERATOR implementation
CLASS zaplink_sxci_data IMPLEMENTATION.
  METHOD anonymize.
    DATA o_conn    TYPE to_connector.
    DATA o_cleaner TYPE REF TO zaplink_cnx_ext_cleaner.
    CLEAR: a0_maindata-uname, a0_maindata-udate, a0_maindata-utime,a0_maindata-aname, a0_maindata-adate, a0_maindata-atime.
    IF implementation IS BOUND.
      o_conn = zaplink_connectors=>create_connector( type = implementation->type
                                                 connuuid = implementation->connector ).
      TRY.
          o_cleaner ?= o_conn.
          o_cleaner->anonymize( implementation ).
        CATCH cx_root.
      ENDTRY.
    ENDIF.
    super->anonymize( ).
  ENDMETHOD.
  METHOD from_data.
    def_name = fm_data-implementation-exit_name.
    CALL METHOD super->from_data
      EXPORTING
        fm_data = fm_data.
    a0_maindata-main = fm_data-implementation.
    a0_maindata-mast_langu = fm_data-mast_langu.
    filter-enhanceable = fm_data-impl_w_filter.
    filter-datatype = fm_data-filter_datatype.
    filter-values = fm_data-filter_values.
  ENDMETHOD.
  METHOD to_data.
    def_name = a0_maindata-exit_name.
    CALL METHOD super->to_data
      RECEIVING
        fm_data = fm_data.
    fm_data-implementation = a0_maindata-main.
    fm_data-mast_langu = a0_maindata-mast_langu.
    fm_data-impl_w_filter = filter-enhanceable.
    fm_data-filter_datatype = filter-datatype.
    fm_data-filter_values = filter-values.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_SXCI_DATA implementation
CLASS zaplink_sxsd_data IMPLEMENTATION.
  METHOD anonymize.
    DATA o_conn    TYPE to_connector.
    DATA o_cleaner TYPE REF TO zaplink_cnx_ext_cleaner.
    CLEAR: a0_maindata-uname, a0_maindata-udate, a0_maindata-utime.
    IF interface IS BOUND.
      o_conn = zaplink_connectors=>create_connector( type = interface->type
                                                 connuuid = interface->connector ).
      TRY.
          o_cleaner ?= o_conn.
          o_cleaner->anonymize( interface ).
        CATCH cx_root.
      ENDTRY.
    ENDIF.
    TRY.
        super->anonymize( ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD constructor.
    super->constructor( ).
  ENDMETHOD.
  METHOD from_data.
    DATA _fc    LIKE LINE OF functions_codes.
    DATA _cc    LIKE LINE OF controls_composites.
    DATA _scr   LIKE LINE OF subscreens.
    DATA _t     LIKE LINE OF tables.
    FIELD-SYMBOLS:
      <fc>  LIKE LINE OF fm_data-fcodes,
      <cc>  LIKE LINE OF fm_data-cocos,
      <in>  LIKE LINE OF fm_data-intas,
      <scr> LIKE LINE OF fm_data-scrns,
      <me>  LIKE LINE OF fm_data-methods,
      <it>  LIKE LINE OF fm_data-inactive_tabstrips.
    a0_maindata-main = fm_data-definition.
    a0_maindata-mast_langu = fm_data-mast_langu.
    a0_maindata-ext_clname = fm_data-ext_clname.
    LOOP AT fm_data-intas ASSIGNING <in>
      WHERE exit_name = a0_maindata-exit_name.
      CLEAR _t.
      _t = <in>.
      CLEAR: _t-exit_name. " VERSION
      INSERT _t INTO TABLE tables.
    ENDLOOP.
    LOOP AT fm_data-cocos ASSIGNING <cc>
      WHERE exit_name = a0_maindata-exit_name.
      CLEAR _cc.
      _cc = <cc>.
      CLEAR: _cc-exit_name. " VERSION
      INSERT _cc INTO TABLE controls_composites.
    ENDLOOP.
    LOOP AT fm_data-fcodes ASSIGNING <fc>
      WHERE exit_name = a0_maindata-exit_name.
      CLEAR _fc.
      _fc = <fc>.
      CLEAR: _fc-exit_name. " VERSION
      INSERT _fc INTO TABLE functions_codes.
    ENDLOOP.
    LOOP AT fm_data-scrns ASSIGNING <scr>
      WHERE exit_name = a0_maindata-exit_name.
      CLEAR _scr.
      _scr = <scr>.
      CLEAR: _scr-exit_name. " VERSION
      INSERT _scr INTO TABLE subscreens.
    ENDLOOP.
  ENDMETHOD.
  METHOD to_data.
    DATA _in  LIKE LINE OF fm_data-intas.
    DATA _cc  LIKE LINE OF fm_data-cocos.
    DATA _fc  LIKE LINE OF fm_data-fcodes.
    DATA _scr LIKE LINE OF fm_data-scrns.
    FIELD-SYMBOLS:
      <t>   LIKE LINE OF tables,
      <scr> LIKE LINE OF subscreens,
      <fc>  LIKE LINE OF functions_codes,
      <cc>  LIKE LINE OF controls_composites.
    fm_data-definition = a0_maindata-main.
    fm_data-mast_langu = a0_maindata-mast_langu.
    fm_data-ext_clname = a0_maindata-ext_clname.
    LOOP AT tables ASSIGNING <t>.
      CLEAR _in.
      _in = <t>.
      _in-exit_name = a0_maindata-exit_name.
      INSERT _in INTO TABLE fm_data-intas.
    ENDLOOP.
    LOOP AT controls_composites ASSIGNING <cc>.
      CLEAR _cc.
      _cc = <cc>.
      _cc-exit_name = a0_maindata-exit_name.
      INSERT _cc INTO TABLE fm_data-cocos.
    ENDLOOP.
    LOOP AT functions_codes ASSIGNING <fc>.
      CLEAR _fc.
      _fc = <fc>.
      _fc-exit_name = a0_maindata-exit_name.
      INSERT _fc INTO TABLE fm_data-fcodes.
    ENDLOOP.
    LOOP AT subscreens ASSIGNING <scr>.
      CLEAR _scr.
      _scr = <scr>.
      _scr-exit_name = a0_maindata-exit_name.
      INSERT _scr INTO TABLE fm_data-scrns.
    ENDLOOP.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_SXSD_DATA implementation
CLASS zaplink_vari_raw IMPLEMENTATION.
  METHOD anonymize.
    DATA o_raw   TYPE to_mydata.
    IF raw IS BOUND.    o_raw ?= raw.   o_raw->anonymize( ).    ENDIF.
    CALL METHOD super->anonymize.
  ENDMETHOD.
  METHOD constructor.
    DATA o_comp     TYPE to_component.
    DATA o_raw      TYPE to_mydata.
    DATA o_conn     TYPE to_connector.
    DATA s_variant  TYPE zaplink_vari_data=>ts_variant_key.
    DATA d_name     TYPE td_compname.
    IF fm_data IS INITIAL.    " create from ZL_EZXML
      CREATE OBJECT o_comp.
    ELSE.
      CREATE OBJECT o_comp.
      IF fm_data-header-variant CP zaplink_vari_data=>variant_prefix-system OR fm_data-header-variant CP zaplink_vari_data=>variant_prefix-customer.
        o_comp->set_type( zaplink_program=>supportedtypes-sys_variant ).
      ELSE.
        o_comp->set_type( zaplink_program=>supportedtypes-appl_variant ).
      ENDIF.
      s_variant-program = fm_data-header-report.
      s_variant-variant = fm_data-header-variant.
      d_name = zaplink_vari_data=>key_2_name( s_variant ).
      o_comp->set_name( d_name ).
    ENDIF.
    CALL METHOD super->constructor
      EXPORTING
        o_comp = o_comp.
    CREATE OBJECT o_raw.
    raw ?= o_raw.
    IF NOT fm_data IS INITIAL.    o_raw->from_data( fm_data ).      CLEAR: o_raw->a0_maindata-report, o_raw->a0_maindata-variant.     ENDIF.
    CREATE OBJECT o_conn TYPE zaplink_program.
    update_connector_data( o_conn ).
  ENDMETHOD.
  METHOD to_data.
    DATA o_raw      TYPE to_mydata.
    DATA s_variant  TYPE zaplink_vari_data=>ts_variant_key.
    DATA d_name     TYPE td_compname.
    s_variant = zaplink_vari_data=>name_2_key( me->name ).
    o_raw ?= raw.
    o_raw->a0_maindata-report = s_variant-program.
    o_raw->a0_maindata-variant = s_variant-variant.
    fm_data = o_raw->to_data( ).
  ENDMETHOD.
ENDCLASS. "ZAPLINK_VARI_RAW implementation
CLASS zaplink_dictionary IMPLEMENTATION.
  METHOD class_constructor.
    c_typegroup-type = 'TYPE'.    c_typegroup-kind = zaplink_connectors=>get_typekind( c_typegroup-type ).
  ENDMETHOD.
  METHOD constructor.
    DATA type LIKE LINE OF supported_types.
    CALL METHOD super->constructor.
    mac_create_log application_log ballog_subobject space.    application_log->msgid = 'ZAPLINK_DICTIONARY'.
    type-type = supportedtypes-type_group.    INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-domain.        INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-data_element.  INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-view.          INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-table.         INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-table_content. INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-table_type.    INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-search_help.   INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-lock_object.   INSERT type INTO TABLE supported_types.
    type-type = supportedtypes-ext_index.     INSERT type INTO TABLE supported_types. " Issue 55
    type-type = supportedtypes-table_index.   INSERT type INTO TABLE supported_types.
    uuid = _uuid.
    version = _ver.
  ENDMETHOD.
  METHOD export_data_element.
    DATA d_name     TYPE ddobjname.
    DATA str        TYPE string.
    DATA subrc      TYPE sy-subrc.
    DATA s_fm_data  TYPE zaplink_dtel_data=>ts_fm_data.
    DATA d_mask     TYPE doku_obj.
    DATA t_texts    TYPE STANDARD TABLE OF dd04t WITH DEFAULT KEY.
    TRY.
        d_name = component->get_name( ).
        CALL FUNCTION 'DDIF_DTEL_GET'
          EXPORTING
            name          = d_name
            state         = 'M'
            langu         = ' '
          IMPORTING
            dd04v_wa      = s_fm_data-header
            tpara_wa      = s_fm_data-param
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_DTEL_GET' sy-subrc.
        ENDIF.
        SELECT *
          INTO TABLE t_texts
          FROM dd04t
          WHERE rollname = d_name
            AND ddtext <> space.
        SORT t_texts BY ddlanguage as4local.
        DELETE ADJACENT DUPLICATES FROM t_texts COMPARING ddlanguage.
        s_fm_data-texts = t_texts.
        d_mask = d_name.
        s_fm_data-docs = zaplink_documentation=>get( ids = zaplink_dtel_data=>r_doc_ids
                                                  object = d_mask ).
        CREATE OBJECT object.
        object->from_data( s_fm_data ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_domain.
    DATA d_name     TYPE ddobjname.
    DATA str        TYPE string.
    DATA subrc      TYPE sy-subrc.
    DATA s_fm_data  TYPE zaplink_doma_data=>ts_fm_data.
    DATA d_mask     TYPE doku_obj.
    DATA t_texts    TYPE STANDARD TABLE OF dd01t WITH DEFAULT KEY.
    DATA t_vtexts   TYPE STANDARD TABLE OF dd07t WITH DEFAULT KEY.
    TRY.
        d_name = component->get_name( ).
        CALL FUNCTION 'DDIF_DOMA_GET'
          EXPORTING
            name          = d_name
            state         = 'M'
          IMPORTING
            dd01v_wa      = s_fm_data-header
          TABLES
            dd07v_tab     = s_fm_data-values
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_DOMA_GET' sy-subrc.
        ENDIF.
        SELECT *
          INTO TABLE t_texts
          FROM dd01t
          WHERE domname = d_name
            AND ddtext <> space.
        SORT t_texts BY ddlanguage as4local.
        DELETE ADJACENT DUPLICATES FROM t_texts COMPARING ddlanguage.
        s_fm_data-texts = t_texts.
        SELECT *
          INTO TABLE t_vtexts
          FROM dd07t
          WHERE domname = d_name
            AND ddtext <> space.
        SORT t_vtexts BY ddlanguage as4local valpos.            " Issue 96
        DELETE ADJACENT DUPLICATES FROM t_vtexts COMPARING ddlanguage valpos. " Issue 96
        s_fm_data-values_texts = t_vtexts.
        d_mask = d_name.
        s_fm_data-docs = zaplink_documentation=>get( ids = zaplink_doma_data=>r_doc_ids
                                                  object = d_mask ).
        CREATE OBJECT object.
        object->from_data( s_fm_data ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_index.
    DATA d_name     TYPE td_compname.
    DATA s_index    TYPE ts_idx_key.
    DATA str        TYPE string.
    DATA subrc      TYPE sy-subrc.
    DATA s_fm_data  TYPE zaplink_xinx_data=>ts_fm_data.
    DATA d_mask     TYPE doku_obj.
    DATA t_texts    TYPE STANDARD TABLE OF dd12t WITH DEFAULT KEY.
    TRY.
        d_name = component->get_name( ).
        s_index = zaplink_xinx_data=>name_2_key( d_name ).
        CALL FUNCTION 'DDIF_INDX_GET'
          EXPORTING
            name          = s_index-table
            id            = s_index-index
            state         = 'M'
          IMPORTING
            dd12v_wa      = s_fm_data-header
          TABLES
            dd17v_tab     = s_fm_data-fields
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_INDX_GET' sy-subrc.
        ENDIF.
        SELECT *
          INTO TABLE t_texts
          FROM dd12t
          WHERE sqltab = s_index-table
            AND indexname = s_index-index
            AND ddtext <> space.
        SORT t_texts BY ddlanguage as4local.
        DELETE ADJACENT DUPLICATES FROM t_texts COMPARING ddlanguage.
        s_fm_data-texts = t_texts.
        d_mask = s_index.
        s_fm_data-docs = zaplink_documentation=>get( ids = zaplink_xinx_data=>r_doc_ids
                                                  object = d_mask ).
        CREATE OBJECT object.
        object->from_data( s_fm_data ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_lock_object.
    DATA d_name     TYPE ddobjname.
    DATA str        TYPE string.
    DATA subrc      TYPE sy-subrc.
    DATA s_fm_data  TYPE zaplink_enqu_data=>ts_fm_data.
    DATA d_mask     TYPE doku_obj.
    DATA t_texts    TYPE STANDARD TABLE OF dd25t WITH DEFAULT KEY.
    TRY.
        d_name = component->get_name( ).
        CALL FUNCTION 'DDIF_ENQU_GET'
          EXPORTING
            name          = d_name
          IMPORTING
            dd25v_wa      = s_fm_data-header
          TABLES
            dd26e_tab     = s_fm_data-tables
            dd27p_tab     = s_fm_data-fields
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_ENQU_GET' sy-subrc.
        ENDIF.
        SELECT *
          INTO TABLE t_texts
          FROM dd25t
          WHERE viewname = d_name
            AND ddtext <> space.
        SORT t_texts BY ddlanguage as4local.
        DELETE ADJACENT DUPLICATES FROM t_texts COMPARING ddlanguage.
        s_fm_data-texts = t_texts.
        d_mask = d_name.
        s_fm_data-docs = zaplink_documentation=>get( ids = zaplink_enqu_data=>r_doc_ids
                                                  object = d_mask ).
        CREATE OBJECT object.
        object->from_data( s_fm_data ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_search_help.
    DATA d_name     TYPE ddobjname.
    DATA str        TYPE string.
    DATA subrc      TYPE sy-subrc.
    DATA s_fm_data  TYPE zaplink_shlp_data=>ts_fm_data.
    DATA d_mask     TYPE doku_obj.
    DATA t_texts    TYPE STANDARD TABLE OF dd30t WITH DEFAULT KEY.
    TRY.
        d_name = component->get_name( ).
        CALL FUNCTION 'DDIF_SHLP_GET'
          EXPORTING
            name          = d_name
            state         = space
          IMPORTING
            dd30v_wa      = s_fm_data-header
          TABLES
            dd31v_tab     = s_fm_data-sub_sh
            dd32p_tab     = s_fm_data-fields
            dd33v_tab     = s_fm_data-ssh_params
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_SHLP_GET' sy-subrc.
        ENDIF.
        SELECT *
          INTO TABLE t_texts
          FROM dd30t
          WHERE shlpname = d_name
            AND ddtext <> space.
        SORT t_texts BY ddlanguage as4local.
        DELETE ADJACENT DUPLICATES FROM t_texts COMPARING ddlanguage.
        s_fm_data-texts = t_texts.
        d_mask = d_name.
        s_fm_data-docs = zaplink_documentation=>get( ids = zaplink_shlp_data=>r_doc_ids
                                                  object = d_mask ).
        CREATE OBJECT object.
        object->from_data( s_fm_data ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_table.
    DATA d_name     TYPE ddobjname.
    DATA str        TYPE string.
    DATA subrc      TYPE sy-subrc.
    DATA s_fm_data  TYPE zaplink_tabl_data=>ts_fm_data.
    DATA d_mask     TYPE doku_obj.
    DATA f_subcomp  TYPE td_with_subcomp.
    DATA t_texts    TYPE STANDARD TABLE OF dd02t WITH DEFAULT KEY.
    DATA t_ftexts   TYPE STANDARD TABLE OF dd03t WITH DEFAULT KEY.
    TRY.
        d_name = component->get_name( ).
        f_subcomp = component->get_with_subcomp( ).
        CALL FUNCTION 'DDIF_TABL_GET'
          EXPORTING
            name          = d_name
            state         = 'M'
          IMPORTING
            dd02v_wa      = s_fm_data-header
            dd09l_wa      = s_fm_data-tech
          TABLES
            dd03p_tab     = s_fm_data-fields
            dd05m_tab     = s_fm_data-fk_fields
            dd08v_tab     = s_fm_data-forein_keys
            dd12v_tab     = s_fm_data-indexes
            dd17v_tab     = s_fm_data-idx_fields
            dd35v_tab     = s_fm_data-search_helps
            dd36m_tab     = s_fm_data-sh_fields
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_TABL_GET' sy-subrc.
        ENDIF.
        SELECT *
          INTO TABLE t_texts
          FROM dd02t
          WHERE tabname = d_name
            AND ddtext <> space.
        SORT t_texts BY ddlanguage as4local.
        DELETE ADJACENT DUPLICATES FROM t_texts COMPARING ddlanguage.
        s_fm_data-texts = t_texts.
        SELECT *
          INTO TABLE t_ftexts
          FROM dd03t
          WHERE tabname = d_name
            AND ddtext <> space.
        SORT t_ftexts BY ddlanguage as4local.
        DELETE ADJACENT DUPLICATES FROM t_ftexts COMPARING ddlanguage.
        s_fm_data-fields_texts = t_ftexts.
        d_mask = d_name.
        s_fm_data-docs = zaplink_documentation=>get( ids = zaplink_tabl_data=>r_doc_ids
                                                  object = d_mask ).
        IF f_subcomp < sub_component-with_mine.
          CLEAR: s_fm_data-indexes, s_fm_data-idx_fields.
        ELSEIF f_subcomp >= sub_component-with_all
            OR f_subcomp >= sub_component-with_required AND s_fm_data-header-contflag CO 'CG'.
          s_fm_data-with_content = abap_true.
        ENDIF.
        CREATE OBJECT object.
        object->from_data( s_fm_data ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_table_content.
    DATA d_table    TYPE zaplink_tabu_data=>td_table_name.
    TRY.
        d_table = component->get_name( ).
        CREATE OBJECT object.
        object->from_data( d_table ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_table_type.
    DATA d_name     TYPE ddobjname.
    DATA str        TYPE string.
    DATA subrc      TYPE sy-subrc.
    DATA s_fm_data  TYPE zaplink_ttyp_data=>ts_fm_data.
    DATA d_mask     TYPE doku_obj.
    DATA t_texts    TYPE STANDARD TABLE OF dd40t WITH DEFAULT KEY.
    TRY.
        d_name = component->get_name( ).
        CALL FUNCTION 'DDIF_TTYP_GET'
          EXPORTING
            name          = d_name
            state         = space
          IMPORTING
            dd40v_wa      = s_fm_data-header
          TABLES
            dd42v_tab     = s_fm_data-keys
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_TTYP_GET' sy-subrc.
        ENDIF.
        SELECT *
          INTO TABLE t_texts
          FROM dd40t
          WHERE typename = d_name
            AND ddtext <> space.
        SORT t_texts BY ddlanguage as4local.
        DELETE ADJACENT DUPLICATES FROM t_texts COMPARING ddlanguage.
        s_fm_data-texts = t_texts.
        d_mask = d_name.
        s_fm_data-docs = zaplink_documentation=>get( ids = zaplink_ttyp_data=>r_doc_ids
                                                  object = d_mask ).
        CREATE OBJECT object.
        object->from_data( s_fm_data ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_type_group.
    DATA d_type     TYPE td_typegroup.
    DATA str        TYPE string.
    DATA subrc      TYPE sy-subrc.
    DATA t_source   TYPE tt_abaprawsource.
    DATA o_src      TYPE REF TO cl_wb_source.
    TRY.
        d_type = component->get_name( ).
        o_src = get_type_group( d_type ).
        CHECK o_src IS BOUND.
        o_src->get_source_old( IMPORTING old_source = t_source ).
        CREATE OBJECT object.
        object->a0_maindata-name = d_type.
        object->a0_maindata-uccheck = o_src->l_progdir_entry-uccheck.
        SELECT SINGLE masterlang FROM tadir
                                 INTO object->a0_maindata-lang
             WHERE  pgmid       = c_typegroup-kind
             AND    object      = c_typegroup-type
             AND    obj_name    = object->a0_maindata-name.
        SELECT SINGLE ddtext FROM ddtypet INTO object->a0_maindata-text
               WHERE typegroup  = object->a0_maindata-name
                 AND ddlanguage = object->a0_maindata-lang.
        object->set_source( t_source ).
        object->_code_signature = get_typegroup_signature( d_type ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD export_view.
    DATA d_name     TYPE ddobjname.
    DATA str        TYPE string.
    DATA subrc      TYPE sy-subrc.
    DATA s_fm_data  TYPE zaplink_view_data=>ts_fm_data.
    DATA d_mask     TYPE doku_obj.
    DATA t_texts    TYPE STANDARD TABLE OF dd25t WITH DEFAULT KEY.
    TRY.
        d_name = component->get_name( ).
        CALL FUNCTION 'DDIF_VIEW_GET'
          EXPORTING
            name          = d_name
            state         = 'M'
            langu         = ' '
          IMPORTING
            dd25v_wa      = s_fm_data-header
            dd09l_wa      = s_fm_data-tech
          TABLES
            dd26v_tab     = s_fm_data-tables
            dd27p_tab     = s_fm_data-fields
            dd28j_tab     = s_fm_data-joins
            dd28v_tab     = s_fm_data-wheres
          EXCEPTIONS
            illegal_input = 1
            OTHERS        = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_VIEW_GET' sy-subrc.
        ENDIF.
        SELECT *
          INTO TABLE t_texts
          FROM dd25t
          WHERE viewname = d_name
            AND ddtext <> space.
        SORT t_texts BY ddlanguage as4local.
        DELETE ADJACENT DUPLICATES FROM t_texts COMPARING ddlanguage.
        s_fm_data-texts = t_texts.
        d_mask = d_name.
        s_fm_data-docs = zaplink_documentation=>get( ids = zaplink_view_data=>r_doc_ids
                                                  object = d_mask ).
        CREATE OBJECT object.
        object->from_data( s_fm_data ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD get_typegroup_signature.
    DATA t_src    TYPE tt_abaprawsource.
    DATA s_src    TYPE td_abapsource.
    DATA o_src    TYPE REF TO cl_wb_source.
    o_src = get_type_group( type_group ).
    CHECK o_src IS BOUND.
    o_src->get_source_old( IMPORTING old_source = t_src ).
    zaplink_tools=>pretty_printer( CHANGING table = t_src ).
    zaplink_tools=>condense_abap_source( CHANGING table = t_src ).
    s_src = zaplink_tools=>table_2_string( t_src ).
    result = zaplink_tools=>calculate_md5_hash( s_src ).
  ENDMETHOD.
  METHOD get_type_group.
    DATA d_type     TYPE td_typegroup.
    DATA str        TYPE string.
    DATA subrc      TYPE sy-subrc.
    DATA t_source   TYPE TABLE OF string.
    FIELD-SYMBOLS:
      <o_s> TYPE REF TO cl_wb_source.
    PERFORM xx_first_get IN PROGRAM saplsd31
            USING    type_group space dd_eu_type-type_group 'S' space 'X'
            CHANGING subrc.
    str = '(SAPLSD31)SOURCE_INSTANCE'.
    ASSIGN (str) TO <o_s>.
    IF sy-subrc <> 0.
      EXIT.
    ENDIF.
    result = <o_s>.
  ENDMETHOD.
  METHOD import_data_element.
    DATA d_name         TYPE rsedd0-ddobjname.
    DATA d_subrc        TYPE sy-subrc.
    DATA s_fm_data      TYPE zaplink_dtel_data=>ts_fm_data.
    TRY.
        s_fm_data = o_data->to_data( ).
        d_name = s_fm_data-header-rollname.
        CALL FUNCTION 'RS_DD_DELETE_OBJ'
          EXPORTING
            no_ask               = abap_true
            objname              = d_name
            objtype              = dd_eu_type-data_element
          EXCEPTIONS
            not_executed         = 1
            object_not_found     = 0
            object_not_specified = 3
            permission_failure   = 4
            dialog_needed        = 0      " Object is used : Issue 96
            OTHERS               = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'RS_DD_DELETE_OBJ' sy-subrc.
        ENDIF.
        CALL FUNCTION 'DDIF_DTEL_PUT'
          EXPORTING
            name              = d_name
            dd04v_wa          = s_fm_data-header
          EXCEPTIONS
            dtel_not_found    = 1
            name_inconsistent = 2
            dtel_inconsistent = 3
            put_failure       = 4
            put_refused       = 5
            OTHERS            = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_DTEL_PUT' sy-subrc.
        ENDIF.
        DELETE FROM dd04t WHERE rollname = s_fm_data-header-rollname.
        MODIFY dd04t FROM TABLE s_fm_data-texts.
        zaplink_documentation=>set( s_fm_data-docs ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_domain.
    DATA d_name         TYPE rsedd0-ddobjname.
    DATA d_subrc        TYPE sy-subrc.
    DATA s_fm_data      TYPE zaplink_doma_data=>ts_fm_data.
    TRY.
        s_fm_data = o_data->to_data( ).
        d_name = s_fm_data-header-domname.
        CALL FUNCTION 'RS_DD_DELETE_OBJ'
          EXPORTING
            no_ask               = abap_true
            objname              = d_name
            objtype              = dd_eu_type-domain
          EXCEPTIONS
            not_executed         = 1
            object_not_found     = 0
            object_not_specified = 3
            permission_failure   = 4
            dialog_needed        = 0      " Object is used : Issue 96
            OTHERS               = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'RS_DD_DELETE_OBJ' sy-subrc.
        ENDIF.
        CALL FUNCTION 'DDIF_DOMA_PUT'
          EXPORTING
            name              = d_name
            dd01v_wa          = s_fm_data-header
          TABLES
            dd07v_tab         = s_fm_data-values
          EXCEPTIONS
            doma_not_found    = 1
            name_inconsistent = 2
            doma_inconsistent = 3
            put_failure       = 4
            put_refused       = 5
            OTHERS            = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_DOMA_PUT' sy-subrc.
        ENDIF.
        DELETE FROM dd01t WHERE domname = s_fm_data-header-domname.
        MODIFY dd01t FROM TABLE s_fm_data-texts.
        DELETE FROM dd07t WHERE domname = s_fm_data-header-domname.
        MODIFY dd07t FROM TABLE s_fm_data-values_texts.
        zaplink_documentation=>set( s_fm_data-docs ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_index.
    DATA s_index        TYPE ts_idx_key.
    DATA d_subrc        TYPE sy-subrc.
    DATA s_fm_data      TYPE zaplink_xinx_data=>ts_fm_data.
    DATA object_name   TYPE  ddsym10tab-name.
    TRY.
        s_fm_data = o_data->to_data( ).
        s_index-table = s_fm_data-header-sqltab.   s_index-index = s_fm_data-header-indexname.
        object_name = zaplink_xinx_data=>key_2_name( s_index ).
        CALL FUNCTION 'RS_DD_INDX_DELETE'
          EXPORTING
            objname              = s_index-table
            indexname            = s_index-index
            extension            = s_fm_data-header-isextind
          EXCEPTIONS
            object_not_found     = 0
            object_not_specified = 2
            permission_failure   = 3
            action_cancelled     = 4
            OTHERS               = 5.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'RS_DD_INDX_DELETE' sy-subrc.
        ENDIF.
        CALL FUNCTION 'DDIF_INDX_PUT'
          EXPORTING
            name              = s_index-table
            id                = s_index-index
            dd12v_wa          = s_fm_data-header
          TABLES
            dd17v_tab         = s_fm_data-fields
          EXCEPTIONS
            indx_not_found    = 1
            name_inconsistent = 2
            indx_inconsistent = 3
            put_failure       = 4
            put_refused       = 5
            OTHERS            = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_INDX_PUT' sy-subrc.
        ENDIF.
        DELETE FROM dd12t
               WHERE sqltab = s_index-table
              AND indexname = s_index-table.
        MODIFY dd12t FROM TABLE s_fm_data-texts.
        zaplink_documentation=>set( s_fm_data-docs ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_lock_object.
    DATA d_name         TYPE rsedd0-ddobjname.
    DATA d_subrc        TYPE sy-subrc.
    DATA s_fm_data      TYPE zaplink_enqu_data=>ts_fm_data.
    TRY.
        s_fm_data = o_data->to_data( ).
        d_name = s_fm_data-header-viewname.
        CALL FUNCTION 'RS_DD_DELETE_OBJ'
          EXPORTING
            no_ask               = abap_true
            objname              = d_name
            objtype              = dd_eu_type-lock_object
          EXCEPTIONS
            not_executed         = 1
            object_not_found     = 0
            object_not_specified = 3
            permission_failure   = 4
            dialog_needed        = 0      " Object is used : Issue 96
            OTHERS               = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'RS_DD_DELETE_OBJ' sy-subrc.
        ENDIF.
        CALL FUNCTION 'DDIF_ENQU_PUT'
          EXPORTING
            name              = d_name
            dd25v_wa          = s_fm_data-header
          TABLES
            dd26e_tab         = s_fm_data-tables
            dd27p_tab         = s_fm_data-fields
          EXCEPTIONS
            enqu_not_found    = 1
            name_inconsistent = 2
            enqu_inconsistent = 3
            put_failure       = 4
            put_refused       = 5
            OTHERS            = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_ENQU_PUT' sy-subrc.
        ENDIF.
        DELETE FROM dd25t WHERE viewname = s_fm_data-header-viewname.
        MODIFY dd25t FROM TABLE s_fm_data-texts.
        zaplink_documentation=>set( s_fm_data-docs ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_search_help.
    DATA d_name         TYPE rsedd0-ddobjname.
    DATA d_subrc        TYPE sy-subrc.
    DATA s_fm_data      TYPE zaplink_shlp_data=>ts_fm_data.
    TRY.
        s_fm_data = o_data->to_data( ).
        d_name = s_fm_data-header-shlpname.
        CALL FUNCTION 'RS_DD_DELETE_OBJ'
          EXPORTING
            no_ask               = abap_true
            objname              = d_name
            objtype              = dd_eu_type-search_help
          EXCEPTIONS
            not_executed         = 1
            object_not_found     = 0
            object_not_specified = 3
            permission_failure   = 4
            dialog_needed        = 0      " Object is used : Issue 96
            OTHERS               = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'RS_DD_DELETE_OBJ' sy-subrc.
        ENDIF.
        CALL FUNCTION 'DDIF_SHLP_PUT'
          EXPORTING
            name              = d_name
            dd30v_wa          = s_fm_data-header
          TABLES
            dd31v_tab         = s_fm_data-sub_sh
            dd32p_tab         = s_fm_data-fields
            dd33v_tab         = s_fm_data-ssh_params
          EXCEPTIONS
            shlp_not_found    = 1
            name_inconsistent = 2
            shlp_inconsistent = 3
            put_failure       = 4
            put_refused       = 5
            OTHERS            = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_SHLP_PUT' sy-subrc.
        ENDIF.
        DELETE FROM dd30t WHERE shlpname = s_fm_data-header-shlpname.
        MODIFY dd30t FROM TABLE s_fm_data-texts.
        zaplink_documentation=>set( s_fm_data-docs ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_table.
    DATA d_name         TYPE rsedd0-ddobjname.
    DATA d_subrc        TYPE sy-subrc.
    DATA s_fm_data      TYPE zaplink_tabl_data=>ts_fm_data.
    DATA t_idx_flds     TYPE zaplink_tabl_data=>tt_dd17v.
    DATA d_cname        TYPE td_compname.
    FIELD-SYMBOLS: <i> LIKE LINE OF s_fm_data-indexes.
    TRY.
        s_fm_data = o_data->to_data( ).
        d_name = s_fm_data-header-tabname.
        CALL FUNCTION 'DDIF_TABL_PUT'
          EXPORTING
            name              = d_name
            dd02v_wa          = s_fm_data-header
            dd09l_wa          = s_fm_data-tech
          TABLES
            dd03p_tab         = s_fm_data-fields
            dd05m_tab         = s_fm_data-fk_fields
            dd08v_tab         = s_fm_data-forein_keys
            dd35v_tab         = s_fm_data-search_helps
            dd36m_tab         = s_fm_data-sh_fields
          EXCEPTIONS
            tabl_not_found    = 1
            name_inconsistent = 2
            tabl_inconsistent = 3
            put_failure       = 4
            put_refused       = 5
            OTHERS            = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_TABL_PUT' sy-subrc.
        ENDIF.
        LOOP AT s_fm_data-indexes ASSIGNING <i>.
          t_idx_flds = s_fm_data-idx_fields.    DELETE t_idx_flds WHERE indexname <> <i>-indexname.
          CALL FUNCTION 'DDIF_INDX_PUT'
            EXPORTING
              name              = d_name
              id                = <i>-indexname
              dd12v_wa          = <i>
            TABLES
              dd17v_tab         = t_idx_flds
            EXCEPTIONS
              indx_not_found    = 1
              name_inconsistent = 2
              indx_inconsistent = 3
              put_failure       = 4
              put_refused       = 5
              OTHERS            = 6.
          IF sy-subrc <> 0.
            mac_add_mf_and_raise 'DDIF_INDX_PUT' sy-subrc.
          ENDIF.
        ENDLOOP.
        DELETE FROM dd02t WHERE tabname = s_fm_data-header-tabname.
        MODIFY dd02t FROM TABLE s_fm_data-texts.
        DELETE FROM dd03t WHERE tabname = s_fm_data-header-tabname.
        MODIFY dd03t FROM TABLE s_fm_data-fields_texts.
        zaplink_documentation=>set( s_fm_data-docs ).
        IF s_fm_data-with_content = abap_true.
          d_cname = s_fm_data-header-tabname.
          IF NOT active_component( type = supportedtypes-table
                                   name = d_cname ) = abap_true.
            SET EXTENDED CHECK OFF.
            IF 1 = 2.   MESSAGE i000 WITH s_fm_data-header-tabname.   ENDIF.
            SET EXTENDED CHECK ON.
            CALL METHOD application_log->add_error
              EXPORTING
                id_msgno = '000'
                id_msgv1 = s_fm_data-header-tabname.
          ELSEIF NOT o_data->content IS INITIAL.
            DATA content TYPE REF TO data.
            DATA o_node TYPE REF TO if_ixml_element.
            DATA ez_xml    TYPE REF TO zaplink_easyxml.
            FIELD-SYMBOLS:
              <n>  TYPE any,
              <tc> TYPE STANDARD TABLE.
            CREATE OBJECT ez_xml.
            CREATE DATA content TYPE STANDARD TABLE OF (s_fm_data-header-tabname).
            ASSIGN content->* TO <tc>.
            ASSIGN o_data->content->* TO <n>.
            o_node = <n>.
            ez_xml->read_any( EXPORTING xml_node = o_node
                               CHANGING      any = <tc> ).
            INSERT (s_fm_data-header-tabname) FROM TABLE <tc>.
          ENDIF.
        ENDIF.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_table_type.
    DATA d_name         TYPE rsedd0-ddobjname.
    DATA d_subrc        TYPE sy-subrc.
    DATA s_fm_data      TYPE zaplink_ttyp_data=>ts_fm_data.
    TRY.
        s_fm_data = o_data->to_data( ).
        d_name = s_fm_data-header-typename.
        CALL FUNCTION 'RS_DD_DELETE_OBJ'
          EXPORTING
            no_ask               = abap_true
            objname              = d_name
            objtype              = dd_eu_type-table_type
          EXCEPTIONS
            not_executed         = 1
            object_not_found     = 0
            object_not_specified = 3
            permission_failure   = 4
            dialog_needed        = 0      " Object is used : Issue 96
            OTHERS               = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'RS_DD_DELETE_OBJ' sy-subrc.
        ENDIF.
        CALL FUNCTION 'DDIF_TTYP_PUT'
          EXPORTING
            name              = d_name
            dd40v_wa          = s_fm_data-header
          TABLES
            dd42v_tab         = s_fm_data-keys
          EXCEPTIONS
            ttyp_not_found    = 1
            name_inconsistent = 2
            ttyp_inconsistent = 3
            put_failure       = 4
            put_refused       = 5
            OTHERS            = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_TTYP_PUT' sy-subrc.
        ENDIF.
        DELETE FROM dd40t WHERE typename = s_fm_data-header-typename.
        MODIFY dd40t FROM TABLE s_fm_data-texts.
        zaplink_documentation=>set( s_fm_data-docs ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_type_group.
    DATA d_typegroup    TYPE td_typegroup.
    DATA d_name         TYPE rsedd0-ddobjname.
    DATA d_subrc        TYPE sy-subrc.
    DATA t_source       TYPE zaplink_type_data=>tt_string.
    DATA d_program      TYPE progdir.
    DATA str            TYPE string.
    FIELD-SYMBOLS:
      <prog> TYPE sy-repid.          "Typgruppeninclude
    TRY.
        d_typegroup = o_data->a0_maindata-name.
        PERFORM tygr_exists IN PROGRAM saplsd31
              USING    d_typegroup
              CHANGING d_subrc.
        IF d_subrc = 0.
          d_name = d_typegroup.
          CALL FUNCTION 'RS_DD_DELETE_OBJ'
            EXPORTING
              objname              = d_name
              objtype              = dd_eu_type-type_group
            EXCEPTIONS
              not_executed         = 1
              object_not_found     = 0
              object_not_specified = 3
              permission_failure   = 4
              dialog_needed        = 0      " Object is used : Issue 96
              OTHERS               = 6.
          IF sy-subrc <> 0.
            mac_add_mf_and_raise 'RS_DD_DELETE_OBJ' sy-subrc.
          ENDIF.
        ENDIF.
        t_source = o_data->get_source( ).
        CALL FUNCTION 'RS_DD_TYGR_INSERT_SOURCES'
          EXPORTING
            typegroupname        = o_data->a0_maindata-name
            ddtext               = o_data->a0_maindata-text
            corrnum              = space
            devclass             = space
          TABLES
            source               = t_source
          EXCEPTIONS
            already_exists       = 1
            not_executed         = 2
            permission_failure   = 3
            object_not_specified = 4
            illegal_name         = 5
            OTHERS               = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'RS_DD_TYGR_INSERT_SOURCES' sy-subrc.
        ENDIF.
        PERFORM tygr_exists IN PROGRAM saplsd31
                USING    d_typegroup
                CHANGING d_subrc.
        IF d_subrc <> 0.
          EXIT.
        ENDIF.
        str = '(SAPLSD31)PROGNAME'.
        ASSIGN (str) TO <prog>.
        IF sy-subrc <> 0.
          EXIT.
        ENDIF.
        CALL FUNCTION 'READ_PROGDIR'
          EXPORTING
            i_progname = <prog>
          IMPORTING
            e_progdir  = d_program
          EXCEPTIONS
            not_exists = 1
            OTHERS     = 2.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'READ_PROGDIR' sy-subrc.
        ENDIF.
        IF d_program-uccheck <> o_data->a0_maindata-uccheck.
          d_program-uccheck = o_data->a0_maindata-uccheck.
          CALL FUNCTION 'UPDATE_PROGDIR'
            EXPORTING
              i_progdir    = d_program
              i_progname   = <prog>
              i_state      = d_program-state
            EXCEPTIONS
              not_executed = 1
              OTHERS       = 2.
          IF sy-subrc <> 0.
            mac_add_mf_and_raise 'UPDATE_PROGDIR' sy-subrc.
          ENDIF.
        ENDIF.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD import_view.
    DATA d_name         TYPE rsedd0-ddobjname.
    DATA d_subrc        TYPE sy-subrc.
    DATA s_fm_data      TYPE zaplink_view_data=>ts_fm_data.
    TRY.
        s_fm_data = o_data->to_data( ).
        d_name = s_fm_data-header-viewname.
        CALL FUNCTION 'RS_DD_DELETE_OBJ'
          EXPORTING
            no_ask               = abap_true
            objname              = d_name
            objtype              = dd_eu_type-view
          EXCEPTIONS
            not_executed         = 1
            object_not_found     = 0
            object_not_specified = 3
            permission_failure   = 4
            dialog_needed        = 0      " Object is used : Issue 96
            OTHERS               = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'RS_DD_DELETE_OBJ' sy-subrc.
        ENDIF.
        CALL FUNCTION 'DDIF_VIEW_PUT'
          EXPORTING
            name              = d_name
            dd25v_wa          = s_fm_data-header
            dd09l_wa          = s_fm_data-tech
          TABLES
            dd26v_tab         = s_fm_data-tables
            dd27p_tab         = s_fm_data-fields
            dd28j_tab         = s_fm_data-joins
            dd28v_tab         = s_fm_data-wheres
          EXCEPTIONS
            view_not_found    = 1
            name_inconsistent = 2
            view_inconsistent = 3
            put_failure       = 4
            put_refused       = 5
            OTHERS            = 6.
        IF sy-subrc <> 0.
          mac_add_mf_and_raise 'DDIF_VIEW_PUT' sy-subrc.
        ENDIF.
        DELETE FROM dd25t WHERE viewname = s_fm_data-header-viewname.
        MODIFY dd25t FROM TABLE s_fm_data-texts.
        zaplink_documentation=>set( s_fm_data-docs ).
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~anonymize.
    mac_obj_data.
    DEFINE lmac_do_obj.
      &1 ?= object->raw.
      &1->anonymize( ).
    END-OF-DEFINITION.
    CHECK object IS BOUND.
    CASE object->type.
      WHEN supportedtypes-type_group.     lmac_do_obj o_typegroup.
      WHEN supportedtypes-domain.         lmac_do_obj o_domain.
      WHEN supportedtypes-data_element.   lmac_do_obj o_data_e.
      WHEN supportedtypes-view.           lmac_do_obj o_view.
      WHEN supportedtypes-table.          lmac_do_obj o_table.        " Issue 86
      WHEN supportedtypes-ext_index.      lmac_do_obj o_index.        " Issue 55
      WHEN supportedtypes-table_type.     lmac_do_obj o_tab_type.     " Issue 86
      WHEN supportedtypes-search_help.    lmac_do_obj o_s_help.       " Issue 86
      WHEN supportedtypes-lock_object.    lmac_do_obj o_lock_obj.     " Issue 86
      WHEN OTHERS.
        mac_raise_type_not_supported me->class_name object->type.
    ENDCASE.
    TRY.      " Issue 86
        super->zaplink_cnx_ext_cleaner~anonymize( object ).
      CATCH zaplink_cx_connector INTO o_mycx.
        RAISE EXCEPTION o_mycx.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_cleaner~unanonymize.
  ENDMETHOD.
  METHOD zaplink_cnx_ext_code_signature~get_signature.
    DATA d_type   TYPE td_comptype.
    DATA d_tgrp   TYPE td_typegroup.
    TRY.
        d_type = component->get_type( ).
        CASE d_type.
          WHEN supportedtypes-type_group.
            d_tgrp = component->get_name( ).
            result = get_typegroup_signature( d_tgrp ).
          WHEN supportedtypes-domain OR supportedtypes-data_element OR supportedtypes-table_type OR supportedtypes-search_help OR supportedtypes-mactchcode_id OR
               supportedtypes-lock_object OR supportedtypes-matchcode_obj OR supportedtypes-table_index OR supportedtypes-ext_index OR supportedtypes-table  OR supportedtypes-view.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~create_new_raw.
    mac_obj_data.
    DATA o_raw_idx TYPE to_raw_index.
    DEFINE lmac_obj_create.
      CREATE OBJECT &1.
      object->raw = &1.
    END-OF-DEFINITION.
    CREATE OBJECT object.
    CASE type.
      WHEN supportedtypes-type_group.     lmac_obj_create o_typegroup.
      WHEN supportedtypes-domain.         lmac_obj_create o_domain.
      WHEN supportedtypes-data_element.   lmac_obj_create o_data_e.
      WHEN supportedtypes-view.           lmac_obj_create o_view.
      WHEN supportedtypes-table.          lmac_obj_create o_table.
      WHEN supportedtypes-table_content.  lmac_obj_create o_content.
      WHEN supportedtypes-ext_index OR supportedtypes-table_index.
        CREATE OBJECT o_raw_idx.
        object = o_raw_idx.
        lmac_obj_create o_index.                              " Issue 55
      WHEN supportedtypes-table_type.     lmac_obj_create o_tab_type.
      WHEN supportedtypes-search_help.    lmac_obj_create o_s_help.
      WHEN supportedtypes-lock_object.    lmac_obj_create o_lock_obj.
      WHEN OTHERS.
        CLEAR object.
        mac_raise_type_not_supported me->class_name type.
    ENDCASE.
  ENDMETHOD.
  METHOD zaplink_connector~delete_from_sap.
    DATA d_name    TYPE td_compname.
    DATA d_objname TYPE rsedd0-ddobjname.
    DATA d_type    TYPE rsedd0-ddobjtype.
    DATA type      TYPE td_comptype.
    DATA s_index   TYPE ts_idx_key.
    TRY.
        type = component->get_type( ).
        d_name = component->get_name( ).
        CASE type.
          WHEN supportedtypes-type_group.
            d_type = dd_eu_type-type_group.
          WHEN supportedtypes-domain.
            d_type = dd_eu_type-domain.
          WHEN supportedtypes-data_element.
            d_type = dd_eu_type-data_element.
          WHEN supportedtypes-table_type.
            d_type = dd_eu_type-table_type.
          WHEN supportedtypes-search_help.
            d_type = dd_eu_type-search_help.
          WHEN supportedtypes-mactchcode_id.
            d_type = dd_eu_type-mactchcode_id.
          WHEN supportedtypes-lock_object.
            d_type = dd_eu_type-lock_object.
          WHEN supportedtypes-matchcode_obj.
            d_type = dd_eu_type-matchcode_obj.
          WHEN supportedtypes-ext_index OR supportedtypes-table_index.                        " Issue 55
            IF type = supportedtypes-table_index.   d_type = dd_eu_type-table_index.    ELSE.   d_type = dd_eu_type-ext_index.    ENDIF.
            s_index = zaplink_xinx_data=>name_2_key( d_name ).
            CALL FUNCTION 'RS_DD_INDX_DELETE'
              EXPORTING
                objname              = s_index-table
                indexname            = s_index-index
                extension            = 'X'
              EXCEPTIONS
                object_not_found     = 1
                object_not_specified = 2
                permission_failure   = 3
                action_cancelled     = 4
                OTHERS               = 5.
            IF sy-subrc <> 0.
              CASE sy-subrc.
                WHEN 1.
                  RAISE EXCEPTION TYPE zaplink_cx_connector
                    EXPORTING
                      textid = zaplink_cx_connector=>not_found.
                WHEN OTHERS.
                  mac_add_mf_and_raise 'RS_DD_INDX_DELETE' sy-subrc.
              ENDCASE.
            ENDIF.
            zaplink_tools=>remove_comp_from_working_area( type = type
                                                          name = d_name ).
            EXIT.
          WHEN supportedtypes-table_content.
            EXIT.
          WHEN supportedtypes-table.
            d_type = dd_eu_type-transp_table.
          WHEN supportedtypes-view.
            d_type = dd_eu_type-view.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        IF NOT d_type IS INITIAL.
          d_objname = d_name.
          CALL FUNCTION 'RS_DD_DELETE_OBJ'
            EXPORTING
              no_ask               = 'X'
              objname              = d_objname
              objtype              = d_type
            EXCEPTIONS
              not_executed         = 1
              object_not_found     = 2
              object_not_specified = 3
              permission_failure   = 4
              dialog_needed        = 5
              OTHERS               = 6.
          IF sy-subrc <> 0. " SAP NameSpace
            CASE sy-subrc.
              WHEN 2.
                RAISE EXCEPTION TYPE zaplink_cx_connector
                  EXPORTING
                    textid = zaplink_cx_connector=>not_found.
              WHEN OTHERS.
                mac_add_mf_and_raise 'RS_DD_DELETE_OBJ' sy-subrc.
            ENDCASE.
          ENDIF.
        ENDIF.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
    result = abap_true.
    zaplink_tools=>remove_comp_from_working_area( type = type
                                                  name = d_name ).
  ENDMETHOD.
  METHOD zaplink_connector~do_exists.
    DATA d_name      TYPE td_compname.
    DATA d_ddname    TYPE rsedd0-ddobjname.
    DATA d_type      TYPE rsedd0-ddobjtype.
    DATA type        TYPE td_comptype.
    DATA s_idxkey    TYPE ts_idx_key.
    DATA d_secname   TYPE rsedd0-indexid.
    exists = me->exists-not_exists.
    TRY.
        type = component->get_type( ).
        d_name = component->get_name( ).
        CASE type.
          WHEN supportedtypes-type_group.
            d_type = dd_eu_type-type_group.
          WHEN supportedtypes-domain.
            d_type = dd_eu_type-domain.
          WHEN supportedtypes-data_element.
            d_type = dd_eu_type-data_element.
          WHEN supportedtypes-table_type.
            d_type = dd_eu_type-table_type.
          WHEN supportedtypes-search_help.
            d_type = dd_eu_type-search_help.
          WHEN supportedtypes-mactchcode_id.
            d_type = dd_eu_type-mactchcode_id.
          WHEN supportedtypes-lock_object.
            d_type = dd_eu_type-lock_object.
          WHEN supportedtypes-matchcode_obj.
            d_type = dd_eu_type-matchcode_obj.
          WHEN supportedtypes-ext_index.
            d_type = dd_eu_type-ext_index.
            s_idxkey = zaplink_xinx_data=>name_2_key( d_name ).
            d_secname = s_idxkey-index.
            d_name = s_idxkey-table.
          WHEN supportedtypes-table_index.
            d_type = dd_eu_type-table_index.
            s_idxkey = zaplink_xinx_data=>name_2_key( d_name ).
            d_secname = s_idxkey-index.
            d_name = s_idxkey-table.
          WHEN supportedtypes-table OR supportedtypes-table_content OR supportedtypes-t_cluster_pool.
            d_type = dd_eu_type-transp_table.
          WHEN supportedtypes-view.
            d_type = dd_eu_type-view.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name type.
        ENDCASE.
        d_ddname = d_name.
        IF NOT d_type IS INITIAL AND NOT d_name IS INITIAL.
          CALL FUNCTION 'INTERN_DD_CHECK_EXIST'
            EXPORTING
              objname               = d_ddname
              objtype               = d_type
              err_message           = abap_false
              exists                = abap_true
              secname               = d_secname
            EXCEPTIONS
              object_not_found      = 1
              other_object_class    = 2
              invalid_parameter     = 3
              object_already_exists = 4
              OTHERS                = 5.
          IF sy-subrc = 0. " SAP NameSpace
            exists = me->exists-exists.
          ELSE.
            CASE sy-subrc.
              WHEN 1  OR 2.
              WHEN OTHERS.
                mac_add_mf_and_raise 'INTERN_DD_CHECK_EXIST' sy-subrc.
            ENDCASE.
          ENDIF.
        ENDIF.
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~is_supported_version.
    result = abap_false.
    IF version = _ver.    result = abap_true.   ENDIF.
  ENDMETHOD.
  METHOD zaplink_connector~read_from_sap.
    mac_obj_data.
    DATA d_type       TYPE td_comptype.
    DEFINE mac_catch_local_cx.
      CATCH zaplink_cx_connector INTO o_mycx.
        IF NOT o_mycx->messages IS BOUND.
          o_mycx->messages = application_log.
          o_mycx->update( ).
        ENDIF.
        RAISE EXCEPTION o_mycx.
    END-OF-DEFINITION.
    TRY.
        d_type = component->get_type( ).
        CREATE OBJECT object.
        object->set_component( component ).
        CASE d_type.
          WHEN supportedtypes-type_group.
            TRY.
                o_typegroup = export_type_group( component ).
                mac_catch_local_cx.
            ENDTRY.
            CLEAR o_typegroup->a0_maindata-name.
            object->raw = o_typegroup.
          WHEN supportedtypes-domain.
            TRY.
                o_domain = export_domain( component ).
                mac_catch_local_cx.
            ENDTRY.
            CLEAR o_domain->a0_maindata-domname.
            object->raw = o_domain.
          WHEN supportedtypes-data_element.
            TRY.
                o_data_e = export_data_element( component ).
                mac_catch_local_cx.
            ENDTRY.
            CLEAR o_data_e->a0_maindata-rollname.
            object->raw = o_data_e.
          WHEN supportedtypes-view.
            TRY.
                o_view = export_view( component ).
                mac_catch_local_cx.
            ENDTRY.
            CLEAR o_view->a0_maindata-viewname.
            object->raw = o_view.
          WHEN supportedtypes-table.
            TRY.
                o_table = export_table( component ).
                mac_catch_local_cx.
            ENDTRY.
            CLEAR o_table->a0_maindata-tabname.
            object->raw = o_table.
          WHEN supportedtypes-table_content.
            TRY.
                o_content = export_table_content( component ).
                mac_catch_local_cx.
            ENDTRY.
            object->raw = o_content.
          WHEN supportedtypes-ext_index OR supportedtypes-table_index.                      " Issue 55
            TRY.
                o_index = export_index( component ).
                mac_catch_local_cx.
            ENDTRY.
            CLEAR: o_index->a0_maindata-sqltab,  o_index->a0_maindata-indexname.
            object->raw = o_index.
          WHEN supportedtypes-table_type.
            TRY.
                o_tab_type = export_table_type( component ).
                mac_catch_local_cx.
            ENDTRY.
            CLEAR o_tab_type->a0_maindata-typename.
            object->raw = o_tab_type.
          WHEN supportedtypes-search_help.
            TRY.
                o_s_help = export_search_help( component ).
                mac_catch_local_cx.
            ENDTRY.
            CLEAR o_s_help->a0_maindata-shlpname.
            object->raw = o_s_help.
          WHEN supportedtypes-lock_object.
            TRY.
                o_lock_obj = export_lock_object( component ).
                mac_catch_local_cx.
            ENDTRY.
            CLEAR o_lock_obj->a0_maindata-viewname.
            object->raw = o_lock_obj.
          WHEN OTHERS.
            CLEAR object.
            mac_raise_type_not_supported me->class_name d_type.
        ENDCASE.
        object->update_connector_data( me ).                  " Issue 66
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
  METHOD zaplink_connector~write_to_sap.
    mac_obj_data.
    DATA o_comp       TYPE to_component.
    DATA s_index      TYPE ts_idx_key.
    DEFINE lmac_catch_local_cx.
      CATCH zaplink_cx_connector INTO o_mycx.
        IF NOT o_mycx->messages IS BOUND.
          o_mycx->messages = application_log.
          o_mycx->update( ).
        ENDIF.
        RAISE EXCEPTION o_mycx.
    END-OF-DEFINITION.
    TRY.
        CASE object->type.
          WHEN supportedtypes-type_group.
            o_typegroup ?= object->raw.
            o_typegroup->a0_maindata-name = object->name.
            TRY.
                components = import_type_group( o_typegroup ).
                lmac_catch_local_cx.
            ENDTRY.
          WHEN supportedtypes-domain.
            o_domain ?= object->raw.
            o_domain->a0_maindata-domname = object->name.
            TRY.
                components = import_domain( o_domain ).
                lmac_catch_local_cx.
            ENDTRY.
          WHEN supportedtypes-data_element.
            o_data_e ?= object->raw.
            o_data_e->a0_maindata-rollname = object->name.
            TRY.
                components = import_data_element( o_data_e ).
                lmac_catch_local_cx.
            ENDTRY.
          WHEN supportedtypes-view.
            o_view ?= object->raw.
            o_view->a0_maindata-viewname = object->name.
            TRY.
                components = import_view( o_view ).
                lmac_catch_local_cx.
            ENDTRY.
          WHEN supportedtypes-table.
            o_table ?= object->raw.
            o_table->a0_maindata-tabname = object->name.
            TRY.
                components = import_table( o_table ).
                lmac_catch_local_cx.
            ENDTRY.
          WHEN supportedtypes-table_content.
            o_content ?= object->raw.
            TRY.
                lmac_catch_local_cx.
            ENDTRY.
          WHEN supportedtypes-ext_index OR supportedtypes-table_index. " Issue 55
            o_index ?= object->raw.
            s_index = zaplink_xinx_data=>name_2_key( object->name ).
            o_index->a0_maindata-sqltab = s_index-table.
            o_index->a0_maindata-indexname = s_index-index.
            TRY.
                components = import_index( o_index ).
                lmac_catch_local_cx.
            ENDTRY.
          WHEN supportedtypes-table_type.
            o_tab_type ?= object->raw.
            o_tab_type->a0_maindata-typename = object->name.
            TRY.
                components = import_table_type( o_tab_type ).
                lmac_catch_local_cx.
            ENDTRY.
          WHEN supportedtypes-search_help.
            o_s_help ?= object->raw.
            o_s_help->a0_maindata-shlpname = object->name.
            TRY.
                components = import_search_help( o_s_help ).
                lmac_catch_local_cx.
            ENDTRY.
          WHEN supportedtypes-lock_object.
            o_lock_obj ?= object->raw.
            o_lock_obj->a0_maindata-viewname = object->name.
            TRY.
                components = import_lock_object( o_lock_obj ).
                lmac_catch_local_cx.
            ENDTRY.
          WHEN OTHERS.
            mac_raise_type_not_supported me->class_name object->type.
        ENDCASE.
        check_component_list( EXPORTING     object = object
                               CHANGING components = components ). " Issue 92
        mac_def_catch zaplink_cx_connector.
    ENDTRY.
  ENDMETHOD.
ENDCLASS. "ZAPLINK_DICTIONARY implementation
CLASS zaplink_xinx_raw IMPLEMENTATION.
  METHOD anonymize.
    DATA o_raw   TYPE REF TO zaplink_xinx_data.
    IF raw IS BOUND.    o_raw ?= raw.   o_raw->anonymize( ).    ENDIF.
    CALL METHOD super->anonymize.
  ENDMETHOD.
  METHOD constructor.
    DATA s_index TYPE zaplink_xinx_data=>ts_idx_key.
    DATA o_comp  TYPE to_component.
    DATA o_raw   TYPE REF TO zaplink_xinx_data.
    DATA s_key   TYPE ts_compkey.
    DATA o_conn  TYPE to_connector.
    IF fm_data IS INITIAL.    " create from ZL_EZXML
      CREATE OBJECT o_comp.
    ELSE.
      s_index-table = fm_data-header-sqltab.
      s_index-index = fm_data-header-indexname.
      s_key-name = zaplink_xinx_data=>key_2_name( s_index ).
      IF fm_data-header-isextind IS INITIAL.
        s_key-type = zaplink_dictionary=>supportedtypes-table_index.
      ELSE.
        s_key-type = zaplink_dictionary=>supportedtypes-ext_index.
      ENDIF.
      CREATE OBJECT o_comp.
      o_comp->set_type( s_key-type ).   o_comp->set_name( s_key-name ).
    ENDIF.
    CALL METHOD super->constructor
      EXPORTING
        o_comp = o_comp.
    CREATE OBJECT o_raw.
    raw ?= o_raw.
    IF NOT fm_data IS INITIAL.    o_raw->from_data( fm_data ).    CLEAR: o_raw->a0_maindata-sqltab, o_raw->a0_maindata-indexname, o_raw->a0_maindata-isextind.    ENDIF.
    CREATE OBJECT o_conn TYPE zaplink_dictionary.
    update_connector_data( o_conn ).
  ENDMETHOD.
  METHOD to_data.
    DATA s_index TYPE zaplink_xinx_data=>ts_idx_key.
    DATA o_raw   TYPE REF TO zaplink_xinx_data.
    o_raw ?= raw.
    s_index = zaplink_xinx_data=>name_2_key( name ).
    o_raw->a0_maindata-sqltab = s_index-table.
    o_raw->a0_maindata-indexname = s_index-index.
    IF type = zaplink_dictionary=>supportedtypes-ext_index.   o_raw->a0_maindata-isextind = abap_true.    ENDIF.
    fm_data = o_raw->to_data( ).
  ENDMETHOD.
ENDCLASS. "ZAPLINK_XINX_RAW implementation
TABLES: tadir.
PARAMETERS:
  p_path TYPE zaplink_extractor=>td_directoryname OBLIGATORY LOWER CASE.
SELECT-OPTIONS:
  s_srcs FOR tadir-srcsystem  DEFAULT sy-sysid,
  s_type FOR tadir-object,
  s_name FOR tadir-obj_name,
  s_pack FOR tadir-devclass.
PARAMETERS:
  p_ext TYPE abap_bool AS CHECKBOX DEFAULT abap_true.
SELECT-OPTIONS:
  s_author FOR tadir-author DEFAULT sy-uname.
SELECTION-SCREEN BEGIN OF BLOCK mode WITH FRAME TITLE TEXT-mod.
PARAMETERS em_type TYPE c RADIOBUTTON GROUP r3 DEFAULT 'X'.
PARAMETERS em_pack TYPE c RADIOBUTTON GROUP r3.
PARAMETERS em_p_t  TYPE c RADIOBUTTON GROUP r3.
PARAMETERS em_cnx  TYPE c RADIOBUTTON GROUP r3.
SELECTION-SCREEN END OF BLOCK mode.
PARAMETERS f_sub TYPE zaplink_datatypes=>td_with_subcomp DEFAULT zaplink_datatypes=>default_sub_component_level.

AT SELECTION-SCREEN OUTPUT.
  DATA active TYPE i.

  %_p_path_%_app_%-text = 'Fichier local'.
  %_s_srcs_%_app_%-text = 'System source'.
  %_s_type_%_app_%-text = 'Type d''objet'.
  %_s_name_%_app_%-text = 'Nom d''objet'.
  %_s_pack_%_app_%-text = 'Packages'.
  %_p_ext_%_app_%-text = 'Ss packages'.
  %_s_author_%_app_%-text = 'Auteur'.

  IF em_cnx IS INITIAL.
    active = 1.
  ELSE.
    active = 0.
  ENDIF.
  LOOP AT SCREEN.
    CHECK screen-name ='S_PACK'.
    screen-active = active.
    MODIFY SCREEN.
  ENDLOOP.

START-OF-SELECTION.
  zaplink_connectors=>clear_connectors( ).
  DATA _cx_90335e5d44316adf4805a732f TYPE REF TO zaplink_cx_component.
  TRY.
      zaplink_connectors=>add_local_connector('ZAPLINK_CHECKPOINTS').
      zaplink_connectors=>add_local_connector('ZAPLINK_OBJECT').
      zaplink_connectors=>add_local_connector('ZAPLINK_PACKAGE').
      zaplink_connectors=>add_local_connector('ZAPLINK_DOCUMENTATION').
      zaplink_connectors=>add_local_connector('ZAPLINK_DICTIONARY').
      zaplink_connectors=>add_local_connector('ZAPLINK_ENHANCEMENT').
      zaplink_connectors=>add_local_connector('ZAPLINK_OS_COMMAND').
      zaplink_connectors=>add_local_connector('ZAPLINK_FUNCTION_GROUP').
      zaplink_connectors=>add_local_connector('ZAPLINK_MESSAGE').
      zaplink_connectors=>add_local_connector('ZAPLINK_PROGRAM').
      zaplink_connectors=>add_local_connector('ZAPLINK_BADI').
      zaplink_connectors=>add_local_connector('ZAPLINK_TRANSACTION').
    CATCH zaplink_cx_component INTO _cx_90335e5d44316adf4805a732f.
      _cx_90335e5d44316adf4805a732f->write( ).
      BREAK-POINT.
      RAISE EXCEPTION _cx_90335e5d44316adf4805a732f.
  ENDTRY.
  DATA o_extract   TYPE REF TO zaplink_extractor.
  DATA d_hierarchy TYPE zaplink_extractor=>td_dirhierarchy.
  DATA target_dir TYPE zaplink_extractor=>td_directoryname.
  DATA srcsystem  TYPE zaplink_extractor=>tr_srcsystem.
  DATA type TYPE zaplink_extractor=>tr_comptype.
  DATA name TYPE zaplink_extractor=>tr_compname.
  DATA packages TYPE zaplink_extractor=>tr_packages.
  DATA ext TYPE abap_bool.
  DATA author TYPE zaplink_extractor=>tr_author.
  target_dir = p_path.
  srcsystem = s_srcs[].
  type = s_type[].
  name = s_name[].
  packages = s_pack[].
  ext = p_ext.
  author = s_author[].
  CREATE OBJECT o_extract.
  CASE abap_true.
    WHEN em_cnx.
      CALL METHOD o_extract->extract_connectors
        EXPORTING
          target_dir = target_dir
          package    = packages.
      EXIT.
    WHEN em_pack.
      d_hierarchy = zaplink_extractor=>dirhierachies-devc.
    WHEN em_type.
      d_hierarchy = zaplink_extractor=>dirhierachies-type.
    WHEN em_p_t.
      d_hierarchy = zaplink_extractor=>dirhierachies-dcty.
  ENDCASE.
  o_extract->extract( target_dir = target_dir
                      srcsystem  = srcsystem
                      type       = type
                      name       = name
                      packages   = packages
                      ext        = ext
                      hierarchy  = d_hierarchy
                      author     = author
                           f_sub = f_sub ).

END-OF-SELECTION.
